//  ------------------------------------------------------------------------------------
//  Hamilton Company Software Product
//  File: HSLMECCLibImpl.hs_
//
//  This is a part of the module HxMetEdCompCmd.
//  Implementation of the MECC Template Library.
//
//  File creation date:  2001-12-05 by CJo
//  Last revision date:  2005-08-18 by CJo
//
//  Copyright (c) 2005 by Hamilton Bonaduz AG.
//
//
//  Modification History
//  --------------------
//  1.00  2001-12-05 by CJo  Initial file creation.
//  1.01  2003-03-12 by CJo  Add string Ids for steps 'Submethod Call' and 'Return'.
//  1.10  2003-10-20 by CJo  Add function RaiseRuntimeErrorEx(), used by the Step 'File Open'
//                           Add IDS::errorStepFileOpenFailed, errorStepFailedTimeout
//  1.11  2004-02-13 by CJo  Help file used to generate the error changed to HTML Help (.chm).
//  1.20  2005-02-01 by CJo  Add function TraceComment(), add Util::Split()
//  1.21  2005-02-09 by CJo  Add function EndlessSequenceLoopWarning() used from step Loop.
//  1.22  2005-08-18 by CJo  Improved generation of HelpFileName within RaiseRuntimeErrorEx.
//                           Try to detect also help-files for default- or no-language, added/use GetModuleHelpFileName().
//  ------------------------------------------------------------------------------------


#ifndef __HSLMECCLibImpl_hsl__
#define __HSLMECCLibImpl_hsl__  1

#ifndef __HSLStrLib_hsl__
#include "HSLStrLib.hsl"
#endif

namespace MECC
{
	#ifndef __HSLStringTableLib_hsl__
	#include "HSLStringTableLib.hs_"
	#endif

	// --------------------------------------------------------------------------------------
	// Debugging
	// --------------------------------------------------------------------------------------

	//	#define _DEBUG		1													// specifies the debug version of the MECC library

	// --------------------------------------------------------------------------------------
	// Declaration of "exported" functions
	// --------------------------------------------------------------------------------------

	// --------------------------------------------------------------------------------------
	// Functionality used from Steps
	// --------------------------------------------------------------------------------------
	static function TraceComment(							// Splitt the text (by the newline) and trace each line.
		variable& text) void;								// i: text to trace, may contains '\n' to identifiy a line break.

	// Traces a warning message if for the passed file the fileValidFlag is not 'valid'.
	// If file validation is disabled the warning message is traced in all cases. 
	static function EndlessSequenceLoopWarning(		// Loop over sequences, trace warning 'indication for endless loop over sequences detected'
		variable& fileName) void;							// i:  file name, warning is not traced if file validation status is 'valid'

	// --------------------------------------------------------------------------------------
	// Error Handling
	// --------------------------------------------------------------------------------------

	static function RaiseRuntimeErrorEx(				// raises a runtime error, allows to add an additional description
		variable errorId,										// i: error id (integer)
		variable stepNameStrTblId,							// i: step name string table id (integer)
		variable errorDescriptionStrTblId,				// i: error description string table id (integer)
		variable& additionalDescription,					// i: additional description (string)
		variable& moduleName) void;						// i: name of module supplying help for the errorId (string), e.g. HxMetEdCompCmd

	// Obsolete function, used by steps generated by steps created with V3.1 or older.
	// Never steps uses the RaiseRuntimeErrorEx() function.
	static function RaiseRuntimeError(					// raises a runtime error
		variable errorId,										// i: error id (integer)
		variable stepNameStrTblId,							// i: step name string table id (integer)
		variable errorDescriptionStrTblId,				// i: error description string table id (integer)
		variable& moduleName) void;						// i: name of module supplying help for the errorId (string), e.g. HxMetEdCompCmd


	// --------------------------------------------------------------------------------------
	// Constants
	// --------------------------------------------------------------------------------------
	namespace Const
	{
		static const variable helpFileExtension(".chm");			// HTML Help file
		static const variable commentTextLineDelimiter("\n");	// Delimiter used within the comment string to seperate lines
	}

	// --------------------------------------------------------------------------------------
	// Constants
	// --------------------------------------------------------------------------------------
	namespace FormatTraceStatus
	{
		static const variable start            (1);
		static const variable complete         (2);
		static const variable _error           (3);
		static const variable progress         (4);
		static const variable completeWithError(5);
	}

	// --------------------------------------------------------------------------------------
	// Error Ids
	// --------------------------------------------------------------------------------------

	namespace IDE
	{
		static const variable first           (0);							// guard
		static const variable noError           (first + 0);				// No error.
		static const variable invalidParameter  (first + 1);				// The parameter is incorrect.
		static const variable createObjectFailed(first + 2);				// Create object faild
		static const variable getObjectFailed   (first + 3);				// Get object (querry interface) failed
		static const variable last            (first + 3);					// guard
	}

	// --------------------------------------------------------------------------------------
	// String Ids
	// --------------------------------------------------------------------------------------

	namespace IDS
	{
		// private
		static const variable first                 (IDE::last + 1);		// guard

		static const variable openingBracket          (first + 0);			// opening bracket 
		static const variable closingBracket          (first + 1);			// closing bracket
		static const variable point                   (first + 2);			// point (.)
		static const variable runtimeError            (first + 3);			// smart step runtime error 
		static const variable trcSource               (first + 4);			// FormatTrace Source
		static const variable trcEndlessLoopWarning   (first + 5);			// TrcMsg for endless loop indication warning

		// public: runtime errors
		static const variable errorUnspecified        (first + 6);			// runtime error: unspecified error 
		static const variable errorStepFailed         (first + 7);			// runtime error: step failed 
		static const variable errorStepFileOpenFailed (first + 8);			// runtime error: step file open failed
		static const variable errorStepFailedTimeout  (first + 9);			// runtime error: step failed (e.g. timeout)

		// public: step names
		static const variable firstStepName                (first + 10);				// guard step names
		static const variable stepNameComment                (firstStepName + 0);
		static const variable stepNameAssignment             (firstStepName + 1);
		static const variable stepNameMathematicalExpr       (firstStepName + 2);
		static const variable stepNameLoop                   (firstStepName + 3);
		static const variable stepNameLoopBreak              (firstStepName + 4);
		static const variable stepNameIfThenElse             (firstStepName + 5);
		static const variable stepNameSeqSetCurrent          (firstStepName + 6);
		static const variable stepNameSeqGetCurrent          (firstStepName + 7);
		static const variable stepNameSeqSetEnd              (firstStepName + 8);
		static const variable stepNameSeqGetEnd              (firstStepName + 9);
		static const variable stepNameAlignSequences         (firstStepName + 10);
		static const variable stepNameFileOpen               (firstStepName + 11);
		static const variable stepNameFileSetPos             (firstStepName + 12);
		static const variable stepNameFileRead               (firstStepName + 13);
		static const variable stepNameFileWrite              (firstStepName + 14);
		static const variable stepNameFileClose              (firstStepName + 15);
		static const variable stepNameTimerStart             (firstStepName + 16);
		static const variable stepNameTimerWait              (firstStepName + 17);
		static const variable stepNameTimerReadElapsed       (firstStepName + 18);
		static const variable stepNameTimerRestart           (firstStepName + 19);
		static const variable stepNameDlgUserInput           (firstStepName + 20);
		static const variable stepNameDlgUserOutput          (firstStepName + 21);
		static const variable stepNameComPortOpen            (firstStepName + 22);
		static const variable stepNameComPortRead            (firstStepName + 23);
		static const variable stepNameComPortWrite           (firstStepName + 24);
		static const variable stepNameComPortClose           (firstStepName + 25);
		static const variable stepNameShell                  (firstStepName + 26);
		static const variable stepNameSetEvent               (firstStepName + 27);
		static const variable stepNameWaitForEvent           (firstStepName + 28);
		static const variable stepNameAbort                  (firstStepName + 29);
		static const variable stepNameUserHandleError        (firstStepName + 30);
		static const variable stepNameThreadBegin            (firstStepName + 31);
		static const variable stepNameThreadWaitFor          (firstStepName + 32);
		static const variable stepNameLibFunctionCall        (firstStepName + 33);
		static const variable stepNameSingleLibFunctionCall  (firstStepName + 34);
		static const variable stepNameSubmethodCall          (firstStepName + 35);
		static const variable stepNameReturn                 (firstStepName + 36);
		static const variable lastStepName                 (firstStepName + 36);				// guard step names

		static const variable last                         (lastStepName);		// guard
	}


	// --------------------------------------------------------------------------------------
	// Library Initialization 
	// --------------------------------------------------------------------------------------

	static variable initializedLib(hslFalse);							// initialization state of the MECC library

	static function InitMECCLibrary() variable;									// initializes the MECC library (only once)


	// --------------------------------------------------------------------------------------
	// Utilities
	// --------------------------------------------------------------------------------------

	namespace Util
	{
		static function IsString(											// returns true if the variable value is a string
			variable var) variable;														// i: variable

		static function IsNumber(											// returns true if the variable value is a number
			variable var) variable;														// i: variable

		static function IsInteger(											// returns true if the variable value is an integer
			variable var) variable;														// i: variable

		static function IsFloat(											// returns true if the variable value is a float
			variable var) variable;														// i: variable

		static function IsNegative(										// returns true if the number is negative
			variable number) variable;													// i: number

		static function GetModuleHelpFileName(							// Returns the help file name qualified for current language
			variable& moduleName) variable;											// i: Module name (e.g. HxMetEdCompCmd)

		// See VBScript 'Split' function.
		// Remark: - Don't pass parameters 'str' and 'delimiter' by reference, because they might be modified.
		//         - The ASCII #007 is used to replace '\n' within the string for VB-script Eval function.
		static function Split(
			variable str,							// i: string to splitt
			variable delimiter,					// i: delimiter
			variable& substrings[]) void;		// o: splitted substring

	}


	// --------------------------------------------------------------------------------------
	// Exception handling
	// --------------------------------------------------------------------------------------

	namespace Error
	{
		static function Raise(												// raises a runtime error
			variable errorId,													// i: error id, one of IDE
			variable& fileName,												// i: file name
			variable& funcName,												// i: function name
			variable& lineNumber) void;									// i: line number

		static function RaiseEx(											// raises a runtime error
			variable errorId,													// i: error id, one of IDE
			variable& fileName,												// i: file name
			variable& funcName,												// i: function name
			variable& lineNumber,											// i: line number as string
			variable& addDescription) void;								// i: addition error description		
	}


	// ======================================================================================
	// Implementation 
	// ======================================================================================

	// --------------------------------------------------------------------------------------
	// Library Initialization 
	// --------------------------------------------------------------------------------------

	static function InitMECCLibrary() variable
	{
		// initialize the MECC library once only
		if (!initializedLib)
		{
			StringTable::Init("HSLMECCLib");
			#ifdef _DEBUG
				StringTable::Dump();
			#endif

			initializedLib = hslTrue;
		}
		return(initializedLib);
	}


	// --------------------------------------------------------------------------------------
	// Functionality used from Steps
	// --------------------------------------------------------------------------------------
	static function TraceComment(
		variable& text) void				// i:
	{
		variable arrTextLines[];
		variable size, index;
		
		// initialize the library
		InitMECCLibrary();

		if (!Util::IsString(text))
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());

		Util::Split(text, Const::commentTextLineDelimiter, arrTextLines);

		size = arrTextLines.GetSize();
		for ( index=0; index < size; index++ )
		{
			Trace(arrTextLines.ElementAt(index));
		}
	}


	static function EndlessSequenceLoopWarning(
		variable& fileName) void		// i:
	{
		variable isFileValidationEnabled(-1);
		object hxRegistryPtr;

		// initialize the library
		InitMECCLibrary();

		if (!Util::IsString(fileName))
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());

		if ( 0 == hxRegistryPtr.CreateObject("HXREGLib.HxRegistry") )
		{
			Error::RaiseEx(IDE::createObjectFailed, GetFileName(), GetFunctionName(), GetLineNumber(), "HXREGLib.HxRegistry");
		}
		isFileValidationEnabled = hxRegistryPtr.FileValidation();
		hxRegistryPtr.ReleaseObject();

		if ( 0 != isFileValidationEnabled)
		{
			// File validation is enabled, check if the file is valid because in this case we must not trace a warning
			variable fileValidFlag(-1);
			object hxSecurityComPtr;
			object hxSecurityFileComPtr;
			// definition of enum from HxSecurityCom
			//const variable HxSecurityCOMValidation_validationInvalid    (0);
			  const variable HxSecurityCOMValidation_validationValid      (1);
			//const variable HxSecurityCOMValidation_validationIrrelevant (2);

			if ( 0 == hxSecurityComPtr.CreateObject("Hamilton.HxSecurityCom") )
			{
				Error::RaiseEx(IDE::createObjectFailed, GetFileName(), GetFunctionName(), GetLineNumber(), "Hamilton.HxSecurityCom");
			}
			if ( 0 == hxSecurityComPtr.GetObject("IHxSecurityFileCom", hxSecurityFileComPtr) )
			{
				Error::RaiseEx(IDE::getObjectFailed, GetFileName(), GetFunctionName(), GetLineNumber(), "IHxSecurityFileCom");
			}
			hxSecurityFileComPtr.GetFileValidation(fileName, fileValidFlag);
			hxSecurityFileComPtr.ReleaseObject();
			hxSecurityComPtr.ReleaseObject();

			if ( HxSecurityCOMValidation_validationValid == fileValidFlag )
			{
				// Validation is enabled and file is valid -> no warning trace
				return;
			}
		}

		FormatTrace(StringTable::Load(IDS::trcSource), StringTable::Load(IDS::stepNameLoop),
						FormatTraceStatus::progress, StringTable::Load(IDS::trcEndlessLoopWarning));
	}


	// --------------------------------------------------------------------------------------
	// Error Handling used from Steps
	// --------------------------------------------------------------------------------------

	static function RaiseRuntimeError(
		variable errorId,
		variable stepNameStrTblId,
		variable errorDescriptionStrTblId,
		variable& moduleName) void
	{
		RaiseRuntimeErrorEx(errorId, stepNameStrTblId, errorDescriptionStrTblId, "", moduleName);
	}


	static function RaiseRuntimeErrorEx(
		variable errorId,
		variable stepNameStrTblId,
		variable errorDescriptionStrTblId,
		variable& additionalDescription,
		variable& moduleName) void
	{
		// initialize the library
		InitMECCLibrary();

		// check params to be valid
		if (!Util::IsNumber(errorId))
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());
		if (!Util::IsInteger(errorId))
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());
		if (!Util::IsNumber(stepNameStrTblId))
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());
		if (!Util::IsInteger(stepNameStrTblId))
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());
		if (Util::IsNegative(stepNameStrTblId))
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());
		if (!Util::IsNumber(errorDescriptionStrTblId))
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());
		if (!Util::IsInteger(errorDescriptionStrTblId))
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());
		if (Util::IsNegative(errorDescriptionStrTblId))
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());
		if (!Util::IsString(additionalDescription))
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());
		if (!Util::IsString(moduleName))
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());

		err.Raise(errorId, 
					 StringTable::Load(IDS::runtimeError) + 
					 StringTable::Load(IDS::openingBracket) + 
					 StringTable::Load(stepNameStrTblId) + 
					 StringTable::Load(IDS::closingBracket) + 
					 StringTable::Load(IDS::point) + 
					 "\n" +
					 StringTable::Load(errorDescriptionStrTblId) +
					 additionalDescription,
					 Util::GetModuleHelpFileName(moduleName));
	}


	// --------------------------------------------------------------------------------------
	// Utilities
	// --------------------------------------------------------------------------------------

	static function Util::IsString(variable var) variable
	{
		return(hslString.Compare(GetType(var)) == 0);
	}

	static function Util::IsNumber(variable var) variable
	{
		return(hslString.Compare(GetType(var)) != 0);
	}

	static function Util::IsInteger(variable var) variable
	{
		return(hslInteger.Compare(GetType(var)) == 0);
	}

	static function Util::IsFloat(variable var) variable
	{
		return(hslFloat.Compare(GetType(var)) == 0);
	}

	static function Util::IsNegative(variable number) variable
	{
		return(number < 0);
	}

	static function Util::GetModuleHelpFileName(variable& moduleName) variable
	{
		variable helpFileName;
		variable binPathPrefix;
		
		// Note: The help for this library is located within the bin directory (module-help)
		// For use of SearchPath we must pass a filename with path.
		binPathPrefix = GetBinPath() + "\\";

		helpFileName = moduleName + GetLanguage() + Const::helpFileExtension;		// current language
		if ("" == SearchPath(binPathPrefix + helpFileName))
		{
			helpFileName = moduleName + "Enu" + Const::helpFileExtension;				// default language, fixed to enu
			if ("" == SearchPath(binPathPrefix + helpFileName))
			{
				helpFileName = moduleName + Const::helpFileExtension;						// no language
				if ("" == SearchPath(binPathPrefix + helpFileName))
				{
					// no help file found within bin-dir
					// return the helpFileName with current language, maybe its existing/found on other
					// place or its registered and found by this way.
					helpFileName = moduleName + GetLanguage() + Const::helpFileExtension;
				}
			}
		}

		return( helpFileName );
	}


	// See VBScript 'Split' function.
	// Remark: - Don't pass parameters 'str' and 'delimiter' by reference, because they might be modified.
	//         - The ASCII #007 is used to replace '\n' within the string for VB-script Eval function.
	static function Util::Split(
		variable str,						// i:
		variable delimiter,				// i:
		variable& substrings[]) void	// o:
	{
		substrings.SetSize(0);
		if (Util::IsString(str))
		{
			object scriptControl;
			variable size, index;

			// Create script control
			if ( 0 == scriptControl.CreateObject("MSScriptControl.ScriptControl") )
			{
				Error::RaiseEx(IDE::createObjectFailed, GetFileName(), GetFunctionName(), GetLineNumber(), "MSScriptControl.ScriptControl");
			}

			scriptControl.Language = "VBScript";

			// Escape delimiter
			StrReplace(str,       "\"", "\"\"");
			StrReplace(delimiter, "\"", "\"\"");

			// Newline ("\n") within the string to Eval may not be handled.
			// replace it within str and delimiter if available
			// use a exotic replacement character to hope to never make the
			// input string invalid.
			StrReplace(str,       "\n", "\007");
			StrReplace(delimiter, "\n", "\007");

			// Split string
			substrings = scriptControl.Eval("Split(\"" + str + "\", \"" + delimiter + "\")");

			// Undo the newline change wihtin the splitted values.
			size = substrings.GetSize();
			for ( index=0; index < size; index++ )
			{
				StrReplace(substrings.ElementAt(index), "\007", "\n");
			}

		}
	}


	// --------------------------------------------------------------------------------------
	// Exception handling
	// --------------------------------------------------------------------------------------

	static function Error::Raise(variable errorId, variable& fileName, variable& funcName, variable& lineNumber) void
	{
		Error::RaiseEx(errorId, fileName, funcName, lineNumber, "");
	}

	static function Error::RaiseEx(variable errorId, variable& fileName, variable& funcName, variable& lineNumber, variable& addDescription) void
	{
		variable description("");

		// set error description
		description = fileName + "(" + lineNumber + ") : " + funcName + "()\n" + StringTable::Load(errorId);
		description = description + addDescription;
		err.SetDescription(description);

		// raise error (no library help file available for this version)
		err.Raise(errorId, err.GetDescription()/*, StringTable::Load(IDS::helpFileName)*/);
	}

}

#endif
// $$author=cjoerg$$valid=0$$time=2005-08-18 10:48$$checksum=f2278782$$length=083$$