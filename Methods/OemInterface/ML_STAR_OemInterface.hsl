//  ------------------------------------------------------------------------------------
//  Hamilton Company Software Product
//  File: ML_STAR_OemInterface.hsl
//
//  This is a part of the module HxStarOemInterface.
//
//  This method implements an interface which read commands out of a data base
//  and executes corresponding ML_STAR-steps.
//
//  File creation date:  2004-10-13 by cjoerg
//  Last revision date:  2009-11-24 by cjoerg
//
//  Copyright (c) 2009 by Hamilton Bonaduz AG.
//
//
//  Modification History
//  --------------------
//  1.50  2009-11-24 by cjoerg  - Updated for extend table StepList to 7 double parameters (countOfDouble=7).
//                              - Added new parameters to the following steps:
//                                 - MlStar::_1000ulChAspirate
//                                 - MlStar::_1000ulChDispense
//                                 - MlStar::_5mlChAspirate
//                                 - MlStar::_5mlChDispense
//                                 - MlStar::coRe96Aspirate
//                                 - MlStar::coRe96Dispense
//                                 - MlStar::coRe384Aspirate
//                                 - MlStar::coRe384Dispense
//                                 - MlStar::coRe384TipPickUp
//                              - Added the following commands:
//                                 - 1000ul Channel Dispense on the Fly
//                                 - 5ml Channel Dispense on the Fly
//
//  1.40  2008-02-26 by cjoerg  - MlStar::coRe384TipPickUp added new parameters
//                              - MlStar::coReGrip1000ulGetPlate added new parameter
//                              - MlStar::CoReGrip_MovePlate added new parameter xAcceleration
//                              - MlStar::coReGripPlacePlate added new parameters xAcceleration and checkPlate
//                              - MlStar::nanoDispense added new parameter volumeCheck
//                              - MlStar::nanoWash added new parameter diagnosticMode
//                              - MlStar::initialize removed parameters - initializeAlways remains only.
//                              - Added the following commands:
//                                 - Added 5ml Channel Steps:
//                                    - 5ml Channel Tip Pick Up
//                                    - 5ml Channel Aspirate
//                                    - 5ml Channel Dispense
//                                    - 5ml Channel Tip Eject
//                                    - 5ml Channel Get Last Liquid Level
//                                 - Added 5ml CO-RE Grip Steps:
//                                    - 5ml Channel CO-RE Grip Get Plate
//                                    - 5ml Channel CO-RE Grip Place Plate
//                                    - 5ml Channel CO-RE Grip Move Plate
//                                    - 5ml Channel CO-RE Grip Read Barcode
//                                 - Added Tube Grip Steps:
//                                    - Tube Grip Get
//                                    - Tube Grip Place
//                                    - Tube Grip Move
//                                    - Tube Grip Read Barcode
//                                 - Added Tube Grip Steps:
//                                    - Tube Grip Get
//                                    - Tube Grip Place
//                                 - Added Miscellaneous Steps:
//                                    - 5ml Channel Move To Position
//                                    - Wait For TADM Upload
//                                    - Get Channel Exclude State
//                                 - Added S-Tube Caper Steps:
//                                    - S-Tube Cap
//                                    - S-Tube Decap
//
//  1.30  2006-10-24 by cjoerg  Extend table StepList to 12 integer parameters (countOfInteger=12).
//                              - MlStar::dispense: extended with parameters 'side touch' (PI29).
//                                Parameter is added in single step for V4.1.
//                              - Extended with parameter 'grip mode':
//                                - MlStar::iSwapGetPlate
//                                - MlStar::iSwapMovePlate
//                                - MlStar::iSwapOpenGripper
//                                - MlStar::iSwapCloseGripper
//                                - MlStar::iSwapGetFirstPlatePosition
//                              - Extended MlStar::iSwapReadPlateBarcode with parameter 'minimal Z-position' and :
//                                'Y-position during read'.
//                              - MlStar::coRe96Dispense: extended with parameters 'side touch' (PI28).
//                              - MlStar::coRe96Wash: completely updated for dual chamber wash.
//                              - MlStar::coRe96EmptyWasher: completely updated for dual chamber wash station.
//                              - MlStar::coReGripGetPlate: extended with parameter 'grip speed' and 'Z-speed'
//                              - MlStar::coReGripPlacePlate: extended with parameter 'Z-speed' and 'plate press on dinstance'
//                              - MlStar::coReGripReadPlateBarcode: extended with parameter 'minimal Z-postion during read'
//                              - Added the following commands:
//                                - MlStar::coRe384TipPickUp
//                                - MlStar::coRe384TipEject
//                                - MlStar::coRe384Aspirate
//                                - MlStar::coRe384Dispense
//                                - MlStar::coRe384Wash
//                                - MlStar::coRe384EmptyWasher
//                                - MlStar::nanoPrepare
//                                - MlStar::nanoAspirate
//                                - MlStar::nanoDispense
//                                - MlStar::nanoDispenseFly
//                                - MlStar::nanoWash
//                                - MlStar::reLoadCarrier
//  1.22  2005-08-12 by cjoerg  Extend table StepList to 8 integer parameters (countOfInteger=8).
//                              - MlStar::dispense: extended with parameters 'touch off' (PI28) and
//                                'dispense position above touch' (PD45). Added in single step for V4.0.
//                              - MlStar::coRe96Wash: changed parameters for new designed wash step.
//                              - Extended with parameter 'collision control':
//                                - MlStar::iSwapGetFirstPlatePosition
//                                - MlStar::iSwapGetPlate
//                                - MlStar::iSwapMovePlate
//                                - MlStar::iSwapPlacePlate
//                                - MlStar::iSwapReadPlateBarcode
//                              - Added new commands
//                                - MlStar::getLastLiquidLevel (39)
//                                - MlStar::tipTrackingSpeef (40)
//                              - Added debug traces to getContainerVolume().
//                              - Added debug traces for 'startPosition' use in CO-RE 96 head commands
//                              - Removed obsolete ALIM_COMPATIBLE_MODE and its depending states / step.
//                                This mode has been added to be compatible in V3.2 with the
//                                previous implementation named ALIM.
//                                With the HxStarOemInterface this mode has never been released.
//  1.21  2005-06-27 by cjoerg  - Updated device-statement for changed hsl-syntax.
//  1.20  2004-10-19 by cjoerg  - Moved all low level steps into their own file, wrapped by a 
//                                hsl-function for each step. Located in: \ML_STAR_Steps.
//                                Usefull to edit the error-recovery options for a client
//                                of the OEM Interface.
//                              - initChannelVolumes() changed to return an array of volumes.
//  1.10  2004-10-14 by cjoerg  - Add the following commands:
//                                  - CO-RE 96 Head: Tip Pick Up
//                                  - CO-RE 96 Head: Tip Eject
//                                  - CO-RE 96 Head: Aspirate
//                                  - CO-RE 96 Head: Dispense
//                                  - CO-RE 96 Head: Wash
//                                  - CO-RE 96 Head: Empty Washer
//                                  - CO-RE Grip: Get Plate
//                                  - CO-RE Grip: Pace Plate
//                                  - CO-RE Grip: Move Plate
//                                  - CO-RE Grip: Read Plate Barcode
//                                  - Calibrate Carrier
//                                  - Lock Front Cover
//  1.00  2004-10-13 by cjoerg   - Get file from module HxStarSettings
//                               - Changed file name of expected deck layout to 'ML_STAR_OemInterface.lay'
//                               - Changed file name of command list database to 'ML_STAR_OemInterface_CommandList.mdb'
//                               - Changed directory of command list database to configured <Phoenix LogFiles Path>
//                               - Changed naming of events to 'event_ML_STAR_OemInterface_IsWaiting' and
//                                 'event_ML_STAR_OemInterface_Continue'.
//                               - Changed implementation so that after each execution of a command the 
//                                 OEM Interface method changes to the waiting state.
//                               - Removed command 'Wait' (1002). Not longer needed because OEM Interface method
//                                 changes to state waiting after execution of each command.
//                               - Added define for ALIM_COMPATIBLE mode
//  ------------------------------------------------------------------------------------

device mlstar("ML_STAR_OemInterface.lay", "ML_STAR", hslTrue);		// The device and deck layout for the MlStar commands


namespace AL
{

	#ifndef __HSLStrLib_hsl__
	#include "HSLStrLib.hsl"					// Used for command FirmwareCommand.
	#endif

	namespace STR									// Include the StringTable in its own namespace!
	{
		#ifndef __HSLStringTableLib_hsl__
		#include "HSLStringTableLib.hs_"
		#endif
	}


	// ====================================================================================================
	// Debugging
	// ====================================================================================================

	//#define _DEBUG_AL						1										// specifies the debug version

	//#define _DEBUG_STAR_STEPPARAMS		1										// ML_STAR commands traces the parameters before step execution

	//#define _DEBUG							1										// debugs also the included libraries


	// ====================================================================================================
	// ML_STAR OEM Interface: Implementation
	// ====================================================================================================

	// ----------------------------------------------------------------------------------------------------
	// String table initialization 
	// ----------------------------------------------------------------------------------------------------
	static function initStringTable() variable;						// initializes the string table (only once)


	// ----------------------------------------------------------------------------------------------------
	// Command state
	// ----------------------------------------------------------------------------------------------------
	namespace CommandState
	{
		static const variable first					( 0 );				// Guard
		static const variable undefined				(first + 0);		// No command pending
		static const variable readStart				(first + 1);		// Reading of command started
		static const variable readComplete			(first + 2);		// Command data readed from StepList
		static const variable executeStart			(first + 3);		// Command started
		static const variable executeComplete		(first + 4);		// Command completed
		static const variable resultWritten			(first + 5);		// Result is written.
		static const variable last						(first + 5);		// Guard
	}


	// ----------------------------------------------------------------------------------------------------
	// Functions
	// ----------------------------------------------------------------------------------------------------

	// Main function to read and execute commands from the Command List.
	// Implements an endless loop until command 'Method Complete' or 'Abort'.
	static function runOemInterface() void;

	// Set the command state for a specific command.
	// Parameter stepID checked in the debug version but not used at this time, because currently
	// only ONE command is readed and executet at the same time.
	function setCommandState(
		variable stepID,											// i: StepID for which the state shall be set.
		variable state) void;									// i: One of the CommandState to set.

	// Get the command state for a specific command.
	// Parameter stepID checked in the debug version but not used at this time, because currently
	// only ONE command is readed and executet at the same time.
	// 
	// Return: One of CommandState as integer
	function getCommandState(
		variable stepID) variable;								// i: StepID for which the state shall be returned.

	// Perform a complete waiting -- continue procedure.
	// Signal the event 'isWaiting' and wait for the event 'continue' for infinite time.
	// Traces both states (waiting start -- complete).
	function performWaiting() void;

	// Functions for access to the readed columns of the StepList.
	// Parameter stepID checked but not used at this time, because currently only ONE command
	// is readed and executet at the same time.
	// The indexes for the parameters are one-based.
	function getCommandID(variable stepID) variable;								// Return a integer
	function getStringParam(variable stepID, variable index) variable; 		// Return a string
	function getIntegerParam(variable stepID, variable index) variable; 		// Return a integer
	function getDoubleParam(variable stepID, variable index) variable; 		// Return a double

	// Set/Get for the flag that indicates that the method shall finish next
	static function setFinishMethodFlag(variable value) void;
	static function getFinishMethodFlag() variable;

	// Set/Get for the flag that indicates that the method shall abort next
	static function setAbortMethodFlag(variable value) void;
	static function getAbortMethodFlag() variable;

	// Close files and clean up.
	// Calls also the cleanUp-functions for the other namespaces
	static function cleanUp() void;

	// The main abort handler. Is called even the method aborts.
	// Write the (abort) result for all readed commands and call cleanUp().
	static global function oemInterface_mainAbortHandler() void;

	// Only one command is readed at one time. Write abort result for it.
	static function writeAbortResultForAllReaded() void;

	// Write the abort resut for the command identified by the given stepID.
	// If the command was not readed or already completed not result is written.
	// 
	// Return: ResultList::CommandResult::aborted if a command was readed but not completed, otherwise
	//         the result of the completed command is returned.
	static function writeAbortResult(
		variable stepID) variable;				// StepID as integer


	// ----------------------------------------------------------------------------------------------------
	// 'Public' members
	// ----------------------------------------------------------------------------------------------------
	static variable m_dataBaseFile("");										// Initialized with the absolute path and
																						// file name after method start.

	// ----------------------------------------------------------------------------------------------------
	// 'Private' members
	// ----------------------------------------------------------------------------------------------------
	static variable m_commandListStepID;							// Counting of the StepID to read. Is incremented
																				// each time before reading a command.

	static variable m_initializedLib(hslFalse);					// initialization state of the string table
	static variable m_commandState(CommandState::undefined);	// stores the command state, one of CommandState

	static variable m_finishMethodFlag(hslFalse);				// Set to true to finish by a command
	static variable m_abortMethodFlag(hslFalse);					// Set to true to abort by a command


	// ====================================================================================================
	// StepList: Access, handling, interpretation of the StepList table
	// ====================================================================================================
	namespace StepList
	{
		// -------------------------------------------------------------------------------------------------
		// Constants
		// -------------------------------------------------------------------------------------------------
		static const variable tableName("StepList");			// Name of the table to open

		// -------------------------------------------------------------------------------------------------
		// Constants: Parameters and column definition
		// -------------------------------------------------------------------------------------------------
		static const variable countOfString(3);				// Count of string parameters
		static const variable countOfInteger(12);				// Count of integer parameters
		static const variable countOfDouble(7);				// Count of double parameters

		static const variable firstString(1);					// No of first string parameter
		static const variable firstInteger(21);				// No of first integer parameter
		static const variable firstDouble(41);					// No of first double parameter

		static const variable countOfParamNumDigits(2);		// Count of the digits used to number the paramaters
																			// (e.g. parameter 2 is numbered as '02' with two digits)
		// -------------------------------------------------------------------------------------------------
		// 'Public' functions
		// -------------------------------------------------------------------------------------------------

		// Reads a command out of the StepList-table. Overwrites the last readed parameter set.
		// The readed values are available by the get...functions.
		// My raise a exception if the read fails.
		//
		function readCommand(
			variable stepID) void;				// i: StepID of the command to read as integer.

		// Functions for access to the readed data out of the StepList-table.
		// The index-parameter is one-based.
		//
		function getCommandID()  variable;							// Return a integer
		function getStringParam(variable index) variable;		// Return a string
		function getIntegerParam(variable index) variable;		// Return a integer
		function getDoubleParam(variable index) variable;		// Return a double

		// Clean up and close the StepList-table.
		function cleanUp() void;


		// -------------------------------------------------------------------------------------------------
		// 'Private' functions
		// -------------------------------------------------------------------------------------------------

		// Prepare the file for read access once and set the size of the parameter arrays.
		// Reset all parameter values by each call.
		//
		static function prepare() void;

		// Returns a integer number as string. Returned string has equal ore more than
		// 'countOfParamNumDigits' digits. Missing digits are filled left with '0'.
		//
		// Return: Formatted number as string
		//
		static function formatParameterNo(
			variable number) variable;					// i: Number to format (integer).


		// -------------------------------------------------------------------------------------------------
		// 'Private' members
		// -------------------------------------------------------------------------------------------------

		static file fileHandle;							// File opened for read a command:
		static variable r_stepID;						//    readed StepID
		static variable r_commandID;					//    readed CommandID
		static variable r_ps[];							//    arry of readed string parameters (index: 0...countOfString-1)
		static variable r_pi[];							//    arry of readed integer parameters (index: 0...countOfInteger-1)
		static variable r_pd[];							//    arry of readed double parameters (index: 0...countOfDouble-1)

		static variable isPrepared(hslFalse);		// Flag set to true if StepList is prepared.

	} // End namespace StepList



	// ====================================================================================================
	// PositionData: Access, handling, interpretation of the PositionData table
	// ====================================================================================================

	namespace PositionData
	{

		// -------------------------------------------------------------------------------------------------
		// Constants
		// -------------------------------------------------------------------------------------------------

		static const variable tableName("PositionData");	// Name of the table to open


		// -------------------------------------------------------------------------------------------------
		// 'Public' functions
		// -------------------------------------------------------------------------------------------------

		// Initialize a sequence with elemets out of the PositionData table. Existing elements are NOT
		// removed first. Current is always set to one.
		// Query for the stepID and groupID to get the actual data out of the data base by each call.
		//
		function initStepSequence(
			variable stepID,											//  i: Identifier for the requested position as integer
			variable groupID,											//  i: GroupID of the position data as integer
			sequence& stepSequence) void;							// io: Readed elements are added to this sequence,
																			//     current is always set to 1.

		// Clean up and close the file.
		function cleanUp() void;


		// -------------------------------------------------------------------------------------------------
		// 'Private' functions
		// -------------------------------------------------------------------------------------------------

		// Prepare the file for read access once.
		// Reset all parameter values by each call.
		//
		static function prepare() void;


		// -------------------------------------------------------------------------------------------------
		// 'Private' members
		// -------------------------------------------------------------------------------------------------

		static file  fileHandle;									// File opened for read a step sequence:
		static variable r_labwareID("");							//    readed LabwareID
		static variable r_positionID("");						//    readed PositionID

		static variable isPrepared(hslFalse);					// Flag set to true if the table fields are added

	} // End namespace PositionData



	// ====================================================================================================
	// VolumeData: Access, handling, interpretation of the VolumeData table
	// ====================================================================================================

	namespace VolumeData
	{

		// -------------------------------------------------------------------------------------------------
		// Constants
		// -------------------------------------------------------------------------------------------------

		static const variable tableName("VolumeData");		// Name of the table to open


		// -------------------------------------------------------------------------------------------------
		// 'Public' functions
		// -------------------------------------------------------------------------------------------------

		// Read a volume for each used channel out of the VolumeData table.
		// May raise a exception.
		// For unused channels no volume is readed and the volume is set to 0.
		// The volumes for channels that exceeds the channel pattern also 0 is set.
		// e.g. channelPattern = "0110"
		// 	volume[0] = 0.0 (unused channel)
		// 	volume[1] = first value out of the VolumeData table
		// 	volume[2] = second value out of the VolumeData table
		// 	volume[3] = 0.0 (unused channel)
		// 	volume[4] = 0.0 (exceeds the channel pattern)
		// 	volume[5] = ......
		//												
		function initChannelVolumes(
			variable stepID,											// i: Identifier for the requested volumes as integer
			variable& channelPattern) variable[];				// i: Channel pattern
		
		function initChannelVolumesNano(
			variable stepID,											// i: Identifier for the requested volumes as integer
			variable& channelPattern) variable[];				// i: Channel pattern

		// Clean up and close the file.
		function cleanUp() void;


		// -------------------------------------------------------------------------------------------------
		// 'Private' functions
		// -------------------------------------------------------------------------------------------------

		// Prepare the file for read access once.
		// Reset all parameter values by each call.
		//
		static function prepare() void;


		// -------------------------------------------------------------------------------------------------
		// 'Private' members
		// -------------------------------------------------------------------------------------------------
		static file  fileHandle;									// File opened for read.
		static variable r_volume(0.0);							//    readed volume

		static variable isPrepared(hslFalse);					// Flag set to hslTrue if the table fields are added

	} // End namespace VolumeData



	// ====================================================================================================
	// ResultList: Writes the ResultList table
	// ====================================================================================================

	namespace ResultList
	{

		// -------------------------------------------------------------------------------------------------
		// Constants
		// -------------------------------------------------------------------------------------------------

		static const variable tableName("ResultList");		// Name of the table to open
		static const variable resultDataLength(255);			// Max length of the strings stored in a field


		// -------------------------------------------------------------------------------------------------
		// CommandResult definitions
		// -------------------------------------------------------------------------------------------------

		namespace CommandResult
		{
			static const variable first					( 0 );				// Guard
			static const variable succeed					(first + 0);		// Command completed successfully.
			static const variable failed					(first + 1);		// Command not completed successfully.
			static const variable fatal					(first + 2);		// Command ends fatal.
			static const variable aborted					(first + 3);		// Method (Command) aborted.
			static const variable last						(first + 3);		// Guard
		}


		// -------------------------------------------------------------------------------------------------
		// 'Public' functions
		// -------------------------------------------------------------------------------------------------

		// Write the result for a Step to the ResultList-table.
		// May throw a exception if file write failed.
		// If the result data are emtpy, fatal result is writen.
		//
		// Return: The commandResult, may be set to ResultList::CommandResult::fatal
		//
		function writeResult(
			variable stepID,							// StepID for which the result shal be written as integer
			variable commandResult,					// One of ResultList::CommandResult as integer
			variable& resultData[]) variable;	// Result data to write

		
		// Checks the error-object and if an unknown errorID is set, overwrites the
		// error-object with unknown-error.
		// Initialize the resultData with fatal error data.
		//
		// Return: ResultList::CommandResult::fatal
		//
		function initFatalResultData(
			variable& resultData[]) variable;			// o: result data for the fatal result


		// Checks the error-object and if an unknown errorID is set, overwrites the
		// error-object with unknown-error.
		// Initialize the resultData with fatal error data.
		//
		// Return: ResultList::CommandResult::aborted
		//
		function initAbortResultData(
			variable& resultData[]) variable;			// o: result data for the abort result


		function cleanUp() void;							// Close the file.

		
		// -------------------------------------------------------------------------------------------------
		// 'Private' functions
		// -------------------------------------------------------------------------------------------------
		static function prepare() void;							// Add the fields to the file-object if necessary.
																			// does not open the file for write!

		static function emptyResultListTable() void;			// Deletes all records out of the table.


		// -------------------------------------------------------------------------------------------------
		// 'Private' members
		// -------------------------------------------------------------------------------------------------

		static file  fileHandle;									// File opened for write.
		static variable w_stepID(-1);								//    StepID to write
		static variable w_commandResult(-1);					//    CommandResult to write
		static variable w_resultNo(-1);							//    ResultNo to write
		static variable w_resultFragment(-1);					//    ResultFragment to write
		static variable w_resultData("");						//    ResultData to write

		static variable isPrepared(hslFalse);					// Flag set to hslTrue if the table fields are added

	} // End namespace ResultList



	// ====================================================================================================
	// Commands:
	// ====================================================================================================

	namespace Cmd
	{

		// =================================================================================================
		// MlStar commands
		// =================================================================================================

		namespace MlStar
		{
			// Used from the libraries included below to disable the global device statement
			// if included from this method.
			#ifndef INCLUDED_FROM_METHOD
				#define INCLUDED_FROM_METHOD 1
			#endif

			// Include of the low level steps. Each step is wraped by a
			// function. Each function is written in a separate library (file).
			#include "ML_STAR_Steps\\Prep_Initialize.hsl"
			#include "ML_STAR_Steps\\Prep_LoadCarrier.hsl"
			#include "ML_STAR_Steps\\Prep_ReLoadCarrier.hsl"
			#include "ML_STAR_Steps\\Prep_UnloadCarrier.hsl"
			#include "ML_STAR_Steps\\Prep_CalibrateCarrier.hsl"
			#include "ML_STAR_Steps\\Prep_SetCarrierTemperature.hsl"
			#include "ML_STAR_Steps\\Prep_GetCarrierTemperature.hsl"
			#include "ML_STAR_Steps\\Prep_LockFrontCover.hsl"
			#include "ML_STAR_Steps\\Prep_CameraChannelMove.hsl"
			#include "ML_STAR_Steps\\Prep_STubeCap.hsl"
			#include "ML_STAR_Steps\\Prep_STubeDecap.hsl"

			#include "ML_STAR_Steps\\Channel_TipPickUp.hsl"					// 1000ul Channel
			#include "ML_STAR_Steps\\Channel_NeedlePickUp.hsl"				// 1000ul Channel
			#include "ML_STAR_Steps\\Channel_TipOrNeedleEject.hsl"		// 1000ul Channel
			#include "ML_STAR_Steps\\Channel_Aspirate.hsl"					// 1000ul Channel
			#include "ML_STAR_Steps\\Channel_Dispense.hsl"					// 1000ul Channel
			#include "ML_STAR_Steps\\Channel_DispenseFly.hsl"				// 1000ul Channel
			#include "ML_STAR_Steps\\Channel_WaitNeedleWashed.hsl"		// 1000ul Channel
			#include "ML_STAR_Steps\\Channel_StartNeedleWash.hsl"			// 1000ul Channel
			#include "ML_STAR_Steps\\Channel_GetLastLiquidLevel.hsl"		// 1000ul Channel

			#include "ML_STAR_Steps\\Channel_5ml_TipPickUp.hsl"				// 5ml Channel
			#include "ML_STAR_Steps\\Channel_5ml_TipEject.hsl"					// 5ml Channel
			#include "ML_STAR_Steps\\Channel_5ml_Aspirate.hsl"					// 5ml Channel
			#include "ML_STAR_Steps\\Channel_5ml_Dispense.hsl"					// 5ml Channel
			#include "ML_STAR_Steps\\Channel_5ml_DispenseFly.hsl"					// 5ml Channel
			#include "ML_STAR_Steps\\Channel_5ml_GetLastLiquidLevel.hsl"	// 5ml Channel

			#include "ML_STAR_Steps\\iSwap_GetPlate.hsl"
			#include "ML_STAR_Steps\\iSwap_PlacePlate.hsl"
			#include "ML_STAR_Steps\\iSwap_MovePlate.hsl"
			#include "ML_STAR_Steps\\iSwap_OpenGripper.hsl"
			#include "ML_STAR_Steps\\iSwap_CloseGripper.hsl"
			#include "ML_STAR_Steps\\iSwap_ReadPlateBarcode.hsl"
			#include "ML_STAR_Steps\\iSwap_GetFirstPlatePosition.hsl"
			#include "ML_STAR_Steps\\iSwap_Park.hsl"
			
			#include "ML_STAR_Steps\\CoRe96Head_TipPickUp.hsl"
			#include "ML_STAR_Steps\\CoRe96Head_TipEject.hsl"
			#include "ML_STAR_Steps\\CoRe96Head_Aspirate.hsl"
			#include "ML_STAR_Steps\\CoRe96Head_Dispense.hsl"
			#include "ML_STAR_Steps\\CoRe96Head_Wash.hsl"
			#include "ML_STAR_Steps\\CoRe96Head_EmptyWasher.hsl"

			#include "ML_STAR_Steps\\CoRe384Head_TipPickUp.hsl"
			#include "ML_STAR_Steps\\CoRe384Head_TipEject.hsl"
			#include "ML_STAR_Steps\\CoRe384Head_Aspirate.hsl"
			#include "ML_STAR_Steps\\CoRe384Head_Dispense.hsl"
			#include "ML_STAR_Steps\\CoRe384Head_Wash.hsl"
			#include "ML_STAR_Steps\\CoRe384Head_EmptyWasher.hsl"

			#include "ML_STAR_Steps\\Nano_Prepare.hsl"
			#include "ML_STAR_Steps\\Nano_Aspirate.hsl"
			#include "ML_STAR_Steps\\Nano_Dispense.hsl"
			#include "ML_STAR_Steps\\Nano_DispenseFly.hsl"
			#include "ML_STAR_Steps\\Nano_Wash.hsl"

			#include "ML_STAR_Steps\\CoReGrip_GetPlate.hsl"			// 1000ul Channel
			#include "ML_STAR_Steps\\CoReGrip_PlacePlate.hsl"		// 1000ul Channel
			#include "ML_STAR_Steps\\CoReGrip_MovePlate.hsl"		// 1000ul Channel
			#include "ML_STAR_Steps\\CoReGrip_ReadBarcode.hsl"		// 1000ul Channel

			#include "ML_STAR_Steps\\CoReGrip_5ml_GetPlate.hsl"		// 5ml Channel
			#include "ML_STAR_Steps\\CoReGrip_5ml_PlacePlate.hsl"		// 5ml Channel
			#include "ML_STAR_Steps\\CoReGrip_5ml_MovePlate.hsl"		// 5ml Channel
			#include "ML_STAR_Steps\\CoReGrip_5ml_ReadBarcode.hsl"	// 5ml Channel

			#include "ML_STAR_Steps\\TubeGrip_Get.hsl"
			#include "ML_STAR_Steps\\TubeGrip_Place.hsl"
			#include "ML_STAR_Steps\\TubeGrip_Move.hsl"
			#include "ML_STAR_Steps\\TubeGrip_ReadBarcode.hsl"

			#include "ML_STAR_Steps\\Misc_ReadPort.hsl"
			#include "ML_STAR_Steps\\Misc_WritePort.hsl"
			#include "ML_STAR_Steps\\Misc_MoveToPosition.hsl"		// 1000ul Channel
			#include "ML_STAR_Steps\\Misc_MoveToPosition_5ml.hsl"	// 5ml Channel
			#include "ML_STAR_Steps\\Misc_MoveAutoLoad.hsl"
			#include "ML_STAR_Steps\\Misc_FirmwareCommand.hsl"
			#include "ML_STAR_Steps\\Misc_TipTrackingSpeed.hsl"
			#include "ML_STAR_Steps\\Misc_WaitForTADM.hsl"
			#include "ML_STAR_Steps\\Misc_GetChannelExcludeState.hsl"


			#ifdef _DEBUG_STAR_STEPPARAMS				// Used to trace parameters (e.g. GetContainerVolume()).
				#ifndef __MlStarStepsUtilLib_hsl__
				#include "MlStarStepsUtilLib.hsl"
				#endif
			#endif


			#ifndef __HSLMlStarCfgKeys_hs___
			#include "HSLMlStarCfgKeys.hs_"				// Defines some key's for use with a MlStar.
			#endif

			#ifndef __HSLMlStarStepReturnLib_hsl__
			#include "HSLMlStarStepReturnLib.hsl"		// Support for interpretation of MlStar step returns.
			#endif

			#ifndef __HSLML_STARLib_hsl__
			#include "HSLML_STARLib.hsl"					// Used for command getContainerVolume.
			#endif

			// ----------------------------------------------------------------------------------------------
			// Additional functions with same context as the included step return library.
			// ----------------------------------------------------------------------------------------------

			namespace StepReturnEx
			{
				// -------------------------------------------------------------------------------------------
				// Numbering of the MlStar step result values, see HxGRUCommmand, 'General Step Result Format'
				// -------------------------------------------------------------------------------------------
				namespace StepResultNo
				{
					static const variable instrumentName		(0);		// Instrument result value 1
					static const variable stepName				(1);		// Instrument result value 2
					static const variable firstBlockData		(2);		// Instrument result value 3
					// Last resultNo is step dependand			(X);		// ResultNo ..X (Instrument result value X)
					static const variable requiredResultCount (firstBlockData+1);	// Minimally required
																										// result count
				}


				// ----------------------------------------------------------------------------------------------
				// MlStar specific error codes, see HxGRUCommmand, 'General Step Result Format'
				// ----------------------------------------------------------------------------------------------

				namespace StepErrorCode
				{
					static const variable OK						(0);		// Step ends with OK
					static const variable OK_Abort_Cancel		(1);		// Step ends with OK, Abort or Cancel
					static const variable fatal					(2);		// Step ends fatal
				}


				// ----------------------------------------------------------------------------------------------
				// Instrument specific values, initialized in prepare()
				// ----------------------------------------------------------------------------------------------

				namespace InstrumentValues
				{
					static variable numberOfChannels(-1);								// No of channels for the instrument
					static variable blockDelimiter("");									// block delimter
					static variable fieldDelimiter("");									// field delimter
				}


				// -------------------------------------------------------------------------------------------
				// 'Private' functions
				// -------------------------------------------------------------------------------------------

				static function bindErrorData(					// Binds and check the error data to the step return. 
																			// Raise an error if the step return contains a fatal error.
					variable& rc[]) void;							// o: step return, string array

				static function checkErrorData(					// Checks the error data in the step return 
					variable& rc[]) variable;						// i: step return as string array
																			// Return: one of the StepErrorCode.

				static function getStepErrorCode(				// Evaluates the step error code out of the block data
					variable& rc[]) variable;						// i: step return as string array
																			// Return: one of the StepErrorCode.

			} // End namespace MlStar::StepReturnEx
			

			// ----------------------------------------------------------------------------------------------
			// Available MlStar CommandID's
			// ----------------------------------------------------------------------------------------------

			namespace ID
			{
				static const variable first								( 1);		// Guard
				static const variable initialize							( 1);	// Intitialize
				static const variable _1000ulChTipPickUp				( 2);	// 1000ul Tip Pick Up
				static const variable _1000ulChNeedlePickUp			( 3);	// 1000ul Needle Pick Up
				static const variable _1000ulChTipNeedleEject		( 4);	// 1000ul Tip/Needle Eject
				static const variable _1000ulChAspirate				( 5);	// 1000ul Aspirate
				static const variable _1000ulChDispense				( 6);	// 1000ul Dispense
				static const variable loadCarrier						( 7);	// Load Carrier
				static const variable unloadCarrier						( 8);	// Unload Carrier
				static const variable _1000ulChWaitNeedleWashed		( 9);	// 1000ul Wait Needle Washed
				static const variable _1000ulChStartNeedleWash		(10);	// 1000ul Start Needle Wash
				static const variable _1000ulChGetContainerVolume	(11);	// 1000ul Get Container Volume
				static const variable iSwapGetPlate						(12);	// iSWAP: Get Plate
				static const variable iSwapPlacePlate					(13);	// iSWAP: Place Plate
				static const variable iSwapMovePlate					(14);	// iSWAP: Move Plate
				static const variable iSwapOpenGripper					(15);	// iSWAP: Open Gripper
				static const variable iSwapCloseGripper				(16);	// iSWAP: Close Gripper
				static const variable iSwapReadPlateBarcode			(17);	// iSWAP: Read Plate Barcode
				static const variable iSwapGetFirstPlatePosition	(18);	// iSWAP: Get First Plate Position
				static const variable iSwapPark							(19);	// iSWAP: Park
				static const variable readPort							(20);	// Read Port
				static const variable writePort							(21);	// Write Port
				static const variable _1000ulChMoveToPosition		(22);	// 1000ul Channel Move To Position
				static const variable moveAutoLoad						(23);	// Move Auto Load
				static const variable execFirmwareCmd					(24);	// Execute a firmware command
				static const variable tccSetCarrierTemperature		(25);	// TCC: Set Carrier Temperature
				static const variable tccGetCarrierTemperature		(26);	// TCC: Get Carrier Temperature
				static const variable coRe96TipPickUp					(27);	// CO-RE 96 Head: Tip Pick Up
				static const variable coRe96TipEject					(28);	// CO-RE 96 Head: Tip Eject
				static const variable coRe96Aspirate					(29);	// CO-RE 96 Head: Aspirate
				static const variable coRe96Dispense					(30);	// CO-RE 96 Head: Dispense
				static const variable coRe96Wash							(31);	// CO-RE 96 Head: Wash
				static const variable coRe96EmptyWasher				(32);	// CO-RE 96 Head: Empty Washer
				static const variable coReGrip1000ulGetPlate			(33);	// 1000ul CO-RE Grip: Get Plate
				static const variable coReGrip1000ulPlacePlate		(34);	// 1000ul CO-RE Grip: Place Plate
				static const variable coReGrip1000ulMovePlate		(35);	// 1000ul CO-RE Grip: Move Plate
				static const variable coReGrip1000ulReadPlateBarcode(36);	// 1000ul CO-RE Grip: Read Plate Barcode
				static const variable calibrateCarrier					(37);	// Calibrate Carrier
				static const variable lockFrontCover					(38);	// Lock Front Cover 
				static const variable _1000ulChGetLastLiquidLevel	(39);	// 1000ul Channel Get Last Liquid Level
				static const variable tipTrackingSpeed					(40);	// Misc: Tip Tracking Speed
				static const variable coRe384TipPickUp					(41);	// CO-RE 384 Head: Tip Pick Up
				static const variable coRe384TipEject					(42);	// CO-RE 384 Head: Tip Eject
				static const variable coRe384Aspirate					(43);	// CO-RE 384 Head: Aspirate
				static const variable coRe384Dispense					(44);	// CO-RE 384 Head: Dispense
				static const variable coRe384Wash						(45);	// CO-RE 384 Head: Wash
				static const variable coRe384EmptyWasher				(46);	// CO-RE 384 Head: Empty Washer
				static const variable nanoPrepare						(47);	// Nanopipettor: Prepare
				static const variable nanoAspirate						(48);	// Nanopipettor: Aspirate
				static const variable nanoDispense						(49);	// Nanopipettor: Dispense
				static const variable nanoDispenseFly					(50);	// Nanopipettor: Dispense On The Fly
				static const variable nanoWash							(51);	// Nanopipettor: Wash
				static const variable reLoadCarrier						(52);	// Re-Load Carrier
				static const variable _5mlChTipPickUp					(53);	// 5ml Channel Tip Pick Up
				static const variable _5mlChTipEject					(54);	// 5ml Channel Tip Eject
				static const variable _5mlChAspirate					(55);	// 5ml Channel Aspirate
				static const variable _5mlChDispense					(56);	// 5ml Channel Dispense
				static const variable _5mlChGetLastLiquidLevel		(57);	// 5ml Channel Get Last Liquid Level
				static const variable _5mlChMoveToPosition			(58);	// 5ml Channel Move To Position
				static const variable coReGrip5mlGetPlate				(59);	// 5ml CO-RE Grip: Get Plate
				static const variable coReGrip5mlPlacePlate			(60);	// 5ml CO-RE Grip: Place Plate
				static const variable coReGrip5mlMovePlate			(61);	// 5ml CO-RE Grip: Move Plate
				static const variable coReGrip5mlReadPlateBarcode	(62);	// 5ml CO-RE Grip: Read Plate Barcode
				static const variable cameraChannelMove				(63);	// Camera Channel Move
				static const variable sTubeCap							(64);	// S-Tube Cap
				static const variable sTubeDecap							(65);	// S-Tube Decap
				static const variable tubeGripGet						(66);	// Tube Grip: Get
				static const variable tubeGripPlace						(67);	// Tube Grip: Place
				static const variable tubeGripMove						(68);	// Tube Grip: Move
				static const variable tubeGripReadBarcode				(69);	// Tube Grip: Read Barcode
				static const variable waitForTADM						(70);	// Wait For TADM Upload
				static const variable getChannelExcludeState			(71);	// Get Channel Exclude State
				static const variable _1000ulChDispenseFly			(72);	// 1000ul Channel Dispense on the Fly
				static const variable _5mlChDispenseFly				(73);	// 5ml Channel Dispense on the Fly
				static const variable last									(73);		// Guard
			}


			// ----------------------------------------------------------------------------------------------
			// Numbering of the result values (zero based) as specified by the HxGRUCommand
			// ----------------------------------------------------------------------------------------------
			namespace InstrResultValue
			{
				static const variable instrumentName		(0);		// Instrument result value 1
				static const variable stepName				(1);		// Instrument result value 2
				static const variable firstBlockData		(2);		// Instrument result value 3
				// Last number is step dependand				(X);		// Instrument result value X
			}


			// ----------------------------------------------------------------------------------------------
			// Numbering of the command result data (zero based) as specified for the OEM Interface
			// ----------------------------------------------------------------------------------------------
			namespace ResultDataNo
			{
				static const variable usedPositions			(0);		// ResultNo 1
				static const variable instrumentName		(1);		// ResultNo 2	(Instrument result value 1)
				static const variable stepName				(2);		// ResultNo 3	(Instrument result value 2)
				static const variable firstBlockData		(3);		// ResultNo 4	(Instrument result value 3)
				// Last resultNo is step dependand			(X);		// ResultNo ..X (Instrument result value
																					//               ...X-1)
				static const variable requiredResultCount 	(firstBlockData+1);	// Minimally required
																										// result count
			}


			// ----------------------------------------------------------------------------------------------
			// 'Public' functions
			// ----------------------------------------------------------------------------------------------

			// Execute one of the MlStar-commands.
			// Expect that all data as defined in the StepList are available for the given StepID.
			// Writes the command result into the ResultList.
			// May raise a exception if the command ends fatal and a abort is required.
			//
			// Return: One of ResultList::CommandResult as integer
			//
			function runCommand(
				variable stepID) variable;				// i: StepID of the command to execute as integer


			// ----------------------------------------------------------------------------------------------
			// 'Private' functions
			// ----------------------------------------------------------------------------------------------

			static function prepare() void;			// Prepare the MlStar commands once. Initiialize the
																// members of the namespace StepReturnEx::InstrumentValues.


			// Implementation of each available command.
			// Parameter stepID [i] identifies the command to execute (integer).
			// May raise an exception if the command ends fatal or an other error occurs.
			//
			// Return: CommandResultData as array of strings.
			//
			static function initialize(						variable stepID) variable[];	// Initialize
			static function _1000ulChTipPickUp(				variable stepID) variable[];	// Tip Pick Up
			static function _1000ulChNeedlePickUp(			variable stepID) variable[];	// Needle Pick Up
			static function _1000ulChTipNeedleEject(		variable stepID) variable[];	// Needle Eject
			static function _1000ulChAspirate(				variable stepID) variable[];	// Aspirate
			static function _1000ulChDispense(				variable stepID) variable[];	// Dispense
			static function _1000ulChDispenseFly(			variable stepID) variable[];	// Dispense
			static function loadCarrier(						variable stepID) variable[];	// Load Carrier
			static function unloadCarrier(					variable stepID) variable[];	// Unload Carrier
			static function _1000ulChWaitNeedleWashed(	variable stepID) variable[];	// Wait Needle Washed
			static function _1000ulChStartNeedleWash(		variable stepID) variable[];	// Start Needle Wash
			static function _1000ulChGetContainerVolume(	variable stepID) variable[];	// Get Container Volume
			static function iSwapGetPlate(					variable stepID) variable[];	// iSWAP: Get Plate
			static function iSwapPlacePlate(					variable stepID) variable[];	// iSWAP: Place Plate
			static function iSwapMovePlate(					variable stepID) variable[];	// iSWAP: Move Plate
			static function iSwapOpenGripper(				variable stepID) variable[];	// iSWAP: Open Gripper
			static function iSwapCloseGripper(				variable stepID) variable[];	// iSWAP: Close Gripper
			static function iSwapReadPlateBarcode(			variable stepID) variable[];	// iSWAP: Read Plate Barcode
			static function iSwapGetFirstPlatePosition(	variable stepID) variable[];	// iSWAP: Get First Plate Position
			static function iSwapPark(							variable stepID) variable[];	// iSWAP: Park
			static function readPort(							variable stepID) variable[];	// Read Port
			static function writePort(							variable stepID) variable[];	// Write Port
			static function _1000ulChMoveToPosition(		variable stepID) variable[];	// Move To Position
			static function moveAutoLoad(						variable stepID) variable[];	// Move Auto Load
			static function execFirmwareCmd(					variable stepID) variable[];	// Execute firmware command
			static function tccSetCarrierTemperature(		variable stepID) variable[];	// TCC: Set Carrier Temperature
			static function tccGetCarrierTemperature(		variable stepID) variable[];	// TCC: Get Carrier Temperature
			static function coRe96TipPickUp(					variable stepID) variable[];	// CO-RE 96 Head: Tip Pick Up
			static function coRe96TipEject(					variable stepID) variable[];	// CO-RE 96 Head: Tip Eject
			static function coRe96Aspirate(					variable stepID) variable[];	// CO-RE 96 Head: Aspirate
			static function coRe96Dispense(					variable stepID) variable[];	// CO-RE 96 Head: Dispense
			static function coRe96Wash(						variable stepID) variable[];	// CO-RE 96 Head: Wash
			static function coRe96EmptyWasher(				variable stepID) variable[];	// CO-RE 96 Head: Empty Washer
			static function coReGrip1000ulGetPlate(		variable stepID) variable[];	// 1000ul CO-RE Grip: Get Plate
			static function coReGrip1000ulPlacePlate(		variable stepID) variable[];	// 1000ul CO-RE Grip: Place Plate
			static function coReGrip1000ulMovePlate(		variable stepID) variable[];	// 1000ul CO-RE Grip: Move Plate
			static function coReGrip1000ulReadPlateBarcode(variable stepID) variable[];	// 1000ul CO-RE Grip: Read Plate Barcode
			static function calibrateCarrier(				variable stepID) variable[];	// Calibrate Carrier
			static function lockFrontCover(					variable stepID) variable[];	// Lock Front Cover
			static function _1000ulChGetLastLiquidLevel(	variable stepID) variable[];	// Get Last Liquid Level
			static function tipTrackingSpeed(				variable stepID) variable[];	// Tip Tracking Speed
			static function coRe384TipPickUp(				variable stepID) variable[];	// CO-RE 384 Head: Tip Pick Up
			static function coRe384TipEject(					variable stepID) variable[];	// CO-RE 384 Head: Tip Eject
			static function coRe384Aspirate(					variable stepID) variable[];	// CO-RE 384 Head: Aspirate
			static function coRe384Dispense(					variable stepID) variable[];	// CO-RE 384 Head: Dispense
			static function coRe384Wash(						variable stepID) variable[];	// CO-RE 384 Head: Wash
			static function coRe384EmptyWasher(				variable stepID) variable[];	// CO-RE 384 Head: Empty Washer
			static function nanoPrepare(						variable stepID) variable[];	// Nanopipettor: Prepare
			static function nanoAspirate(						variable stepID) variable[];	// Nanopipettor: Aspirate
			static function nanoDispense(						variable stepID) variable[];	// Nanopipettor: Dispense
			static function nanoDispenseFly(					variable stepID) variable[];	// Nanopipettor: Dispense On The Fly
			static function nanoWash(							variable stepID) variable[];	// Nanopipettor: Wash
			static function reLoadCarrier(					variable stepID) variable[];	// Re-Load Carrier
			static function _5mlChTipPickUp(					variable stepID) variable[];
			static function _5mlChTipEject(					variable stepID) variable[];
			static function _5mlChAspirate(					variable stepID) variable[];
			static function _5mlChDispense(					variable stepID) variable[];
			static function _5mlChDispenseFly(					variable stepID) variable[];
			static function _5mlChGetLastLiquidLevel(		variable stepID) variable[];
			static function _5mlChMoveToPosition(			variable stepID) variable[];
			static function coReGrip5mlGetPlate(			variable stepID) variable[];
			static function coReGrip5mlPlacePlate(			variable stepID) variable[];
			static function coReGrip5mlMovePlate(			variable stepID) variable[];
			static function coReGrip5mlReadPlateBarcode(	variable stepID) variable[];
			static function cameraChannelMove(				variable stepID) variable[];
			static function sTubeCap(							variable stepID) variable[];
			static function sTubeDecap(						variable stepID) variable[];
			static function tubeGripGet(						variable stepID) variable[];
			static function tubeGripPlace(					variable stepID) variable[];
			static function tubeGripMove(						variable stepID) variable[];
			static function tubeGripReadBarcode(			variable stepID) variable[];
			static function waitForTADM(						variable stepID) variable[];
			static function getChannelExcludeState(		variable stepID) variable[];


			// jjenal 2003-08-19
			// Evaluate the result data of the instrument step 'FirmwareCommand' and format its 
			// first block data:
			//   - ErrFlag       = <evaluated error flag>
			//   - Num           = -1 (not used)
			//   - MainErr       = -1 (not used)
			//   - SlaveErr      = -1 (not used)
			//   - RecoveryBtnId = -1 (not used)
			//   - StepData      = Firmware command (e.g. RF)
			//   - LabwareName   = <empty string> (not used)
			//   - Labwarepos    = <empty string> (not used)
			// The second block data (the original firmware resonse) is used to evaluate 
			// the error flag but remains unchanged!
			//
			// Example 1 (step execution ok, firmware command ok):
			// ---------------------------------------------------
			// Result value 3 from instrument step (first block data):  "RF"
			//                after formatting:                    		"0[-1,-1,-1,-1,RF,,"
			// Result value 4 from instrument step (second block data): "er00/00rf0.0X 2002-05-08"
			//                after formatting (always unchanged): 		"er00/00rf0.0X 2002-05-08"
			//
			// Example 2 (step execution ok, firmware command NOT ok):
			// -------------------------------------------------------
			// Result value 3 from instrument step (first block data):  "RF"
			//                after formatting:                    		"1[-1,-1,-1,-1,RF,,"
			// Result value 4 from instrument step (second block data): "er99/00rf0.0X 2002-05-08"
			//                after formatting (always unchanged): 		"er99/00rf0.0X 2002-05-08"
			//
			static function formatFirmwareCmdResult(
				variable& rc[]) void;	// i: step return as string array
										


			// Complete the instrumentResult to the resultData as specified for a MlStar command.
			// A command that has consumed any sequence positions shall call the function
			// completeResultDataEx().
			//
			static function completeResultData(
				variable& instrumentResult[]) void;		// io: instrumentResult to complete, string array


			// Complete the instrumentResult to the resultData as specified for a MlStar command
			// with the given number of used elements
			// 
			static function completeResultDataEx(		
				variable& instrumentResult[],				// io: instrumentResult to complete, string array
				variable usedPositions) void;				// i : consumed sequence elements as integer


			// Checks the resultData and evaluate the CommandResult by the error code out of the
			// block data(s) of the instrument results.
			// 
			// Return: One of ResultList::CommandResult as integer
			//
			static function evaluateResult(
				variable& resultData[]) variable;	// i: Complete resultData as specified for a MlStar command
																//    as string array

	
			// ----------------------------------------------------------------------------------------------
			// 'Private' data members
			// ----------------------------------------------------------------------------------------------
			static variable isPrepared(hslFalse);		// Store the prepared state.

		}


		// =================================================================================================
		// General commands
		// =================================================================================================

		namespace General
		{

			// ----------------------------------------------------------------------------------------------
			// Available General CommandID's
			// ----------------------------------------------------------------------------------------------

			namespace ID
			{
				static const variable first					( 1001 );		// Guard
				static const variable methodComplete		( 1001);	// Completes the method

				// 2005-08-12/cjoerg: removed, mode not longer supported
				//#ifdef ALIM_COMPATIBLE_MODE
				//	// The command 'Wait' is only available if ALIM_COMPATIBLE_MODE is set. 
				//	static const variable methodWait				( 1002 );	// Wait for the continue
				//#endif

				static const variable methodAbort			( 1003 );	// Aborts the method
				static const variable last						( 1003 );	// Guard
			}


			// ----------------------------------------------------------------------------------------------
			// 'Public' functions
			// ----------------------------------------------------------------------------------------------

			// Execute one of the Gerneal-commands.
			// Expect that all data as defined in the StepList are available for the given StepID.
			// Writes the command result into the ResultList.
			// May raise a exception if the command ends fatal and a abort is required.
			//
			// Return: One of ResultList::CommandResult as integer
			//
			function runCommand(
				variable stepID) variable;				// i: StepID of the command to execute as integer

		}
	}


	// ----------------------------------------------------------------------------------------------------
	// Utilities
	// ----------------------------------------------------------------------------------------------------

	namespace Util
	{
		static function IsString(											// returns true if the value is a string
			variable var) variable;											// i: variable

		static function IsNumber(											// returns true if the value is a number
			variable var) variable;											// i: variable

		static function IsInteger(											// returns true if the value is an integer
			variable var) variable;											// i: variable

		static function IsFloat(											// returns true if the value is a float
			variable var) variable;											// i: variable

		static function formatInteger(									// Returns a string with least width charakters
			variable intValue,												// i: integer, convertet to string and
			variable width) variable;										// i: filled left with witdth zero.

	}


	// ====================================================================================================
	// Traceing
	// ====================================================================================================

	namespace TraceStatus
	{
		static const variable start(1);									// action status for formated trace
		static const variable complete(2);								// action status for formated trace
		static const variable error_(3);									// action status for formated trace
		static const variable progress(4);								// action status for formated trace
		static const variable completeWithError(5);					// action status for formated trace
	}


	// ====================================================================================================
	// Debugging
	// ====================================================================================================
	
	// The Assert function evaluates its argument.
	// In the the debug version of the pipetting library, if the result is 0, the function displays
	// a diagnostic message and aborts the method. If the condition is nonzero, it does nothing.
	// In the the release version of the pipetting library, the function does nothing.
	static function Assert(
		variable expr,												// i: specifies a numeric expression that evaluates to nonzero or 0
		variable location) void;								// i: location (string or number)

	// Trace the indexes and all LabID+PosID of the sequence.
	static function dumpSequence(
		sequence& seq) void;										// i: Sequence to dump

	// Trace all the elements of the array.
	static function dumpArray(
		variable& description,
		variable& arr[]) void;

	// Trace the result data.
	static function dumpResult(
		variable w_stepID,										// i: StepID (integer)
		variable w_commandResult,								// i: CommandResult (integer)
		variable w_resultNo,										// i: ResultNo (integer)
		variable w_resultFragment,								// i: ResultFragment (integer)
		variable& w_resultData) void;							// i: ResultData (string)


	// ====================================================================================================
	// Exception handling
	// ====================================================================================================

	namespace Error
	{
		static function raiseRuntimeError(								// raises a runtime error
			variable errorId,													// i: error id, one of IDE
			variable& fileName,												// i: file name
			variable& funcName,												// i: function name
			variable& lineNumber) void;									// i: line number

		static function raiseRuntimeErrorEx(							// raises a runtime error
			variable errorId,													// i: error id, one of IDE
			variable& additionalDescr,										// i: additional error description
			variable& fileName,												// i: file name
			variable& funcName,												// i: function name
			variable& lineNumber) void;									// i: line number


		static function RaiseLast() void;								// re-throws the last runtime error

	} // End namespace Error



	// ----------------------------------------------------------------------------------------------------
	// Error Id's
	// ----------------------------------------------------------------------------------------------------

	namespace IDE
	{
		static const variable noError											( 0 );					// No error.

		// Errors that always results in an abort of the method.
		static const variable first								  ( noError+1 );			// guard

		static const variable abortFirst							  ( first+0     );		// guard: abort errors
		static const variable fileOpenStepListFailed				(abortFirst + 0);		// File open (StepList) failed.
		static const variable fileReadStepListFailed				(abortFirst + 1);		// File read (StepList) failed.
		static const variable fileOpenPositionDataFailed		(abortFirst + 2);		// File open (PositionData) failed.
		static const variable fileReadPositionDataFailed		(abortFirst + 3);		// File read (PositionData) failed.
		static const variable fileOpenVolumeDataFailed			(abortFirst + 4);		// File open (VolumeData) failed.
		static const variable fileReadVolumeDataFailed			(abortFirst + 5);		// File read (VolumeData) failed.
		static const variable fileOpenResultListFailed			(abortFirst + 6);		// File open (ResultList) failed.
		static const variable fileWriteResultListFailed			(abortFirst + 7);		// File write (ResultList) failed.
		static const variable synchronisationFailed				(abortFirst + 8);		// Synchronisation failed
		static const variable noErrorInformation					(abortFirst + 9);		// Abort without error (user or low level step aborted)
		static const variable abortLast							  ( abortFirst + 9);		// guard: abort errors

		// Other errors.
		static const variable contFirst							  ( abortLast+1 );		// guard: continue errors
		static const variable unknown									(contFirst + 0);		// Unknown error
		static const variable unknownCommandID						(contFirst + 1);		// Unknown CommandId readed
		static const variable unexpectedResultData				(contFirst + 2);		// Unexpected result data detected
		static const variable fileCloseFailed						(contFirst + 3);		// File close failed.
		static const variable mlStarCommandFatal					(contFirst + 4);		// A mlStar command ends fatal.
		static const variable contLast							  ( contFirst + 4);		// guard: continue errors


		static const variable last									  ( contLast );			// guard
	} // End namespace IDE



	// ----------------------------------------------------------------------------------------------------
	// String Id's
	// ----------------------------------------------------------------------------------------------------

	namespace IDS
	{	// private
		static const variable first									(IDE::last + 1);	// guard
		static const variable traceSource							(first + 0);		// Trace: Source of OEM Interfac-trace
		static const variable commandExecute						(first + 1);		// Trace: Execute command( start and end)
		static const variable commaDel								(first + 2);		// Trace: Comma delimiter
		static const variable stepID									(first + 3);		// Trace: StepID=
		static const variable commandID								(first + 4);		// Trace: CommandID=
		static const variable commandResult							(first + 5);		// Trace: CommandResult=
		static const variable waiting									(first + 6);		// Trace: Is waiting (start and end)
		static const variable abort_									(first + 7);		// Trace: Abort run
		static const variable last										(first + 7);		// guard
	} // End namespace IDS


	// ----------------------------------------------------------------------------------------------------
	// String Constants
	// ----------------------------------------------------------------------------------------------------

	namespace StringConstants
	{
		static const variable dataBaseFileName("ML_STAR_OemInterface_CommandList.mdb");	// Command List data base name.
		static const variable thisFileExtension(".hsl");	// Used to cut the extension of this file.
	} // End namespace StringConstants



	// ====================================================================================================
	// OEM Interface: Implementation
	// ====================================================================================================

	method main()
	{
		RegisterAbortHandler("oemInterface_mainAbortHandler");

		{
			// Wait for the event once to be sure that its state is set to not signaled at method start.
			event eventOemInterfaceIsWaiting("event_ML_STAR_OemInterface_IsWaiting");
			eventOemInterfaceIsWaiting.WaitEvent(0);
		}

		// Initialize the string table (load IDS and IDE)
		initStringTable();		

		onerror goto UnhandledException;
		
		runOemInterface();		// Implements the OEM Interface

		return;

		
		UnhandledException:		// Error handler 'unhandled exception'
		{
			#ifdef _DEBUG_AL
			FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
							"Exception received in main(): -> Abort the run!");
			#endif

			// Unhandled exception. Error was not handled by anyone -> Abort the run!
			// Writing of the abort result of started command(s) and clean up is done
			// the registered abort handler.
			abort;
		} // End error handler 

	} // End main()


	static function runOemInterface() void
	{
		variable currentCommandID(-1), currentCommandResult(-1);
		variable traceSource(""), traceAction("");
		variable traceStepID(""), traceCommandID(""), traceResult(""), traceCommaDel("");

		// Init the trace strings
		traceSource    = STR::StringTable::Load(IDS::traceSource);
		traceAction    = STR::StringTable::Load(IDS::commandExecute);
		traceStepID    = STR::StringTable::Load(IDS::stepID);
		traceCommandID = STR::StringTable::Load(IDS::commandID);
		traceResult    = STR::StringTable::Load(IDS::commandResult);
		traceCommaDel  = STR::StringTable::Load(IDS::commaDel);

		// Initialize the dataBaseFile variable.
		// Must be stored under the <Phoenix LogFiles Path> for which all Hamilton users must
		// have full control (read and write).
		m_dataBaseFile = GetLogFilesPath();
		m_dataBaseFile = m_dataBaseFile + "\\" + StringConstants::dataBaseFileName;
		#ifdef _DEBUG_AL
		FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
						"Data Base File: "+m_dataBaseFile);
		#endif

		// Delete the contents of the result list table.
		// All results are appended since V3.00
		ResultList::emptyResultListTable();

		setFinishMethodFlag(hslFalse);
		setAbortMethodFlag(hslFalse);

		m_commandListStepID = (-1);		// Set initial to -1. Is incremented before read to begin with the stepID=0.

		onerror goto OemInterfaceError;

		while ( ! getFinishMethodFlag() )
		{
			currentCommandID = -1;
			currentCommandResult = -1;

			// Increment the stepID for processing the next command
			m_commandListStepID++;

			StepList::readCommand(m_commandListStepID);

			currentCommandID = getCommandID(m_commandListStepID);

			// Trace OEM Interface: command start
			FormatTrace(traceSource, traceAction, TraceStatus::start, traceStepID+IStr(m_commandListStepID)+traceCommaDel+
																						 traceCommandID+IStr(currentCommandID));

			// Evaluate the CommandID
			if (		( currentCommandID >= Cmd::MlStar::ID::first )
					&& ( currentCommandID <= Cmd::MlStar::ID::last ) )
			{
				currentCommandResult = Cmd::MlStar::runCommand(m_commandListStepID);
			}
			else if (		( currentCommandID >= Cmd::General::ID::first )
							&& ( currentCommandID <= Cmd::General::ID::last ) )
			{
				currentCommandResult = Cmd::General::runCommand(m_commandListStepID);
			}
			else
			{
				Error::raiseRuntimeError(IDE::unknownCommandID, GetFileName(), GetFunctionName(), GetLineNumber());
			}

			// Trace OEM Interface: command complete
			FormatTrace(traceSource, traceAction, TraceStatus::complete, traceStepID+IStr(m_commandListStepID)+traceCommaDel+
																							 traceCommandID+IStr(currentCommandID)+traceCommaDel+
																							 traceResult+IStr(currentCommandResult));

			// 2005-08-12/cjoerg: removed, mode not longer supported
			//#ifndef ALIM_COMPATIBLE_MODE
			//// If we are NOT in the ALIM_COMPATIBLE mode (default) we wait after each
			//// executed command (succeed or not), expect if 'Abort' or 'Finished'
		
			// We wait after each executed command, expect if 'Abort' or 'Finished'
			if ( ! getAbortMethodFlag() && ! getFinishMethodFlag() )
			{
				performWaiting();
			}
			
			// 2005-08-12/cjoerg: removed, mode not longer supported
			//#endif

			// 2005-08-12/cjoerg: removed, mode not longer supported
			//#ifdef ALIM_COMPATIBLE_MODE
			//// Check the command result and change to state 'waiting' if not succeed.
			//if ( ResultList::CommandResult::succeed != currentCommandResult )
			//{
			//	// a command failed wait until continue
			//	performWaiting();
			//}
			//#endif

			if ( getAbortMethodFlag() )
			{
				// The abort flag is set -> abort the method.
				abort;
			}
		}

		onerror goto 0;

		cleanUp();

		return;


		OemInterfaceError:		// Error handler
		{
			#ifdef _DEBUG_AL
			FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
							"OEM Interface Error: ErrorID="+IStr(err.GetId()));
			#endif

			// Check for an error that must result in an abort
			if (		( err.GetId() >= IDE::abortFirst )
					&& ( err.GetId() <= IDE::abortLast ) )
			{
				// Do not continue with error handling and recovery.
				// Rethrow the exception to abort the execution.
				Error::RaiseLast();
			}
	
			if (		( getCommandState(m_commandListStepID) >= CommandState::readStart )
					&& ( getCommandState(m_commandListStepID) <  CommandState::resultWritten ) )
			{
				// A command is started (to read) but its result is not written.
				// Write fatal result.
				variable resultData[];
				currentCommandResult = ResultList::initFatalResultData(resultData);
				currentCommandResult = ResultList::writeResult(m_commandListStepID, currentCommandResult, resultData);
			}
			else
			{
				// Command not started or already completed (no result pending to write).
				#ifdef _DEBUG_AL
				Assert( hslFalse, GetFunctionName()+"\n\nOEM Interface Error: But command not started or already completed -> proceed" );
				#endif

				//	Set result=succeed to proceed.
				currentCommandResult = ResultList::CommandResult::succeed;
			}

			err.Clear();	// Error is handled. Clear it.
			resume next;
		} // End error handler 

	}


	static function initStringTable() variable
	{
		// initialize string table library once only
		if ( ! m_initializedLib )
		{
			string fileWithPath("");
			string extension(StringConstants::thisFileExtension);
			variable stringTableFileWithoutExtensions("");

			fileWithPath = GetFileName();
			stringTableFileWithoutExtensions = fileWithPath.Left(fileWithPath.GetLength() - extension.GetLength());

			STR::StringTable::Init(stringTableFileWithoutExtensions);

			#ifdef _DEBUG_AL
			FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
							"StringTable: "+stringTableFileWithoutExtensions);
			STR::StringTable::Dump();
			#endif

			m_initializedLib = hslTrue;
		}
		return( m_initializedLib );
	}


	static function setFinishMethodFlag(variable value) void
	{
		if ( value == hslFalse)
		{
			m_finishMethodFlag = value;
		}
		else
		{
			m_finishMethodFlag = hslTrue;			
		}
	}


	static function getFinishMethodFlag() variable
	{
		return( m_finishMethodFlag );
	}


	static function setAbortMethodFlag(variable value) void
	{
		if ( value == hslFalse)
		{
			m_abortMethodFlag = value;
		}
		else
		{
			m_abortMethodFlag = hslTrue;			
		}
	}


	static function getAbortMethodFlag() variable
	{
		return( m_abortMethodFlag );
	}


	function performWaiting() void
	{
		// Note for declaration of the named events used for syncronisation with
		// a OEM Application (CreateEvent() from the Win32api is called).
		//   Don't declare these events global, because if the method is aborted, all
		//   valid events are signaled by the hsl-executor. And in the context
		//   of the OEM Interface it's not valid to signal the 'iWaiting' event
		//   during abort of the method.

		variable traceSource("");

		onerror goto SynchronisationFailed;

		traceSource = STR::StringTable::Load(IDS::traceSource);

		// Change to waiting state
		{
			// Set the 'isWaiting' event first to signale this state
			event eventOemInterfaceIsWaiting("event_ML_STAR_OemInterface_IsWaiting");
			eventOemInterfaceIsWaiting.SetEvent();
		}

		FormatTrace(traceSource, STR::StringTable::Load(IDS::waiting), TraceStatus::start);
		{
			// Wait for the 'continue' event
			event eventOemInterfaceContinue("event_ML_STAR_OemInterface_Continue");
			eventOemInterfaceContinue.WaitEvent(hslInfinite);
		}
		FormatTrace(traceSource, STR::StringTable::Load(IDS::waiting), TraceStatus::complete);

		// Back in running state

		return;

		SynchronisationFailed:		// Handler 'Synchronisation failed'
		{
			Error::raiseRuntimeError(IDE::synchronisationFailed, GetFileName(), GetFunctionName(), GetLineNumber());
		}
	}


	function setCommandState(variable stepID,
									 variable state) void
	{
		// stepID not used at this time, only ONE command is readed and executet at the same time
		#ifdef _DEBUG_AL
		FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
						"State of command: StepID="+IStr(stepID)+", state="+IStr(state));
		#endif

		// stepID not used at this time to identify different steps.
		// Only ONE command is readed and executet at the same time.
		// Compare the given ID with the current m_commandListStepID to not set an invalid state.
		if ( m_commandListStepID != stepID )
		{
			#ifdef _DEBUG_AL
			Assert( m_commandListStepID == stepID, GetFunctionName()+"\ncommandListStepID="+m_commandListStepID+"\nstepID="+stepID );
			#endif
			return;
		}

		if (		( CommandState::first > state )
				|| ( CommandState::last  < state ) )
		{
			#ifdef _DEBUG_AL
			Assert( hslTrue, GetFunctionName()+"\n\nUnknown CommandState parameter.");
			#endif
			state = CommandState::undefined;
		}

		m_commandState = state;
	}


	function getCommandState(variable stepID) variable
	{
		// stepID not used at this time to identify different steps.
		// Only ONE command is readed and executet at the same time.
		// Compare the given ID with the current m_commandListStepID to not return an invalid state.
		if (		( m_commandListStepID != stepID )
				&& ( m_commandState != CommandState::undefined ) )
		{
			#ifdef _DEBUG_AL
			Assert( m_commandListStepID == stepID, GetFunctionName()+"\ncommandListStepID="+m_commandListStepID+"\nstepID="+stepID );
			#endif
			return( CommandState::undefined );
		}

		return( m_commandState );
	}


	function getCommandID(variable stepID) variable
	{
		// stepID not used at this time, only ONE command is readed and executet at the same time
		#ifdef _DEBUG_AL
		Assert( m_commandListStepID == stepID, GetFunctionName() );
		#endif

		return (StepList::getCommandID());
	}


	function getStringParam(variable stepID,
									variable index) variable
	{
		// stepID not used at this time, only ONE command is readed and executet at the same time
		#ifdef _DEBUG_AL
		Assert( m_commandListStepID == stepID, GetFunctionName() );
		#endif

		return (StepList::getStringParam(index));
	}


	function getIntegerParam(variable stepID,
									 variable index) variable
	{
		// stepID not used at this time, only ONE command is readed and executet at the same time
		#ifdef _DEBUG_AL
		Assert( m_commandListStepID == stepID, GetFunctionName() );
		#endif

		return (StepList::getIntegerParam(index));
	}


	function getDoubleParam(variable stepID,
									variable index) variable
	{
		// stepID not used at this time, only ONE command is readed and executet at the same time
		#ifdef _DEBUG_AL
		Assert( m_commandListStepID == stepID, GetFunctionName() );
		#endif

		return (StepList::getDoubleParam(index));
	}


	static function cleanUp() void
	{
		// Clean up the ResultList
		ResultList::cleanUp();

		// Clean up the VolumeData
		VolumeData::cleanUp();

		// Clean up the PositionData
		PositionData::cleanUp();

		// Clean up the StepList
		StepList::cleanUp();
	}


	static function writeAbortResultForAllReaded() void
	{
		// No parallel command execution at this time
		// only the current command my be executed at this time.
		writeAbortResult(m_commandListStepID);
	}


	static function writeAbortResult(variable stepID) variable
	{
		variable commandResult;

		if (		( getCommandState(stepID) >= CommandState::readStart )
				&& ( getCommandState(stepID) <  CommandState::resultWritten ) )
		{
			// A command is started (to read) but its result is not written.
			// Write abort result.
			variable resultData[];

			if ( err.GetId() == IDE::noError )
			{
				// No error object is set. Set the noErrorInformation ID and description.
				resultData.AddAsLast(IStr(IDE::noErrorInformation));
				resultData.AddAsLast(STR::StringTable::Load(IDE::noErrorInformation));
				commandResult = ResultList::CommandResult::aborted;
			}
			else
			{
				commandResult = ResultList::initAbortResultData(resultData);
			}

			commandResult = ResultList::writeResult(stepID, commandResult, resultData);

			// Trace OEM Interface: command complete
			FormatTrace(STR::StringTable::Load(IDS::traceSource), STR::StringTable::Load(IDS::commandExecute), TraceStatus::complete,
							STR::StringTable::Load(IDS::stepID)+IStr(stepID)+STR::StringTable::Load(IDS::commaDel)+
							STR::StringTable::Load(IDS::commandID)+IStr(getCommandID(stepID))+STR::StringTable::Load(IDS::commaDel)+
							STR::StringTable::Load(IDS::commandResult)+IStr(commandResult));
		}
		else
		{
			// Command not started or already completed (no result pending to write)

			//	Set result to succeed to proceed.
			commandResult = ResultList::CommandResult::succeed;
		}

		return( commandResult );
	}


	static global function oemInterface_mainAbortHandler() void
	{
		// If an error ocurs while execution of an abortHandler, the error is traced
		// but no MsgBox is displayed for this error.

		variable traceSource("");

		#ifdef _DEBUG_AL
		FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
						"ErrorID="+IStr(err.GetId())+"ErrorDescription="+err.GetDescription());
		#endif

		traceSource = STR::StringTable::Load(IDS::traceSource);
		FormatTrace(traceSource, STR::StringTable::Load(IDS::abort_), TraceStatus::start);

		writeAbortResultForAllReaded();
		cleanUp();

		FormatTrace(traceSource, STR::StringTable::Load(IDS::abort_), TraceStatus::complete);
	}


	// ====================================================================================================
	// Util: Implementation
	// ====================================================================================================

	static function Util::IsString(variable var) variable
	{
		return(hslString.Compare(GetType(var)) == 0);
	}

	static function Util::IsNumber(variable var) variable
	{
		variable type;
		type = GetType(var);
		return(hslString.Compare(type) != 0 && "" != type);
	}

	static function Util::IsInteger(variable var) variable
	{
		return(hslInteger.Compare(GetType(var)) == 0);
	}

	static function Util::IsFloat(variable var) variable
	{
		return(hslFloat.Compare(GetType(var)) == 0);
	}

	static function Util::formatInteger(variable intValue,
													variable width) variable
	{
		string str;
		str = IStr(intValue);
		while (str.GetLength() < width)
		{
			str = "0" + str;
		}

		return( str );
	}



	// ====================================================================================================
	// StepList: Implementation
	// ====================================================================================================
	
	function StepList::readCommand(variable stepID) void
	{
		variable commandString("");

		onerror goto FileOpenError;

		StepList::prepare();

		setCommandState(stepID, CommandState::readStart);

		// Close the file (the database connection) to force that a new connection is generated and
		// the latest state of the database is querried.
		if( 0 != StepList::fileHandle.Close() )
		{
			Error::raiseRuntimeError(IDE::fileCloseFailed, GetFileName(), GetFunctionName(), GetLineNumber());
		}

		// Query StepList-table for the stepID
		commandString = "SELECT * FROM "+StepList::tableName + " WHERE StepID="+IStr(stepID);
		if( 0 == StepList::fileHandle.Open(m_dataBaseFile + " " + StepList::tableName, hslRead, commandString) )
		{
			Error::raiseRuntimeError(IDE::fileOpenStepListFailed, GetFileName(), GetFunctionName(), GetLineNumber());
		}

		onerror goto FileReadError;

		if( 0 == StepList::fileHandle.ReadRecord() )
		{
			Error::raiseRuntimeError(IDE::fileReadStepListFailed, GetFileName(), GetFunctionName(), GetLineNumber());
		}

		onerror goto 0;

		#ifdef _DEBUG_AL
		Assert( stepID == StepList::r_stepID, GetFunctionName()+GetLineNumber() );
		#endif

		setCommandState(stepID, CommandState::readComplete);

		return;


		FileOpenError:
		{
			#ifdef _DEBUG_AL
			FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "FileOpenError: ErrorID="+IStr(err.GetId()));
			#endif

			if ( err.GetId() == IDE::fileOpenStepListFailed )
			{
				Error::RaiseLast();
			}
			else
			{
				Error::raiseRuntimeErrorEx(IDE::fileOpenStepListFailed, err.GetDescription(), GetFileName(), GetFunctionName(), GetLineNumber());
			}
		} // End error handler


		FileReadError:
		{
			#ifdef _DEBUG_AL
			FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "FileOpenError: ErrorID="+IStr(err.GetId()));
			#endif

			if ( err.GetId() == IDE::fileReadStepListFailed )
			{
				Error::RaiseLast();
			}
			else
			{
				Error::raiseRuntimeErrorEx(IDE::fileReadStepListFailed, err.GetDescription(), GetFileName(), GetFunctionName(), GetLineNumber());
			}
		} // End error handler
	}


	function StepList::getCommandID() variable
	{
		return( StepList::r_commandID );
	}

	function StepList::getStringParam(variable index) variable
	{
		return( StepList::r_ps.GetAt(index-1) );
	}

	function StepList::getIntegerParam(variable index) variable
	{
		return( StepList::r_pi.GetAt(index-1) );
	}

	function StepList::getDoubleParam(variable index) variable
	{
		return( StepList::r_pd.GetAt(index-1) );
	}


	static function StepList::prepare() void
	{
		variable i(0);

		if ( ! StepList::isPrepared )
		{
			StepList::fileHandle.AddField("StepID", StepList::r_stepID, hslInteger);
			StepList::fileHandle.AddField("CommandID", StepList::r_commandID, hslInteger);

			StepList::r_ps.SetSize(StepList::countOfString);
			for (i=0; i<StepList::countOfString; i++)
				StepList::fileHandle.AddField("PS"+StepList::formatParameterNo(StepList::firstString+i), StepList::r_ps.ElementAt(i), hslString, 255);

			StepList::r_pi.SetSize(StepList::countOfInteger);
			for (i=0; i<StepList::countOfInteger; i++)
				StepList::fileHandle.AddField("PI"+StepList::formatParameterNo(StepList::firstInteger+i), StepList::r_pi.ElementAt(i), hslInteger);

			StepList::r_pd.SetSize(StepList::countOfDouble);
			for (i=0; i<StepList::countOfDouble; i++)
				StepList::fileHandle.AddField("PD"+StepList::formatParameterNo(StepList::firstDouble+i), StepList::r_pd.ElementAt(i), hslFloat);

			StepList::isPrepared = hslTrue;
		}

		// Reset r/w variables
		StepList::r_stepID = -1;
		StepList::r_commandID = -1;

		for (i=0; i<StepList::countOfString; i++)
			StepList::r_ps[i] = "";

		for (i=0; i<StepList::countOfInteger; i++)
			StepList::r_pi[i] = -1;

		for (i=0; i<StepList::countOfDouble; i++)
			StepList::r_pd[i] = -1.0;
	}


	static function StepList::formatParameterNo(variable number) variable
	{
		return( Util::formatInteger(number, StepList::countOfParamNumDigits) );
	}


	function StepList::cleanUp() void
	{
		if ( StepList::isPrepared )
		{
			// Close the file, no problem if it was not opened before.
			if( 0 != StepList::fileHandle.Close() )
			{
				Error::raiseRuntimeError(IDE::fileCloseFailed, GetFileName(), GetFunctionName(), GetLineNumber());
			}
			StepList::fileHandle.RemoveFields();

			StepList::isPrepared = hslFalse;
		}
	}



	// ====================================================================================================
	// Command: Implementation
	// ====================================================================================================

	namespace Cmd
	{

		// ====================================================================================================
		// Cmd::MlStar: Implementation
		// ====================================================================================================

		function MlStar::runCommand(variable stepID) variable
		{
			variable rc[];
			variable currentCommandID(-1);
			variable commandResult(-1);

			onerror goto MlStarError;

			MlStar::prepare();

			// Get the commandID to the given stepID
			currentCommandID = getCommandID(stepID);

			// Evaluate the command to execute
			if      (MlStar::ID::initialize                 == currentCommandID)
				 rc =     MlStar::initialize(stepID);
			else if (MlStar::ID::_1000ulChTipPickUp         == currentCommandID)
				rc =      MlStar::_1000ulChTipPickUp(stepID);
			else if (MlStar::ID::_1000ulChNeedlePickUp      == currentCommandID)
				rc =      MlStar::_1000ulChNeedlePickUp(stepID);
			else if (MlStar::ID::_1000ulChTipNeedleEject    == currentCommandID)
				rc =      MlStar::_1000ulChTipNeedleEject(stepID);
			else if (MlStar::ID::_1000ulChAspirate          == currentCommandID)
				rc =      MlStar::_1000ulChAspirate(stepID);
			else if (MlStar::ID::_1000ulChDispense          == currentCommandID)
				rc =      MlStar::_1000ulChDispense(stepID);
			else if (MlStar::ID::_1000ulChDispenseFly       == currentCommandID)
				rc =      MlStar::_1000ulChDispenseFly(stepID);
			else if (MlStar::ID::loadCarrier                == currentCommandID)
				rc =      MlStar::loadCarrier(stepID);
			else if (MlStar::ID::unloadCarrier              == currentCommandID)
				rc =      MlStar::unloadCarrier(stepID);
			else if (MlStar::ID::_1000ulChWaitNeedleWashed  == currentCommandID)
				rc =      MlStar::_1000ulChWaitNeedleWashed(stepID);
			else if (MlStar::ID::_1000ulChStartNeedleWash   == currentCommandID)
				rc =      MlStar::_1000ulChStartNeedleWash(stepID);
			else if (MlStar::ID::_1000ulChGetContainerVolume == currentCommandID)
				rc =      MlStar::_1000ulChGetContainerVolume(stepID);
			else if (MlStar::ID::iSwapGetPlate              == currentCommandID)
				rc =      MlStar::iSwapGetPlate(stepID);
			else if (MlStar::ID::iSwapPlacePlate            == currentCommandID)
				rc =      MlStar::iSwapPlacePlate(stepID);
			else if (MlStar::ID::iSwapMovePlate             == currentCommandID)
				rc =      MlStar::iSwapMovePlate(stepID);
			else if (MlStar::ID::iSwapOpenGripper           == currentCommandID)
				rc =      MlStar::iSwapOpenGripper(stepID);
			else if (MlStar::ID::iSwapCloseGripper          == currentCommandID)
				rc =      MlStar::iSwapCloseGripper(stepID);
			else if (MlStar::ID::iSwapReadPlateBarcode      == currentCommandID)
				rc =      MlStar::iSwapReadPlateBarcode(stepID);
			else if (MlStar::ID::iSwapGetFirstPlatePosition == currentCommandID)
				rc =      MlStar::iSwapGetFirstPlatePosition(stepID);
			else if (MlStar::ID::iSwapPark                  == currentCommandID)
				rc =      MlStar::iSwapPark(stepID);
			else if (MlStar::ID::readPort                   == currentCommandID)
				rc =      MlStar::readPort(stepID);
			else if (MlStar::ID::writePort                  == currentCommandID)
				rc =      MlStar::writePort(stepID);
			else if (MlStar::ID::_1000ulChMoveToPosition    == currentCommandID)
				rc =      MlStar::_1000ulChMoveToPosition(stepID);
			else if (MlStar::ID::moveAutoLoad               == currentCommandID)
				rc =      MlStar::moveAutoLoad(stepID);
			else if (MlStar::ID::execFirmwareCmd            == currentCommandID)
				rc =      MlStar::execFirmwareCmd(stepID);
			else if (MlStar::ID::tccSetCarrierTemperature   == currentCommandID)
				rc =      MlStar::tccSetCarrierTemperature(stepID);
			else if (MlStar::ID::tccGetCarrierTemperature   == currentCommandID)
				rc =      MlStar::tccGetCarrierTemperature(stepID);
			else if (MlStar::ID::coRe96TipPickUp            == currentCommandID)
				rc =      MlStar::coRe96TipPickUp(stepID);
			else if (MlStar::ID::coRe96TipEject             == currentCommandID)
				rc =      MlStar::coRe96TipEject(stepID);
			else if (MlStar::ID::coRe96Aspirate             == currentCommandID)
				rc =      MlStar::coRe96Aspirate(stepID);
			else if (MlStar::ID::coRe96Dispense             == currentCommandID)
				rc =      MlStar::coRe96Dispense(stepID);
			else if (MlStar::ID::coRe96Wash                 == currentCommandID)
				rc =      MlStar::coRe96Wash(stepID);
			else if (MlStar::ID::coRe96EmptyWasher          == currentCommandID)
				rc =      MlStar::coRe96EmptyWasher(stepID);
			else if (MlStar::ID::coReGrip1000ulGetPlate     == currentCommandID)
				rc =      MlStar::coReGrip1000ulGetPlate(stepID);
			else if (MlStar::ID::coReGrip1000ulPlacePlate   == currentCommandID)
				rc =      MlStar::coReGrip1000ulPlacePlate(stepID);
			else if (MlStar::ID::coReGrip1000ulMovePlate    == currentCommandID)
				rc =      MlStar::coReGrip1000ulMovePlate(stepID);
			else if (MlStar::ID::coReGrip1000ulReadPlateBarcode == currentCommandID)
				rc =      MlStar::coReGrip1000ulReadPlateBarcode(stepID);
			else if (MlStar::ID::calibrateCarrier           == currentCommandID)
				rc =      MlStar::calibrateCarrier(stepID);
			else if (MlStar::ID::lockFrontCover             == currentCommandID)
				rc =      MlStar::lockFrontCover(stepID);
			else if (MlStar::ID::_1000ulChGetLastLiquidLevel == currentCommandID)
				rc =      MlStar::_1000ulChGetLastLiquidLevel(stepID);
			else if (MlStar::ID::tipTrackingSpeed           == currentCommandID)
				rc =      MlStar::tipTrackingSpeed(stepID);
			else if (MlStar::ID::coRe384TipPickUp           == currentCommandID)
				rc =      MlStar::coRe384TipPickUp(stepID);
			else if (MlStar::ID::coRe384TipEject            == currentCommandID)
				rc =      MlStar::coRe384TipEject(stepID);
			else if (MlStar::ID::coRe384Aspirate            == currentCommandID)
				rc =      MlStar::coRe384Aspirate(stepID);
			else if (MlStar::ID::coRe384Dispense            == currentCommandID)
				rc =      MlStar::coRe384Dispense(stepID);
			else if (MlStar::ID::coRe384Wash                == currentCommandID)
				rc =      MlStar::coRe384Wash(stepID);
			else if (MlStar::ID::coRe384EmptyWasher         == currentCommandID)
				rc =      MlStar::coRe384EmptyWasher(stepID);
			else if (MlStar::ID::nanoPrepare                == currentCommandID)
				rc =      MlStar::nanoPrepare(stepID);
			else if (MlStar::ID::nanoAspirate               == currentCommandID)
				rc =      MlStar::nanoAspirate(stepID);
			else if (MlStar::ID::nanoDispense               == currentCommandID)
				rc =      MlStar::nanoDispense(stepID);
			else if (MlStar::ID::nanoDispenseFly            == currentCommandID)
				rc =      MlStar::nanoDispenseFly(stepID);
			else if (MlStar::ID::nanoWash                   == currentCommandID)
				rc =      MlStar::nanoWash(stepID);
			else if (MlStar::ID::reLoadCarrier              == currentCommandID)
				rc =      MlStar::reLoadCarrier(stepID);
			else if (MlStar::ID::_5mlChTipPickUp            == currentCommandID)
				rc =      MlStar::_5mlChTipPickUp(stepID);
			else if (MlStar::ID::_5mlChTipEject             == currentCommandID)
				rc =      MlStar::_5mlChTipEject(stepID);
			else if (MlStar::ID::_5mlChAspirate             == currentCommandID)
				rc =      MlStar::_5mlChAspirate(stepID);
			else if (MlStar::ID::_5mlChDispense             == currentCommandID)
				rc =      MlStar::_5mlChDispense(stepID);
			else if (MlStar::ID::_5mlChDispenseFly          == currentCommandID)
				rc =      MlStar::_5mlChDispenseFly(stepID);
			else if (MlStar::ID::_5mlChGetLastLiquidLevel   == currentCommandID)
				rc =      MlStar::_5mlChGetLastLiquidLevel(stepID);
			else if (MlStar::ID::_5mlChMoveToPosition       == currentCommandID)
				rc =      MlStar::_5mlChMoveToPosition(stepID);
			else if (MlStar::ID::coReGrip5mlGetPlate        == currentCommandID)
				rc =      MlStar::coReGrip5mlGetPlate(stepID);
			else if (MlStar::ID::coReGrip5mlPlacePlate      == currentCommandID)
				rc =      MlStar::coReGrip5mlPlacePlate(stepID);
			else if (MlStar::ID::coReGrip5mlMovePlate       == currentCommandID)
				rc =      MlStar::coReGrip5mlMovePlate(stepID);
			else if (MlStar::ID::coReGrip5mlReadPlateBarcode == currentCommandID)
				rc =      MlStar::coReGrip5mlReadPlateBarcode(stepID);
			else if (MlStar::ID::cameraChannelMove          == currentCommandID)
				rc =      MlStar::cameraChannelMove(stepID);
			else if (MlStar::ID::sTubeCap                   == currentCommandID)
				rc =      MlStar::sTubeCap(stepID);
			else if (MlStar::ID::sTubeDecap                 == currentCommandID)
				rc =      MlStar::sTubeDecap(stepID);
			else if (MlStar::ID::tubeGripGet                == currentCommandID)
				rc =      MlStar::tubeGripGet(stepID);
			else if (MlStar::ID::tubeGripPlace              == currentCommandID)
				rc =      MlStar::tubeGripPlace(stepID);
			else if (MlStar::ID::tubeGripMove               == currentCommandID)
				rc =      MlStar::tubeGripMove(stepID);
			else if (MlStar::ID::tubeGripReadBarcode        == currentCommandID)
				rc =      MlStar::tubeGripReadBarcode(stepID);
			else if (MlStar::ID::waitForTADM                == currentCommandID)
				rc =      MlStar::waitForTADM(stepID);
			else if (MlStar::ID::getChannelExcludeState     == currentCommandID)
				rc =      MlStar::getChannelExcludeState(stepID);



			else
				Error::raiseRuntimeError(IDE::unknownCommandID, GetFileName(), GetFunctionName(), GetLineNumber());

			// Evaluate the command result data
			commandResult = MlStar::evaluateResult(rc);

			// Write the command result data and return the result
			return( ResultList::writeResult(stepID, commandResult, rc) );


			MlStarError:	// Error handler
			{
				// Exception occured during execution of the step.
				// Write the fatal result and return.
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "MlStarError: ErrorID="+IStr(err.GetId()));
				#endif

				// Check for an error that must result in an abort
				if (		( err.GetId() >= IDE::abortFirst )
						&& ( err.GetId() <= IDE::abortLast ) )
				{
					// Do not continue with error handling and recovery.
					// Rethrow the exception.
					Error::RaiseLast();
				}

				commandResult = ResultList::initFatalResultData(rc);

				err.Clear();
				return( ResultList::writeResult(stepID, commandResult, rc) );
			}
		}


		static function MlStar::prepare() void
		{
			if ( ! MlStar::isPrepared )
			{
				// Set the block and field delimiter, and number of channels
				MlStar::StepReturnEx::InstrumentValues::numberOfChannels = mlstar.GetCfgValueWithKey(MlStar::MlStarCfgKey::numberOfChannels);
				MlStar::StepReturnEx::InstrumentValues::blockDelimiter = mlstar.GetCfgValueWithKey(MlStar::MlStarCfgKey::blockSeparator);
				MlStar::StepReturnEx::InstrumentValues::fieldDelimiter = mlstar.GetCfgValueWithKey(MlStar::MlStarCfgKey::wordSeparator);

				// Initialize the HSLMlStarStepReturnLib
				MlStar::StepReturn::SetBlockDelimiterEx(mlstar);
				MlStar::StepReturn::SetFieldDelimiterEx(mlstar);

				MlStar::isPrepared = hslTrue;
			}
		}


		static function MlStar::evaluateResult(variable& resultData[]) variable
		{
			variable stepErrorCode(-1), commandResult(-1);
			variable size(0);

			size = resultData.GetSize();

			// Check the count of the resultData
			if ( size < MlStar::ResultDataNo::requiredResultCount)
			{
				// Less result count as expected.
				Error::raiseRuntimeError(IDE::unexpectedResultData, GetFileName(), GetFunctionName(), GetLineNumber());
			}

			//////////////////////////////////////////////////////////////
			//x 2003-07-02 / cjoerg:
			//x Replaced by the code below.
			//x It was an bug to iterate over all the resultData(s) and get the error code.
			//x Only the resultData[3] must contain an errorCode and only some steps has more
			//x resultData(s) containing such code too (e.g. 'Load Carrier').
			//x Note: This code works well with the previous commands because by iteration over
			//x       the resultData(s) (especialy step 'Load Carrier') from the resultData[5] and [6]
			//x       the evaluated errorCode was allways 0 and this ends never in a fault.
			//
			// Evaluate the error code of the block data(s). Use the highest number as stepErrorCode.
			//for (index=MlStar::ResultDataNo::firstBlockData; index<size; index++)
			//{
			//	errCode = MlStar::StepReturn::GetErrorCode(rc.GetAt(index));
			//
			//	if ( stepErrorCode < errCode )
			//	{
			//		stepErrorCode = errCode;
			//	}
			//}
			//////////////////////////////////////////////////////////////

			// Get the step error code
			// The first block data must contain the error code for all commands
			stepErrorCode = MlStar::StepReturn::GetErrorCode(resultData.GetAt(MlStar::ResultDataNo::firstBlockData));

			// Some commands has more than one block data in the resultData that contains an
			// error code. Get it an use the highest number as stepErrorCode.
			if (		(resultData.GetAt(MlStar::ResultDataNo::stepName) == "LoadCarrier")
					|| (resultData.GetAt(MlStar::ResultDataNo::stepName) == "ReloadCarrier") )
			{
				variable errCode(-1);
				errCode = MlStar::StepReturn::GetErrorCode(resultData.GetAt(MlStar::ResultDataNo::firstBlockData + 1));

				if ( stepErrorCode < errCode )
				{
					// A higher number is set in the second block data. Use this as step error code.
					stepErrorCode = errCode;
				}
			}

			// Evaluate the CommandResult by the stepErrorCode
			if ( MlStar::StepReturnEx::StepErrorCode::OK == stepErrorCode )
			{
				// Step ends with OK. Use result data.
				commandResult = ResultList::CommandResult::succeed;
			}
			else if ( MlStar::StepReturnEx::StepErrorCode::OK_Abort_Cancel == stepErrorCode )
			{
				// Step ends with OK/Cancel/Abort. Use result data.
				commandResult = ResultList::CommandResult::failed;
			}
			else if ( MlStar::StepReturnEx::StepErrorCode::fatal == stepErrorCode )
			{
				// Step ends fatal. Should never be reached, handled over a excpetion in bindErrorData() and
				// should be end in the handler 'MlStarError'.
				#ifdef _DEBUG_AL
				Assert( hslFalse, GetFunctionName()+"\n\nStep which ends fatal should not be evaluated here.\nShould be handled by an exception." );
				#endif
				commandResult = ResultList::CommandResult::fatal;
			}
			else
			{
				// Unexpected step result detected.
				Error::raiseRuntimeError(IDE::unexpectedResultData, GetFileName(), GetFunctionName(), GetLineNumber());
			}

			// Return the command result
			return( commandResult );
		}


		static function MlStar::initialize(variable stepID) variable[]
		{
			variable rc[];
			variable initializeAlways(-1);

			setCommandState(stepID, CommandState::executeStart);

			initializeAlways	= getIntegerParam(stepID, 1);

			onerror goto StepErrorHandler;
			rc = MlStar::Prep_Initialize_002(mlstar,
														initializeAlways);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: Initialize", rc);
			#endif
			
			MlStar::completeResultData(rc);

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: Initialize");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::loadCarrier(variable stepID) variable[]
		{
			variable rc[];
			variable carrierName("");
			variable barcodeFileName("");
			variable barcodeReadPositions("");

			setCommandState(stepID, CommandState::executeStart);

			carrierName				= getStringParam(stepID, 1);
			barcodeFileName		= getStringParam(stepID, 2);
			barcodeReadPositions	= getStringParam(stepID, 3);

			onerror goto StepErrorHandler;
			rc = MlStar::Prep_LoadCarrier_001(mlstar,
														 carrierName,
														 barcodeFileName,
														 barcodeReadPositions);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: LoadCarrier", rc);
			#endif
			
			MlStar::completeResultData(rc);

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: LoadCarrier");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::reLoadCarrier(variable stepID) variable[]
		{
			variable rc[];
			sequence loadSequence; 
			sequence unloadSequence;
			variable barcodeFileName(-1);
			variable sequenceCounting(-1);
			variable loadOnTrayPosition(-1);
			variable reloadEmptyCarrier(-1);

			setCommandState(stepID, CommandState::executeStart);

			barcodeFileName		= getStringParam(stepID, 1);
			sequenceCounting		= getIntegerParam(stepID, 1);
			loadOnTrayPosition	= getIntegerParam(stepID, 2);
			reloadEmptyCarrier	= getIntegerParam(stepID, 3);

			// Init the LoadSequence (GroupID=1), may be empty
			PositionData::initStepSequence(stepID, 1, loadSequence);
			// Init the UnloadSequence (GroupID=2), may be empty
			PositionData::initStepSequence(stepID, 2, unloadSequence);

			onerror goto StepErrorHandler;
			rc = MlStar::Prep_ReLoadCarrier_001(mlstar,
															loadSequence, 
															unloadSequence, 
															barcodeFileName,
															sequenceCounting,
															loadOnTrayPosition,
															reloadEmptyCarrier);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: ReloadCarrier", rc);
			#endif
			
			MlStar::completeResultData(rc);

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: ReloadCarrier");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::unloadCarrier(variable stepID) variable[]
		{
			variable rc[];
			variable carrierName("");

			setCommandState(stepID, CommandState::executeStart);

			carrierName = getStringParam(stepID, 1);

			onerror goto StepErrorHandler;
			rc = MlStar::Prep_UnloadCarrier_001(mlstar,
															carrierName);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: UnloadCarrier", rc);
			#endif
			
			MlStar::completeResultData(rc);

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: UnloadCarrier");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::calibrateCarrier(variable stepID) variable[]
		{
			variable rc[];
			variable carrierName("");
			variable calibrateChannel(-1);

			setCommandState(stepID, CommandState::executeStart);

			carrierName      = getStringParam(stepID, 1);
			calibrateChannel = getIntegerParam(stepID, 1);

			onerror goto StepErrorHandler;
			rc = MlStar::Prep_CalibrateCarrier_001(mlstar,
																carrierName,
																calibrateChannel);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: Calibrate Carrier", rc);
			#endif

			MlStar::completeResultData(rc);
			
			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: Calibrate Carrier");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::tccSetCarrierTemperature(variable stepID) variable[]
		{
			variable rc[];
			variable carrierName("");
			variable temperatureControl(-1);
			variable timeToTemperatureCheck(-1);
			variable goToNextStep(-1);
			variable temperature(-1.0);

			   static const variable tempControl_Off(0);
			// static const variable tempControl_On(1);

			setCommandState(stepID, CommandState::executeStart);

			carrierName        = getStringParam(stepID, 1);
			temperatureControl = getIntegerParam(stepID, 1);

			if ( tempControl_Off != temperatureControl )
			{
				timeToTemperatureCheck = getIntegerParam(stepID, 2);
				goToNextStep           = getIntegerParam(stepID, 3);
				temperature            = getDoubleParam(stepID, 1);
			}
			else
			{
				// Control values are not from interest, set to valid values.
				timeToTemperatureCheck = 0;
				goToNextStep           = 0;
				temperature            = 0.0;
			}

			onerror goto StepErrorHandler;
			rc = MlStar::Prep_SetCarrierTemperature_001(mlstar,
																	  carrierName,
																	  temperatureControl,
																	  timeToTemperatureCheck,
																	  goToNextStep,
																	  temperature);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: SetCarrierTemperature", rc);
			#endif

			MlStar::completeResultData(rc);
			
			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: SetCarrierTemperature");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::tccGetCarrierTemperature(variable stepID) variable[]
		{
			variable rc[];
			variable carrierName("");

			setCommandState(stepID, CommandState::executeStart);

			carrierName = getStringParam(stepID, 1);

			onerror goto StepErrorHandler;
			rc = MlStar::Prep_GetCarrierTemperature_001(mlstar,
																	  carrierName);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: GetCarrierTemperature", rc);
			#endif

			MlStar::completeResultData(rc);
			
			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: GetCarrierTemperature");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::lockFrontCover(variable stepID) variable[]
		{
			variable rc[];
			variable lockSetting(-1);

			setCommandState(stepID, CommandState::executeStart);

			lockSetting = getIntegerParam(stepID, 1);

			onerror goto StepErrorHandler;
			rc = MlStar::Prep_LockFrontCover_001(mlstar,
															 lockSetting);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: Lock Front Cover", rc);
			#endif

			MlStar::completeResultData(rc);
			
			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: Lock Front Cover");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::_1000ulChTipPickUp(variable stepID) variable[]
		{
			variable rc[];
			sequence tipSequence; 
			variable channelVariable("");
			variable sequenceCounting(-1);
			variable channelUse(-1);

			setCommandState(stepID, CommandState::executeStart);

			channelVariable	= getStringParam(stepID, 1);
			sequenceCounting	= getIntegerParam(stepID, 1);
			channelUse			= getIntegerParam(stepID, 2);

			PositionData::initStepSequence(stepID, 1, tipSequence);

			onerror goto StepErrorHandler;
			rc = MlStar::Channel_TipPickUp_001(mlstar,
														  tipSequence, 
														  channelVariable,
														  sequenceCounting,
														  channelUse);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: 1000ul Channel TipPickUp", rc);
			#endif

			MlStar::completeResultDataEx(rc, tipSequence.GetUsedPositions());

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: _1000ulChTipPickUp");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::_1000ulChNeedlePickUp(variable stepID) variable[]
		{
			variable rc[];
			variable channelVariable("");
			variable sequenceCounting(-1);
			variable channelUse(-1);
			sequence needleSequence; 

			setCommandState(stepID, CommandState::executeStart);

			channelVariable	= getStringParam(stepID, 1);
			sequenceCounting	= getIntegerParam(stepID, 1);
			channelUse			= getIntegerParam(stepID, 2);

			PositionData::initStepSequence(stepID, 1, needleSequence);

			onerror goto StepErrorHandler;
			rc = MlStar::Channel_NeedlePickUp_001(mlstar,
															  needleSequence, 
															  channelVariable,
															  sequenceCounting,
															  channelUse);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: 1000ul Channel TipPickUp", rc);
			#endif

			MlStar::completeResultDataEx(rc, needleSequence.GetUsedPositions());

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: _1000ulChNeedlePickUp");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::_1000ulChTipNeedleEject(variable stepID) variable[]
		{
			variable rc[];
			sequence wasteSequence; 
			variable channelVariable("");
			variable sequenceCounting(-1);
			variable channelUse(-1);
			variable useDefaultWaste(-1);

			setCommandState(stepID, CommandState::executeStart);

			channelVariable	= getStringParam(stepID, 1);
			sequenceCounting	= getIntegerParam(stepID, 1);
			channelUse			= getIntegerParam(stepID, 2);
			useDefaultWaste	= getIntegerParam(stepID, 3);

			if ( 0 == useDefaultWaste )
			{
				// Needs the waste-sequence for tip eject
				PositionData::initStepSequence(stepID, 1, wasteSequence);
			}

			onerror goto StepErrorHandler;
			rc = MlStar::Channel_TipOrNeedleEject_001(mlstar,
																	wasteSequence,
																	channelVariable,
																	sequenceCounting,
																	channelUse,
																	useDefaultWaste);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: 1000ul Channel TipEject", rc);
			#endif
			
			if ( 0 == useDefaultWaste )
			{
				MlStar::completeResultDataEx(rc, wasteSequence.GetUsedPositions());
			}
			else
			{
				MlStar::completeResultData(rc);
			}

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: _1000ulChTipNeedleEject");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::_1000ulChAspirate(variable stepID) variable[]
		{
			variable rc[];
			sequence aspirateSequence; 
			variable volumeArray[];
			variable channelVariable("");
			variable liquidClass("");
			variable sequenceCounting(-1);
			variable channelUse(-1);
			variable aspirateMode(-1);
			variable capacitiveLLD(-1);
			variable pressureLLD(-1);
			variable liquidFollowing(-1);
			variable mixCycles(-1);
			variable touchOff(-1);
			variable submergeDepth(-1.0);
			variable liquidHeight(-1.0);
			variable maxLLdDifference(-1.0);
			variable mixPosition(-1.0);
			variable mixVolume(-1.0);
			variable airTransportRetractDist(-1.0);
			variable aspPosAboveTouch(-1.0);

			setCommandState(stepID, CommandState::executeStart);

			channelVariable			= getStringParam(stepID, 1);
			liquidClass					= getStringParam(stepID, 2);
			sequenceCounting			= getIntegerParam(stepID, 1);
			channelUse					= getIntegerParam(stepID, 2);
			aspirateMode				= getIntegerParam(stepID, 3);
			capacitiveLLD				= getIntegerParam(stepID, 4);
			pressureLLD					= getIntegerParam(stepID, 5);
			liquidFollowing			= getIntegerParam(stepID, 6);
			mixCycles					= getIntegerParam(stepID, 7);
			touchOff						= getIntegerParam(stepID, 8);			// added 2009-11-23/cjoerg
			submergeDepth				= getDoubleParam(stepID, 1);
			liquidHeight				= getDoubleParam(stepID, 2);
			maxLLdDifference			= getDoubleParam(stepID, 3);
			mixPosition					= getDoubleParam(stepID, 4);
			mixVolume					= getDoubleParam(stepID, 5);
			airTransportRetractDist	= getDoubleParam(stepID, 6);			// added 2009-11-23/cjoerg
			aspPosAboveTouch			= getDoubleParam(stepID, 7);			// added 2009-11-23/cjoerg

			volumeArray = VolumeData::initChannelVolumes(stepID, channelVariable);

			PositionData::initStepSequence(stepID, 1, aspirateSequence);

			onerror goto StepErrorHandler;
			rc = MlStar::Channel_Aspirate_002(mlstar,
														 aspirateSequence,
														 volumeArray,
														 channelVariable,
														 liquidClass,
														 sequenceCounting,
														 channelUse,
														 aspirateMode,
														 capacitiveLLD,
														 pressureLLD,
														 liquidFollowing,
														 mixCycles,
														 touchOff,
														 submergeDepth,
														 liquidHeight,
														 maxLLdDifference,
														 mixPosition,
														 mixVolume,
														 airTransportRetractDist,
														 aspPosAboveTouch);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: 1000ul Channel Aspirate", rc);
			#endif

			MlStar::completeResultDataEx(rc, aspirateSequence.GetUsedPositions());

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: _1000ulChAspirate");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::_1000ulChDispense(variable stepID) variable[]
		{
			variable rc[];
			sequence dispenseSequence; 
			variable volumeArray[];
			variable channelVariable("");
			variable liquidClass("");
			variable sequenceCounting(-1);
			variable channelUse(-1);
			variable dispenseMode(-1);
			variable capacitiveLLD(-1);
			variable liquidFollowing(-1);
			variable mixCycles(-1);
			variable zMoveAfterStep(-1);
			variable touchOff(-1);
			variable sideTouch(-1);
			variable submergeDepth(-1.0);
			variable liquidHeight(-1.0);
			variable mixPosition(-1.0);
			variable mixVolume(-1.0);
			variable dispPositionAboveTouch(-1.0);
			variable airTransportRetractDist(-1.0);

			setCommandState(stepID, CommandState::executeStart);

			channelVariable			= getStringParam(stepID, 1);
			liquidClass					= getStringParam(stepID, 2);
			sequenceCounting			= getIntegerParam(stepID, 1);
			channelUse					= getIntegerParam(stepID, 2);
			dispenseMode				= getIntegerParam(stepID, 3);
			capacitiveLLD				= getIntegerParam(stepID, 4);
			liquidFollowing			= getIntegerParam(stepID, 5);
			mixCycles					= getIntegerParam(stepID, 6);
			zMoveAfterStep				= getIntegerParam(stepID, 7);
			touchOff						= getIntegerParam(stepID, 8);		// added 2005-07-28 / cjoerg
			sideTouch					= getIntegerParam(stepID, 9);		// added 2006-10-23 / cjoerg
			submergeDepth				= getDoubleParam(stepID, 1);
			liquidHeight				= getDoubleParam(stepID, 2);
			mixPosition					= getDoubleParam(stepID, 3);
			mixVolume					= getDoubleParam(stepID, 4);
			dispPositionAboveTouch	= getDoubleParam(stepID, 5);		// added 2005-07-28 / cjoerg
			airTransportRetractDist	= getDoubleParam(stepID, 6);		// added 2009-11-23/cjoerg

			volumeArray = VolumeData::initChannelVolumes(stepID, channelVariable);

			PositionData::initStepSequence(stepID, 1, dispenseSequence);

			onerror goto StepErrorHandler;
			rc = MlStar::Channel_Dispense_002(mlstar,
														 dispenseSequence,
														 volumeArray,
														 channelVariable,
														 liquidClass,
														 sequenceCounting,
														 channelUse,
														 dispenseMode,
														 capacitiveLLD,
														 liquidFollowing,
														 mixCycles,
														 zMoveAfterStep,
														 touchOff,
														 sideTouch,
														 submergeDepth,
														 liquidHeight,
														 mixPosition,
														 mixVolume,
														 dispPositionAboveTouch,
														 airTransportRetractDist);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: 1000ul Channel Dispense", rc);
			#endif

			MlStar::completeResultDataEx(rc, dispenseSequence.GetUsedPositions());

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: _1000ulChDispense");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::_1000ulChDispenseFly(variable stepID) variable[]
		{
			variable rc[];
			sequence dispenseSequence;
			variable volumeArray[];
			variable channelVariable("");
			variable liquidClass("");
			variable excludedLabwarePositions("");
			variable sequenceCounting(-1);
			variable dispenseOnTheFlyMode(-1);
			variable dispenseDirection(-1);
			variable labwareSurfaceDistance(-1.0);
			variable XspeedDuringDispense(-1.0);
			variable XstartOffset(-1.0);
			variable XaccelerationDistance(-1.0);

			setCommandState(stepID, CommandState::executeStart);

			channelVariable				= getStringParam(stepID, 1);
			liquidClass						= getStringParam(stepID, 2);
			excludedLabwarePositions	= getStringParam(stepID, 3);
			sequenceCounting				= getIntegerParam(stepID, 1);
			dispenseOnTheFlyMode			= getIntegerParam(stepID, 2);
			dispenseDirection				= getIntegerParam(stepID, 3);
			labwareSurfaceDistance		= getDoubleParam(stepID, 1);
			XspeedDuringDispense			= getDoubleParam(stepID, 2);
			XstartOffset					= getDoubleParam(stepID, 3);
			XaccelerationDistance		= getDoubleParam(stepID, 4);

			volumeArray = VolumeData::initChannelVolumes(stepID, channelVariable);

			PositionData::initStepSequence(stepID, 1, dispenseSequence);

			onerror goto StepErrorHandler;
			rc = MlStar::Channel_DispenseFly_001(mlstar,
															 dispenseSequence,
															 volumeArray,
															 channelVariable,
															 liquidClass,
															 excludedLabwarePositions,
															 sequenceCounting,
															 dispenseOnTheFlyMode,
															 dispenseDirection,
															 labwareSurfaceDistance,
															 XspeedDuringDispense,
															 XstartOffset,
															 XaccelerationDistance);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: 1000ul Channel Dispense on the Fly", rc);
			#endif

			MlStar::completeResultDataEx(rc, dispenseSequence.GetUsedPositions());

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: _1000ulChDispenseFly");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::_1000ulChWaitNeedleWashed(variable stepID) variable[]
		{
			variable rc[];
			variable washStationName("");

			setCommandState(stepID, CommandState::executeStart);

			washStationName = getStringParam(stepID, 1);

			onerror goto StepErrorHandler;
			rc = MlStar::Channel_WaitNeedleWashed_001(mlstar,
																	washStationName);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: 1000ul Channel WaitNeeldeWashed", rc);
			#endif
			
			MlStar::completeResultData(rc);

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: _1000ulChWaitNeedleWashed");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::_1000ulChStartNeedleWash(variable stepID) variable[]
		{
			variable rc[];
			variable washStationName("");
			variable liq1_flowRate(-1);
			variable liq2_flowRate(-1);
			variable startWashLiquid(-1);
			variable liq1_rinseTime(-1.0);
			variable liq1_soakTime(-1.0);
			variable liq2_rinseTime(-1.0);
			variable liq2_soakTime(-1.0);
			variable drainingTime(-1.0);

			setCommandState(stepID, CommandState::executeStart);

			washStationName	= getStringParam(stepID, 1);
			liq1_flowRate		= getIntegerParam(stepID, 1);
			liq2_flowRate		= getIntegerParam(stepID, 2);
			startWashLiquid	= getIntegerParam(stepID, 3);
			liq1_rinseTime		= getDoubleParam(stepID, 1);
			liq1_soakTime		= getDoubleParam(stepID, 2);
			liq2_rinseTime		= getDoubleParam(stepID, 3);
			liq2_soakTime		= getDoubleParam(stepID, 4);
			drainingTime		= getDoubleParam(stepID, 5);

			onerror goto StepErrorHandler;
			rc = MlStar::Channel_StartNeedleWash_001(mlstar,
																  washStationName,
																  liq1_flowRate,
																  liq2_flowRate,
																  startWashLiquid,
																  liq1_rinseTime,
																  liq1_soakTime,
																  liq2_rinseTime,
																  liq2_soakTime,
																  drainingTime);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: 1000ul Channel StartNeeldeWash", rc);
			#endif
			
			MlStar::completeResultData(rc);

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: _1000ulChStartNeedleWash");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::_1000ulChGetContainerVolume(variable stepID) variable[]
		{
			variable rc[];								// result data of this command
			variable channelVariable("");			// parameter to read
			variable sequenceCounting(-1);		// parameter to read
			variable capacitiveLLD(-1);			// parameter to read
			variable pressureLLD(-1);				// parameter to read
			variable maxLLdDifference(-1.0);		// parameter to read
			sequence dummyAspirateSequence; 		// sequence where the volume shall be measured

			string strPattern;						// channel pattern as string
			variable measureFailed(hslFalse);	// hslTrue to indicata that the meassure failed at least
															// on one channel
			variable containerVolumes[];			// Array to get the measured volumes 

			variable blockDel(MlStar::StepReturnEx::InstrumentValues::blockDelimiter);		// Ml_Star, block delimiter
			variable fieldDel(MlStar::StepReturnEx::InstrumentValues::fieldDelimiter);		// Ml_Star, field delimiter
			variable blockData("");					// block data generated from this command

			variable index(0), length(0), value(0.0);

			setCommandState(stepID, CommandState::executeStart);

			// Get the command-parameters
			channelVariable	= getStringParam(stepID, 1);
			sequenceCounting	= getIntegerParam(stepID, 1);
			capacitiveLLD		= getIntegerParam(stepID, 2);
			pressureLLD			= getIntegerParam(stepID, 3);
			maxLLdDifference	= getDoubleParam(stepID, 1);

			// Step needs a sequence where the volumes shall be measured and for
			// which labware positions the volume shall be calculated.
			PositionData::initStepSequence(stepID, 1, dummyAspirateSequence);

			#ifdef _DEBUG_STAR_STEPPARAMS
			{
				variable stepName;
				stepName = GetFunctionName();
				MlStar::DEBUG::TraceStepParamDevice(stepName, "device", mlstar);
				MlStar::DEBUG::TraceStepParamSequence(stepName, "dummyAspirateSequence", dummyAspirateSequence);
				MlStar::DEBUG::TraceStepParamVariable(stepName, "channelVariable", channelVariable);
				MlStar::DEBUG::TraceStepParamVariable(stepName, "sequenceCounting", sequenceCounting);
				MlStar::DEBUG::TraceStepParamVariable(stepName, "capacitiveLLD", capacitiveLLD);
				MlStar::DEBUG::TraceStepParamVariable(stepName, "pressureLLD", pressureLLD);
				MlStar::DEBUG::TraceStepParamVariable(stepName, "maxLLdDifference", maxLLdDifference);
			}
			#endif

			onerror goto StepErrorHandler;

			// Measure the container volume.
			// Gets only the last liquid level if capacitiveLLD=0 and pressureLLD=0
			MlStar::HSLML_STAR::MeasureContainerVolume(mlstar,
																	 dummyAspirateSequence,
																	 sequenceCounting,
																	 channelVariable,
																	 capacitiveLLD,
																	 pressureLLD,
																	 maxLLdDifference);

			strPattern = channelVariable;
			length = strPattern.GetLength();

			// Get the measured volumes for each (used or unused) channel
			for( index=1; index<=length; index++)
			{
				value = MlStar::HSLML_STAR::GetContainerVolume(index);			// one-based
				containerVolumes.AddAsLast(value);										// array, zero-based!

				if ( 0 == value )
				{
					measureFailed = hslTrue;		// Measure failed at least on one channel
				}
			}

			#ifdef _DEBUG_AL
			dumpArray("MlStar::HSLML_STAR::_1000ulChGetContainerVolume(s)", containerVolumes);
			#endif

			// Generate the block data as same a HxGRUCommand step generates it
			rc.AddAsLast(mlstar.GetInstrumentName());		// Instrument show name
			rc.AddAsLast("GetContainerVolume");				// Step name, not translated.
			
			// Evaluate the error flag			
			if ( measureFailed )
			{
				// Has error
				blockData = IStr(MlStar::StepReturnEx::StepErrorCode::OK_Abort_Cancel);
			}
			else
			{
				// No error
				blockData = IStr(MlStar::StepReturnEx::StepErrorCode::OK);
			}

			// Generate the block data for all instrument channels (1..n)
			for ( index=1; index<=MlStar::StepReturnEx::InstrumentValues::numberOfChannels; index++ )
			{
				blockData = blockData + blockDel + IStr(index) + fieldDel;	// position, one-based
				blockData = blockData + fieldDel;									// main error, empty
				blockData = blockData + fieldDel;									// slave error, empty
				blockData = blockData + fieldDel;									// recovery button, empty

				value = containerVolumes.GetAt(index-1);							// array zero-based
				if (Util::IsInteger(value))
					value = IStr(value);
				if (Util::IsFloat(value))
					value = FStr(value);

				blockData = blockData + value + fieldDel;							// step data (volume)

				blockData = blockData + fieldDel;									// labwareID, empty
				blockData = blockData;													// positionID, empty, last value.
			}

			rc.AddAsLast(blockData);								// Add block data to the result

			onerror goto 0;


			#ifdef _DEBUG_AL
			dumpArray("Command result: GetContainerVolume", rc);
			#endif
	
			if (		( 0 != capacitiveLLD )
					|| ( 0 != pressureLLD ) )
			{
				// Sequence was used
				MlStar::completeResultDataEx(rc, dummyAspirateSequence.GetUsedPositions());
			}
			else
			{
				// No sequence not used
				MlStar::completeResultData(rc);
			}

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				variable lastErrorDescr("");

				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: _1000ulChGetContainerVolume");
				#endif

				// Exception during during measure of volume, no way to resume.
				// Get the error-description of the library error, but never use
				// because the errorID's of the called library function may be overlapped
				// with the IDE of this method. 

				lastErrorDescr = err.GetDescription();

				// Raise error to leave this command with exception (fatal error)
				Error::raiseRuntimeErrorEx(IDE::mlStarCommandFatal, lastErrorDescr, GetFileName(), GetFunctionName(), GetLineNumber());
			}
		}


		// 2005-07-29 / cjoerg: added new command
		static function MlStar::_1000ulChGetLastLiquidLevel(variable stepID) variable[]
		{
			variable rc[];

			setCommandState(stepID, CommandState::executeStart);

			onerror goto StepErrorHandler;
			rc = MlStar::Channel_GetLastLiquidLevel_001(mlstar);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: 1000ul Channel GetLastLiquidLevel", rc);
			#endif
			
			MlStar::completeResultData(rc);

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: _1000ulChGetLastLiquidLevel");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::iSwapGetPlate(variable stepID) variable[]
		{
			variable rc[];
			sequence plateSequence; 
			sequence lidSequence;
			variable sequenceCounting(-1);
			variable movementType(-1);
			variable transportMode(-1);
			variable labwareOrientation(-1);
			variable gripForce(-1);
			variable inverseGrip(-1);
			variable collisionControl(-1);
			variable gripMode(-1);
			variable retractDistance(-1.0);
			variable liftUpHeight(-1.0);
			variable gripWidth(-1.0);
			variable tolerance(-1.0);
			variable gripHeight(-1.0);
			variable widthBefore(-1.0);

			// enumeration of available movement types
			//variable mtToCarrier    (0);
			variable mtComplexMovement(1);

			// enumeration of available transport modes
			variable tmPlateOnly      (0);
			variable tmLidOnly        (1);
			//variable tmPlateAndLid  (2);

			setCommandState(stepID, CommandState::executeStart);

			sequenceCounting	= getIntegerParam(stepID, 1);
			movementType		= getIntegerParam(stepID, 2);
			transportMode		= getIntegerParam(stepID, 3);
			// integer parameter 4 see below
			gripForce			= getIntegerParam(stepID, 5);
			inverseGrip			= getIntegerParam(stepID, 6);
			collisionControl	= getIntegerParam(stepID, 7);
			gripMode				= getIntegerParam(stepID, 8);
			// double parameter 1 see below
			// double parameter 2 see below
			gripWidth			= getDoubleParam(stepID, 3);
			tolerance			= getDoubleParam(stepID, 4);
			gripHeight			= getDoubleParam(stepID, 5);
			widthBefore			= getDoubleParam(stepID, 6);

			if ( mtComplexMovement == movementType)
			{
				labwareOrientation	= getIntegerParam(stepID, 4);	// Parameters only interpreted
				retractDistance		= getDoubleParam(stepID, 1);	// for a complex movement command.
				liftUpHeight			= getDoubleParam(stepID, 2);	//
			}
			else
			{
				labwareOrientation	= 1;		// Unused parameters.
				retractDistance		= 0.0;	// Set to valid values for passing to the
				liftUpHeight			= 0.0;	// low level step.
			}

			if ( transportMode != tmLidOnly )
			{
				// Needs the plate sequence (GroupID=1)
				PositionData::initStepSequence(stepID, 1, plateSequence);
			}

			if ( transportMode != tmPlateOnly )
			{
				// Needs the lid sequence (GroupID=2)
				PositionData::initStepSequence(stepID, 2, lidSequence);
			}

			onerror goto StepErrorHandler;
			rc = MlStar::iSwap_GetPlate_001(mlstar,
													  plateSequence,
													  lidSequence,
													  sequenceCounting,
													  movementType,
													  transportMode,
													  labwareOrientation,
													  gripForce,
													  inverseGrip,
													  collisionControl,
													  gripMode,
													  retractDistance,
													  liftUpHeight,
													  gripWidth,
													  tolerance,
													  gripHeight,
													  widthBefore);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: iSWAP GetPlate", rc);
			#endif

			if ( transportMode != tmLidOnly )
			{
				// Only plate sequence used or plate sequence used as priority sequence.
				MlStar::completeResultDataEx(rc, plateSequence.GetUsedPositions());
			}
			else
			{
				// Only lid sequence touched, get its used positions.
				MlStar::completeResultDataEx(rc, lidSequence.GetUsedPositions());
			}
			
			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: iSWAP GetPlate");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::iSwapPlacePlate(variable stepID) variable[]
		{
			variable rc[];
			sequence plateSequence; 
			sequence lidSequence;
			variable sequenceCounting(-1);
			variable movementType(-1);
			variable transportMode(-1);
			variable labwareOrientation(-1);
			variable collisionControl(-1);
			variable retractDistance(-1.0);
			variable liftUpHeight(-1.0);

			// enumeration of available movement types
			//variable mtToCarrier    (0);
			variable mtComplexMovement(1);

			// enumeration of available transport modes
			variable tmPlateOnly      (0);
			variable tmLidOnly        (1);
			//variable tmPlateAndLid  (2);

			setCommandState(stepID, CommandState::executeStart);

			sequenceCounting	= getIntegerParam(stepID, 1);
			movementType		= getIntegerParam(stepID, 2);
			transportMode		= getIntegerParam(stepID, 3);
			// integer parameter 4 see below
			collisionControl		= getIntegerParam(stepID, 5);
			// double parameter 1 see below
			// double parameter 2 see below

			if ( mtComplexMovement == movementType)
			{
				labwareOrientation	= getIntegerParam(stepID, 4);	// Parameters only interpreted
				retractDistance		= getDoubleParam(stepID, 1);	// for a complex movement command.
				liftUpHeight			= getDoubleParam(stepID, 2);	//
			}
			else
			{
				labwareOrientation	= 1;		// Unused parameters.
				retractDistance		= 0.0;	// Set to valid values for passing to the
				liftUpHeight			= 0.0;	// low level step.
			}

			if ( transportMode != tmLidOnly )
			{
				// Needs the plate sequence (GroupID=1)
				PositionData::initStepSequence(stepID, 1, plateSequence);
			}

			if ( transportMode != tmPlateOnly )
			{
				// Needs the lid sequence (GroupID=2)
				PositionData::initStepSequence(stepID, 2, lidSequence);
			}

			onerror goto StepErrorHandler;
			rc = MlStar::iSwap_PlacePlate_001(mlstar,
														 plateSequence, 
														 lidSequence,
														 sequenceCounting,
														 movementType,
														 transportMode,
														 labwareOrientation,
														 collisionControl,
														 retractDistance,
														 liftUpHeight);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: iSWAP PutPlate", rc);
			#endif

			if ( transportMode != tmLidOnly )
			{
				// Only plate sequence used or plate sequence used as priority sequence.
				MlStar::completeResultDataEx(rc, plateSequence.GetUsedPositions());
			}
			else
			{
				// Only lid sequence touched, get its used positions.
				MlStar::completeResultDataEx(rc, lidSequence.GetUsedPositions());
			}
			
			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: iSWAP PutPlate");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::iSwapMovePlate(variable stepID) variable[]
		{
			variable rc[];
			sequence destinationSequence;
			variable collisionControl(-1);
			variable gripMode(-1);
			variable usedPositions(0);		// Stores the position count for the current labware
													// of the destinationSequence before calling the
													// low level step.
													// The MovePlate step never counts on the sequence
													// and used positions is not set (always 0).
													// In the OEM interface method context the same count of used
													// positions is returned as the other iSWAP steps does.

			setCommandState(stepID, CommandState::executeStart);

			collisionControl	= getIntegerParam(stepID, 1);
			gripMode				= getIntegerParam(stepID, 2);

			// Needs a sequence (GroupID=1)
			PositionData::initStepSequence(stepID, 1, destinationSequence);

			usedPositions = destinationSequence.GetPositionCountForCurrLabware();

			onerror goto StepErrorHandler;
			rc = MlStar::iSwap_MovePlate_001(mlstar,
														destinationSequence,
														collisionControl,
														gripMode);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: iSWAP MovePlate", rc);
			#endif

			MlStar::completeResultDataEx(rc, usedPositions);
			
			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: iSWAP MovePlate");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::iSwapOpenGripper(variable stepID) variable[]
		{
			variable rc[];
			sequence plateSequence; 
			sequence lidSequence;
			variable sequenceCounting(-1);
			variable transportMode(-1);
			variable gripMode(-1);
			variable openingWidth(-1.0);

			// enumeration of available transport modes
			variable tmPlateOnly      (0);
			variable tmLidOnly        (1);
			//variable tmPlateAndLid  (2);

			setCommandState(stepID, CommandState::executeStart);

			sequenceCounting	= getIntegerParam(stepID, 1);
			transportMode		= getIntegerParam(stepID, 2);
			gripMode				= getIntegerParam(stepID, 3);
			openingWidth		= getDoubleParam(stepID, 1);

			if ( transportMode != tmLidOnly )
			{
				// Needs the plate sequence (GroupID=1)
				PositionData::initStepSequence(stepID, 1, plateSequence);
			}

			if ( transportMode != tmPlateOnly )
			{
				// Needs the lid sequence (GroupID=2)
				PositionData::initStepSequence(stepID, 2, lidSequence);
			}

			onerror goto StepErrorHandler;
			rc = MlStar::iSwap_OpenGripper_001(mlstar,
														  plateSequence,
														  lidSequence,
														  sequenceCounting,
														  transportMode,
														  gripMode,
														  openingWidth);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: iSWAP OpenGripper", rc);
			#endif

			if ( transportMode != tmLidOnly )
			{
				// Only plate sequence used or plate sequence used as priority sequence.
				MlStar::completeResultDataEx(rc, plateSequence.GetUsedPositions());
			}
			else
			{
				// Only lid sequence touched, get its used positions.
				MlStar::completeResultDataEx(rc, lidSequence.GetUsedPositions());
			}
			
			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: iSWAP OpenGripper");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::iSwapCloseGripper(variable stepID) variable[]
		{
			variable rc[];
			sequence plateSequence; 
			sequence lidSequence;
			variable sequenceCounting(-1);
			variable transportMode(-1);
			variable gripForce(-1);
			variable gripMode(-1);
			variable gripWidth(-1.0);
			variable tolerance(-1.0);
			variable gripHeight(-1.0);

			// enumeration of available transport modes
			variable tmPlateOnly      (0);
			variable tmLidOnly        (1);
			//variable tmPlateAndLid  (2);

			setCommandState(stepID, CommandState::executeStart);

			sequenceCounting	= getIntegerParam(stepID, 1);
			transportMode		= getIntegerParam(stepID, 2);
			gripForce			= getIntegerParam(stepID, 3);
			gripMode				= getIntegerParam(stepID, 4);
			gripWidth			= getDoubleParam(stepID, 1);
			tolerance			= getDoubleParam(stepID, 2);
			gripHeight			= getDoubleParam(stepID, 3);

			if ( transportMode != tmLidOnly )
			{
				// Needs the plate sequence (GroupID=1)
				PositionData::initStepSequence(stepID, 1, plateSequence);
			}

			if ( transportMode != tmPlateOnly )
			{
				// Needs the lid sequence (GroupID=2)
				PositionData::initStepSequence(stepID, 2, lidSequence);
			}

			onerror goto StepErrorHandler;
			rc = MlStar::iSwap_CloseGripper_001(mlstar,
															plateSequence,
															lidSequence,
															sequenceCounting,
															transportMode,
															gripForce,
															gripMode,
															gripWidth,
															tolerance,
															gripHeight);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: iSWAP CloseGripper", rc);
			#endif

			if ( transportMode != tmLidOnly )
			{
				// Only plate sequence used or plate sequence used as priority sequence.
				MlStar::completeResultDataEx(rc, plateSequence.GetUsedPositions());
			}
			else
			{
				// Only lid sequence touched, get its used positions.
				MlStar::completeResultDataEx(rc, lidSequence.GetUsedPositions());
			}
			
			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: iSWAP CloseGripper");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::iSwapReadPlateBarcode(variable stepID) variable[]
		{
			variable rc[];
			variable barcodeReaderPosition(-1);
			variable collisionControl(-1);
			variable minimalZpositionDuringRead(-1.0);
			variable YpositionDuringRead(-1.0);

			setCommandState(stepID, CommandState::executeStart);

			barcodeReaderPosition		= getIntegerParam(stepID, 1);
			collisionControl				= getIntegerParam(stepID, 2);
			minimalZpositionDuringRead	= getDoubleParam(stepID, 1);
			YpositionDuringRead			= getDoubleParam(stepID, 2);

			onerror goto StepErrorHandler;
			rc = MlStar::iSwap_ReadPlateBarcode_001(mlstar,
																 barcodeReaderPosition,
																 collisionControl,
																 minimalZpositionDuringRead,
																 YpositionDuringRead);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: iSWAP ReadPlateBarcode", rc);
			#endif

			MlStar::completeResultData(rc);
			
			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: iSWAP ReadPlateBarcode");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::iSwapGetFirstPlatePosition(variable stepID) variable[]
		{
			variable rc[];
			sequence searchSequence; 
			variable sequenceCounting(-1);
			variable gripForce(-1);
			variable inverseGrip(-1);
			variable collisionControl(-1);
			variable gripMode(-1);
			variable gripWidth(-1.0);
			variable tolerance(-1.0);
			variable gripHeight(-1.0);
			variable widthBefore(-1.0);

			setCommandState(stepID, CommandState::executeStart);

			sequenceCounting	= getIntegerParam(stepID, 1);
			gripForce			= getIntegerParam(stepID, 2);
			inverseGrip			= getIntegerParam(stepID, 3);
			collisionControl	= getIntegerParam(stepID, 4);
			gripMode				= getIntegerParam(stepID, 5);
			gripWidth			= getDoubleParam(stepID, 1);
			tolerance			= getDoubleParam(stepID, 2);
			gripHeight			= getDoubleParam(stepID, 3);
			widthBefore			= getDoubleParam(stepID, 4);

			// Needs the search sequence (GroupID=1)
			PositionData::initStepSequence(stepID, 1, searchSequence);

			onerror goto StepErrorHandler;
			rc = MlStar::iSwap_GetFirstPlatePosition_001(mlstar,
																		searchSequence,
																		sequenceCounting,
																		gripForce,
																		inverseGrip,
																		collisionControl,
																		gripMode,
																		gripWidth,
																		tolerance,
																		gripHeight,
																		widthBefore);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: iSWAP GetFirstPlatePosition", rc);
			#endif

			MlStar::completeResultDataEx(rc, searchSequence.GetUsedPositions());
			
			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: iSWAP GetFirstPlatePosition");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::iSwapPark(variable stepID) variable[]
		{
			variable rc[];
			variable showCollisionCheckDialog(-1);

			setCommandState(stepID, CommandState::executeStart);

			showCollisionCheckDialog	= getIntegerParam(stepID, 1);

			onerror goto StepErrorHandler;
			rc = MlStar::iSwap_Park_001(mlstar,
												 showCollisionCheckDialog);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: iSWAP ParkISwap", rc);
			#endif

			MlStar::completeResultData(rc);
			
			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: iSWAP ParkISwap");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::coRe96TipPickUp(variable stepID) variable[]
		{
			variable rc[];
			sequence tipPickUpSequence;
			variable channelVariable("");
			variable sequenceCounting(-1);
			variable reducedPatternMode(-1);

			variable startPosition(-1);

			setCommandState(stepID, CommandState::executeStart);

			channelVariable    = getStringParam(stepID, 1);
			startPosition      = getIntegerParam(stepID, 1);
			sequenceCounting   = getIntegerParam(stepID, 2);
			reducedPatternMode = getIntegerParam(stepID, 3);

			#ifdef _DEBUG_STAR_STEPPARAMS
			{
				variable stepName;
				stepName = GetFunctionName();
				MlStar::DEBUG::TraceStepParamVariable(stepName, "startPosition", startPosition);
				// 2005-08-10/cjoerg: The other parameters are traced in function MlStar::CoRe96Head_....
			}
			#endif

			PositionData::initStepSequence(stepID, 1, tipPickUpSequence);
			tipPickUpSequence.SetCurrentPosition(startPosition);		// If start is invalid sets current to zero
																						// -> ends in step error
			onerror goto StepErrorHandler;
			rc = MlStar::CoRe96Head_TipPickUp_001(mlstar,
															  tipPickUpSequence,
															  channelVariable,
															  sequenceCounting,
															  reducedPatternMode);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: Head96TipPickUp", rc);
			#endif

			MlStar::completeResultDataEx(rc, tipPickUpSequence.GetUsedPositions());

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: Head96TipPickUp");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::coRe96TipEject(variable stepID) variable[]
		{
			variable rc[];
			sequence tipEjectSequence;
			variable sequenceCounting(-1);
			variable tipEjectSetting(-1);

			setCommandState(stepID, CommandState::executeStart);

			// startPosition    = getIntegerParam(stepID, 1);	// readed below, only if needed
			sequenceCounting = getIntegerParam(stepID, 2);
			tipEjectSetting  = getIntegerParam(stepID, 3);

			if ( 0 == tipEjectSetting )		// (off (0), eject on passed positions)
			{
				// Needs the sequence for tip eject and the start position
				variable startPosition(-1);
				startPosition = getIntegerParam(stepID, 1);

				#ifdef _DEBUG_STAR_STEPPARAMS
				{
					variable stepName;
					stepName = GetFunctionName();
					MlStar::DEBUG::TraceStepParamVariable(stepName, "startPosition", startPosition);
					// 2005-08-10/cjoerg: The other parameters are traced in function MlStar::CoRe96Head_....
				}
				#endif

				PositionData::initStepSequence(stepID, 1, tipEjectSequence);
				tipEjectSequence.SetCurrentPosition(startPosition);		// If start is invalid sets current to zero, ends in step error.
			}

			onerror goto StepErrorHandler;
			rc = MlStar::CoRe96Head_TipEject_001(mlstar,
															 tipEjectSequence,
															 sequenceCounting,
															 tipEjectSetting);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: Head96TipEject", rc);
			#endif

			if ( 0 == tipEjectSetting )
			{
				MlStar::completeResultDataEx(rc, tipEjectSequence.GetUsedPositions());
			}
			else
			{
				MlStar::completeResultData(rc);
			}

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: Head96TipEject");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::coRe96Aspirate(variable stepID) variable[]
		{
			variable rc[];
			sequence aspirateSequence; 
			variable liquidClass("");
			variable sequenceCounting(-1);
			variable aspirateMode(-1);
			variable capacitiveLLD(-1);
			variable liquidFollowing(-1);
			variable mixCycles(-1);
			variable aspirateVolume(-1.0);
			variable submergeDepth(-1.0);
			variable liquidHeight(-1.0);
			variable mixPosition(-1.0);
			variable mixVolume(-1.0);
			variable airTransportRetractDist(-1.0);

			variable startPosition(-1);

			setCommandState(stepID, CommandState::executeStart);

			liquidClass					= getStringParam(stepID, 1);
			startPosition				= getIntegerParam(stepID, 1);
			sequenceCounting			= getIntegerParam(stepID, 2);
			aspirateMode				= getIntegerParam(stepID, 3);
			capacitiveLLD				= getIntegerParam(stepID, 4);
			liquidFollowing			= getIntegerParam(stepID, 5);
			mixCycles					= getIntegerParam(stepID, 6);
			aspirateVolume				= getDoubleParam(stepID, 1);
			submergeDepth				= getDoubleParam(stepID, 2);
			liquidHeight				= getDoubleParam(stepID, 3);
			mixPosition					= getDoubleParam(stepID, 4);
			mixVolume					= getDoubleParam(stepID, 5);
			airTransportRetractDist	= getDoubleParam(stepID, 6);		// added 2009-11-23/cjoerg

			#ifdef _DEBUG_STAR_STEPPARAMS
			{
				variable stepName;
				stepName = GetFunctionName();
				MlStar::DEBUG::TraceStepParamVariable(stepName, "startPosition", startPosition);
				// 2005-08-10/cjoerg: The other parameters are traced in function MlStar::CoRe96Head_....
			}
			#endif

			PositionData::initStepSequence(stepID, 1, aspirateSequence);
			aspirateSequence.SetCurrentPosition(startPosition);		// If start is invalid sets current to zero, ends in step error.

			onerror goto StepErrorHandler;
			rc = MlStar::CoRe96Head_Aspirate_002(mlstar,
															 aspirateSequence,
															 liquidClass,
															 sequenceCounting,
															 aspirateMode,
															 capacitiveLLD,
															 liquidFollowing,
															 mixCycles,
															 aspirateVolume,
															 submergeDepth,
															 liquidHeight,
															 mixPosition,
															 mixVolume,
															 airTransportRetractDist);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: Head96Aspirate", rc);
			#endif

			MlStar::completeResultDataEx(rc, aspirateSequence.GetUsedPositions());

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: Head96Aspirate");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::coRe96Dispense(variable stepID) variable[]
		{
			variable rc[];
			sequence dispenseSequence; 
			variable liquidClass("");
			variable sequenceCounting(-1);
			variable dispenseMode(-1);
			variable capacitiveLLD(-1);
			variable liquidFollowing(-1);
			variable mixCycles(-1);
			variable zMoveAfterStep(-1);
			variable sideTouch(-1);
			variable dispenseVolume(-1.0);
			variable submergeDepth(-1.0);
			variable liquidHeight(-1.0);
			variable mixPosition(-1.0);
			variable mixVolume(-1.0);
			variable airTransportRetractDist(-1.0);

			variable startPosition(-1);

			setCommandState(stepID, CommandState::executeStart);

			liquidClass					= getStringParam(stepID, 1);
			startPosition				= getIntegerParam(stepID, 1);
			sequenceCounting			= getIntegerParam(stepID, 2);
			dispenseMode				= getIntegerParam(stepID, 3);
			capacitiveLLD				= getIntegerParam(stepID, 4);
			liquidFollowing			= getIntegerParam(stepID, 5);
			mixCycles					= getIntegerParam(stepID, 6);
			zMoveAfterStep				= getIntegerParam(stepID, 7);
			sideTouch					= getIntegerParam(stepID, 8);
			dispenseVolume				= getDoubleParam(stepID, 1);
			submergeDepth				= getDoubleParam(stepID, 2);
			liquidHeight				= getDoubleParam(stepID, 3);
			mixPosition					= getDoubleParam(stepID, 4);
			mixVolume					= getDoubleParam(stepID, 5);
			airTransportRetractDist	= getDoubleParam(stepID, 6);		// added 2009-11-23/cjoerg

			#ifdef _DEBUG_STAR_STEPPARAMS
			{
				variable stepName;
				stepName = GetFunctionName();
				MlStar::DEBUG::TraceStepParamVariable(stepName, "startPosition", startPosition);
				// 2005-08-10/cjoerg: The other parameters are traced in function MlStar::CoRe96Head_....
			}
			#endif

			PositionData::initStepSequence(stepID, 1, dispenseSequence);
			dispenseSequence.SetCurrentPosition(startPosition);		// If start is invalid sets current to zero, ends in step error.

			onerror goto StepErrorHandler;
			rc = MlStar::CoRe96Head_Dispense_003(mlstar,
															 dispenseSequence,
															 liquidClass,
															 sequenceCounting,
															 dispenseMode,
															 capacitiveLLD,
															 liquidFollowing,
															 mixCycles,
															 zMoveAfterStep,
															 sideTouch,
															 dispenseVolume,
															 submergeDepth,
															 liquidHeight,
															 mixPosition,
															 mixVolume,
															 airTransportRetractDist);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: Head96Dispense", rc);
			#endif

			MlStar::completeResultDataEx(rc, dispenseSequence.GetUsedPositions());

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: Head96Dispense");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::coRe96Wash(variable stepID) variable[]
		{
			variable rc[];
			variable washCycles(-1);
			variable startWashChamber(-1);
			variable one_LiquidFollowing_Head(-1);
			variable one_WashCycles_Head(-1);
			variable one_RefillAfterWash(-1);
			variable one_WashLiquid(-1);
			variable one_LiquidChange(-1);
			variable two_LiquidFollowing_Head(-1);
			variable two_WashCycles_Head(-1);
			variable two_RefillAfterWash(-1);
			variable two_WashLiquid(-1);
			variable two_LiquidChange(-1);
			variable one_WashVolume_Head(-1.0);
			variable one_SubmergeDepth_Head(-1.0);
			variable two_WashVolume_Head(-1.0);
			variable two_SubmergeDepth_Head(-1.0);

			setCommandState(stepID, CommandState::executeStart);

			washCycles               = getIntegerParam(stepID, 1);
			startWashChamber         = getIntegerParam(stepID, 2);
			one_LiquidFollowing_Head = getIntegerParam(stepID, 3);
			one_WashCycles_Head      = getIntegerParam(stepID, 4);
			one_RefillAfterWash      = getIntegerParam(stepID, 5);
			one_WashLiquid           = getIntegerParam(stepID, 6);
			one_LiquidChange         = getIntegerParam(stepID, 7);
			two_LiquidFollowing_Head = getIntegerParam(stepID, 8);
			two_WashCycles_Head      = getIntegerParam(stepID, 9);
			two_RefillAfterWash      = getIntegerParam(stepID, 10);
			two_WashLiquid           = getIntegerParam(stepID, 11);
			two_LiquidChange         = getIntegerParam(stepID, 12);
			one_WashVolume_Head      = getDoubleParam(stepID, 1);
			one_SubmergeDepth_Head   = getDoubleParam(stepID, 2);
			two_WashVolume_Head      = getDoubleParam(stepID, 3);
			two_SubmergeDepth_Head   = getDoubleParam(stepID, 4);

			onerror goto StepErrorHandler;
			rc = MlStar::CoRe96Head_Wash_002(mlstar,
														washCycles,
														startWashChamber,
														one_LiquidFollowing_Head,
														one_WashCycles_Head,
														one_RefillAfterWash,
														one_WashLiquid,
														one_LiquidChange,
														two_LiquidFollowing_Head,
														two_WashCycles_Head,
														two_RefillAfterWash,
														two_WashLiquid,
														two_LiquidChange,
														one_WashVolume_Head,
														one_SubmergeDepth_Head,
														two_WashVolume_Head,
														two_SubmergeDepth_Head);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: Head96Wash", rc);
			#endif

			MlStar::completeResultData(rc);

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: Head96Wash");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::coRe96EmptyWasher(variable stepID) variable[]
		{
			variable rc[];
			variable refillAfterEmpty(-1);
			variable one_WashLiquid(-1);
			variable one_LiqudChange(-1);
			variable two_WashLiquid(-1);
			variable two_LiqudChange(-1);

			setCommandState(stepID, CommandState::executeStart);

			refillAfterEmpty = getIntegerParam(stepID, 1);
			one_WashLiquid   = getIntegerParam(stepID, 2);
			one_LiqudChange  = getIntegerParam(stepID, 3);
			two_WashLiquid   = getIntegerParam(stepID, 4);
			two_LiqudChange  = getIntegerParam(stepID, 5);

			onerror goto StepErrorHandler;
			rc = MlStar::CoRe96Head_EmptyWasher_002(mlstar,
																 refillAfterEmpty,
																 one_WashLiquid,
																 one_LiqudChange,
																 two_WashLiquid,
																 two_LiqudChange);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: Head96EmptyWasher", rc);
			#endif

			MlStar::completeResultData(rc);

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: Head96EmptyWasher");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::coRe384TipPickUp(variable stepID) variable[]
		{
			variable rc[];
			sequence tipPickUpSequence;
         variable headPattern("");
			variable sequenceCounting(-1);
			variable tipMode(-1);
         variable pickUpFromTipLifter(-1);
         variable headPatternAsVariable(-1);
         variable reducedPatternMode(-1);

			setCommandState(stepID, CommandState::executeStart);

			headPattern           = getStringParam(stepID, 1);
			sequenceCounting      = getIntegerParam(stepID, 1);
			tipMode				    = getIntegerParam(stepID, 2);
			pickUpFromTipLifter   = getIntegerParam(stepID, 3);
			headPatternAsVariable = getIntegerParam(stepID, 4);
			reducedPatternMode 	 = getIntegerParam(stepID, 5);

			PositionData::initStepSequence(stepID, 1, tipPickUpSequence);

			onerror goto StepErrorHandler;
			rc = MlStar::CoRe384Head_TipPickUp_003(mlstar,
															   tipPickUpSequence,
																headPattern,
															   sequenceCounting,
															   tipMode,
                                                pickUpFromTipLifter,
                                                headPatternAsVariable,
                                                reducedPatternMode);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: Head384TipPickUp", rc);
			#endif

			MlStar::completeResultDataEx(rc, tipPickUpSequence.GetUsedPositions());

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: Head384TipPickUp");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::coRe384TipEject(variable stepID) variable[]
		{
			variable rc[];
			sequence tipEjectSequence;
			variable sequenceCounting(-1);
			variable tipEjectSetting(-1);

			setCommandState(stepID, CommandState::executeStart);

			sequenceCounting = getIntegerParam(stepID, 1);
			tipEjectSetting  = getIntegerParam(stepID, 2);

			if ( 0 == tipEjectSetting )		// (off (0), eject on passed positions)
			{
				// Needs the sequence for tip eject
				PositionData::initStepSequence(stepID, 1, tipEjectSequence);
			}

			onerror goto StepErrorHandler;
			rc = MlStar::CoRe384Head_TipEject_001(mlstar,
															  tipEjectSequence,
															  sequenceCounting,
															  tipEjectSetting);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: Head384TipEject", rc);
			#endif

			if ( 0 == tipEjectSetting )
			{
				MlStar::completeResultDataEx(rc, tipEjectSequence.GetUsedPositions());
			}
			else
			{
				MlStar::completeResultData(rc);
			}

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: Head384TipEject");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::coRe384Aspirate(variable stepID) variable[]
		{
			variable rc[];
			sequence aspirateSequence; 
			variable liquidClass("");
			variable sequenceCounting(-1);
			variable aspirateMode(-1);
			variable capacitiveLLD(-1);
			variable liquidFollowing(-1);
			variable mixCycles(-1);
			variable aspirateVolume(-1.0);
			variable submergeDepth(-1.0);
			variable liquidHeight(-1.0);
			variable mixPosition(-1.0);
			variable mixVolume(-1.0);
			variable airTransportRetractDist(-1.0);

			setCommandState(stepID, CommandState::executeStart);

			liquidClass					= getStringParam(stepID, 1);
			sequenceCounting			= getIntegerParam(stepID, 1);
			aspirateMode				= getIntegerParam(stepID, 2);
			capacitiveLLD				= getIntegerParam(stepID, 3);
			liquidFollowing			= getIntegerParam(stepID, 4);
			mixCycles					= getIntegerParam(stepID, 5);
			aspirateVolume				= getDoubleParam(stepID, 1);
			submergeDepth				= getDoubleParam(stepID, 2);
			liquidHeight				= getDoubleParam(stepID, 3);
			mixPosition					= getDoubleParam(stepID, 4);
			mixVolume					= getDoubleParam(stepID, 5);
			airTransportRetractDist	= getDoubleParam(stepID, 6);		// added 2009-11-23/cjoerg

			PositionData::initStepSequence(stepID, 1, aspirateSequence);

			onerror goto StepErrorHandler;
			rc = MlStar::CoRe384Head_Aspirate_002(mlstar,
															  aspirateSequence,
															  liquidClass,
															  sequenceCounting,
															  aspirateMode,
															  capacitiveLLD,
															  liquidFollowing,
															  mixCycles,
															  aspirateVolume,
															  submergeDepth,
															  liquidHeight,
															  mixPosition,
															  mixVolume,
															  airTransportRetractDist);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: Head384Aspirate", rc);
			#endif

			MlStar::completeResultDataEx(rc, aspirateSequence.GetUsedPositions());

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: Head384Aspirate");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::coRe384Dispense(variable stepID) variable[]
		{
			variable rc[];
			sequence dispenseSequence; 
			variable liquidClass("");
			variable sequenceCounting(-1);
			variable dispenseMode(-1);
			variable capacitiveLLD(-1);
			variable liquidFollowing(-1);
			variable mixCycles(-1);
			variable zMoveAfterStep(-1);
			variable sideTouch(-1);
			variable dispenseVolume(-1.0);
			variable submergeDepth(-1.0);
			variable liquidHeight(-1.0);
			variable mixPosition(-1.0);
			variable mixVolume(-1.0);
			variable airTransportRetractDist(-1.0);

			setCommandState(stepID, CommandState::executeStart);

			liquidClass					= getStringParam(stepID, 1);
			sequenceCounting			= getIntegerParam(stepID, 1);
			dispenseMode				= getIntegerParam(stepID, 2);
			capacitiveLLD				= getIntegerParam(stepID, 3);
			liquidFollowing			= getIntegerParam(stepID, 4);
			mixCycles					= getIntegerParam(stepID, 5);
			zMoveAfterStep				= getIntegerParam(stepID, 6);
			sideTouch					= getIntegerParam(stepID, 7);
			dispenseVolume				= getDoubleParam(stepID, 1);
			submergeDepth				= getDoubleParam(stepID, 2);
			liquidHeight				= getDoubleParam(stepID, 3);
			mixPosition					= getDoubleParam(stepID, 4);
			mixVolume					= getDoubleParam(stepID, 5);
			airTransportRetractDist = getDoubleParam(stepID, 6);		// added 2009-11-23/cjoerg

			PositionData::initStepSequence(stepID, 1, dispenseSequence);

			onerror goto StepErrorHandler;
			rc = MlStar::CoRe384Head_Dispense_002(mlstar,
															  dispenseSequence,
															  liquidClass,
															  sequenceCounting,
															  dispenseMode,
															  capacitiveLLD,
															  liquidFollowing,
															  mixCycles,
															  zMoveAfterStep,
															  sideTouch,
															  dispenseVolume,
															  submergeDepth,
															  liquidHeight,
															  mixPosition,
															  mixVolume,
															  airTransportRetractDist);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: Head384Dispense", rc);
			#endif

			MlStar::completeResultDataEx(rc, dispenseSequence.GetUsedPositions());

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: Head384Dispense");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::coRe384Wash(variable stepID) variable[]
		{
			variable rc[];
			variable washCycles(-1);
			variable startWashChamber(-1);
			variable one_LiquidFollowing_Head(-1);
			variable one_WashCycles_Head(-1);
			variable one_RefillAfterWash(-1);
			variable one_WashLiquid(-1);
			variable one_LiquidChange(-1);
			variable two_LiquidFollowing_Head(-1);
			variable two_WashCycles_Head(-1);
			variable two_RefillAfterWash(-1);
			variable two_WashLiquid(-1);
			variable two_LiquidChange(-1);
			variable one_WashVolume_Head(-1.0);
			variable one_SubmergeDepth_Head(-1.0);
			variable two_WashVolume_Head(-1.0);
			variable two_SubmergeDepth_Head(-1.0);

			setCommandState(stepID, CommandState::executeStart);

			washCycles               = getIntegerParam(stepID, 1);
			startWashChamber         = getIntegerParam(stepID, 2);
			one_LiquidFollowing_Head = getIntegerParam(stepID, 3);
			one_WashCycles_Head      = getIntegerParam(stepID, 4);
			one_RefillAfterWash      = getIntegerParam(stepID, 5);
			one_WashLiquid           = getIntegerParam(stepID, 6);
			one_LiquidChange         = getIntegerParam(stepID, 7);
			two_LiquidFollowing_Head = getIntegerParam(stepID, 8);
			two_WashCycles_Head      = getIntegerParam(stepID, 9);
			two_RefillAfterWash      = getIntegerParam(stepID, 10);
			two_WashLiquid           = getIntegerParam(stepID, 11);
			two_LiquidChange         = getIntegerParam(stepID, 12);
			one_WashVolume_Head      = getDoubleParam(stepID, 1);
			one_SubmergeDepth_Head   = getDoubleParam(stepID, 2);
			two_WashVolume_Head      = getDoubleParam(stepID, 3);
			two_SubmergeDepth_Head   = getDoubleParam(stepID, 4);

			onerror goto StepErrorHandler;
			rc = MlStar::CoRe384Head_Wash_001(mlstar,
														 washCycles,
														 startWashChamber,
														 one_LiquidFollowing_Head,
														 one_WashCycles_Head,
														 one_RefillAfterWash,
														 one_WashLiquid,
														 one_LiquidChange,
														 two_LiquidFollowing_Head,
														 two_WashCycles_Head,
														 two_RefillAfterWash,
														 two_WashLiquid,
														 two_LiquidChange,
														 one_WashVolume_Head,
														 one_SubmergeDepth_Head,
														 two_WashVolume_Head,
														 two_SubmergeDepth_Head);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: Head384Wash", rc);
			#endif

			MlStar::completeResultData(rc);

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: Head384Wash");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::coRe384EmptyWasher(variable stepID) variable[]
		{
			variable rc[];
			variable refillAfterEmpty(-1);
			variable one_WashLiquid(-1);
			variable one_LiqudChange(-1);
			variable two_WashLiquid(-1);
			variable two_LiqudChange(-1);

			setCommandState(stepID, CommandState::executeStart);

			refillAfterEmpty = getIntegerParam(stepID, 1);
			one_WashLiquid   = getIntegerParam(stepID, 2);
			one_LiqudChange  = getIntegerParam(stepID, 3);
			two_WashLiquid   = getIntegerParam(stepID, 4);
			two_LiqudChange  = getIntegerParam(stepID, 5);

			onerror goto StepErrorHandler;
			rc = MlStar::CoRe384Head_EmptyWasher_001(mlstar,
																  refillAfterEmpty,
																  one_WashLiquid,
																  one_LiqudChange,
																  two_WashLiquid,
																  two_LiqudChange);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: Head384EmptyWasher", rc);
			#endif

			MlStar::completeResultData(rc);

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: Head384EmptyWasher");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}



		static function MlStar::nanoPrepare(variable stepID) variable[]
		{
			variable rc[];
			variable prepareMode(-1);

			setCommandState(stepID, CommandState::executeStart);

			prepareMode = getIntegerParam(stepID, 1);

			onerror goto StepErrorHandler;
			rc = MlStar::Nano_Prepare_001(mlstar,
													prepareMode);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: NanoFillSystem", rc);
			#endif

			MlStar::completeResultData(rc);

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: NanoFillSystem");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::nanoAspirate(variable stepID) variable[]
		{
			variable rc[];
			sequence aspirateSequence;
			variable volumeArray[];
			variable channelVariable("");
			variable sequenceCounting(-1);
			variable aspirateOilGap(-1);
			variable channelID(-1);
			variable pressureLLD(-1);
			variable liquidFollowing(-1);
			variable aspirationPressure(-1);
			variable submergeDepth(-1.0);
			variable liquidHeight(-1.0);
			variable swapSpeed(-1.0);

			setCommandState(stepID, CommandState::executeStart);

			channelVariable		= getStringParam(stepID, 1);
			sequenceCounting		= getIntegerParam(stepID, 1);
			aspirateOilGap			= getIntegerParam(stepID, 2);
			channelID				= getIntegerParam(stepID, 3);
			pressureLLD				= getIntegerParam(stepID, 4);
			liquidFollowing		= getIntegerParam(stepID, 5);
			aspirationPressure	= getIntegerParam(stepID, 6);
			submergeDepth			= getDoubleParam(stepID, 1);
			liquidHeight			= getDoubleParam(stepID, 2);
			swapSpeed				= getDoubleParam(stepID, 3);

			volumeArray = VolumeData::initChannelVolumesNano(stepID, channelVariable);

			PositionData::initStepSequence(stepID, 1, aspirateSequence);

			onerror goto StepErrorHandler;
			rc = MlStar::Nano_Aspirate_001(mlstar,
													 aspirateSequence,
													 volumeArray,
													 channelVariable,
													 sequenceCounting,
													 aspirateOilGap,
													 channelID,
													 pressureLLD,
													 liquidFollowing,
													 aspirationPressure,
													 submergeDepth,
													 liquidHeight,
													 swapSpeed);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: NanoAspirate", rc);
			#endif

			MlStar::completeResultDataEx(rc, aspirateSequence.GetUsedPositions());

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: NanoAspirate");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::nanoDispense(variable stepID) variable[]
		{
			variable rc[];
			sequence dispenseSequence;
			variable volumeArray[];
			variable channelVariable("");
			variable sequenceCounting(-1);
			variable channelID(-1);
			variable zMoveAfterStep(-1);
			variable dispensationPressure(-1);
         variable volumeCheck(-1);
			variable dispenseHeight(-1.0);

			setCommandState(stepID, CommandState::executeStart);

			channelVariable		= getStringParam(stepID, 1);
			sequenceCounting		= getIntegerParam(stepID, 1);
			channelID				= getIntegerParam(stepID, 2);
			zMoveAfterStep			= getIntegerParam(stepID, 3);
			dispensationPressure	= getIntegerParam(stepID, 4);
			volumeCheck       	= getIntegerParam(stepID, 5);
			dispenseHeight			= getDoubleParam(stepID, 1);

			volumeArray = VolumeData::initChannelVolumesNano(stepID, channelVariable);

			PositionData::initStepSequence(stepID, 1, dispenseSequence);

			onerror goto StepErrorHandler;
			rc = MlStar::Nano_Dispense_002(mlstar,
													 dispenseSequence,
													 volumeArray,
													 channelVariable,
													 sequenceCounting,
													 channelID,
													 zMoveAfterStep,
													 dispensationPressure,
													 dispenseHeight,
                                        volumeCheck);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: NanoDispense", rc);
			#endif

			MlStar::completeResultDataEx(rc, dispenseSequence.GetUsedPositions());

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: NanoDispense");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}

		static function MlStar::nanoDispenseFly(variable stepID) variable[]
		{
			variable rc[];
			sequence dispenseSequence;
			variable volumeArray[];
			variable channelVariable("");
			variable sequenceCounting(-1);
			variable dispenseOnTheFlyMode(-1);
			variable channelID(-1);
			variable dispensationPressure(-1);
			variable dispenseDirection(-1);
			variable dispenseHeight(-1.0);
			variable XspeedDuringDispense(-1.0);
			variable XaccelerationDistance(-1.0);
		
			setCommandState(stepID, CommandState::executeStart);

			channelVariable			= getStringParam(stepID, 1);
			sequenceCounting			= getIntegerParam(stepID, 1);
			dispenseOnTheFlyMode		= getIntegerParam(stepID, 2);
			channelID					= getIntegerParam(stepID, 3);
			dispensationPressure		= getIntegerParam(stepID, 4);
			dispenseDirection			= getIntegerParam(stepID, 5);
			dispenseHeight				= getDoubleParam(stepID, 1);
			XspeedDuringDispense		= getDoubleParam(stepID, 2);
			XaccelerationDistance	= getDoubleParam(stepID, 3);

			volumeArray = VolumeData::initChannelVolumesNano(stepID, channelVariable);

			PositionData::initStepSequence(stepID, 1, dispenseSequence);

			onerror goto StepErrorHandler;
			rc = MlStar::Nano_DispenseFly_001(mlstar,
														 dispenseSequence,
														 volumeArray,
														 channelVariable,
														 sequenceCounting,
														 dispenseOnTheFlyMode,
														 channelID,
														 dispensationPressure,
														 dispenseDirection,
														 dispenseHeight,
														 XspeedDuringDispense,
														 XaccelerationDistance);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: NanoDispenseFly", rc);
			#endif

			MlStar::completeResultDataEx(rc, dispenseSequence.GetUsedPositions());

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: NanoDispenseFly");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::nanoWash(variable stepID) variable[]
		{
			variable rc[];
			variable channelID(-1);
			variable flushTime(-1);
			variable washAtUltrasonicBath(-1);
			variable refillWashLiquid(-1);
			variable washTime(-1);
         variable diagnosticMode(-1);
			variable submergeDepth(-1.0);

			setCommandState(stepID, CommandState::executeStart);

			channelID 				= getIntegerParam(stepID, 1);
			flushTime 				= getIntegerParam(stepID, 2);
			washAtUltrasonicBath	= getIntegerParam(stepID, 3);
			refillWashLiquid 		= getIntegerParam(stepID, 4);
			washTime 				= getIntegerParam(stepID, 5);
			diagnosticMode 		= getIntegerParam(stepID, 6);
			submergeDepth			= getDoubleParam(stepID, 1);

			onerror goto StepErrorHandler;
			rc = MlStar::Nano_Wash_002(mlstar,
												channelID,
												flushTime,
												washAtUltrasonicBath,
												refillWashLiquid,
												washTime,
												submergeDepth,
                                    diagnosticMode);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: NanoWash", rc);
			#endif

			MlStar::completeResultData(rc);

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: NanoWash");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}



		static function MlStar::coReGrip1000ulGetPlate(variable stepID) variable[]
		{
			variable rc[];
			sequence plateSequence; 
			sequence lidSequence;
			sequence toolSequence;
			variable sequenceCounting(-1);
			variable transportMode(-1);
			variable gripForce(-1);
			variable gripperToolChannel(-1);
			variable checkPlate(-1.0);
			variable gripWidth(-1.0);
			variable gripHeight(-1.0);
			variable widthBefore(-1.0);
			variable gripSpeed(-1.0);
			variable Zspeed(-1.0);


			// enumeration of available transport modes
			static const variable tmPlateOnly      (0);
			static const variable tmLidOnly        (1);
			//static const variable tmPlateAndLid  (2);

			setCommandState(stepID, CommandState::executeStart);

			sequenceCounting	 = getIntegerParam(stepID, 1);
			transportMode		 = getIntegerParam(stepID, 2);
			gripForce			 = getIntegerParam(stepID, 3);
			gripperToolChannel = getIntegerParam(stepID, 4);
			checkPlate		    = getIntegerParam(stepID, 5);
         gripWidth			 = getDoubleParam(stepID, 1);
			gripHeight			 = getDoubleParam(stepID, 2);
			widthBefore			 = getDoubleParam(stepID, 3);
			gripSpeed			 = getDoubleParam(stepID, 4);
			Zspeed				 = getDoubleParam(stepID, 5);


			if ( transportMode != tmLidOnly )
			{
				// Needs the plate sequence (GroupID=1)
				PositionData::initStepSequence(stepID, 1, plateSequence);
			}

			if ( transportMode != tmPlateOnly )
			{
				// Needs the lid sequence (GroupID=2)
				PositionData::initStepSequence(stepID, 2, lidSequence);
			}

			// Init the tool sequence (GroupID=2)
			PositionData::initStepSequence(stepID, 3, toolSequence);

			onerror goto StepErrorHandler;
			rc = MlStar::CoReGrip_GetPlate_003(mlstar,
														  plateSequence,
														  lidSequence,
														  toolSequence,
														  sequenceCounting,
														  transportMode,
														  gripForce,
														  gripperToolChannel,
														  gripWidth,
														  gripHeight,
														  widthBefore,
														  gripSpeed,
														  Zspeed,
                                            checkPlate);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: 1000ul Channel CO-RE Grip -> Get Plate", rc);
			#endif

			if ( transportMode != tmLidOnly )
			{
				// Only plate sequence used or plate sequence used as priority sequence.
				MlStar::completeResultDataEx(rc, plateSequence.GetUsedPositions());
			}
			else
			{
				// Only lid sequence touched, get its used positions.
				MlStar::completeResultDataEx(rc, lidSequence.GetUsedPositions());
			}
			
			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: coReGrip1000ulGetPlate");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::coReGrip1000ulPlacePlate(variable stepID) variable[]
		{
			variable rc[];
			sequence plateSequence; 
			sequence lidSequence;
			variable sequenceCounting(-1);
			variable transportMode(-1);
			variable ejectToolWhenFinish(-1);
         variable xAcceleration(-1);
         variable checkPlate(-1);
			variable Zspeed(-1.0);
			variable platePressOnDistance(-1.0);

			// enumeration of available transport modes
			static const variable tmPlateOnly      (0);
			static const variable tmLidOnly        (1);
			//static const variable tmPlateAndLid  (2);

			setCommandState(stepID, CommandState::executeStart);

			sequenceCounting		= getIntegerParam(stepID, 1);
			transportMode			= getIntegerParam(stepID, 2);
			ejectToolWhenFinish	= getIntegerParam(stepID, 3);
			xAcceleration        = getIntegerParam(stepID, 4);
			checkPlate           = getIntegerParam(stepID, 5);
			Zspeed 					= getDoubleParam(stepID, 1);
			platePressOnDistance	= getDoubleParam(stepID, 2);

			if ( transportMode != tmLidOnly )
			{
				// Needs the plate sequence (GroupID=1)
				PositionData::initStepSequence(stepID, 1, plateSequence);
			}

			if ( transportMode != tmPlateOnly )
			{
				// Needs the lid sequence (GroupID=2)
				PositionData::initStepSequence(stepID, 2, lidSequence);
			}

			onerror goto StepErrorHandler;
			rc = MlStar::CoReGrip_PlacePlate_003(mlstar,
															 plateSequence,
															 lidSequence,
															 sequenceCounting,
															 transportMode,
															 ejectToolWhenFinish,
															 Zspeed,
															 platePressOnDistance,
                                              xAcceleration,
                                              checkPlate);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: 1000ul CO-RE Grip -> Place Plate", rc);
			#endif

			if ( transportMode != tmLidOnly )
			{
				// Only plate sequence used or plate sequence used as priority sequence.
				MlStar::completeResultDataEx(rc, plateSequence.GetUsedPositions());
			}
			else
			{
				// Only lid sequence touched, get its used positions.
				MlStar::completeResultDataEx(rc, lidSequence.GetUsedPositions());
			}
			
			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: coReGrip1000ulPlacePlate");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::coReGrip1000ulMovePlate(variable stepID) variable[]
		{
			variable rc[];
			sequence destinationSequence;
         variable xAcceleration(-1);
			variable usedPositions(0);		// Stores the position count for the current labware
													// of the destinationSequence before calling the
													// low level step.
													// The MovePlate step never counts on the sequence
													// and used positions is not set (always 0).
													// In the OEM interface  method context the same count of used
													// positions is returned as the other CO-RE Grip steps does.

			setCommandState(stepID, CommandState::executeStart);

			xAcceleration		= getIntegerParam(stepID, 1);

			// Needs a sequence (GroupID=1)
			PositionData::initStepSequence(stepID, 1, destinationSequence);

			usedPositions = destinationSequence.GetPositionCountForCurrLabware();

			onerror goto StepErrorHandler;
			rc = MlStar::CoReGrip_MovePlate_002(mlstar,
															destinationSequence,
                                             xAcceleration);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: 1000ul Channel CO-RE Grip -> Move Plate", rc);
			#endif

			MlStar::completeResultDataEx(rc, usedPositions);
			
			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: coReGrip1000ulMovePlate");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::coReGrip1000ulReadPlateBarcode(variable stepID) variable[]
		{
			variable rc[];
			variable barcodeReaderPosition(-1);
			variable minimalZpositionDuringRead(-1.0);

			setCommandState(stepID, CommandState::executeStart);

			barcodeReaderPosition = getIntegerParam(stepID, 1);
			minimalZpositionDuringRead = getDoubleParam(stepID, 1);

			onerror goto StepErrorHandler;
			rc = MlStar::CoReGrip_ReadBarcode_002(mlstar,
															  barcodeReaderPosition,
															  minimalZpositionDuringRead);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: 1000ul Channel CO-RE Grip -> Read Plate Barcode", rc);
			#endif

			MlStar::completeResultData(rc);
			
			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: coReGrip1000ulReadPlateBarcode");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}



		static function MlStar::readPort(variable stepID) variable[]
		{
			variable rc[];
			variable portNumber(-1);

			setCommandState(stepID, CommandState::executeStart);

			portNumber	= getIntegerParam(stepID, 1);

			onerror goto StepErrorHandler;
			rc = MlStar::Misc_ReadPort_001(mlstar,
													 portNumber);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: ReadPort", rc);
			#endif

			MlStar::completeResultData(rc);
			
			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: ReadPort");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::writePort(variable stepID) variable[]
		{
			variable rc[];
			variable portNumber(-1);
			variable portSetting(-1);

			setCommandState(stepID, CommandState::executeStart);

			portNumber	= getIntegerParam(stepID, 1);
			portSetting	= getIntegerParam(stepID, 2);

			onerror goto StepErrorHandler;
			rc = MlStar::Misc_WritePort_001(mlstar,
													  portNumber,
													  portSetting);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: WritePort", rc);
			#endif

			MlStar::completeResultData(rc);
			
			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: WritePort");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::_1000ulChMoveToPosition(variable stepID) variable[]
		{
			variable rc[];
			variable mode(-1);
			variable direction(-1);
			variable absolutePosition(-1.0);
			variable relativePosition(-1.0);

			// enumeration of available move modes
			variable mmToAbsoluteDeckPosition    (0);
			//variable mmRelativeToCurrentPosition (1);

			setCommandState(stepID, CommandState::executeStart);

			mode					= getIntegerParam(stepID, 1);
			direction			= getIntegerParam(stepID, 2);

			if ( mmToAbsoluteDeckPosition == mode )
			{
				absolutePosition	= getDoubleParam(stepID, 1);
				relativePosition	= 0;		// unused, set to valid value
			}
			else
			{
				relativePosition	= getDoubleParam(stepID, 2);
				absolutePosition	= 0;		// unused, set to valid value
			}

			onerror goto StepErrorHandler;
			rc = MlStar::Misc_MoveToPosition_001(mlstar,
															 mode,
															 direction,
															 absolutePosition,
															 relativePosition);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: 1000ul Channel MoveToPosition", rc);
			#endif

			MlStar::completeResultData(rc);
			
			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: _1000ulChMoveToPosition");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::moveAutoLoad(variable stepID) variable[]
		{
			variable rc[];
			variable trackNumber(-1);

			setCommandState(stepID, CommandState::executeStart);

			trackNumber	= getIntegerParam(stepID, 1);

			onerror goto StepErrorHandler;
			rc = MlStar::Misc_MoveAutoLoad_001(mlstar,
														  trackNumber);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: MoveAutoLoad", rc);
			#endif

			MlStar::completeResultData(rc);
			
			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: MoveAutoLoad");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}

		
		// 2005-07-29 / cjoerg: added new command
		static function MlStar::tipTrackingSpeed(variable stepID) variable[]
		{
			variable rc[];
			variable pipettingDevice(-1);
			variable speedFactor(-1);

			setCommandState(stepID, CommandState::executeStart);

			pipettingDevice	= getIntegerParam(stepID, 1);
			speedFactor			= getDoubleParam(stepID, 1);

			onerror goto StepErrorHandler;
			rc = MlStar::Misc_TipTrackingSpeed_001(mlstar,
																pipettingDevice,
																speedFactor);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: TipTrackingSpeed", rc);
			#endif

			MlStar::completeResultData(rc);
			
			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: TipTrackingSpeed");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		// jjenal 2003-08-18
		static function MlStar::execFirmwareCmd(variable stepID) variable[]
		{
			variable rc[];
			variable commandString("");
			variable parameterString("");

			setCommandState(stepID, CommandState::executeStart);

			commandString   = getStringParam(stepID, 1);
			parameterString = getStringParam(stepID, 2);

			onerror goto StepErrorHandler;
			rc = MlStar::Misc_FirmwareCommand_001(mlstar,
															  commandString,
															  parameterString);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: FirmwareCommand", rc);
			#endif


			// The instrument step 'FirmwareCommand' doesn't format its block data
			// (e.g. no 'ErrFlag' in front etc.). Therefore it must still be done.
			MlStar::formatFirmwareCmdResult(rc);

			MlStar::completeResultData(rc);

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: FirmwareCommand");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}

		}


		static function MlStar::formatFirmwareCmdResult(variable& rc[]) void
		{
			variable errorFlag(MlStar::StepReturnEx::StepErrorCode::OK);
			variable firmwareCommand("");
			variable firmwareResponse("");


			// Get the firmware response (second block data of the step result)
			firmwareResponse = rc.GetAt(MlStar::StepReturnEx::StepResultNo::firstBlockData + 1);

			// Set the error flag to:
			// - OK					: if firmware response starts NOT with "er..." (e.g. "rq...")
			// - OK					: if firmware response starts with "er00..." (e.g. "er00/00...)
			// - OK_Abort_Cancel	: if firmware response starts with "erXX...", where "XX" is not equal to "00" (e.g. "er99..."
			errorFlag = MlStar::StepReturnEx::StepErrorCode::OK;
			if (    (0 == StrFind(firmwareResponse, "er"))
			     && (2 != StrFind(firmwareResponse, "00")) )
			{
				errorFlag = MlStar::StepReturnEx::StepErrorCode::OK_Abort_Cancel;
			}

			// Format the first block data (the firmware command):
			// block data: ErrFlag       = <evaluated error flag>
			// block data: Num           = -1 (not used)
			// block data: MainErr       = -1 (not used)
			// block data: SlaveErr      = -1 (not used)
			// block data: RecoveryBtnId = -1 (not used)
			// block data: StepData      = Firmware command (e.g. CI)
			// block data: LabwareName   = <empty string> (not used)
			// block data: Labwarepos    = <empty string> (not used)
			// e.g. 0[-1,-1,-1,-1,CI,,
			firmwareCommand = StrIStr(errorFlag);
			firmwareCommand = firmwareCommand + "[-1,-1,-1,-1,";
			firmwareCommand = firmwareCommand + rc.GetAt(MlStar::StepReturnEx::StepResultNo::firstBlockData);
			firmwareCommand = firmwareCommand + ",,";

			#ifdef _DEBUG_AL
			FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
							" firmwareCommand = ", firmwareCommand);
			FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, 
							"; firmwareResponse = ", firmwareResponse);
			#endif

			rc.SetAt(MlStar::StepReturnEx::StepResultNo::firstBlockData, firmwareCommand);
	
	   }


		static function MlStar::_5mlChTipPickUp(variable stepID) variable[]
		{
			variable rc[];
			sequence tipSequence; 
			variable channelVariable("");
			variable sequenceCounting(-1);
			variable channelUse(-1);

			setCommandState(stepID, CommandState::executeStart);

			channelVariable	= getStringParam(stepID, 1);
			sequenceCounting	= getIntegerParam(stepID, 1);
			channelUse			= getIntegerParam(stepID, 2);

			PositionData::initStepSequence(stepID, 1, tipSequence);

			onerror goto StepErrorHandler;
			rc = MlStar::Channel_5ml_TipPickUp_001(mlstar,
																tipSequence, 
																channelVariable,
																sequenceCounting,
																channelUse);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: 5ml Channel TipPickUp", rc);
			#endif

			MlStar::completeResultDataEx(rc, tipSequence.GetUsedPositions());

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: _5mlChTipPickUp");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::_5mlChTipEject(variable stepID) variable[]
		{
			variable rc[];
			sequence wasteSequence; 
			variable channelVariable("");
			variable sequenceCounting(-1);
			variable channelUse(-1);
			variable useDefaultWaste(-1);

			setCommandState(stepID, CommandState::executeStart);

			channelVariable	= getStringParam(stepID, 1);
			sequenceCounting	= getIntegerParam(stepID, 1);
			channelUse			= getIntegerParam(stepID, 2);
			useDefaultWaste	= getIntegerParam(stepID, 3);

			if ( 0 == useDefaultWaste )
			{
				// Needs the waste-sequence for tip eject
				PositionData::initStepSequence(stepID, 1, wasteSequence);
			}

			onerror goto StepErrorHandler;
			rc = MlStar::Channel_5ml_TipOrNeedleEject_001(mlstar,
																		 wasteSequence,
																		 channelVariable,
																		 sequenceCounting,
																		 channelUse,
																		 useDefaultWaste);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: 5ml Channel TipEject", rc);
			#endif
			
			if ( 0 == useDefaultWaste )
			{
				MlStar::completeResultDataEx(rc, wasteSequence.GetUsedPositions());
			}
			else
			{
				MlStar::completeResultData(rc);
			}

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: _5mlChTipEject");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::_5mlChAspirate(variable stepID) variable[]
		{
			variable rc[];
			sequence aspirateSequence; 
			variable volumeArray[];
			variable channelVariable("");
			variable liquidClass("");
			variable sequenceCounting(-1);
			variable channelUse(-1);
			variable aspirateMode(-1);
			variable capacitiveLLD(-1);
			variable pressureLLD(-1);
			variable liquidFollowing(-1);
			variable mixCycles(-1);
			variable touchOff(-1);
			variable submergeDepth(-1.0);
			variable liquidHeight(-1.0);
			variable maxLLdDifference(-1.0);
			variable mixPosition(-1.0);
			variable mixVolume(-1.0);
			variable airTransportRetractDist(-1.0);
			variable aspPosAboveTouch(-1.0);

			setCommandState(stepID, CommandState::executeStart);

			channelVariable			= getStringParam(stepID, 1);
			liquidClass					= getStringParam(stepID, 2);
			sequenceCounting			= getIntegerParam(stepID, 1);
			channelUse					= getIntegerParam(stepID, 2);
			aspirateMode				= getIntegerParam(stepID, 3);
			capacitiveLLD				= getIntegerParam(stepID, 4);
			pressureLLD					= getIntegerParam(stepID, 5);
			liquidFollowing			= getIntegerParam(stepID, 6);
			mixCycles					= getIntegerParam(stepID, 7);
			touchOff						= getIntegerParam(stepID, 8);		// added 2009-11-23/cjoerg
			submergeDepth				= getDoubleParam(stepID, 1);
			liquidHeight				= getDoubleParam(stepID, 2);
			maxLLdDifference			= getDoubleParam(stepID, 3);
			mixPosition					= getDoubleParam(stepID, 4);
			mixVolume					= getDoubleParam(stepID, 5);
			airTransportRetractDist = getDoubleParam(stepID, 6);		// added 2009-11-23/cjoerg
			aspPosAboveTouch			= getDoubleParam(stepID, 7);		// added 2009-11-23/cjoerg

			volumeArray = VolumeData::initChannelVolumes(stepID, channelVariable);

			PositionData::initStepSequence(stepID, 1, aspirateSequence);

			onerror goto StepErrorHandler;
			rc = MlStar::Channel_5ml_Aspirate_002(mlstar,
															  aspirateSequence,
															  volumeArray,
															  channelVariable,
															  liquidClass,
															  sequenceCounting,
															  channelUse,
															  aspirateMode,
															  capacitiveLLD,
															  pressureLLD,
															  liquidFollowing,
															  mixCycles,
															  touchOff,
															  submergeDepth,
															  liquidHeight,
															  maxLLdDifference,
															  mixPosition,
															  mixVolume,
															  airTransportRetractDist,
															  aspPosAboveTouch);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: 5ml Channel Aspirate", rc);
			#endif

			MlStar::completeResultDataEx(rc, aspirateSequence.GetUsedPositions());

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: _5mlChAspirate");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::_5mlChDispense(variable stepID) variable[]
		{
			variable rc[];
			sequence dispenseSequence; 
			variable volumeArray[];
			variable channelVariable("");
			variable liquidClass("");
			variable sequenceCounting(-1);
			variable channelUse(-1);
			variable dispenseMode(-1);
			variable capacitiveLLD(-1);
			variable liquidFollowing(-1);
			variable mixCycles(-1);
			variable zMoveAfterStep(-1);
			variable touchOff(-1);
			variable sideTouch(-1);
			variable submergeDepth(-1.0);
			variable liquidHeight(-1.0);
			variable mixPosition(-1.0);
			variable mixVolume(-1.0);
			variable dispPositionAboveTouch(-1.0);
			variable airTransportRetractDist(-1.0);

			setCommandState(stepID, CommandState::executeStart);

			channelVariable			= getStringParam(stepID, 1);
			liquidClass					= getStringParam(stepID, 2);
			sequenceCounting			= getIntegerParam(stepID, 1);
			channelUse					= getIntegerParam(stepID, 2);
			dispenseMode				= getIntegerParam(stepID, 3);
			capacitiveLLD				= getIntegerParam(stepID, 4);
			liquidFollowing			= getIntegerParam(stepID, 5);
			mixCycles					= getIntegerParam(stepID, 6);
			zMoveAfterStep				= getIntegerParam(stepID, 7);
			touchOff						= getIntegerParam(stepID, 8);		// added 2005-07-28 / cjoerg
			sideTouch					= getIntegerParam(stepID, 9);		// added 2006-10-23 / cjoerg
			submergeDepth				= getDoubleParam(stepID, 1);
			liquidHeight				= getDoubleParam(stepID, 2);
			mixPosition					= getDoubleParam(stepID, 3);
			mixVolume					= getDoubleParam(stepID, 4);
			dispPositionAboveTouch	= getDoubleParam(stepID, 5);		// added 2005-07-28 / cjoerg
			airTransportRetractDist	= getDoubleParam(stepID, 6);		// added 2009-11-23/cjoerg

			volumeArray = VolumeData::initChannelVolumes(stepID, channelVariable);

			PositionData::initStepSequence(stepID, 1, dispenseSequence);

			onerror goto StepErrorHandler;
			rc = MlStar::Channel_5ml_Dispense_002(mlstar,
															  dispenseSequence,
															  volumeArray,
															  channelVariable,
															  liquidClass,
															  sequenceCounting,
															  channelUse,
															  dispenseMode,
															  capacitiveLLD,
															  liquidFollowing,
															  mixCycles,
															  zMoveAfterStep,
															  touchOff,
															  sideTouch,
															  submergeDepth,
															  liquidHeight,
															  mixPosition,
															  mixVolume,
															  dispPositionAboveTouch,
															  airTransportRetractDist);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: 5ml Channel Dispense", rc);
			#endif

			MlStar::completeResultDataEx(rc, dispenseSequence.GetUsedPositions());

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: _5mlChDispense");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::_5mlChDispenseFly(variable stepID) variable[]
		{
			variable rc[];
			sequence dispenseSequence;
			variable volumeArray[];
			variable channelVariable("");
			variable liquidClass("");
			variable excludedLabwarePositions("");
			variable sequenceCounting(-1);
			variable dispenseOnTheFlyMode(-1);
			variable dispenseDirection(-1);
			variable labwareSurfaceDistance(-1.0);
			variable XspeedDuringDispense(-1.0);
			variable XstartOffset(-1.0);
			variable XaccelerationDistance(-1.0);

			setCommandState(stepID, CommandState::executeStart);

			channelVariable				= getStringParam(stepID, 1);
			liquidClass						= getStringParam(stepID, 2);
			excludedLabwarePositions	= getStringParam(stepID, 3);
			sequenceCounting				= getIntegerParam(stepID, 1);
			dispenseOnTheFlyMode			= getIntegerParam(stepID, 2);
			dispenseDirection				= getIntegerParam(stepID, 3);
			labwareSurfaceDistance		= getDoubleParam(stepID, 1);
			XspeedDuringDispense			= getDoubleParam(stepID, 2);
			XstartOffset					= getDoubleParam(stepID, 3);
			XaccelerationDistance		= getDoubleParam(stepID, 4);

			volumeArray = VolumeData::initChannelVolumes(stepID, channelVariable);

			PositionData::initStepSequence(stepID, 1, dispenseSequence);

			onerror goto StepErrorHandler;
			rc = MlStar::Channel_5ml_DispenseFly_001(mlstar,
																  dispenseSequence,
																  volumeArray,
																  channelVariable,
																  liquidClass,
																  excludedLabwarePositions,
																  sequenceCounting,
																  dispenseOnTheFlyMode,
																  dispenseDirection,
																  labwareSurfaceDistance,
																  XspeedDuringDispense,
																  XstartOffset,
																  XaccelerationDistance);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: 5ml Channel Dispense on the Fly", rc);
			#endif

			MlStar::completeResultDataEx(rc, dispenseSequence.GetUsedPositions());

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: _5mlChDispenseFly");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::_5mlChGetLastLiquidLevel(variable stepID) variable[]
		{
			variable rc[];

			setCommandState(stepID, CommandState::executeStart);

			onerror goto StepErrorHandler;
			rc = MlStar::Channel_5ml_GetLastLiquidLevel_001(mlstar);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: 5ml Channel GetLastLiquidLevel", rc);
			#endif
			
			MlStar::completeResultData(rc);

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: _5mlChGetLastLiquidLevel");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::_5mlChMoveToPosition(variable stepID) variable[]
		{
			variable rc[];
			variable mode(-1);
			variable direction(-1);
			variable absolutePosition(-1.0);
			variable relativePosition(-1.0);

			// enumeration of available move modes
			variable mmToAbsoluteDeckPosition    (0);
			//variable mmRelativeToCurrentPosition (1);

			setCommandState(stepID, CommandState::executeStart);

			mode					= getIntegerParam(stepID, 1);
			direction			= getIntegerParam(stepID, 2);

			if ( mmToAbsoluteDeckPosition == mode )
			{
				absolutePosition	= getDoubleParam(stepID, 1);
				relativePosition	= 0;		// unused, set to valid value
			}
			else
			{
				relativePosition	= getDoubleParam(stepID, 2);
				absolutePosition	= 0;		// unused, set to valid value
			}

			onerror goto StepErrorHandler;
			rc = MlStar::Misc_MoveToPosition_5ml_001(mlstar,
																  mode,
																  direction,
																  absolutePosition,
																  relativePosition);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: 5ml Channel MoveToPosition", rc);
			#endif

			MlStar::completeResultData(rc);
			
			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: _5mlChMoveToPosition");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::coReGrip5mlGetPlate(variable stepID) variable[]
		{
			variable rc[];
			sequence plateSequence; 
			sequence lidSequence;
			sequence toolSequence;
			variable sequenceCounting(-1);
			variable transportMode(-1);
			variable gripForce(-1);
			variable gripperToolChannel(-1);
			variable checkPlate(-1.0);
			variable gripWidth(-1.0);
			variable gripHeight(-1.0);
			variable widthBefore(-1.0);
			variable gripSpeed(-1.0);
			variable Zspeed(-1.0);


			// enumeration of available transport modes
			static const variable tmPlateOnly      (0);
			static const variable tmLidOnly        (1);
			//static const variable tmPlateAndLid  (2);

			setCommandState(stepID, CommandState::executeStart);

			sequenceCounting	 = getIntegerParam(stepID, 1);
			transportMode		 = getIntegerParam(stepID, 2);
			gripForce			 = getIntegerParam(stepID, 3);
			gripperToolChannel = getIntegerParam(stepID, 4);
			checkPlate		    = getIntegerParam(stepID, 5);
         gripWidth			 = getDoubleParam(stepID, 1);
			gripHeight			 = getDoubleParam(stepID, 2);
			widthBefore			 = getDoubleParam(stepID, 3);
			gripSpeed			 = getDoubleParam(stepID, 4);
			Zspeed				 = getDoubleParam(stepID, 5);


			if ( transportMode != tmLidOnly )
			{
				// Needs the plate sequence (GroupID=1)
				PositionData::initStepSequence(stepID, 1, plateSequence);
			}

			if ( transportMode != tmPlateOnly )
			{
				// Needs the lid sequence (GroupID=2)
				PositionData::initStepSequence(stepID, 2, lidSequence);
			}

			// Init the tool sequence (GroupID=2)
			PositionData::initStepSequence(stepID, 3, toolSequence);

			onerror goto StepErrorHandler;
			rc = MlStar::CoReGrip_5ml_GetPlate_001(mlstar,
																plateSequence,
																lidSequence,
														 		toolSequence,
																sequenceCounting,
																transportMode,
																gripForce,
																gripperToolChannel,
																gripWidth,
																gripHeight,
																widthBefore,
																gripSpeed,
																Zspeed,
                                          		checkPlate);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: 5ml Channel CO-RE Grip -> Get Plate", rc);
			#endif

			if ( transportMode != tmLidOnly )
			{
				// Only plate sequence used or plate sequence used as priority sequence.
				MlStar::completeResultDataEx(rc, plateSequence.GetUsedPositions());
			}
			else
			{
				// Only lid sequence touched, get its used positions.
				MlStar::completeResultDataEx(rc, lidSequence.GetUsedPositions());
			}
			
			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: coReGrip5mlGetPlate");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::coReGrip5mlPlacePlate(variable stepID) variable[]
		{
			variable rc[];
			sequence plateSequence; 
			sequence lidSequence;
			variable sequenceCounting(-1);
			variable transportMode(-1);
			variable ejectToolWhenFinish(-1);
         variable xAcceleration(-1);
         variable checkPlate(-1);
			variable Zspeed(-1.0);
			variable platePressOnDistance(-1.0);

			// enumeration of available transport modes
			static const variable tmPlateOnly      (0);
			static const variable tmLidOnly        (1);
			//static const variable tmPlateAndLid  (2);

			setCommandState(stepID, CommandState::executeStart);

			sequenceCounting		= getIntegerParam(stepID, 1);
			transportMode			= getIntegerParam(stepID, 2);
			ejectToolWhenFinish	= getIntegerParam(stepID, 3);
			xAcceleration        = getIntegerParam(stepID, 4);
			checkPlate           = getIntegerParam(stepID, 5);
			Zspeed 					= getDoubleParam(stepID, 1);
			platePressOnDistance	= getDoubleParam(stepID, 2);

			if ( transportMode != tmLidOnly )
			{
				// Needs the plate sequence (GroupID=1)
				PositionData::initStepSequence(stepID, 1, plateSequence);
			}

			if ( transportMode != tmPlateOnly )
			{
				// Needs the lid sequence (GroupID=2)
				PositionData::initStepSequence(stepID, 2, lidSequence);
			}

			onerror goto StepErrorHandler;
			rc = MlStar::CoReGrip_5ml_PlacePlate_001(mlstar,
																  plateSequence,
																  lidSequence,
																  sequenceCounting,
																  transportMode,
																  ejectToolWhenFinish,
																  Zspeed,
																  platePressOnDistance,
																  xAcceleration,
																  checkPlate);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: 5ml CO-RE Grip -> Place Plate", rc);
			#endif

			if ( transportMode != tmLidOnly )
			{
				// Only plate sequence used or plate sequence used as priority sequence.
				MlStar::completeResultDataEx(rc, plateSequence.GetUsedPositions());
			}
			else
			{
				// Only lid sequence touched, get its used positions.
				MlStar::completeResultDataEx(rc, lidSequence.GetUsedPositions());
			}
			
			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: coReGrip5mlPlacePlate");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::coReGrip5mlMovePlate(variable stepID) variable[]
		{
			variable rc[];
			sequence destinationSequence;
         variable xAcceleration(-1);
			variable usedPositions(0);		// Stores the position count for the current labware
													// of the destinationSequence before calling the
													// low level step.
													// The MovePlate step never counts on the sequence
													// and used positions is not set (always 0).
													// In the OEM interface  method context the same count of used
													// positions is returned as the other CO-RE Grip steps does.

			setCommandState(stepID, CommandState::executeStart);

			xAcceleration		= getIntegerParam(stepID, 1);

			// Needs a sequence (GroupID=1)
			PositionData::initStepSequence(stepID, 1, destinationSequence);

			usedPositions = destinationSequence.GetPositionCountForCurrLabware();

			onerror goto StepErrorHandler;
			rc = MlStar::CoReGrip_5ml_MovePlate_001(mlstar,
																 destinationSequence,
																 xAcceleration);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: 5ml Channel CO-RE Grip -> Move Plate", rc);
			#endif

			MlStar::completeResultDataEx(rc, usedPositions);
			
			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: coReGrip5mlMovePlate");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::coReGrip5mlReadPlateBarcode(variable stepID) variable[]
		{
			variable rc[];
			variable barcodeReaderPosition(-1);
			variable minimalZpositionDuringRead(-1.0);

			setCommandState(stepID, CommandState::executeStart);

			barcodeReaderPosition = getIntegerParam(stepID, 1);
			minimalZpositionDuringRead = getDoubleParam(stepID, 1);

			onerror goto StepErrorHandler;
			rc = MlStar::CoReGrip_5ml_ReadBarcode_001(mlstar,
																	barcodeReaderPosition,
																	minimalZpositionDuringRead);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: 5ml Channel CO-RE Grip -> Read Plate Barcode", rc);
			#endif

			MlStar::completeResultData(rc);
			
			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: coReGrip5mlReadPlateBarcode");
				#endif
			
				// Bind error data, raise a error of fatal error in error data
				MlStar::StepReturnEx::bindErrorData(rc);
				
				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::cameraChannelMove(variable stepID) variable[]
		{
			variable rc[];
			sequence moveToSequence;
			variable moveToLabwareId("");
			variable sequenceCounting(-1);
			variable identifyLabwareBy(-1);
			variable ZoffsetBase(-1);
			variable ZmoveDuringStep(-1);
			variable Xoffset(-1.0);
			variable Yoffset(-1.0);
			variable Zoffset(-1.0);

			// enumeration of available identify labware by modes
			static const variable ilbSequence   (0);
			//static const variable ilbLabwareId  (1);

			setCommandState(stepID, CommandState::executeStart);
			
			sequenceCounting	= getIntegerParam(stepID, 1);
			identifyLabwareBy	= getIntegerParam(stepID, 2);
			ZoffsetBase			= getIntegerParam(stepID, 3);
			ZmoveDuringStep	= getIntegerParam(stepID, 4);
			Xoffset				= getDoubleParam(stepID, 1);
			Yoffset				= getDoubleParam(stepID, 2);
			Zoffset				= getDoubleParam(stepID, 3);

			if ( identifyLabwareBy != ilbSequence )
			{
				moveToLabwareId = getStringParam(stepID, 1);
			}
			else
			{
				moveToLabwareId = "";
				PositionData::initStepSequence(stepID, 1, moveToSequence);
			}

			onerror goto StepErrorHandler;
			rc = MlStar::Prep_CameraChannelMove_001(	mlstar,
																	moveToSequence,
																	moveToLabwareId,
																	sequenceCounting,
																	identifyLabwareBy,
																	ZoffsetBase,
																	ZmoveDuringStep,
																	Xoffset,
																	Yoffset,
																	Zoffset);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: Camera Channel Move", rc);
			#endif

			if ( identifyLabwareBy != ilbSequence )
			{
				MlStar::completeResultDataEx(rc, 0);
			}
			else
			{
				MlStar::completeResultDataEx(rc, moveToSequence.GetUsedPositions());
			}

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: CameraChannelMove");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::sTubeCap(variable stepID) variable[]
		{
			variable rc[];
			sequence tubeSequence;
			variable channelVariable("");
			variable sequenceCounting(-1);
			variable channelUse(-1);

			setCommandState(stepID, CommandState::executeStart);

			channelVariable	= getStringParam(stepID, 1);
			sequenceCounting	= getIntegerParam(stepID, 1);
			channelUse			= getIntegerParam(stepID, 2);

			PositionData::initStepSequence(stepID, 1, tubeSequence);

			onerror goto StepErrorHandler;
			rc = MlStar::Prep_STubeCap_001(	mlstar,
														tubeSequence, 
														channelVariable,
														sequenceCounting,
														channelUse);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: S-Tube Cap", rc);
			#endif

			MlStar::completeResultDataEx(rc, tubeSequence.GetUsedPositions());

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: sTubeCap");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::sTubeDecap(variable stepID) variable[]
		{
			variable rc[];
			sequence tubeSequence;
			variable channelVariable("");
			variable sequenceCounting(-1);
			variable channelUse(-1);

			setCommandState(stepID, CommandState::executeStart);

			channelVariable	= getStringParam(stepID, 1);
			sequenceCounting	= getIntegerParam(stepID, 1);
			channelUse			= getIntegerParam(stepID, 2);

			PositionData::initStepSequence(stepID, 1, tubeSequence);

			onerror goto StepErrorHandler;
			rc = MlStar::Prep_STubeDecap_001(mlstar,
														tubeSequence, 
														channelVariable,
														sequenceCounting,
														channelUse);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: S-Tube Decap", rc);
			#endif

			MlStar::completeResultDataEx(rc, tubeSequence.GetUsedPositions());

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: sTubeDecap");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::tubeGripGet(variable stepID) variable[]
		{
			variable rc[];
			sequence tubeSequence;
			variable sequenceCounting(-1);
			variable gripHeight(-1.0);
			variable openingWithBefore(-1.0);

			setCommandState(stepID, CommandState::executeStart);

			sequenceCounting	= getIntegerParam(stepID, 1);
			gripHeight			= getDoubleParam(stepID, 1);
			openingWithBefore	= getDoubleParam(stepID, 2);


			PositionData::initStepSequence(stepID, 1, tubeSequence);

			onerror goto StepErrorHandler;
			rc = MlStar::TubeGrip_Get_001(mlstar,
														tubeSequence, 
														sequenceCounting,
														gripHeight,
														openingWithBefore);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: Tube Grip Get", rc);
			#endif

			MlStar::completeResultDataEx(rc, tubeSequence.GetUsedPositions());

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: tubeGripGet");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::tubeGripPlace(variable stepID) variable[]
		{
			variable rc[];
			sequence tubeSequence;
			variable sequenceCounting(-1);
			variable relativeOpenWith(-1.0);

			setCommandState(stepID, CommandState::executeStart);

			sequenceCounting	= getIntegerParam(stepID, 1);
			relativeOpenWith	= getDoubleParam(stepID, 1);

			PositionData::initStepSequence(stepID, 1, tubeSequence);

			onerror goto StepErrorHandler;
			rc = MlStar::TubeGrip_Place_001(	mlstar,
														tubeSequence, 
														sequenceCounting,
														relativeOpenWith);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: Tube Grip Place", rc);
			#endif

			MlStar::completeResultDataEx(rc, tubeSequence.GetUsedPositions());

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: tubeGripPlace");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::tubeGripMove(variable stepID) variable[]
		{
			variable rc[];
			sequence tubeSequence;

			setCommandState(stepID, CommandState::executeStart);

			PositionData::initStepSequence(stepID, 1, tubeSequence);

			onerror goto StepErrorHandler;
			rc = MlStar::TubeGrip_Move_001(	mlstar,
														tubeSequence);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: Tube Grip Move", rc);
			#endif

			MlStar::completeResultDataEx(rc, tubeSequence.GetUsedPositions());

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: tubeGripMove");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::tubeGripReadBarcode(variable stepID) variable[]
		{
			variable rc[];
			variable readerPosition;

			setCommandState(stepID, CommandState::executeStart);

			readerPosition	= getIntegerParam(stepID, 1);

			onerror goto StepErrorHandler;
			rc = MlStar::TubeGrip_ReadBarcode_001(	mlstar,
																readerPosition);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: Tube Grip Read Barcode", rc);
			#endif

			MlStar::completeResultData(rc);

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: tubeGripReadBarcode");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::waitForTADM(variable stepID) variable[]
		{
			variable rc[];
			variable headType;

			setCommandState(stepID, CommandState::executeStart);

			headType	= getIntegerParam(stepID, 1);

			onerror goto StepErrorHandler;
			rc = MlStar::Misc_WaitForTADM_001(	mlstar,
															headType);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: Wait For TADM Upload", rc);
			#endif

			MlStar::completeResultData(rc);

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: waitForTADM");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::getChannelExcludeState(variable stepID) variable[]
		{
			variable rc[];
			variable headType;

			setCommandState(stepID, CommandState::executeStart);

			headType	= getIntegerParam(stepID, 1);

			onerror goto StepErrorHandler;
			rc = MlStar::Misc_GetChannelExcludeState_001(mlstar,
																		headType);
			onerror goto 0;

			#ifdef _DEBUG_AL
			dumpArray("Instrument result: Get Channel Exclude State", rc);
			#endif

			MlStar::completeResultData(rc);

			setCommandState(stepID, CommandState::executeComplete);

			return( rc );


			StepErrorHandler:
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"StepErrorHandler: getChannelExcludeState");
				#endif

				// Bind error data
				MlStar::StepReturnEx::bindErrorData(rc);

				err.Clear();	// Error is handled. Clear it.
				resume next;
			}
		}


		static function MlStar::completeResultData(variable& instrumentResult[]) void
		{
			MlStar::completeResultDataEx(instrumentResult, -1);	// used positions entry not
																					// used from this command.
		}


		static function MlStar::completeResultDataEx(variable& instrumentResult[],
																	variable usedPositions) void
		{
			// Add the 'used positions' to the first position of the instrumentResult.
			instrumentResult.InsertElementAt(MlStar::ResultDataNo::usedPositions, IStr(usedPositions));
		}



		// ----------------------------------------------------------------------------------------------------
		// Cmd::MlStar::StepReturn: Implementation of additional functions
		// ----------------------------------------------------------------------------------------------------

		static function MlStar::StepReturnEx::bindErrorData(variable& rc[]) void
		{
			variable data[];
			variable stepErrorCode(-1);

			// Initialize the out parameter first with an empty array
			rc = data;

			data = err.GetData();

			if ( data.GetSize() >= MlStar::StepReturnEx::StepResultNo::requiredResultCount )
			{
				// Expected instrument result count present
				rc = data;
				stepErrorCode = MlStar::StepReturnEx::checkErrorData(rc);
			}
			else
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"Expected result count not present in instrument result.");
				#endif

				Error::RaiseLast();
			}

			// If the step ends fatal set fatal error, bind the error description and raise an error
			if ( MlStar::StepReturnEx::StepErrorCode::fatal == stepErrorCode )
			{
				// Fatal error detected in the block data.
				Error::raiseRuntimeErrorEx(IDE::mlStarCommandFatal, err.GetDescription(), GetFileName(), GetFunctionName(), GetLineNumber());
			}
		}


		static function MlStar::StepReturnEx::checkErrorData(variable& rc[]) variable
		{
			variable stepErrorCode(-1);

			// We are recovering from an error and if none of the step return strings (block data) has 
			// an error set it must be a software programming error.

			stepErrorCode = MlStar::StepReturnEx::getStepErrorCode(rc);

			if ( MlStar::StepReturnEx::StepErrorCode::OK == stepErrorCode )
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"Instrument step failed but no error code found in instrument result!");
				#endif
				// None of the step return strings has an error set, that must be a software programming
				// error. Re-throw error.
				Error::RaiseLast();
			}

			return( stepErrorCode );
		}


		static function MlStar::StepReturnEx::getStepErrorCode(variable& rc[]) variable
		{
			variable stepErrorCode(-1);

			// The first block data must contain the error code for all commands
			stepErrorCode = MlStar::StepReturn::GetErrorCode(rc.GetAt(MlStar::InstrResultValue::firstBlockData));

			// Some commands has more than one block data in the resultData that contains an
			// error code. Get it an use the highest number as stepErrorCode.
			if ( rc.GetAt(MlStar::InstrResultValue::stepName) == "LoadCarrier")
			{
				variable errCode(-1);
				errCode = MlStar::StepReturn::GetErrorCode(rc.GetAt(MlStar::InstrResultValue::firstBlockData + 1));

				if ( stepErrorCode < errCode )
				{
					// A higher number is set in the second block data. Use this as step error code.
					stepErrorCode = errCode;
				}
			}

			// Validate the error code that it's one of the well known.
			if (		( MlStar::StepReturnEx::StepErrorCode::OK              != stepErrorCode )
					&& ( MlStar::StepReturnEx::StepErrorCode::OK_Abort_Cancel != stepErrorCode )
					&& ( MlStar::StepReturnEx::StepErrorCode::fatal           != stepErrorCode ) )
			{
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"Unknown error code found in the block data ("+IStr(stepErrorCode)+").");
				#endif

				// Unknown error code found in the block data
				Error::raiseRuntimeError(IDE::unexpectedResultData, GetFileName(), GetFunctionName(), GetLineNumber());
			}

			return( stepErrorCode );
		}

		

		// =================================================================================================
		// Cmd::General: Implementation
		// =================================================================================================

		static function General::runCommand(variable stepID) variable
		{
			variable rc[];
			variable currentCommandID(-1);
			variable commandResult(-1);

			onerror goto GeneralCommandError;

			// Get the commandID to the given stepID
			currentCommandID = getCommandID(stepID);

			// Evaluate the command to execute

			// 2005-08-12/cjoerg: removed, mode not longer supported
			//#ifdef ALIM_COMPATIBLE_MODE
			//// The command 'Wait' is only available if ALIM_COMPATIBLE_MODE is set. 
			//if (General::ID::methodWait == currentCommandID)
			//{
			//	setCommandState(stepID, CommandState::executeStart);
			//	performWaiting();
			//	setCommandState(stepID, CommandState::executeComplete);
			//}
			//#endif

			if      (General::ID::methodComplete == currentCommandID)
			{
				setCommandState(stepID, CommandState::executeStart);
				setFinishMethodFlag(hslTrue);		// Set the finish flag to finish the method, see runOemInterface()
				setCommandState(stepID, CommandState::executeComplete);
			}
			else if (General::ID::methodAbort == currentCommandID)
			{
				setCommandState(stepID, CommandState::executeStart);
				setAbortMethodFlag(hslTrue);		// Set the abort flag to abort the method, see runOemInterface()
				setCommandState(stepID, CommandState::executeComplete);
			}
			else
			{
				Error::raiseRuntimeError(IDE::unknownCommandID, GetFileName(), GetFunctionName(), GetLineNumber());
			}

			// Set the command result to OK and the result data to empty string
			commandResult = ResultList::CommandResult::succeed;
			rc.AddAsLast("");

			return( ResultList::writeResult(stepID, commandResult, rc) );


			GeneralCommandError:	// Error handler
			{
				// Exception occured during execution of the command.
				// Write the fatal result and return.
				#ifdef _DEBUG_AL
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
								"GenralCommandError: ErrorID="+IStr(err.GetId()));
				#endif

				// Check for an error that must result in an abort
				if (		( err.GetId() >= IDE::abortFirst )
						&& ( err.GetId() <= IDE::abortLast ) )
				{
					// Do not continue with error handling and recovery.
					// Rethrow the exception.
					Error::RaiseLast();
				}

				commandResult = ResultList::initFatalResultData(rc);

				err.Clear();
				return( ResultList::writeResult(stepID, commandResult, rc) );
			}
		}

	} // End namespace Cmd




	// ====================================================================================================
	// PositionData: Implementation
	// ====================================================================================================

	static function PositionData::initStepSequence(variable stepID,
																  variable groupID,
																  sequence& stepSequence) void
	{
		variable commandString("");

		onerror goto FileOpenError;

		PositionData::prepare();

		// Close the file (the database connection) to force that a new connection is generated and
		// the latest state of the database is querried.
		if( 0 != PositionData::fileHandle.Close() )
		{
			Error::raiseRuntimeError(IDE::fileCloseFailed, GetFileName(), GetFunctionName(), GetLineNumber());
		}

		commandString = "SELECT * FROM "+PositionData::tableName + " WHERE StepID="+IStr(stepID) + " AND GroupID="+IStr(groupID);
		commandString = commandString + " ORDER BY SortKey ASC";
		if( 0 == PositionData::fileHandle.Open(m_dataBaseFile + " " + PositionData::tableName, hslRead, commandString) )
		{
			Error::raiseRuntimeError(IDE::fileOpenPositionDataFailed, GetFileName(), GetFunctionName(), GetLineNumber());
		}

		onerror goto FileReadError;

		while (PositionData::fileHandle.Eof() == 0)
		{
			if( 0 == PositionData::fileHandle.ReadRecord() )
			{
				Error::raiseRuntimeError(IDE::fileReadPositionDataFailed, GetFileName(), GetFunctionName(), GetLineNumber());
			}

			stepSequence.Add(PositionData::r_labwareID, PositionData::r_positionID);
		}

		onerror goto 0;

		stepSequence.SetCurrentPosition(1);

		#ifdef _DEBUG_AL
		dumpSequence(stepSequence);
		#endif

		return;


		FileOpenError:
		{
			#ifdef _DEBUG_AL
			FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "FileOpenError: ErrorID="+IStr(err.GetId()));
			#endif

			if ( err.GetId() == IDE::fileOpenPositionDataFailed )
			{
				Error::RaiseLast();
			}
			else
			{
				Error::raiseRuntimeErrorEx(IDE::fileOpenPositionDataFailed, err.GetDescription(), GetFileName(), GetFunctionName(), GetLineNumber());
			}
		} // End error handler


		FileReadError:
		{
			#ifdef _DEBUG_AL
			FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "FileReadError: ErrorID="+IStr(err.GetId()));
			#endif

			if ( err.GetId() == IDE::fileReadPositionDataFailed )
			{
				Error::RaiseLast();
			}
			else
			{
				Error::raiseRuntimeErrorEx(IDE::fileReadPositionDataFailed, err.GetDescription(), GetFileName(), GetFunctionName(), GetLineNumber());
			}
		} // End error handler
	}


	static function PositionData::prepare() void
	{
		if ( ! PositionData::isPrepared )
		{
			PositionData::fileHandle.AddField("LabwareID", PositionData::r_labwareID, hslString);
			PositionData::fileHandle.AddField("PositionID", PositionData::r_positionID, hslString);

			PositionData::isPrepared = hslTrue;
		}

		// Reset r/w variables
		PositionData::r_labwareID = "";
		PositionData::r_positionID = "";
	}


	static function PositionData::cleanUp() void
	{
		if ( PositionData::isPrepared )
		{
			// Close the file, no problem if it was not opened before.
			if( 0 != PositionData::fileHandle.Close() )
			{
				Error::raiseRuntimeError(IDE::fileCloseFailed, GetFileName(), GetFunctionName(), GetLineNumber());
			}
			PositionData::fileHandle.RemoveFields();

			PositionData::isPrepared = hslFalse;
		}
	}



	// ====================================================================================================
	// VolumeData: Implementation
	// ====================================================================================================


	static function VolumeData::initChannelVolumes(variable stepID,
																  variable& channelPattern) variable[]
	{
		variable volumesArray[];
		variable commandString("");
		variable i(0), length(0);
		string strPattern;

		onerror goto FileOpenError;

		VolumeData::prepare();

		// Close the file (the database connection) to force that a new connection is generated and
		// the latest state of the database is querried.
		if( 0 != VolumeData::fileHandle.Close() )
		{
			Error::raiseRuntimeError(IDE::fileCloseFailed, GetFileName(), GetFunctionName(), GetLineNumber());
		}

		commandString = "SELECT * FROM "+VolumeData::tableName + " WHERE StepID="+IStr(stepID);
		commandString = commandString + " ORDER BY SortKey ASC";
		if( 0 == VolumeData::fileHandle.Open(m_dataBaseFile + " " + VolumeData::tableName, hslRead, commandString) )
		{
			Error::raiseRuntimeError(IDE::fileOpenVolumeDataFailed, GetFileName(), GetFunctionName(), GetLineNumber());
		}

		onerror goto FileReadError;

		// Initialize the array with 16 volumes. For activated channels read the next volume from the file.
		strPattern = channelPattern;
		length = strPattern.GetLength();
		for ( i=0; i<16; i++ )
		{
			if ( i < length )
			{
				if ( strPattern.Mid(i, 1) != "0" )
				{
					// A used channel, read next volume from file
					if( 0 == VolumeData::fileHandle.ReadRecord() )
					{
						Error::raiseRuntimeError(IDE::fileReadVolumeDataFailed, GetFileName(), GetFunctionName(), GetLineNumber());
					}

					volumesArray.AddAsLast(VolumeData::r_volume);
				}
				else
				{
					// A unused channel
					volumesArray.AddAsLast(0.0);
				}				
			}
			else
			{
				// Index exceeds the channel pattern
				volumesArray.AddAsLast(0.0);				
			}
		}

		#ifdef _DEBUG_AL
		dumpArray("Readed volumes: volume", volumesArray);
		#endif

		onerror goto 0;

		return( volumesArray );


		FileOpenError:
		{
			#ifdef _DEBUG_AL
			FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "FileOpenError: ErrorID="+IStr(err.GetId()));
			#endif

			if ( err.GetId() == IDE::fileOpenVolumeDataFailed )
			{
				Error::RaiseLast();
			}
			else
			{
				Error::raiseRuntimeErrorEx(IDE::fileOpenVolumeDataFailed, err.GetDescription(), GetFileName(), GetFunctionName(), GetLineNumber());
			}
		} // End error handler


		FileReadError:
		{
			#ifdef _DEBUG_AL
			FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "FileReadError: ErrorID="+IStr(err.GetId()));
			#endif

			if ( err.GetId() == IDE::fileReadVolumeDataFailed )
			{
				Error::RaiseLast();
			}
			else
			{
				Error::raiseRuntimeErrorEx(IDE::fileReadVolumeDataFailed, err.GetDescription(), GetFileName(), GetFunctionName(), GetLineNumber());
			}
		} // End error handler

	}


	static function VolumeData::initChannelVolumesNano(variable stepID,
																  		variable& channelPattern) variable[]
	{
		variable volumesArray[];
		variable index, size;

		volumesArray = VolumeData::initChannelVolumes(stepID, channelPattern);
		
		size = volumesArray.GetSize();
		for ( index=0; index<size; index++ )
		{
			// Convert to nanoliter and integer
			volumesArray.SetAt(index, Floor(volumesArray.GetAt(index) * 1000.0));
		}

		return( volumesArray );
	}


	static function VolumeData::prepare() void
	{
		if ( ! VolumeData::isPrepared )
		{
			VolumeData::fileHandle.AddField("Volume", VolumeData::r_volume, hslFloat);

			VolumeData::isPrepared = hslTrue;
		}

		// Reset r/w variable
		VolumeData::r_volume = -1.0;
	}


	static function VolumeData::cleanUp() void
	{
		if ( VolumeData::isPrepared )
		{
			// Close the file, no problem if it was not opened before.
			if( 0 != VolumeData::fileHandle.Close() )
			{
				Error::raiseRuntimeError(IDE::fileCloseFailed, GetFileName(), GetFunctionName(), GetLineNumber());
			}
			VolumeData::fileHandle.RemoveFields();

			VolumeData::isPrepared = hslFalse;
		}
	}



	// ====================================================================================================
	// ResultList: Implementation
	// ====================================================================================================

	static function ResultList::writeResult(variable stepID,
														 variable commandResult,
														 variable& resultData[]) variable
	{
		variable index(0);
		variable resultFragment(0);
		variable resulatDataValue;
		string resultDataStr("");
		string resultDataFragmentStr("");

		ResultList::prepare();

		// Open for adding one record 'hslAppend'
		if( 0 == ResultList::fileHandle.Open(m_dataBaseFile + " " + ResultList::tableName, hslAppend) )
		{
			Error::raiseRuntimeError(IDE::fileOpenResultListFailed, GetFileName(), GetFunctionName(), GetLineNumber());
		}


		if ( resultData.GetSize() == 0 )
		{
			#ifdef _DEBUG_AL
			FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,
							"No result data entry found! Init and write fatal result");
			#endif

			commandResult = ResultList::initFatalResultData(resultData);
		}

		ResultList::w_stepID = stepID;
		ResultList::w_commandResult = commandResult;


		// Write each element of the result data. Convert to string if necessary.
		for( index=0; index<resultData.GetSize(); index++)
		{
			ResultList::w_resultNo = index + 1;

			// Get the value and convert to type string.
			resulatDataValue = resultData.GetAt(index);
			if (Util::IsInteger(resulatDataValue))
				resulatDataValue = IStr(resulatDataValue);
			if (Util::IsFloat(resulatDataValue))
				resulatDataValue = FStr(resulatDataValue);

			resultDataStr = resulatDataValue;

			resultFragment = 1;
			
			while ( hslTrue )		// Write the resultData, fragmented if necessary
			{
				variable startPos((resultFragment-1)*ResultList::resultDataLength);

				if (		( startPos >= resultDataStr.GetLength())
						&& ( resultFragment > 1) )
				{
					break;	// resultData string is processed and minimally one fragment is written
				}

				// Extracts the next part of the resultData
				resultDataFragmentStr = resultDataStr.Mid(startPos, ResultList::resultDataLength);

				ResultList::w_resultFragment = resultFragment;
				ResultList::w_resultData = resultDataFragmentStr;

				#ifdef _DEBUG_AL
				dumpResult(ResultList::w_stepID, ResultList::w_commandResult, ResultList::w_resultNo, ResultList::w_resultFragment, ResultList::w_resultData);
				#endif

				if( 0 == ResultList::fileHandle.WriteRecord() )
				{
					Error::raiseRuntimeError(IDE::fileWriteResultListFailed, GetFileName(), GetFunctionName(), GetLineNumber());
				}

				resultFragment++;
			}
		}

		// Close the file (which closes the database connection) to force a flush.
		if( 0 != ResultList::fileHandle.Close() )
		{
			Error::raiseRuntimeError(IDE::fileCloseFailed, GetFileName(), GetFunctionName(), GetLineNumber());
		}

		// Result of this command is written to the file -> update the state
		setCommandState(stepID, CommandState::resultWritten);

		return( commandResult );
	}


	static function ResultList::initFatalResultData(variable& resultData[]) variable
	{
		variable result[];

		// Check that the error is a known error
		if (		( err.GetId() < IDE::first )
				|| ( err.GetId() > IDE::last ) )
		{
			// Unknown error ID detected, get last description and raise to overwrite the error object
			variable lastErrorDescr("");
			lastErrorDescr = err.GetDescription();

			onerror resume next;
			Error::raiseRuntimeErrorEx(IDE::unknown, lastErrorDescr, GetFileName(), GetFunctionName(), GetLineNumber());
			onerror goto 0;
		}

		result.AddAsLast(IStr(err.GetId()));
		result.AddAsLast(err.GetDescription());

		resultData = result;

		return( ResultList::CommandResult::fatal );
	}


	static function ResultList::initAbortResultData(variable& resultData[]) variable
	{
		variable result[];

			// Unknown error ID detected, get last description and raise to overwrite the error object
		if (		( err.GetId() < IDE::first )
				|| ( err.GetId() > IDE::last ) )
		{
			// Unknown error ID detected
			variable lastErrorDescr("");
			lastErrorDescr = err.GetDescription();

			onerror resume next;
			Error::raiseRuntimeErrorEx(IDE::unknown, lastErrorDescr, GetFileName(), GetFunctionName(), GetLineNumber());
			onerror goto 0;
		}

		result.AddAsLast(IStr(err.GetId()));
		result.AddAsLast(err.GetDescription());

		resultData = result;

		return( ResultList::CommandResult::aborted );
	}


	static function ResultList::emptyResultListTable() void
	{
		ResultList::prepare();

		// Execute one open for 'write' to delete existing records.
		if( 0 == ResultList::fileHandle.Open(m_dataBaseFile + " " + ResultList::tableName, hslWrite) )
		{
			Error::raiseRuntimeError(IDE::fileOpenResultListFailed, GetFileName(), GetFunctionName(), GetLineNumber());
		}

		ResultList::cleanUp();
	}



	static function ResultList::prepare() void
	{
		if ( ! ResultList::isPrepared )
		{
			ResultList::fileHandle.AddField("StepID", ResultList::w_stepID, hslInteger);
			ResultList::fileHandle.AddField("CommandResult", ResultList::w_commandResult, hslInteger);
			ResultList::fileHandle.AddField("ResultNo", ResultList::w_resultNo, hslInteger);
			ResultList::fileHandle.AddField("ResultFragment", ResultList::w_resultFragment, hslInteger);
			ResultList::fileHandle.AddField("ResultData", ResultList::w_resultData, hslString, ResultList::resultDataLength);

			//if( 0 == ResultList::fileHandle.Open(m_dataBaseFile + " " + ResultList::tableName, hslWrite) )
			//{
			//	Error::raiseRuntimeError(IDE::fileOpenResultListFailed, GetFileName(), GetFunctionName(), GetLineNumber());
			//}

			ResultList::isPrepared = hslTrue;
		}

		// Reset r/w variables
		ResultList::w_stepID = -1;
		ResultList::w_commandResult = -1;
		ResultList::w_resultNo = -1;
		ResultList::w_resultFragment = -1;
		ResultList::w_resultData = "";
	}


	static function ResultList::cleanUp() void
	{
		if ( ResultList::isPrepared )
		{
			if( 0 != ResultList::fileHandle.Close() )
			{
				Error::raiseRuntimeError(IDE::fileCloseFailed, GetFileName(), GetFunctionName(), GetLineNumber());
			}
			ResultList::fileHandle.RemoveFields();

			ResultList::isPrepared = hslFalse;
		}
	}



	// ====================================================================================================
	// Error: Implementation
	// ====================================================================================================

	static function Error::raiseRuntimeError(variable errorId,
														  variable& fileName,
														  variable& funcName,
														  variable& lineNumber) void
	{
		Error::raiseRuntimeErrorEx(errorId, "", fileName, funcName, lineNumber);
	}


	static function Error::raiseRuntimeErrorEx(variable errorId,
															 variable& additionalDescr,
															 variable& fileName,
															 variable& funcName,
															 variable& lineNumber) void
	{
		variable description("");
		
		// Generate the full description
		if ( additionalDescr == "" )
		{
			description = STR::StringTable::Load(errorId);
		}
		else
		{
			description = STR::StringTable::Load(errorId) + "\n\n("+additionalDescr+")";
		}

		description = fileName + "("+lineNumber+") : " + funcName + "().\n\n" + description;
		err.SetDescription(description);

		// raise error
		err.Raise(errorId, err.GetDescription());
	}


	static function Error::RaiseLast() void
	{
		// re-raise error
		err.Raise();
	}



	// ====================================================================================================
	// Debugging: Implementation
	// ====================================================================================================

	static function Assert(variable expr,	
								  variable location) void
	{
		#ifdef _DEBUG_AL
		if ( ! expr )
		{
			if (Util::IsInteger(location))
				location = IStr(location);
			if (Util::IsFloat(location))
				location = FStr(location);
			FormatTrace("DEBUG", "Assert()", TraceStatus::progress, "Debug Assertion failed, Debug Error - " + location);
			MessageBox("Debug Assertion failed:\nDebug Error - " + location, "DEBUG : Assert()", hslError | hslOKOnly);
			abort;
		}
		#endif
	}


	static function dumpSequence(sequence& seq) void
	{
		#ifdef _DEBUG_AL
		variable index(0), size(0);
		variable currentBackup(-1);

		currentBackup = seq.GetCurrentPosition();

		size = seq.GetTotal();
		FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "Name: '", seq.GetName(), "', Current: ", currentBackup, ", End: ", seq.GetCount(), ", Total: ", size);
		for (index=0; index<size; index++)
		{
			seq.SetCurrentPosition(index+1);
			FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "Element "+IStr(index+1), ": LabID=", seq.GetLabwareId(), " / PosID=", seq.GetPositionId());
		}

		seq.SetCurrentPosition(currentBackup);
		#endif
	}


	static function dumpArray(variable& description, variable& arr[]) void
	{
		#ifdef _DEBUG_AL
		variable index(0), size(0), value;

		if (Util::IsInteger(description))
			description = IStr(description);
		if (Util::IsFloat(description))
			description = FStr(description);
			
		size = arr.GetSize();
		
		if ( size == 0 )
		{
			FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, description+": Empty array!");
		}

		for (index=0; index<size; index++)
		{	value = arr.GetAt(index);
			if (Util::IsInteger(value))
				value = IStr(value);
			if (Util::IsFloat(value))
				value = FStr(value);
			FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, description+"."+IStr(index)+": "+value);
		}
		#endif
	}


	static function dumpResult(variable w_stepID,
										variable w_commandResult,
										variable w_resultNo,
										variable w_resultFragment,
										variable& w_resultData) void
	{
		#ifdef _DEBUG_AL
		FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress,   "StepID: ", w_stepID,
																							", CommandResult: ", w_commandResult,
																							", ResultNo: ", w_resultNo,
																							", ResultFragment: ", w_resultFragment,
																							", ResultData: ", w_resultData);
		#endif
	}


} // End namespace AL
// $$author=wbarmettler$$valid=1$$time=2017-03-14 13:14$$checksum=b3d872d8$$length=088$$