//***************************************************************************************************
//
// Library for Methods of Microlab® 2005-2006 STARline Maintenance
// Copyright © by HAMILTON Bonaduz AG, CH-7402 Bonaduz.
// All rights reserved.
//
//***************************************************************************************************
//
/// Modification History
// 2005-04-21	Alessandro Carrara : Initial file creation.
// 2005-09-02  Urban Bernhard		 : Implemented simple error recovery for
//											   CO-RE 96 Head washstation firmware commands (SCR# 1039)
//	2005-09-13	Alessandro Carrara :	Implemented the new requirements and (SCR# 1062)
//
// 2006-03-14  Werner Barmettler  : Add Nanopipettor                  Finde_nanoPipettorMaintenance
// 2006-08-18  Werner Barmettler  : Add DC Wash Station Daily         Find_DCWashStationMaintenanceDaily
// 2006-08-18  Werner Barmettler  : Add DC Wash Station Weekly        Find_DCWashStationMaintenanceWeekly
// 2006-09-08  Werner Barmettler  : Add BVS Daily                     Find_BVSMaintenanceDaily
// 2006-09-08  Werner Barmettler  : Add BVS Weekly							 Find_BVSMaintenanceWeekly
// 2006-09-08  Werner Barmettler  : Add 96/384 Wash Station Daily     Find_WashStation_96_384_MaintenanceDaily
// 2006-09-08  Werner Barmettler  : Add 96/384 Wash Station Weekly    Find_WashStation_96_384_MaintenanceWeekly
// 2006-09-27  Werner Barmettler  : Update Nanopipettor               Find_nanoPipettorMaintenance
// 2006-10-03  Werner Barmettler  : Removed all Nanopipetor code
// 2006-10-07  Werner Barmettler  : MoveLeft new function 
//                                  C0RU Request maximal ranges of X drives
// 2006-10-10  Werner Barmettler  : Add if two CoRe 96/384 wash station (dual chamber) installed
//                                  First labware is for 384 wash station next labware is for  96 wash station   
//												Add Labare for DC Wash Station
// 2006-10-17  Werner Barmettler  : UpDate DC Wash Station for HW + HU + HV 
// 2006-10-18  Werner Barmettler  : UpDate 96/384 Wash Station for HW + HU + HV 
// 2006-10-18  Werner Barmettler  : UpDate BVS Wash Station
// 2006-10-19  Werner Barmettler  : Removed TraceDlgOK, TraceDlgCancel,  TraceDlgYes, TraceDlgNo
// 2006-10-20  Werner Barmettler  : Add function HasTempControlledCarrier()
// 2006-10-26  Thomas Benz			 : function DCWashStationMaintenanceDaily() code deleted
// 2006-10-26  Thomas Benz			 : function BVSMaintenanceDaily()	HSLStarBVSLib::BVSTerminate(pumpID); inserted
// 2006-10-26  Thomas Benz			 : function BVSMaintenanceWeekly() 	HSLStarBVSLib::BVSTerminate(pumpID); inserted
// 2006-10-26  Thomas Benz			 : function HasCORE96HeadWasher() corrected
// 2006-11-10  Fernando Garcia    : - include HSLVacuuBrandPump.hs_ i/o HSLVacuuBrandPump.hsl
//                                  - SCR #1200:
//                                    - added function LockCover()
//                                    - added return value to BVSMaintenanceDaily() and BVSMaintenanceWeekly()
//                                      to evaluate if front cover locking was successful
//                                  - SCR #1201: 
//                                    - removed unneeded call to HSLStarBVSLib::BVSInitialize() in BVSMaintenanceWeekly()
// 2006-12-20  Fernando Garcia    : - SCR #1244:
//                                    - use wash containter one (red) for rinsing in
//                                      CrWashStationMaintenance() and CrWashStationMaintenanceDaily()
//                                  - SCR #1245:
//                                    - modified ShowInfiniteSoakTimer() to show a message to user
//                                      while waiting. Timer is no more stoppable, time is no more infinite 
//                                      and is taken from variable soakTimerWaitTime (24h).
// 2007-01-09	Urban Bernhard		 : - function MoveRight() and MoveLeft() enhanced with full dual arm support
// 2007-01-15	Urban Bernhard		 : - support all possible 'Arm-configurations', i.e. left arm only, right arm only, dual arm
// 2007-01-31  Fernando Garcia    : - SCR #1244 (amendment):
//                                    fixed parameters passed to StartWashCRand3rdGen() in both
//                                    CrWashStationMaintenance() and CrWashStationMaintenanceDaily().
//                                    The blue container was emptied too due to this wrong parameters i/o only the red.
// 2007-03-01  Fernando Garcia    : - Add function RequestInstrumentInitStatus()
//											   - Save ML STAR parameters to file in \Logfiles\ (InstrParam::InstrParamFile)
//                                    (May be used in case of a maintenance abort to restore the parameters)
//											   - Add function RestoreParamsFromFile()
//											   - Add function GetNumberOfChannels()
// 2007-07-05  Fernando Garcia    : - SCR #1284:
//                                    allow BVS to be connected to COM ports 1 to 255 (i/o only 1 to 4)
// 2007-10-30	Urban Bernhard		 : - Updated function StoreProcessDataOnInstrument() due to firmware interface change
//												  (C0AV parmeter 'vo' new range 0..24 --> before 0..9)
//											   - Enhanced function RestoreParamsFromFile(). Will only restore instrument data if last run was aborted
//											   - Add function OnAbortMaintenance()
// 2008-01-25  Urban Bernhard		 : - SCR #1346:
//                                    - Corrected initialization of members pumpTypeStation1, pumpTypeStation2 and pumpTypeStation3 within 
//	                                     function InitializeAndCheckConfiguration()
// 2008-07-10  Thomas Benz          - Nano function imported and enlarged
//                                  - String IDS imported and updated in string table
//                                  - nanoPipettorMaintenance StartUp and daily morning maintenance enlarged with dry of helium pump
//                                  - Decontamination function implemented
//                                  - Function InitializeAndCheckConfiguration() enlarged
//                                     -  call of RequestNanopipettorSerialNumber() inserted
//                                     -  search for parameter xt## --> instrument size in slots implemented
//                                     -  search for parameter xa## --> autoload max slots
//
// 2008-07-24   Claudio Jörg        - Add and use function ParseFwResult() to evaluate the extended machin configuration (C0QM).
//                                  - Added call of RestoreParamsFromFile() during InitializeAndCheckConfiguration(). This
//                                    call was missing in the version released with 4.2.0.4062!
//                                  - Removed functions GetNumberOfChannels(), and RequestInstrumentInitStatus() becaus not used.
//                                  - GetProcessedStateAsString() changed to use GetProcessState() instead of self evaluation
//                                    of the state again.
//                                  - CLLDCheckForChannels1000ul(). Position the channel onto the check position by using
//                                    the "C0JM" command. Previously the channel was onyl moved to the Y of the check position,
//                                    there was never a move to the X of the check position and the cLLD check was done on the same
//                                    X-position as the tip pick up just before.
//                                  - Integrated 5ml Channel Checks, updated report generation.
//
// 2008-09-05  Thomas Benz          - Function AddNanoServiceCarrier() moved from nanoPipettorMaintenance to AddAllNeededLabware
//
// 2008-09-25  Claudio Jörg         - TightnessCheckChannel5ml(). Fixed problem with initialisation of the plunger drive after
//                                    measurement. The command PXDI (for 1000ul channels) was used instead of LXDI (for 5ml
//                                    channels) which causes an error ("Firmware command <PXDI> with parameter <> failed! -
//                                    return value <er30>"if no 1000ul channels are installed.
//                                  - InitializeAndCheckConfiguration(). Request/save parameter values to file onyl if the 
//                                    corresponding channels (1000ul/5ml) are installed - save empty string if not installed.
//                                  - RestoreParamsFromFile(). Restore only if the corresponding channels (1000ul/5ml) are
//                                    installed. Before set the values check if them has been saved during previous run.
//                                    
//
// 2009-03-23  Thomas Benz          - Function AddNanoServiceCarrier() slot input range corrected (-3 ... up do max slots -5)
//
// 2009-10-21  Claudio Jörg         - Fixed bug in CLLDCheckForChannels1000ul / CLLDCheckForChannels5ml:
//                                    In case if only ONE (1000ul or 5ml) channel is installed the command C0JM / C0LL has
//                                    been generated by using a wrong syntax and the CLD check ends in a FW-syntax error
//                                    <er01/31>. The command must be generated without using the '&' character.
//                                  - Changed 5ml channel tightness check drop limits according to updated DPFH E2830167r/1.4.
//                                    Updated also the check procedure for changed movements/timeouts.
// 2010-01-21  Claudio Jörg         - Added functions GetNumberOfPipettingChannel1000ul() and GetNumberOfPipettingChannel5ml()
//                                  - Extended HasRightArm() / HasLeftArm() to regard XL-channels, tube gripper and imaging
//                                    channel too (identical as already done in the IVD maintenance).
//                                  - Extended InitializeAndCheckConfiguration() to evaluate the extensions listed above.
//                                    (identical as already done in the IVD maintenance).
//                                    
//
// 2010-12-02  Thomas Benz          - Added CO-RE 96 Tadm Head tightness check for daily and weekly maintenance
//                                  - Extended InitializeAndCheckConfiguration() to evaluate the CO-RE 96 Tadm Head extension.
//                                  - Extended InitializeProcessCheckStates() with CO-RE 96 Tadm Head.
//                                  - Extended GetProcessState() with CO-RE 96 Tadm Head state.
//                                  - Extended RestoreParamsFromFile() with CO-RE 96 Tadm Head parameter.
//                                  - Extended CreateReportFile() with CO-RE 96 Tadm Head channel errors.
//
//
// 2012-09-27  Thomas Benz          - Added Easy Puncher daily and weekly maintenance
//                                  - Extended InitializeAndCheckConfiguration() to evaluate the easy puncher and card gripper extension.
//                                  - Extended InitializeProcessCheckStates() with easy punch.
//                                  - Extended GetProcessState() with easy punch state.
//                                  - Extended CreateReportFile() with easy punch error.
//                                  - Extended HasRightArm()
//                                  - Extended HasLeftArm()
//
// 2012-10-23  Erich Caflisch       - Optimized function "searchFingerPositions" for 3 types of card gripper
//
// 2013-01-23  Thomas Benz          - CO-RE 96 Tadm Head tightness check for daily and weekly maintenance updated
// 2013-03-14  Thomas Benz          - Exchange punch head dialog updated
// 2013-06-14  Thomas Benz          - MeassureUnderPressure96TadmHead() loop max count changed from maxPressureIncrease5ml
//                                    to maxPressureIncrease96TadmHead.
// 2016-05-23  Thomas Benz          - SCR #1610
//                                    New private function easyPunchMovePuncherHead(device ML_STAR,  variable moveToReplacePosition) defined
//                                    to move the puncher head to the service position and back. Used in easyPunchDailyMaintenance().
//
//********************************************************************************************************************************

#ifndef __HslStarLineMaintMetLib_hsl__
#define __HslStarLineMaintMetLib_hsl__	1

//================================
//deactivate for release version
//--------------------------------------------------------------------------------
//
//#define __develop__ 1
//--------------------------------------------------------------------------------
//#define HSL_RUNTIME 1

#ifdef __develop__
 	device ML_STAR;
	#define HSL_RUNTIME 1
#endif

//================================

namespace PID // process id definitions
{
	static const variable dailyMaint(0);
	static const variable weeklyMaint(1);

	static const variable dailyMorningMaintNano(7);
	static const variable startUpMaintNano(8);
	static const variable decontaminationMaintNano(9);
}

namespace PS // process state definitions
{
	static const variable notInstalled(-2);
	static const variable open(-1);			 // = not performed
	static const variable failed(0);
	static const variable successful(1);
//	static const variable performed(2);
	static const variable Installed(3);
}

namespace MPS // maintenance process state
{
	static const variable mpsIncomplete(-1);
	static const variable mpsFailed(0);
	static const variable mpsSuccessful(1);
}

namespace MERR	// maintenance errors
{
	// individual channel errors
	static string tightnessCheckChannel1000ulError[];		// Tightness 1000ul
	static string cLLDCheckChannel1000ulError[];				// cLLD 1000ul
	static string tightnessCheckChannel5mlError[];			// Tightness 5ml
	static string cLLDCheckChannel5mlError[];					// cLLD 5ml
	static string tightnessCheckChannel96TadmHeadError[];		// Tightness CO-RE 96 TADM Haed
}

namespace FimwareNodeID // node definitions
{
	static const variable notInstalled(-1);
	static const variable HW(25);
	static const variable HU(26);
	static const variable HV(27);
}

namespace CoverLock // front cover locking
{
	static const variable coverLock(hslTrue);
	static const variable coverUnlock(hslFalse);
}

namespace InstrParam // ML_STAR parameters
{
	static const string InstrParamFile("\\Maintenance_SN%s_Params.xls");
	static const string TableName(" PowerOnValues");
}

namespace PuncherCount // easyPuncher punch count counter
{
	static const string PuncherCountFile("\\EasyPunch_SN%s_Count.xls");
	static const string PuncherCountCurrentTableName(" EasyPunch");
   static const variable PuncherCountHeadLifeCycles(250000);
   static const string PuncherCountHeadLifeCyclesTxt("250'000");
}

//--------------------------------------------------------------------------------------------------------------------------------------
// Section 1 : Interface of MaintenanceLibrary
//--------------------------------------------------------------------------------------------------------------------------------------

#ifndef HSL_RUNTIME	// Parser constant, always defined at
							// run-time, but not at edit-time.

namespace MtcLib		// This will prevent clashing of variable
							// and function names across libraries.
{
	//-----------------------------------------------------------------------------------------------------
	function InitializeAndCheckConfiguration( device ML_STAR, variable instrumentNr ) {}
	//-----------------------------------------------------------------------------------------------------
	// Initialize variables and instrument, evaluate and check configuration data
	//
	// RETURN		none
	//-----------------------------------------------------------------------------------------------------

   //-----------------------------------------------------------------------------------------------------
	function MoveAutoloadRight( device ML_STAR ) {}
	//-----------------------------------------------------------------------------------------------------
	// Move autoload to the right most position
	// 
	// RETURN		none
	//-----------------------------------------------------------------------------------------------------

   //-----------------------------------------------------------------------------------------------------
	function MoveRight( device ML_STAR , variable instrumentNr ) {}
	//-----------------------------------------------------------------------------------------------------
	// Move arms and autoload to the right most position
	// 
	// Since 4.1: Dual arm instruments supported
	//
	// RETURN		none
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function MoveLeft( device ML_STAR ) {}
	//-----------------------------------------------------------------------------------------------------
	// Move arms and autoload to the left most position
	//
	// Since 4.1: Dual arm instruments supported
	//
	// RETURN		none
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function IsCoverClosed( device ML_STAR ) {}
	//-----------------------------------------------------------------------------------------------------
	// Check, if instrument cover is closed
	//
	// RETURN		HslTrue	: cover is closed
	//					HslFalse	: cover is open
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function LockCover( device ML_STAR, variable lockFront, string msg, string title ) {}
	//-----------------------------------------------------------------------------------------------------
	// Lock / Unlock front cover of given device
	//
	// RETURN		HslTrue  : all operations succeeded
	//             HslFalse : locking front cover not succeeded
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function IsDeckEmpty( device ML_STAR ) {}
	//-----------------------------------------------------------------------------------------------------
	// Check if deck is empty (no carriers detected)
	//
	// RETURN		HslTrue	: deck is empty
	//					HslFalse	: deck is not empty (carrier detected)
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function UnloadDeck( device ML_STAR ) {}
	//-----------------------------------------------------------------------------------------------------
	// Unload all carriers from deck, using auto load.
	//
	// RETURN		none
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function StoreProcessDataOnInstrument( variable &processId, device ML_STAR ) {}
	//-----------------------------------------------------------------------------------------------------
	// Store timestamp and 'overallProcessedState' for process with id 'processId' on instrument
	//
	// RETURN		none
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function CreateReportFile( variable &templateFile, variable &reportFileName, variable &reportExcelAreaName ) {}
	//-----------------------------------------------------------------------------------------------------
	// Creates a maintenance report file
	//
	// RETURN		none
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function SetPowerOnValuesForAllChannels1000ul( device ML_STAR ) {}
	//-----------------------------------------------------------------------------------------------------
	// Set the "power-ON" values for all 1000ul channels.
	//
	//	RETURN		none
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function SetPowerOnValuesForAllChannels5ml( device ML_STAR ) {}
	//-----------------------------------------------------------------------------------------------------
	// Set the "power-ON" values for all 5ml channels.
	//
	//	RETURN		none
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function SetPowerOnValuesFor96TadmHead( device ML_STAR ) {}
	//-----------------------------------------------------------------------------------------------------
	// Set the "power-ON" values for 96 tadm head.
	//
	//	RETURN		none
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
   function GetLabwarePath() {}
	//-----------------------------------------------------------------------------------------------------
	// Retrieves the labware path from registry.
	// 
	//	RETURN		labware path
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function Core96HeadWsMaintenance( device ML_STAR, variable nodeId ) {}
	//-----------------------------------------------------------------------------------------------------
	// Execute maintenance for installed 96 CORE Head Wash stations
	//
	// RETURN 		none
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function Core96HeadWsMaintenanceDaily( device ML_STAR, variable nodeId ) {}
	//-----------------------------------------------------------------------------------------------------
	// Execute maintenance for installed 96 CORE Head Wash stations (Daily Maintenance)
	//
	// RETURN 		none
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function rd3GenerationMaintenance( device ML_STAR ) {}
	//-----------------------------------------------------------------------------------------------------
	// Execute maintenance for installed 3rd Generation Wash stations
	//
	// RETURN 		none
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function rd3GenerationMaintenanceDaily( device ML_STAR ) {}
	//-----------------------------------------------------------------------------------------------------
	// Execute maintenance for installed 3rd Generation Wash stations (Daily Maintenace)
	//
	// RETURN 		none
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function CrWashStationMaintenance( device ML_STAR ) {}
	//-----------------------------------------------------------------------------------------------------
	// Execute maintenance for installed CR Wash stations (Weekly Maintenance)
	//
	// RETURN 		none
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function CrWashStationMaintenanceDaily( device ML_STAR ) {}
	//-----------------------------------------------------------------------------------------------------
	// Execute maintenance for installed CR Wash stations (Daily Maintenance)
	//
	// RETURN 		none
	//-----------------------------------------------------------------------------------------------------


	//-----------------------------------------------------------------------------------------------------
	function DCWashStationMaintenanceDaily( device ML_STAR ) {}
	//-----------------------------------------------------------------------------------------------------
	// Execute maintenance for installed DC Wash stations (Daily Maintenance)
	//
	// RETURN 		none
	//-----------------------------------------------------------------------------------------------------


	//-----------------------------------------------------------------------------------------------------
	function DCWashStationMaintenanceWeekly( device ML_STAR ) {}
	//-----------------------------------------------------------------------------------------------------
	// Execute maintenance for installed DC Wash stations (Weekly Maintenance)
	//
	// RETURN 		none
	//-----------------------------------------------------------------------------------------------------


	//-----------------------------------------------------------------------------------------------------
	function WashStation_96_384_MaintenanceDaily( device ML_STAR) {}
	//-----------------------------------------------------------------------------------------------------
	// Execute maintenance for installed 96 /384 Wash stations (Daily Maintenance)
	//
	// RETURN 		none
	//-----------------------------------------------------------------------------------------------------


	//-----------------------------------------------------------------------------------------------------
	function WashStation_96_384_MaintenanceWeekly( device ML_STAR ) {}
	//-----------------------------------------------------------------------------------------------------
	// Execute maintenance for installed 96 /384 Wash stations (Weekly Maintenance)
	//
	// RETURN 		none
	//-----------------------------------------------------------------------------------------------------


	//-----------------------------------------------------------------------------------------------------
	function BVSMaintenanceDaily( device ML_STAR ) {}
	//-----------------------------------------------------------------------------------------------------
	// Execute maintenance for installed BVS (Daily Maintenance)
	//
	// RETURN 		HslTrue  : all operations executed successfully
	//             HslFalse : front cover could not be locked
	//-----------------------------------------------------------------------------------------------------


	//-----------------------------------------------------------------------------------------------------
	function BVSMaintenanceWeekly( device ML_STAR ) {}
	//-----------------------------------------------------------------------------------------------------
	// Execute maintenance for installed BVS (Weekly Maintenance)
	//
	// RETURN 		HslTrue  : all operations executed successfully
	//             HslFalse : front cover could not be locked
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function TightnessCheckChannel1000ul( device ML_STAR ) void {}
	//-----------------------------------------------------------------------------------------------------
	// Proceed Tightness check for all 1000ul channels.
	//
	//	RETURN		none
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function TightnessCheckChannel5ml( device ML_STAR ) void {}
	//-----------------------------------------------------------------------------------------------------
	// Proceed Tightness check for all 5ml channels.
	//
	//	RETURN		none
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function TightnessCheck96TadmHead( device ML_STAR ) void {}
	//-----------------------------------------------------------------------------------------------------
	// Proceed Tightness check for CO-RE 96 TADM head.
	//
	//	RETURN		none
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function CLLDCheckChannel1000ul( device ML_STAR ) void {}
	//-----------------------------------------------------------------------------------------------------
	// Proceed cLLD check for all 1000ul channels.
	//
	//	RETURN		none
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function CLLDCheckChannel5ml( device ML_STAR ) void {}
	//-----------------------------------------------------------------------------------------------------
	// Proceed cLLD check for all 5ml channels.
	//
	//	RETURN		none
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function SetInstrumentCheckState( variable processState ) {}
	//-----------------------------------------------------------------------------------------------------
	// RETURN		None
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function GetNumberOfPipettingChannel1000ul() variable { return(0); }
	//-----------------------------------------------------------------------------------------------------
	//
	// RETURN		number of installed 1000ul Pipetting Channels, may be 0
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function GetNumberOfPipettingChannel5ml() variable { return(0); }
	//-----------------------------------------------------------------------------------------------------
	//
	// RETURN		number of installed 5ml Pipetting Channels, may be 0
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function HasPipettingChannel1000ul() variable { return(0); }
	//-----------------------------------------------------------------------------------------------------
	//
	// RETURN		hslTrue if 1000ul channels are installed, else hslFalse
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function HasPipettingChannel5ml() variable { return(0); }
	//-----------------------------------------------------------------------------------------------------
	//
	// RETURN		hslTrue if 5ml channels are installed, else hslFalse
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function Has96TadmHead() variable { return(0); }
	//-----------------------------------------------------------------------------------------------------
	//
	// RETURN		hslTrue if CO-RE 96 TADM Head is installed, else hslFalse
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function HasCRWasher() {}
	//-----------------------------------------------------------------------------------------------------
	//
	// RETURN		hslTrue if at least one CR wash station is installed, else hslFalse
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function Has3rdGenWasher() {}
	//-----------------------------------------------------------------------------------------------------
	//
	// RETURN		hslTrue if at least one 3rd generation wash station is installed, else hslFalse
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function HasCORE96HeadWasher() {}
	//-----------------------------------------------------------------------------------------------------
	//
	// RETURN		if installed the node ID of CO-RE 96 Head wash station, else -1
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function HasDCWasher()	{}
	//-----------------------------------------------------------------------------------------------------
	//
	// RETURN		if installed the node ID of DC wash station, else -1
	//-----------------------------------------------------------------------------------------------------


	function Has_96_384_Washer() {}
	//-----------------------------------------------------------------------------------------------------
	//
	// RETURN		if installed the node ID of 96/384 wash station, else -1
	//-----------------------------------------------------------------------------------------------------


	//-----------------------------------------------------------------------------------------------------
	function GetProcessState() {}
	//-----------------------------------------------------------------------------------------------------
	//
	// RETURN		maintenance process states: mpsIncomplete(-1); mpsFailed(0); mpsSuccessful(1);
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function HasAutoload() {}
	//-----------------------------------------------------------------------------------------------------
	//
	// RETURN		hslTrue if an autoload is installed, else hslFalse
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function HasRightArm() {}
	//-----------------------------------------------------------------------------------------------------
	//
	// RETURN		hslTrue if right arm with all configurations are installed, else hslFalse
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function HasLeftArm() {}
	//-----------------------------------------------------------------------------------------------------
	//
	// RETURN		hslTrue if left arm with all configurations are installed, else hslFalse

	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function HasTempControlledCarrier() {}
	//-----------------------------------------------------------------------------------------------------
	//
	// RETURN		hslTrue if left arm with all configurations are installed, else hslFalse
	//
	//-----------------------------------------------------------------------------------------------------
		
	function OnAbortMaintenance() {}
	//-----------------------------------------------------------------------------------------------------
	// Updates the file 'Maintenance_SNxxxx_Params.xls' with the original params
	// 
	//	RETURN		none
	//-----------------------------------------------------------------------------------------------------



   // ====================================================================================================
   //
   // ================================= Nano pipettor functions ==========================================
   //
   // ====================================================================================================

	//-----------------------------------------------------------------------------------------------------
	function nanoPipettorMaintenance(device ML_STAR, variable processID) {}
	//-----------------------------------------------------------------------------------------------------
	// Execute maintenance for installed Nano Pipettor Daily Maintenance
	//
	// RETURN 		none
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function GetProcessStateNano() {}
	//-----------------------------------------------------------------------------------------------------
	//
	// RETURN		maintenance process states:  mpsFailed(0); mpsSuccessful(1);
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function CreateReportFileNano( variable &templateFile, variable &reportFileName, variable &reportExcelAreaName ) {}
	//-----------------------------------------------------------------------------------------------------
	// Creates a maintenance report file
	//
	// RETURN		none
	//-----------------------------------------------------------------------------------------------------



   // ====================================================================================================
   //
   // ================================= Easy Puncher functions ===========================================
   //
   // ====================================================================================================
	//-----------------------------------------------------------------------------------------------------
	function EasyPuncher_MaintenanceDaily( device ML_STAR) {}
	//-----------------------------------------------------------------------------------------------------
	// Execute maintenance for installed Easy puncher (Daily Maintenance)
	//
	// RETURN 		none
	//-----------------------------------------------------------------------------------------------------


	//-----------------------------------------------------------------------------------------------------
	function EasyPuncher_MaintenanceWeekly( device ML_STAR ) {}
	//-----------------------------------------------------------------------------------------------------
	// Execute maintenance for installed Easy puncher (Weekly Maintenance)
	//
	// RETURN 		none
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function HasEasyPuncher() variable { return(hslFalse); }
	//-----------------------------------------------------------------------------------------------------
	//
	// RETURN		hslTrue if an easy puncher is installed, else hslFalse
	//-----------------------------------------------------------------------------------------------------


} // namespace MtcLib

#endif	// HSL_RUNTIME

//--------------------------------------------------------------------------------------------------------------------------------------
// Section 2 : Implementation of MaintenanceLibrary
//--------------------------------------------------------------------------------------------------------------------------------------

#ifdef HSL_RUNTIME	// Parser constant, always defined at
							// run-time, but not at edit-time.

namespace MtcLib		// This will prevent clashing of variable
							// and function names across libraries.
{

	//=====================================================================================================
	// includes
	//=====================================================================================================
	#ifndef __HSLStrLib_hsl__
	#include "HSLStrLib.hsl"
	#endif

	#ifndef __HSLStringTableLib_hsl__
	#include "HSLStringTableLib.hs_"
	#endif

	#ifndef __HSLMthLib_hsl__
	#include "HSLMthLib.hsl"
	#endif

	#ifndef __HSLFilLib_hsl__
	#include "HSLFilLib.hsl"
	#endif

	#ifndef __HSLTimLib_hsl__
	#include "HSLTimLib.hsl"
	#endif

	#ifndef __HSLDevLib_hsl__
	#include "HSLDevLib.hsl"
	#endif

	#ifndef __HSLVacuuBrandPumpImpl_hsl__
	#include "HSLVacuuBrandPump.hs_"
	#endif

	#ifndef __HslStarLineMaintMetConst_hsl__
	#include "HslStarLineMaintMetConst.hs_"
	#endif

   #ifndef __HSLArrLib_hsl__
	#include "HSLArrLib.hsl"
   #endif

	/*#ifndef __HSLDeckVisualize_hsl__
	#include "HSLDeckVisualize.hsl"
	#endif*/


	//=====================================================================================================
	// declaration of variables and constants
	//=====================================================================================================

	// error string table
	namespace IDE // error string ID
	{
		static const variable first(0);
		static const variable firmwareCommandFailed(first + 1);
		static const variable fileCopyFailed(first + 2);
		static const variable fileOpenFailed(first + 3);
		static const variable cfgAutoloadMissing(first + 4);
		static const variable timerSetError(first + 5);
		static const variable timerWaitError(first + 6);
		static const variable unknownChannel(first + 7);
		static const variable templateFileNotExist(first + 8);
		static const variable hardwareError(first + 9);
		static const variable noWashFluidError(first + 10);
		static const variable unexpectedInstrumentError(first + 11);
		static const variable parseFirmwareCommandFailed(first + 12);
		static const variable last(first + 12);
	}

	// string table
	namespace IDS // string ID
	{
		static const variable first(IDE::last + 1);
		static const variable trcDialogOK(first + 1); 
		static const variable trcDialogCancel(first + 2); 
		static const variable trcInstrName(first + 3); 
		static const variable trcUserSwVersion(first + 4); 
		static const variable trcOperator(first + 5); 
		static const variable trcInstrSerialNo(first + 6); 
		static const variable trcInstrNoOfChannels1000ul(first + 7); 
		static const variable procStateSuccessful(first + 8); 
		static const variable procStateFailed(first + 9); 
		static const variable checkSuccessful(first + 10); 
		static const variable checkFailed(first + 11); 
		static const variable buildOverPressure1000ulFailed(first + 12); 
		static const variable dropOverPressure1000ulFailed(first + 13); 
		static const variable buildUnderPressure1000ulFailed(first + 14); 
		static const variable dropUnderPressure1000ulFailed(first + 15); 
		static const variable cLLDcheck1000ulAirFailed(first + 16); 
		static const variable cLLDcheck1000ulBlockFailed(first + 17); 
		static const variable testSum(first + 18); 
		static const variable channel1000ul(first + 19); 
		static const variable tightnessCheckFailed(first + 20); 
		static const variable cLLDCheckFailed(first + 21); 
		static const variable measuredLeakage(first + 22); 
		static const variable reachedPressure(first + 23); 
		static const variable reachedVacuum(first + 24); 
		static const variable trcTypeOfPumps(first + 25); 
		static const variable dlgCheckWashModulesTitle(first + 26); 
		static const variable dlgCheckWashModulesText(first + 27); 
		static const variable dlgWashRinseContFullTitle(first + 28); 
		static const variable dlgWashRinseContFullText(first + 29); 
		static const variable dlgWashRinseContEmptyText(first + 30); 
		static const variable dlgLoadNeedlesTitle(first + 31); 
		static const variable dlgLoadNeedlesText(first + 32); 
		static const variable checkNotInstalled(first + 33); 
		static const variable checkNotPerformed(first + 34); 
		static const variable checkInstalled(first + 35); 
		static const variable noChannelsInstalled(first + 36); 
		static const variable checkPerformed(first + 37); 
		static const variable procStateIncomplete(first + 38); 
		static const variable trcDialogYes(first + 39); 
		static const variable trcDialogNo(first + 40); 
		static const variable dlgWash96Wash1Title(first + 41); 
		static const variable dlgWash96Wash1Text(first + 42); 
		static const variable dlgWash96Wash6Title(first + 43); 
		static const variable dlgWash96Wash6Text(first + 44); 
		static const variable dlgWash96Wash8Title(first + 45); 
		static const variable dlgWash96Wash8Text(first + 46); 
		static const variable dlgWash3rdWash1Title(first + 47); 
		static const variable dlgWash3rdWash1Text(first + 48); 
		static const variable dlgWash3rdWash6Title(first + 49); 
		static const variable dlgWash3rdWash6Text(first + 50); 
		static const variable traceSource(first + 51); 
		static const variable traceActionCORE96HeadWashMaint(first + 52); 
		static const variable titleErrorHandling(first + 53); 
		static const variable errorDuringCORE96HeadWashMaint(first + 54); 
		static const variable errorIgnoredByOperator(first + 55); 
		static const variable errorRetry(first + 56); 
		static const variable trcDialogAbort(first + 57); 
		static const variable trcDialogRetry(first + 58); 
		static const variable trcDialogIgnore(first + 59); 
		static const variable dlgWash3rdWashRinseTitle(first + 60); 
		static const variable dlgWash3rdWashRinseText(first + 61); 
		static const variable dlgWash3rdWashFullDailyTitle(first + 62); 
		static const variable dlgWash3rdWashFullDailyText(first + 63); 
		static const variable dlgWashCrWashFullDailyTitle(first + 64); 
		static const variable dlgWashCrWashFullDailyText(first + 65); 
		static const variable dlgWashCrWashRinseTitle(first + 66); 
		static const variable dlgWashCrWashRinseText(first + 67); 
		static const variable dlgDailyDCWash1Title(first+ 68); 
		static const variable dlgDailyDCWash2Title(first+ 69); 
		static const variable dlgDailyDCWash3Title(first+ 70); 
		static const variable traceActionDailyDCWashStation(first+ 71); 
		static const variable dlgWeeklyDCWash1Title(first+ 72); 
		static const variable dlgWeeklyDCWash1Text(first+ 73); 
		static const variable dlgWeeklyDCWash3Title(first+ 74); 
		static const variable dlgWeeklyDCWash3Text(first+ 75); 
		static const variable traceActionWeeklyDCWashStation(first+ 76); 
		static const variable errorDuringWeeklyDCWashStationMaint(first+ 77); 
		static const variable dlgDaily_96_384_Wash1Title(first + 78); 
		static const variable dlgDaily_96_384_Wash1Text(first + 79); 
		static const variable dlgDaily_96_384_Wash2Title(first + 80); 
		static const variable dlgDaily_96_384_Wash2Text(first + 81); 
		static const variable dlgDaily_96_384_Wash3Title(first + 82); 
		static const variable dlgDaily_96_384_Wash3Text(first + 83); 
		static const variable traceActionDaily_96_384_WashStation(first + 84); 
		static const variable errorDuringDaily_96_384_WashStationMaint(first + 85); 
		static const variable dlgWeekly_96_384_Wash1Title(first + 86); 
		static const variable dlgWeekly_96_384_Wash1Text(first + 87); 
		static const variable dlgWeekly_96_384_Wash2Title(first + 88); 
		static const variable dlgWeekly_96_384_Wash2Text(first + 89); 
		static const variable dlgWeekly_96_384_Wash3Title(first + 90); 
		static const variable dlgWeekly_96_384_Wash3Text(first + 91); 
		static const variable traceActionWeekly_96_384_WashStation(first + 92); 
		static const variable errorDuringWeekly_96_384_WashStationMaint(first + 93); 
		static const variable dlgExecuteDailyBVSTitle(first + 94); 
		static const variable dlgExecuteDailyBVSInstalledText(first + 95); 
		static const variable dlgDailyBVSWash1Title(first + 96); 
		static const variable dlgDailyBVSWash1Text(first + 97); 
		static const variable dlgDailyBVSWash2Title(first + 98); 
		static const variable dlgDailyBVSWash2Text(first + 99); 
		static const variable dlgDailyBVSWash3Title(first + 100); 
		static const variable dlgDailyBVSWash3Text(first + 101); 
		static const variable dlgDailyBVSWash4Title(first + 102); 
		static const variable dlgDailyBVSWash4Text(first + 103); 
		static const variable dlgExecuteWeeklyBVSTitle(first + 104); 
		static const variable dlgExecuteWeeklyBVSInstalledText(first + 105); 
		static const variable dlgWeeklyBVSWash1Title(first + 106); 
		static const variable dlgWeeklyBVSWash1Text(first + 107); 
		static const variable dlgWeeklyBVSWash2Title(first + 108); 
		static const variable dlgWeeklyBVSWash2Text(first + 109); 
		static const variable dlgWeeklyBVSWash3Title(first + 110); 
		static const variable dlgWeeklyBVSWash3Text(first + 111); 
		static const variable dlgWeeklyBVSWash4Title(first + 112); 
		static const variable dlgWeeklyBVSWash4Text(first + 113); 
		static const variable dlgWeeklyDCWash2Title(first+ 114); 
		static const variable dlgWeeklyDCWash2Text(first+ 115); 
		static const variable dlgSleepForWashTime(first+ 116); 
		static const variable errorDuringDailyDCWashStationMaint(first+ 117);
		static const variable dlgWashRinseContEmptyTitle(first + 118);  	   
		static const variable dlgDailyDCWash1Text(first+119);
		static const variable dlgDailyDCWash2Text(first+120);
		static const variable dlgDailyDCWash3Text(first+121);
		static const variable errorDuringBVSInitText(first+122);
		static const variable dlgDailyCloseCoverTitle(first+123);
		static const variable dlgDailyCloseCoverText(first+124);
		static const variable dlgWeeklyCloseCoverTitle(first+125);
		static const variable dlgWeeklyCloseCoverText(first+126);
		static const variable soakTimerWaitText(first+127);
      // nano pipettor
		static const variable dlgCheckNanoPipettorTitleMorning(first + 128);
		static const variable dlgNanoOpenTheBottleText(first + 129);
		static const variable dlgNanoCheckPressureHe(first + 130);
		static const variable dlgNanoChangeBottleHe(first + 131);
		static const variable dlgNanoPressureOfHelium(first + 132);
		static const variable dlgNanoMBAR(first + 133);
		static const variable dlgNanoHeLow(first + 134);
		static const variable dlgNanoHeHigh(first + 135);
		static const variable dlgCheckNanoPipettorTitleDecontamination(first + 136);
		static const variable dlgCheckNanoPipettorTitleStartUp(first + 137);
		static const variable dlgNanoCO2High(first + 138);
		static const variable dlgNanoFillUpWaterHand(first + 139);
		static const variable dlgNanoEnterXPosition(first + 140);
	   static const variable dlgNanoAddCarrierTitle(first + 141);
   	static const variable dlgNanoSparging(first + 142);
	   static const variable dlgNanoServiceCarrier(first + 143);
	   static const variable dlgNanoEmptyWasteChamber(first + 144);
	   static const variable dlgNanoHeIsToHigh(first + 145);
	   static const variable dlgNanoHeIsToLow(first + 146);
	  	static const variable dlgNanoTraceUser(first + 147);
	  	static const variable dlgNanoPressureHe30(first + 148);
	   static const variable dlgNanoTraceSystem(first + 149);
	   static const variable dlgNanoWaterSystemFull(first + 150);
	   static const variable dlgNanoWasteContainerHand(first + 151);
	   static const variable dlgNanoWasteContainerIsEmpty(first + 152);
	   static const variable dlgNanoCloseValves(first + 153);
		static const variable dlgNanoExchangeCleaningLiquid(first + 154);
		static const variable dlgNanoXPositionConform0(first + 155);
		static const variable dlgNanoXPositionConform1(first + 156);
		static const variable dlgNanoXPositionConform2(first + 157);
		static const variable dlgNanoXPositionConform3(first + 158);
		static const variable dlgNanoTrackPosition(first + 159);
		static const variable dlgNanoTrackPosition1(first+ 160);
      static const variable dlgNano8_Channel_Head_not_installed(first+ 161);
      static const variable dlgNano8_Channel_Head_high_viscosity_installed(first+ 162);
      static const variable dlgNano8_Channel_Head_low_volume_installed(first+ 163);
      static const variable dlgNanon_channel_head_not_installed(first+ 164);
      static const variable dlgNanon_channel_head_high_viscosity_installed(first+ 165);
      static const variable dlgNanon_channel_head_low_volume_installed(first+ 166);
      static const variable dlgNanoDraying_Time(first+ 167);
		static const variable dlgNanoCO2Low(first + 168);
		static const variable dlgNanoPressureOfCO2(first + 169);
		static const variable dlgNanoDryHeliumPump(first + 170);
		static const variable dlgNanoDryHeliumPumpError(first + 171);
      static const variable dlgNanoWrongXPosition(first + 172);
      static const variable dlgNanoHeHighEndCorrection(first + 173);
      static const variable dlgNanoRemoveWaterFromSystem(first + 174);
      static const variable dlgNanoRemoveWaterFromSystemError(first + 175);
      static const variable dlgNanoFillUpDecontaminateFluid(first + 176);
      static const variable dlgNanoDecontaminateSystem(first + 177);
      static const variable dlgNanoDecontaminateSystemError(first + 178);
      static const variable dlgNanoRemoveDecontWaterFromSystem(first + 179);
      static const variable dlgNanoRemoveDecontWaterFromSystemError(first + 180);
      static const variable dlgNanoFillUpRinseWaterFluid(first + 181);
      static const variable dlgNanoRinseSystem(first + 182);
      static const variable dlgNanoRinseSystemError(first + 183);
      static const variable dlgNanoRemoveRinseWaterFromSystem(first + 184);
      static const variable dlgNanoRemoveRinseWaterFromSystemError(first + 185);
      static const variable dlgNanoEmptyRefillContainer(first + 186);
      static const variable dlgNanoRefillContainerNeedsToBeEmpty(first + 187);
      static const variable dlgNanoMoveToWaste(first + 188);
      static const variable dlgNanoMoveToWasteError(first + 189);
      // end nano pipettor

      static const variable trcInstrNoOfChannels5ml(first + 190);
		static const variable cLLDcheck5mlAirFailed(first + 191); 
		static const variable cLLDcheck5mlBlockFailed(first + 192); 
		static const variable buildOverPressure5mlFailed(first + 193); 
		static const variable dropOverPressure5mlFailed(first + 194); 
		static const variable buildUnderPressure5mlFailed(first + 195); 
		static const variable dropUnderPressure5mlFailed(first + 196); 
		static const variable channel5ml(first + 197); 

		static const variable buildOverPressure96TadmHeadFailed(first + 198); 
		static const variable dropOverPressure96TadmHeadFailed(first + 199); 
		static const variable buildUnderPressure96TadmHeadFailed(first + 200); 
		static const variable dropUnderPressure96TadmHeadFailed(first + 201); 
		static const variable trcInstr96TadmHead(first + 202); 
		static const variable dlg96TadmHeadTitle(first + 203); 
		static const variable dlg96TadmHeadCarrierMissing(first + 204);
		static const variable dlg96TadmHeadCarrierPosition(first + 205);
		static const variable err96TadmHeadCannotMoveToTool(first + 206);
		static const variable dlg96TadmHeadCheckTool(first + 207);
		static const variable channel96TadmHead(first + 208); 

		static const variable easyPunchDlgTitle(first + 209);
		static const variable easyPunchDlgWTitle(first + 210);
		static const variable easyPunchDlgCleanWaste(first + 211);
		static const variable easyPunchDlgCleanFrame(first + 212);
		static const variable easyPunchDlgCleanDeck(first + 213);
		static const variable easyPunchDlgCleanHead(first + 214);
		static const variable easyPunchDlgInsertSN(first + 215);
		static const variable easyPunchDlgInsertPN(first + 216);
  		static const variable easyPunchDlgMountHead(first + 217);
		static const variable easyPunchDlgChangeHead(first + 218);
		static const variable easyPunchDlgCleanDustWaste(first + 219);
		static const variable easyPunchDlgCleanGripClamp(first + 220);
      static const variable easyPunchIonisatorStateFailed(first + 221);
      static const variable easyPunchXyzCheckFailed(first + 222);
      static const variable easyPunchCloseFrontCover(first + 223);

		static const variable last(first+223);
	}

	// String and number constants used for dynamic decklayout creation
	namespace LabwrData
	{
		//******************************
		//*  String constants
		//******************************

		// labware file names
		static const variable crWS1FileName("\\ML_STAR\\WASHSTATION\\Car_Wash_1_CR_HighNeedle_A00.tml");
		static const variable crWS2FileName("\\ML_STAR\\WASHSTATION\\Car_Wash_2_CR_HighNeedle_A00.tml");

		static const variable gen3rdWS1FileName("\\ML_STAR\\Car_Wash_1_300ulNeedle.tml");
		static const variable gen3rdWS2FileName("\\ML_STAR\\Car_Wash_2_300ulNeedle.tml");

		static const variable core96HeadWashstationHU("\\ML_STAR\\96CoreHead\\CORE_HU_96WashStation_A00.tml");
		static const variable core96HeadWashstationHV("\\ML_STAR\\96CoreHead\\CORE_HV_96WashStation_A00.tml");
		static const variable core96HeadWashstationHW("\\ML_STAR\\96CoreHead\\CORE_HW_96WashStation_A00.tml");

		static const variable core96DualWashstationHU("\\ML_STAR\\96CoreHead\\CORE96DualWashStation_HU_A00.tml");
		static const variable core96DualWashstationHV("\\ML_STAR\\96CoreHead\\CORE96DualWashStation_HV_A00.tml");
		static const variable core96DualWashstationHW("\\ML_STAR\\96CoreHead\\CORE96DualWashStation_HW_A00.tml");

		static const variable core384HeadDualWashstationHU("\\ML_STAR\\384CoreHead\\CORE384DualWashStation_HU_A00.tml");
		static const variable core384HeadDualWashstationHV("\\ML_STAR\\384CoreHead\\CORE384DualWashStation_HV_A00.tml");
		static const variable core384HeadDualWashstationHW("\\ML_STAR\\384CoreHead\\CORE384DualWashStation_HW_A00.tml");

		static const variable DCWashstationHU("\\ML_STAR\\WASHSTATION\\DC_WashStation_300ul_CR_Needle_HU.rck");
		static const variable DCWashstationHV("\\ML_STAR\\WASHSTATION\\DC_WashStation_300ul_CR_Needle_HV.rck");
		static const variable DCWashstationHW("\\ML_STAR\\WASHSTATION\\DC_WashStation_300ul_CR_Needle_HW.rck");


		// labware id
		static const variable crWS1LabId("CR_Washer1");
		static const variable crWS2LabId("CR_Washer2");

		static const variable gen3rdWS1LabId("Gen3_Washer1");
		static const variable gen3rdWS2LabId("Gen3_Washer2");

		static const variable core96HeadWsHULabId("core96DualWashstationHU");
		static const variable core96HeadWsHVLabId("core96HeadWashstationHV");
		static const variable core96HeadWsHWLabId("core96HeadWashstationHW");

		static const variable core96DualWashstationHULabId("core96DualWashstationHU");
		static const variable core96DualWashstationHVLabId("core96DualWashstationHV");
		static const variable core96DualWashstationHWLabId("core96DualWashstationHW");

		static const variable core384DualWashstationHULabId("core384DualWashStationHU");
		static const variable core384DualWashstationHVLabId("core384DualWashStationHV");
		static const variable core384DualWashstationHWLabId("core384DualWashStationHW");

		static const variable DCWashstationHULabId("DCWashstationHU");
		static const variable DCWashstationHVLabId("DCWashstationHV");
		static const variable DCWashstationHWLabId("DCWashstationHW");


		// preloaded rack labware id
		static const variable crWS1RackId1("washstation_1_cr_highneedle_a00_0001");
		static const variable crWS1RackId2("washstation_2_cr_highneedle_a00_0001");
		static const variable crWS1RackId3("washstation_3_cr_highneedle_a00_0001");
		static const variable crWS2RackId1("washstation_4_cr_highneedle_a00_0001");
		static const variable crWS2RackId2("washstation_5_cr_highneedle_a00_0001");
		static const variable crWS2RackId3("washstation_6_cr_highneedle_a00_0001");

		static const variable gen3rdWS1RackId1("washstation_1_300ulneedle_0001");
		static const variable gen3rdWS1RackId2("washstation_2_300ulneedle_0001");
		static const variable gen3rdWS1RackId3("washstation_3_300ulneedle_0001");
		static const variable gen3rdWS2RackId1("washstation_4_300ulneedle_0001");
		static const variable gen3rdWS2RackId2("washstation_5_300ulneedle_0001");
		static const variable gen3rdWS2RackId3("washstation_6_300ulneedle_0001");

		// labware file names Nanopipettor
		static const variable nanoService_carrier("\\ML_STAR\\NANO\\service_carrier.tml");
		// labware id
		static const variable NanoService_CarrierId("service_carrier");

      // labware for easy puncher
		static const variable easyPuncherHW("\\ML_STAR\\PUNCHER\\PuncherModule.tml");
		static const variable easyPuncherHWLabId("PuncherModule");


		//******************************
		//*  number constants
		//******************************

		static const variable washStation1(1);
		static const variable washStation2(2);

		static const variable startWithWashLiquidOne(0); // wash solution
		static const variable startWithWashLiquidTwo(1); // rinse solution

		// Cr and 3rd Wash Stations
		static const variable tRinseTime60(60);
		static const variable tSoakTime1(1);
		static const variable tSoakTime300(300);
		static const variable tFlowRate12(12);
		static const variable tDrainingTime12(12);

		// 96CoreHeadWashStation
		static const variable tSoakTimeWait(300);
	}

	// --------------------------------------------------------------------------------------
	// Tracing
	// --------------------------------------------------------------------------------------
	namespace TraceStatus
	{
		static const variable start(1);									// action status for formated trace
		static const variable complete(2);								// action status for formated trace
		static const variable error_(3);									// action status for formated trace
		static const variable progress(4);								// action status for formated trace
		static const variable completeWithError(5);					// action status for formated trace
	}

	// --------------------------------------------------------------------------------------
	// Firmware Error codes
	// --------------------------------------------------------------------------------------
	namespace C0ErrorCode
	{
		// master error messages
		static const variable syntaxError 	   		( 1);
		static const variable hardwareError    		( 2);
		static const variable noWashFluidError 		(18);
		static const variable slaveError 				(99);
	}

	namespace DCWasherErrCode
	{
		// slave error information
		static const variable ls1NotSwitchToActive	(50);
		static const variable ls2NotSwitchToActive	(51);
		static const variable ls1NotSwitchToInactive	(60);
		static const variable ls2NotSwitchToInactive	(61);
	}

   namespace STARWatch
   {	
   	static variable deviceAddress("");        // last device address
      static variable deviceType("");           // device type
   	static variable techData("");	            // technical data of device 

   	// Const for STAR Watch keyword definitions
   	static const variable statusFailed("FAILED");
   	static const variable statusOK("OK");
   	static const variable statusReport("REPORTED");
   	static const variable statusTrend("TREND");
   	static const variable statusNA("NA");  // status: not applicable

   	//static const variable cLDDCheck("CLLD_CHECK");
   	static const variable cycleCounter("CYCLES");
   	static const variable deviceInfo("DEVICE");
     	//static const variable startUpStatus("START_UP");
   	//static const variable trend("TREND");
   	//static const variable tightness("TIGHTNESS");
      static const variable jonisatorState("JONISATORSTATE");
      static const variable easyPunchHeadCount("EASYPUNCHHEADCOUNT");
      static const variable easyPunchXJustage("EASYPUNCHXJUSTAGE");
      static const variable easyPunchYJustage("EASYPUNCHYJUSTAGE");
      static const variable easyPunchZJustage("EASYPUNCHZJUSTAGE");
      static const variable easyPunchLagData("EASYPUNCHLAGDATA");
   }

	// firmware acknowledge
	static const string 		fwRetOk("er00");
	static const variable 	fwRetOkLength(4); 		// number of char from fwRetOk


	// process state variables
	static variable overallProcessedState(PS::failed);
	static variable tightnessCheckChannel1000ulState(PS::notInstalled);
	static variable cLLDCheckChannel1000ulState(PS::notInstalled);
	static variable tightnessCheckChannel5mlState(PS::notInstalled);
	static variable cLLDCheckChannel5mlState(PS::notInstalled);
	static variable instrumentCheckState(PS::notInstalled);
	static variable needleWashStation_1_CheckState(PS::notInstalled);
	static variable needleWashStation_2_CheckState(PS::notInstalled);
	static variable crWashStation_1_CheckState(PS::notInstalled);
	static variable crWashStation_2_CheckState(PS::notInstalled);
	static variable dcWashStation_HU_CheckState(PS::notInstalled);
	static variable dcWashStation_HV_CheckState(PS::notInstalled);
	static variable dcWashStation_HW_CheckState(PS::notInstalled);
	static variable head96WashStation_HU_CheckState(PS::notInstalled);
	static variable head96WashStation_HV_CheckState(PS::notInstalled);
	static variable head96WashStation_HW_CheckState(PS::notInstalled);
	static variable head_96_384_WashStation_HU_CheckState(PS::notInstalled);
	static variable head_96_384_WashStation_HV_CheckState(PS::notInstalled);
	static variable head_96_384_WashStation_HW_CheckState(PS::notInstalled);
	static variable BVS_CheckState(PS::notInstalled);
	static variable BVS(PS::notInstalled);
  	static variable nanoPipettorCheckState(PS::notInstalled);
	static variable tightnessCheckChannel96TadmHeadState(PS::notInstalled);
	static variable easyPuncherState(PS::notInstalled);



	// initialization state of the Maintenance Methods Library
	static variable initializedLib(hslFalse);

	//********************************************************
	//* configuration
	//********************************************************
	static string operatorName;
	static string releaseVersion;
	static string instrName;
	static string instrSerialNo;
   
	static variable instrNumberOfChannels1000ul;
   static variable instrNumberOfChannels5ml;
	static variable coverLocking;
	static variable autoLoad;
	static variable washStation1;
	static variable washStation2;

	// extended configuration
	static variable pumpStation1;
	static variable pumpStation2;
	static variable pumpStation3;
	static variable exwashStation1;
	static variable exwashStation2;
   static variable head96TadmHead;                // 0 = TADM head not installed, 1 = installed

	// pump unit type
	static variable pumpTypeStation1;
	static variable pumpTypeStation2;
	static variable pumpTypeStation3;

	// left arm
	static variable leftArmHasChannel;
	static variable leftArmHasISwap;
	static variable leftArmHas96Head;
	static variable leftArmHas384Head;
	static variable leftArmHasNanoDisp;		
	static variable leftArmHasXlChannels;			// added 2010-01-21/cjoerg
	static variable leftArmHasTubeGripper;			// added 2010-01-21/cjoerg		
	static variable leftArmHasImagingChannel;		// added 2010-01-21/cjoerg
   static variable leftArmHasCardGripper;

	// right arm
	static variable rightArmHasChannel;
	static variable rightArmHasISwap;
	static variable rightArmHas96Head;
	static variable rightArmHas384Head;
	static variable rightArmHasNanoDisp;	
	static variable rightArmHasXlChannels;			// added 2010-01-21/cjoerg	
	static variable rightArmHasTubeGripper;		// added 2010-01-21/cjoerg		
	static variable rightArmHasImagingChannel;	// added 2010-01-21/cjoerg
   static variable rightArmHasCardGripper;
	static variable maxRightX;
	static variable minRightX;
	static variable maxLeftX;
	static variable minLeftX;
	
	// Nano Dispenser
	static variable nanoPipettor;
	static variable nanoPipettorPlusN;
   static string   nanoSerialNo;
	
   //	Temp. controlled carriers
	static variable TempControlledCarrier1;
	static variable TempControlledCarrier2;

   // puncher and puncher card handler
   static variable cardGripper;
   static variable easyPuncher;
   private variable kq, mx0, mx1, mx2, my0,my1, mz0, mz1, pc0, pc1, pc2;
   const variable cardGripperXstepResPuncher(1140.0/34121.0);    // [0.1mm/Step]  ==> 0.00334105096568096mm/step      
   const variable cardGripperYstepResPuncher(1630.0/48773.0);    // [0.1mm/Step]  ==> 0.0033420129989953mm/step      
   const variable cardGripperZstepResPuncher(300.0/149299.0);    // [0.1mm/Step]  ==> 0.00020093905518456mm/step      
   const variable cardGripperYstepResGripper(4530.0/ 145607.0);  // [0.1mm/Step] ==> 0.0031111141634674mm/step
   const variable cardGripperZstepResGripper(5.0/128.0);         // [0.1mm/Step] ==> 0.00390625mm/step
   const variable cardGripperJustageTorerance(1.0);               // tolerance to saved justage data
//   private variable cardInPuncherHead(hslFalse);


	//********************************************************
	
	static const string traverseHeightForFwCommand("2450");

	static const variable maxNoOfChannel1000ul(16);
	static const variable maxNoOfChannel5ml(8);
   static const variable maxNoOfChannel96TadmHead(96);            // count of head channels

	static const variable stepsPerMiliMeterChannel1000ul(93.217);	// see E2890005a, Pip Channel (1000ul) Resolution Z-drive
	static const variable stepsPerMiliMeterChannel5ml(93.217);		// see E2890243a, XL Pip Channel (5m) Resolution Z-drive

	static const variable maintNeedleLengthChannel1000ul(51.9);
	static const variable maintNeedleLengthChannel5ml(108.0);

	static variable instrNumberOfNeedles1000ul;		// number of 1000ul maintenance needles
	static variable instrNumberOfNeedles5ml;			// number of 5ml maintenance needles

	// Declaration of variables for Pressure Controller
   static variable SystemPressure(0);           // System Pressure in [mbar]
   static variable VacuumPressure(0);           // vacuum Pressure in [mbar]
   static variable HeliumPressure(0);           // Helium Pressure in [mbar]
   static variable CO2Pressure(0);              // CO2    Pressure in [mbar]

   // Declaration of const variables for Nano Pressure Controller
   static const variable HeliumPressureHigh(1950);    //  1950 Helium Pressure in [mbar]
   static const variable HeliumPressureLow(1650);     //  1650 Helium Pressure in [mbar]

   static const variable CO2HVPressureHigh(850);      //  850 CO2 Pressure in [mbar]
   static const variable CO2HVPressureLow(650);       //  650 CO2 Pressure in [mbar]
   static const variable CO2HVPressureDefault(0.75);  //  750 CO2 Pressure in [bar] default value for trace

	static const variable CO2LVPressureHigh(650);      //  650 CO2 Pressure in [mbar]
   static const variable CO2LVPressureLow(450);       //  450 CO2 Pressure in [mbar]
   static const variable CO2LVPressureDefault(0.55);  //  550 CO2 Pressure in [bar] default value for trace

   // Request Nano serial number
   static const variable NanoSerialNoPos(10);          // 0 based position of nano serial number
   static const variable NanoSerialNoLenght(4);        // length of nano serial number

   // Request Nano liquid level sensors
   static const variable SystemReservoirLiquidLevelSensor_1(0);   // 1st value :	System reservoir liquid level sensor 1
   static const variable SystemReservoirLiquidLevelSensor_2(2);   // 2nd value :	System reservoir liquid level sensor 2
   static const variable WasteReservoirLiquidLevelSensor_1(4);    // 3rd value :	Waste reservoir liquid level sensor 1
   static const variable WasteReservoirLiquidLevelSensor_2(6);    // 4th value :	Waste reservoir liquid level sensor 2
   static const variable RefillReservoirLiquidLevelSensor_1(8);   // 5th value :	Refill reservoir liquid level sensor 1
   static const variable RefillReservoirLiquidLevelSensor_2(10);  // 6th value :	Refill reservoir liquid level sensor 2
   static const variable UltrasonicBathLiquidLevelSensor(12);     // 7th value :	Ultrasonic bath liquid level sensor
   static const variable WasteOnDeckLiquidlevelsensor(14);        // 8th value :	Waste on deck liquid level sensor

   // Nano decontamination wait time
   static const variable NanoDecontaminationWaitTime(1200);       // time in seconds to wait for steep od decontaminate fluid
   static const variable NanoBeforeEmptyRefillCont1WaitTime(1200);// time in seconds to wait before start empty refill container
   static const variable NanoDryWaitTime1(120);                   // time in seconds to wait for dry the seyonic from water
   static const variable NanoDryWaitTime2(30);                    // time in seconds to wait for dry the seyonic from ethanol
   static const variable NanoDryWaitTime3(300);                   // time in seconds to wait for dry the seyonic from rinse water


	// solenoid valve of NP nano pressure controller
   static const variable NP_SolenoidValve_B("00");    // Valve B number  vn00
   static const variable NP_SolenoidValve_H("01");    // Valve H number  vn01
   static const variable NP_SolenoidValve_I("02");    // Valve I number  vn02
   static const variable NP_SolenoidValve_K("03");    // Valve K number  vn03
   static const variable NP_SolenoidValve_N("04");    // Valve N number  vn04
   static const variable NP_SolenoidValve_P("05");    // Valve P number  vn05
   static const variable NP_SolenoidValve_Q("06");    // Valve Q number  vn06
   static const variable NP_SolenoidValve_R("07");    // Valve R number  vn07
   static const variable NP_SolenoidValve_S("08");    // Valve S number  vn08 has changes in new version > E0.2
   static const variable NP_SolenoidValve_T("09");    // Valve T number  vn09
   static const variable NP_SolenoidValve_U("10");    // Valve U number  vn10
   static const variable NP_SolenoidValve_V("11");    // Valve V number  vn11
   static const variable NP_SolenoidValve_W("12");    // Valve W number  vn12
   static const variable NP_SolenoidValve_X("13");    // Valve X number  vn13
   static const variable NP_SolenoidValve_Y("14");    // Valve Y number  vn14 exist only in old version E0.2
	// solenoid valve of N0 nano ppipettor
   static const variable N0_SolenoidValve_D("0");     // Valve D number  vn0
   static const variable N0_SolenoidValve_E("1");     // Valve E number  vn1
   static const variable N0_SolenoidValve_F("2");     // Valve F number  vn2
   static const variable N0_SolenoidValve_G("3");     // Valve G number  vn3
   static const variable N0_SolenoidValve_L("4");     // Valve L number  vn4
	// nano pipettor valve
   static const variable pipettorValve_8_Head("0");   // Valve for channels on head 8
   static const variable pipettorValve_N_Head("1");   // Valve for channel on head N
   // nano waste position
   static variable NanoWasteX(0.0);                   // x position of nano waste
   static variable NanoWasteY(0.0);                   // y position of nano waste
   static variable NanoWasteZ(0.0);                   // z position of nano waste
   static const variable NanoWasteZMoveUpDist(15.0);  // 15 mm above labware definition

	// waste block check position
	static string checkPosX; // X position in 0.1mm
	static string checkPosY; // Y position in 0.1mm
	static string checkPosZ; // Z position in 0.1mm

	// 1000ul channels data (array from 0..15 for channel 1..16)
	// --> common channel data
	static variable chanNeedleIndex1000ul[];	 		// needle index (0..7) assigned to channel
	// --> channel tightness results
	static variable chanUPressBeginTimer1000ul[];	// values of under pressure measurements, on start timer
	static variable chanUPressEndTimer1000ul[];		// values of under pressure measurements, on end timer
	static variable chanOPressBeginTimer1000ul[];	// values of over pressure measurements, on start timer
	static variable chanOPressEndTimer1000ul[];		// values of over pressure measurements, on end timer
	// --> channel cLLD check results
	static variable chanDetectLevelAir1000ul[];		// hslTrue if level detected (in the air); otherwise hslFalse
	static variable chanDetectLevelBlock1000ul[];	// hslTrue if level detected (on waste block); otherwise hslFalse

	// 5ml channels data (array from 0..7 for channel 1..8)
	// --> common channel data
	static variable chanNeedleIndex5ml[];	 		// needle index (0..0, because currently only one 5ml Needle) assigned to channel
	// --> channel tightness results
	static variable chanUPressBeginTimer5ml[];	// values of under pressure measurements, on start timer
	static variable chanUPressEndTimer5ml[];		// values of under pressure measurements, on end timer
	static variable chanOPressBeginTimer5ml[];	// values of over pressure measurements, on start timer
	static variable chanOPressEndTimer5ml[];		// values of over pressure measurements, on end timer
	// --> channel cLLD check results
	static variable chanDetectLevelAir5ml[];		// hslTrue if level detected (in the air); otherwise hslFalse
	static variable chanDetectLevelBlock5ml[];	// hslTrue if level detected (on waste block); otherwise hslFalse

	// tightness check constants for 1000ul
	static variable dropLimit1000ul           (400);	// [Pa] <= 4 mbar
	static variable minPressureLimit1000ul   (3500);	// [Pa] minimal pressure >= 35 mbar
	static variable targetPressure1000ul     (4000);	// [Pa] target pressure >= 40 mbar
	static variable maxPressureIncrease1000ul  (30);	// maximal number of pressure increases to reach target pressure

	// tightness check constants for 5ml
	static variable dropLimit5ml            (400);		// [Pa] <= 2 mbar
	static variable minPressureLimit5ml    (9000);		// [Pa] minimal pressure >= 90 mbar
	static variable targetPressure5ml     (10000);		// [Pa] target pressure >= 100 mbar
	static variable maxPressureIncrease5ml   (30);		// maximal number of pressure increases to reach target pressure

	// parameter zc and zh for cLLD check firmware command ZL
	static string zhParamChannel1000ulBlock;
	static string zcParamChannel1000ulBlock;
	static string zhParamChannel1000ulAir;
	static string zcParamChannel1000ulAir;
	static string zhParamChannel5mlBlock;
	static string zcParamChannel5mlBlock;
	static string zhParamChannel5mlAir;
	static string zcParamChannel5mlAir;


	// original parameter values for to restore after temporary changes
	static string zhOriginalChannel1000ul;
	static string zcOriginalChannel1000ul;
	static string ziOriginalChannel1000ul;
	static string zjOriginalChannel1000ul;
	static string zvOriginalChannel1000ul;
	static string zlOriginalChannel1000ul;
	static string dpOriginalChannel1000ul;
	static string zhOriginalChannel5ml;
	static string zcOriginalChannel5ml;
	static string ziOriginalChannel5ml;
	static string zjOriginalChannel5ml;
	static string zvOriginalChannel5ml;
	static string zlOriginalChannel5ml;
	static string dpOriginalChannel5ml;
   static string dqOriginal96TadmHead;                      // original value of parameter dq
	static string zvOriginalCardGripper;
	static string yvOriginalCardGripper;

   // CO-RE 96 Tadm head
   static variable chanUPressBeginTimer96TadmHead[]; 	      // values of under pressure measurements, on start timer
	static variable chanUPressEndTimer96TadmHead[];          // values of under pressure measurements, on end timer
	static variable chanOPressBeginTimer96TadmHead[];        // values of over pressure measurements, on start timer
	static variable chanOPressEndTimer96TadmHead[];          // values of over pressure measurements, on end timer
	// tightness check constants
	static variable dropLimit96TadmHead           (1500);	   // [Pa] <= 15 mbar
	static variable minPressureLimit96TadmHead    (3000);		// [Pa] minimal pressure >= 30 mbar
	static variable targetPressure96TadmHead      (3700);		// [Pa] target pressure >= 37 mbar
	static variable maxPressureIncrease96TadmHead   (50);		// maximal number of pressure increases to reach target pressure
	static variable CoRe96TadmHeadToolX             (0);     // x position of maintenance tool
	static variable CoRe96TadmHeadToolY             (0);     // y position of maintenance tool
   static sequence CoRe96TadmHeadToolSeq;
   static sequence CoRe96TadmHeadToolEjectSeq;
   //static const variable maxNoOfChannel96TadmHead(96);    // see above
	//static string  dqOriginal96TadmHead;                   // see above
	//MERR.tightnessCheckChannel96TadmHeadError[];	         // see above
   //static variable head96TadmHead;                        // see above
   //static variable tightnessCheckChannel96TadmHeadState   // see above
	//static const variable title96TadmHeadRow		   (15); // see below
	//static const variable tightness96TadmHeadRow	   (16); // see below


	// deck positions
	static const variable deckPosFirst(1);
	static const variable deckPosFistHigh(29);
	static variable deckPosLast;              // max positions of autoload slots
   static variable maxDeckSlots;             // max positions of deck slots

	// carriers on deck and loading tray
	static variable deckLowPos;	 		// deck positions low (<deckPosFistHigh)
	static variable deckHighPos; 			// deck positions high (>=deckPosFistHigh)
	static variable loadingTrayLowPos;	// loading tray positions (<deckPosFistHigh)
	static variable loadingTrayHighPos;	// loading tray positions (>=deckPosFistHigh)

	// report file: cell positions (column/row)
	static const variable instrNameCol			(3);
	static const variable instrNameRow					( 5);
	static const variable releaseVersionCol	(6);
	static const variable releaseVersionRow			( 5);
	static const variable instrSerialNoCol		(3);
	static const variable instrSerialNoRow				( 6);

	// general valid/used column pointers:
	static const variable installedFlagCol		(3);				// column for installed or not installed
	static const variable statusCol				(4);				// column for successful, failed, --- (not installed) or not performed

	static const variable deckAndWasteRow				( 8);

	static const variable title1000ulChannelRow		(10);
	static const variable tightnessChannel1000ulRow	(11);
   static const variable cLLDChannel1000ulRow		(12);
	static const variable title5mlChannelRow			(13);
	static const variable tightnessChannel5mlRow		(14);
	static const variable cLLDChannel5mlRow			(15);
	static const variable title96TadmHeadRow		   (16);
	static const variable tightness96TadmHeadRow	   (17);

	static const variable needleWashStation1Row		(19);
	static const variable needleWashStation2Row		(20);

	static const variable crWashStation1Row			(22);
	static const variable crWashStation2Row			(23);

	static const variable hu96WashStationRow			(25);
	static const variable hv96WashStationRow			(26);
	static const variable hw96WashStationRow			(27);

	static const variable dcWashStationHuRow			(29);
	static const variable dcWashStationHvRow			(30);
	static const variable dcWashStationHwRow			(31);

	static const variable hu_96_384_WashStationRow	(33);
	static const variable hv_96_384_WashStationRow	(34);
	static const variable hw_96_384_WashStationRow	(35);

	static const variable bvsRow							(37);

	static const variable easyPunchRow              (39);

	static const variable overallSummaryRow			(43);		// row for Status, Date, Time and Operator
	static const variable processedStateCol	(2); 				// successful,failed or incomplete
	static const variable dateCol					(3);
	static const variable timeCol					(4);
	static const variable operatorNameCol		(5);

	static const variable testSummaryCol		(3);
	static const variable testSummaryFirstRow			(47);

	// Nano Pipettor
	static const variable nanoSerialNoCol(3);
	static const variable nanoSerialNoRow(7);
	static const variable nanoStateRow(11);
	static const variable nanoProcessedStateCol(2);
	static const variable nanoDateCol(3);
	static const variable nanoTimeCol(4);
	static const variable nanoOperatorNameCol(5);



	// timer used within parallel thread
	timer soakTimer;

   // soak timer wait time (in seconds)
   static const variable soakTimerWaitTime(86399); // (24h)

	// Const of BVS
   static const variable BVS1(1);
   static const variable BVS2(2);
   static const variable BVS3(3);
   static const variable BVS4(4);

   static const variable Morning(0);
   static const variable Evening(1);
   static const variable Weekly(2);
	static const variable Daily(3);

	
	//=====================================================================================================
	// prototyping local functions
	//=====================================================================================================

	// initializes the Maintenance Methods Library (only once)
	static function InitMaintMetLibrary();

	// executes firmware command and checks return value
	static function FwCommand( variable &fwCommand, variable &fwParameter, variable errCheck, device ML_STAR);

	// updates a single cell in the excel sheet of the report file
	static function UpdateCellInReportFile( file &reportFile, variable column, variable row, string &value);

	// get String value from processed state (overall state)
	static function GetProcessedStateAsString();

	// get String value from check state
	static function GetCheckStateAsString( variable &state );

	// get String value from installtion config
	static function GetInstallationStateAsString( variable &state );

	// get 1000ul channel preassure values from instrument and return it (as absolute value - unsigned)
	static function GetAbsPressureOfChannel1000ul( variable channelIndex, device ML_STAR );

	// get 5ml channel preassure values from instrument and return it (as absolute value - unsigned)
	static function GetAbsPressureOfChannel5ml( variable channelIndex, device ML_STAR );


	// get 1000ul channel preassure values from instrument and save them (absolute values) in 'saveArray'
	static function SavePressureChannel1000ul( variable &saveArray[], variable fromChannelIndex, variable noOfChannels, device ML_STAR );

	// get 5ml channel preassure values from instrument and save them (absolute values) in 'saveArray'
	static function SavePressureChannel5ml( variable &saveArray[], variable fromChannelIndex, variable noOfChannels, device ML_STAR );

	// set pressure drop timer and wait 'seconds' for signal
	static function PressureDropWait( variable seconds );

	// set pressure build timer and wait 'seconds' for signal
	static function PressureBuildWait( variable seconds );

	// soak time for wash station
	static function SoakTimeWait( variable seconds );

	// meassure over pressure tightness for a defined number of 1000ul channels
	static function MeassureOverPressure1000ul( variable fromChannelIndex, variable noOfChannels, device ML_STAR );

	// meassure over pressure tightness for a defined number of 5ml channels
	static function MeassureOverPressure5ml( variable fromChannelIndex, variable noOfChannels, device ML_STAR );

	// meassure under pressure tightness for a defined number of 1000ul channels
	static function MeassureUnderPressure1000ul( variable fromChannelIndex, variable noOfChannels, device ML_STAR );

	// meassure under pressure tightness for a defined number of 5ml channels
	static function MeassureUnderPressure5ml( variable fromChannelIndex, variable noOfChannels, device ML_STAR );

	// cLLD check for a defined number of 1000ul channels
	static function CLLDCheckForChannels1000ul( variable fromChannelIndex, variable noOfChannels, device ML_STAR );

	// cLLD check for a defined number of 5ml channels
	static function CLLDCheckForChannels5ml( variable fromChannelIndex, variable noOfChannels, device ML_STAR );

	// returns abreviation of firmware command for 1000ul channel node (P1..PG)
	static function FwChannelNode1000ul( variable channelIndex );

	// returns abreviation of firmware command for 5ml channel node (L1..L8)
	static function FwChannelNode5ml( variable channelIndex );

	// Dump data for debugging
	static function DumpData();

	// Initialize process check states
	static function InitializeProcessCheckStates();

 	// create dynamic layout
	static function AddAllNeededLabware( device ML_STAR );

	// start wash of CR and 3rd Gen. wash station
	static function StartWashCRand3rdGen(	device ML_STAR, variable washStationNr, variable rinseTime1,
		variable rinseTime2, variable soakTime1, variable soakTime2, variable flowRate1,
		variable flowRate2, variable drainingTime, variable startWashLiquid, variable isCRwashstation );

	// start tightness check (including pick up and discard teaching needles) for a defined number of 1000ul channels
	static function StartTightnessCheckForChannels1000ul( variable fromChannelIndex, variable noOfChannels, device ML_STAR );

	// start tightness check (including pick up and discard teaching needles) for a defined number of 5ml channels
	static function StartTightnessCheckForChannels5ml( variable fromChannelIndex, variable noOfChannels, device ML_STAR );

	// start cLLD check (including pick up and discard teaching needles) for a defined number of 1000ul channels
	static function StartCLLDCheckForChannels1000ul( variable fromChannelIndex, variable noOfChannels, device ML_STAR );

	// start cLLD check (including pick up and discard teaching needles) for a defined number of 5ml channels
	static function StartCLLDCheckForChannels5ml( variable fromChannelIndex, variable noOfChannels, device ML_STAR );

	// Call WaitForNeedleWash Single Step for all moduls
	static function WaitUntilAllWashPumpsStopped(device ML_STAR, variable washStationNr, variable isCRwashstation);

	// error recorey for CO-RE 96 Head firmware commands
	static function ErrorRecoveryCORE96Head( variable errCode );	// returns hslTrue if user decided to repeat the command, else hslFalse

	// error recorey for DC Wash Station firmware commands
	static function ErrorRecoveryDCWashStation( variable errCode,variable processDay );	// returns hslTrue if user decided to repeat the command, else hslFalse

	static function FirmwareErrorCheck( string &result );				// return 0, if the result string contains no error
																						// otherwise the error code returned from instrument

	static function ParseFwResult(string &fwResult, string &parameter, variable count) variable;
         // Look up for 'parameter' (2 chars, lower case) within the passed fwResult
         // and extracts the 'count' of caracters directly after the first found of 'parameter'.
         // Return: the extracted caracters
         // Throws and error if the 'parameter' is not found!

	static function GetTipPatternParam(variable fromChannelIndex, variable countOfChannels, variable totalNoOfChannels) variable;
			// Generates a Tip Pattern parameter (tr) for use with master command (C0)
			// fromChannelIndex  : zero based index of first active channel
			// noOfChannels      : count of active channels starting on fromChannelIndex
			// totalNoOfChannels : total number of available channels
			// Return: tip pattern string (e.g. GetTipPatternParam(2, 3, 8) returns "0 0 1 1 1 0 0 0"


	static function RestoreParamsFromFile( device ML_STAR ) variable;
	//-----------------------------------------------------------------------------------------------------
	// Restores the ML STAR default parameters read from file in \Logfiles\.
	//	RETURN		hslTrue if function succeeds, else hslFalse

	// starts a global timer within a parallel thread
	function ShowInfiniteSoakTimer()
	{
      soakTimer.SetTimerViewName( StringTable::Load(IDS::soakTimerWaitText) );
		soakTimer.SetTimer(soakTimerWaitTime);
		soakTimer.WaitTimer(hslTrue, hslFalse);
	}

	static function WashTimerWait( variable seconds);

	static function SleepForWash(variable seconds);

	static function DCWashStationCommandEF(variable Parameter,device ML_STAR );
	
	static function DCWashStationCommandEE(variable Parameter,device ML_STAR );

	function LockCover( device ML_STAR, variable lockFront, string msg, string title ) variable;


	//-----------------------------------------------------------------------------------------------------
	static function SwitchLoadingIndicators(variable firstPosInt, variable countOfPos, device ML_STAR );
	//-----------------------------------------------------------------------------------------------------
   // Set autoload loading light to blinking from firstPosInt to firstPosInt + countOfPos
   // firstPosInt == 0 switch off the light.
   // Negative firstPosInt is possible, but only lights above 0 can be switched on.
	// 
	//	RETURN		FwCommand() error
	//-----------------------------------------------------------------------------------------------------


   // nano internal function
	//-----------------------------------------------------------------------------------------------------
   static function AddNanoServiceCarrier(device ML_STAR);

   static function RequestLiquidLevelSensors( variable &SensorWertLevel, variable SensorPos, device ML_STAR );

	static function SwitchNPSolenoidValve(variable ValvePos, variable isOpen, device ML_STAR);

   static function SwitchN0SolenoidValve(variable valvePos, variable isOpen, device ML_STAR);

   static function SwitchPipettorValve(variable pipettorHead, variable isOpen, device ML_STAR);

	static function SetNanoPressureToAmbient( device ML_STAR );

	static function StartNanoVacuumPump( device ML_STAR );

	static function StopNanoVacuumPump( device ML_STAR );

	static function StartNanoRefillPump( device ML_STAR );

	static function StopNanoRefillPump( device ML_STAR );

	static function EmptyWasteOnDeck(device ML_STAR );

	static function EmptyUltrasonicBath(device ML_STAR );

	static function ExchangeCleaningLiquidAtUltrsonicBath(device ML_STAR);

  	static function GetPressureState(device ML_STAR );

	static function SetTimeNanoPipettor(variable TimeNanoPipettor,device ML_STAR, string traceAction );

	static function RequestNanopipettor_High_Low_Viscosity(variable &Channel_8_Head , variable &Channel_N_Head ,device ML_STAR, string traceAction );

   static function RequestNanopipettorSerialNumber(device ML_STAR);

   static function NanoMoveToWaste(device ML_STAR, variable Channel_N_Head, variable traceAction);

   static function EmptyAccuAndSeyonic(device ML_STAR, variable TitleNanopipettor, variable Channel_N_Head);

   static function DrySeyonicSystem(device ML_STAR, variable TitleNanopipettor, variable Channel_N_Head, variable dryTime);

   static function EmptyRefillContainer(device ML_STAR, variable TitleNanopipettor);

   static function EmptySystemReservoir(device ML_STAR, variable TitleNanopipettor);

   static function EmptyUltraSonicBathSpecial(device ML_STAR, variable TitleNanopipettor, variable onlyTubes);

   static function CleanDecontaminateNanoSystem(device ML_STAR, variable Channel_N_Head,
                           variable traceAction, variable TitleNanopipettor, variable msgBoxText);

   static function NanoTimeWait( variable seconds, variable title, variable cancelAllowed);
   // end nano internal function

	//-----------------------------------------------------------------------------------------------------
   // CORE 96 Head internal functions

	// get CO-RE 96 TADM Head preassure values from given channel and return it
	static function Get96TadmHeadPressureOverage( variable positive, device ML_STAR ) variable;
	static function Get96TadmHeadChannelPressure( variable channelPressure[], device ML_STAR );

   // tools pick up uses loopCount of sqeece
	static function SpezialSqueezeFor96TadmHead( variable loopCount, device ML_STAR);

   // meassure over pressure tightness for CO-RE 96 TADM head
	static function MeassureOverPressure96TadmHead( device ML_STAR );

   // meassure under pressure tightness for CO-RE 96 TADM head
	static function MeassureUnderPressure96TadmHead( device ML_STAR );

   // check for CO-RE 96 TADM Head maintenace tool
   static function CheckFor96TadmHeadMaintenanceTool( device ML_STAR );

   // check for CO-RE 96 TADM Head maintenace tool position
   static function CheckFor96TadmHeadMaintenanceToolPosition( device ML_STAR );

	// start tightness check (including pick up and discard tool) for CO-RE 96 TADM head
	static function StartTightnessCheckFor96TadmHead( device ML_STAR );
	// end CORE 96 Head internal functions
   //-----------------------------------------------------------------------------------------------------


	//-----------------------------------------------------------------------------------------------------
   // easyPunch internal functions
   static function easyPunchDailyMaintenance(device ML_STAR, string title) variable;
   static function CalculateUsedPunchCount(device ML_STAR, string &puncherSN, string &puncherPN) variable;
   static function SetCleanedPunchHead(variable puncherSN, variable puncherPN) variable;
   static function checkIonisatorState(device ML_STAR, string title) variable;
   static function executePunchGripperAlignment(device ML_STAR, string title) variable;
   static function checkEasyPunchMovements(device ML_STAR) variable;
   // end easyPunch internal functions
	//-----------------------------------------------------------------------------------------------------

	static function TraceSTARWatchData(
          device& ML_STAR, variable deviceAddress, 
          variable testType,variable testCondition,variable testID,variable testRevision,
			 variable status, variable outputParameter, variable lowerLimit, variable upperLimit, variable traceData);

	// initializes the Maintenance Methods Library (only once)
	static function ABS(variable var) variable;

   //=====================================================================================================
	// implementation interface functions
	//=====================================================================================================

	//-----------------------------------------------------------------------------------------------------
	function GetLabwarePath()
	//-----------------------------------------------------------------------------------------------------
	{
		variable labwarePath("");
		object registry;

		registry.CreateObject("HXREGLib.HxRegistry.1");
		labwarePath = registry.LabwarePath;
		registry.ReleaseObject();

		return(labwarePath);
	} // end GetLabwarePath


	//-----------------------------------------------------------------------------------------------------
	static function ErrorRecoveryCORE96Head(variable errCode)
	//-----------------------------------------------------------------------------------------------------
	{
		variable message, messageEx, title, type, answer, traceSource, traceAction;
		string s;

		traceSource = StringTable::Load(IDS::traceSource);
		traceAction = StringTable::Load(IDS::traceActionCORE96HeadWashMaint);

		message = StringTable::Load(IDS::errorDuringCORE96HeadWashMaint) + "\n\n";

		if(errCode == C0ErrorCode::hardwareError ||
			errCode == DCWasherErrCode::ls1NotSwitchToInactive ||
			errCode == DCWasherErrCode::ls2NotSwitchToInactive)
		{
			messageEx = StringTable::Load(IDE::hardwareError);
			message = message + messageEx;
			FormatTrace(traceSource, traceAction, TraceStatus::error_, StringTable::Load(IDE::hardwareError));
		}

		else
		if(errCode == C0ErrorCode::noWashFluidError ||
			errCode == DCWasherErrCode::ls1NotSwitchToActive ||
			errCode == DCWasherErrCode::ls2NotSwitchToActive)
		{
			messageEx = StringTable::Load(IDE::noWashFluidError);
			message = message + messageEx;
			FormatTrace(traceSource, traceAction, TraceStatus::error_, StringTable::Load(IDE::noWashFluidError));
		}

		// any other, unexpected error (such errors cannot be handled by user --> raise error)
		else
		if(errCode != 0)
			err.Raise(IDE::unexpectedInstrumentError, StringTable::Load(IDE::unexpectedInstrumentError));

		title = StringTable::Load(IDS::titleErrorHandling);
		type = hslAbortRetryIgnore | hslError | hslDefButton2;

		// ask user how to handle the error
		answer = MessageBox(message, title, type);

		if(hslAbort == answer)
			abort;

		if(hslRetry == answer)
			return (hslTrue);

		if(hslIgnore == answer)
			return (hslFalse);
	}// end ErrorRecoveryCORE96Head


	//-----------------------------------------------------------------------------------------------------
	static function ErrorRecoveryDCWashStation( variable errCode,variable processDay )
	//-----------------------------------------------------------------------------------------------------
	{
		variable message, messageEx, title, type, answer, traceSource, traceAction;
		string s;

		if (processDay == Daily)
		{
			traceSource = StringTable::Load(IDS::traceSource);
			traceAction = StringTable::Load(IDS::traceActionDailyDCWashStation);
			message = StringTable::Load(IDS::errorDuringDailyDCWashStationMaint) + "\n\n";
		}
		else
		{
			traceSource = StringTable::Load(IDS::traceSource);
			traceAction = StringTable::Load(IDS::traceActionWeeklyDCWashStation);
			message = StringTable::Load(IDS::errorDuringWeeklyDCWashStationMaint) + "\n\n";
		}

		if(errCode == C0ErrorCode::hardwareError ||
			errCode == DCWasherErrCode::ls1NotSwitchToInactive ||
			errCode == DCWasherErrCode::ls2NotSwitchToInactive)
		{
			messageEx = StringTable::Load(IDE::hardwareError);
			message = message + messageEx;
			FormatTrace(traceSource, traceAction, TraceStatus::error_, StringTable::Load(IDE::hardwareError));
		}

		else
		if(errCode == C0ErrorCode::noWashFluidError ||
			errCode == DCWasherErrCode::ls1NotSwitchToActive ||
			errCode == DCWasherErrCode::ls2NotSwitchToActive)
		{
			messageEx = StringTable::Load(IDE::noWashFluidError);
			message = message + messageEx;
			FormatTrace(traceSource, traceAction, TraceStatus::error_, StringTable::Load(IDE::noWashFluidError));
		}

		// any other, unexpected error (such errors cannot be handled by user --> raise error)
		else
		if(errCode != 0)
			err.Raise(IDE::unexpectedInstrumentError, StringTable::Load(IDE::unexpectedInstrumentError));

		title = StringTable::Load(IDS::titleErrorHandling);
		type = hslRetryCancel | hslError | hslDefButton1;

		// ask user how to handle the error
		answer = MessageBox(message, title, type);

		if(hslCancel == answer)
			abort;
	
		if(hslRetry == answer)
			return (hslTrue);

	}// end ErrorRecoveryCORE96Head

	//-----------------------------------------------------------------------------------------------------
	function WaitUntilAllWashPumpsStopped(device ML_STAR, variable washStationNr, variable isCRwashstation)
	//-----------------------------------------------------------------------------------------------------
	{
		variable washModulId, i;

		for(i = 1; i <= 3; i++) // important: suppose all washstation have 3 wash modules!
		{
			if(washStationNr == LabwrData::washStation1)
			{
				if(isCRwashstation)
				{
					if(i == 1)
						washModulId = LabwrData::crWS1RackId1;
					else if(i == 2)
						washModulId = LabwrData::crWS1RackId2;
					else if(i == 3)
						washModulId = LabwrData::crWS1RackId3;
				}
				else
				{
					if(i == 1)
						washModulId = LabwrData::gen3rdWS1RackId1;
					else if(i == 2)
						washModulId = LabwrData::gen3rdWS1RackId2;
					else if(i == 3)
						washModulId = LabwrData::gen3rdWS1RackId3;
				}
			}
			else if(washStationNr == LabwrData::washStation2)
			{
				if(isCRwashstation)
				{
					if(i == 1)
						washModulId = LabwrData::crWS2RackId1;
					else if(i == 2)
						washModulId = LabwrData::crWS2RackId2;
					else if(i == 3)
						washModulId = LabwrData::crWS2RackId3;
				}
				else
				{
					if(i == 1)
						washModulId = LabwrData::gen3rdWS2RackId1;
					else if(i == 2)
						washModulId = LabwrData::gen3rdWS2RackId2;
					else if(i == 3)
						washModulId = LabwrData::gen3rdWS2RackId3;
				}
			}

			ML_STAR._BCAAD4F5_0BD2_4d9c_8243_70DD893496CB( "e1327ee6_a8dc_4284_91250693ae830aa8" ); // WaitNeedleWashed
		}
	}

	//-----------------------------------------------------------------------------------------------------
	function CrWashStationMaintenance( device ML_STAR)
	//-----------------------------------------------------------------------------------------------------
	{
		string traceText;
		variable maintenanceExecuted(hslFalse);

		// set check state to failed
		crWashStation_1_CheckState = PS::failed;
		crWashStation_2_CheckState = PS::failed;

		// prompt for preparing wash/rinse solution containers
		if ( hslOK != MessageBox(
			StringTable::Load(IDS::dlgWashRinseContFullText),
			StringTable::Load(IDS::dlgWashRinseContFullTitle),
			hslOKCancel	| hslInformation, hslInfinite ) )
		{
			// Cancel -> end of WashRinceContFull procedure
			traceText = StringTable::Load(IDS::dlgWashRinseContFullTitle);
			Trace(traceText);
			return;
		}

		// CR Wash Station 1 + 2 installed
		if(exwashStation1 == 1 && exwashStation2 == 1)
		{
			variable handle;
			variable handles[ ];
         
         handle = Fork("ShowInfiniteSoakTimer");
			handles.AddAsLast(handle);

			// 1st wash step (startWithWashLiquidOne = wash solution)

			// wash station 1
			StartWashCRand3rdGen(ML_STAR, LabwrData::washStation1, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime300,
						0, LabwrData::tFlowRate12, 0, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidOne, hslTrue);

			// wash station 2
			StartWashCRand3rdGen(ML_STAR, LabwrData::washStation2, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime300,
						0, LabwrData::tFlowRate12, 0, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidOne, hslTrue);

			// 2nd wash step (startWithWashLiquidOne = wash solution)

			// wash station 1
			StartWashCRand3rdGen(ML_STAR, LabwrData::washStation1, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime1,
			 			0, LabwrData::tFlowRate12, 0, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidOne, hslTrue);

			// wash station 2
			StartWashCRand3rdGen(ML_STAR, LabwrData::washStation2, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime1,
						0, LabwrData::tFlowRate12, 0, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidOne, hslTrue);

			// wait for needle wash finished
			WaitUntilAllWashPumpsStopped(ML_STAR, LabwrData::washStation1, hslTrue);
			WaitUntilAllWashPumpsStopped(ML_STAR, LabwrData::washStation2, hslTrue);

			// new rinse procedure
				MessageBox( StringTable::Load(IDS::dlgWashCrWashRinseText),	StringTable::Load(IDS::dlgWashCrWashRinseTitle),
					hslOKOnly | hslInformation, hslInfinite );

			// 1st and 2nd rinse step (startWithWashLiquidOne = rinse solution)
			loop(2)
			{
				// wash station 1
				StartWashCRand3rdGen(ML_STAR, LabwrData::washStation1, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime1,
						0, LabwrData::tFlowRate12, 0, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidOne, hslTrue);

				// wash station 2
				StartWashCRand3rdGen(ML_STAR, LabwrData::washStation2, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime1,
						0, LabwrData::tFlowRate12, 0, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidOne, hslTrue);
			}

			// wait for needle wash finished
			WaitUntilAllWashPumpsStopped(ML_STAR, LabwrData::washStation1, hslTrue);
			WaitUntilAllWashPumpsStopped(ML_STAR, LabwrData::washStation2, hslTrue);

			soakTimer.SetTimer(0);
			Join(handles, 0);

			crWashStation_1_CheckState = PS::successful;
			crWashStation_2_CheckState = PS::successful;

			maintenanceExecuted = hslTrue;
		}

		if (!maintenanceExecuted)
		{
			// only CR Wash Station 1 installed ?
			if (exwashStation1 == 1)
			{
				variable handle;
				variable handles[ ];

				handle = Fork("ShowInfiniteSoakTimer");
				handles.AddAsLast(handle);

				// 1st wash step (startWithWashLiquidOne = wash solution)
				StartWashCRand3rdGen(ML_STAR, LabwrData::washStation1, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime300,
							0, LabwrData::tFlowRate12, 0, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidOne, hslTrue);

				// 2nd wash step (startWithWashLiquidOne = wash solution)
				StartWashCRand3rdGen(ML_STAR, LabwrData::washStation1, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime1,
				 			0, LabwrData::tFlowRate12, 0, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidOne, hslTrue);

				// wait for needle wash finished
				WaitUntilAllWashPumpsStopped(ML_STAR, LabwrData::washStation1, hslTrue);

				// new rinse procedure
				MessageBox( StringTable::Load(IDS::dlgWashCrWashRinseText),	StringTable::Load(IDS::dlgWashCrWashRinseTitle),
					hslOKOnly	| hslInformation, hslInfinite );

				// 1st and 2nd rinse step (startWithWashLiquidOne = rinse solution)
				loop(2)
				{
					StartWashCRand3rdGen(ML_STAR, LabwrData::washStation1, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime1,
							0, LabwrData::tFlowRate12, 0, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidOne, hslTrue);
				}

				// wait for needle wash finished
				WaitUntilAllWashPumpsStopped(ML_STAR, LabwrData::washStation1, hslTrue);

				soakTimer.SetTimer(0);
				Join(handles, 0);

				crWashStation_1_CheckState = PS::successful;
		 	}
			else
				crWashStation_1_CheckState = PS::notInstalled;


			// only CR Wash Station 2 installed ?
			if (exwashStation2 == 1)
			{
				variable handle;
				variable handles[ ];

				handle = Fork("ShowInfiniteSoakTimer");
				handles.AddAsLast(handle);

				// 1st wash step (startWithWashLiquidOne = wash solution)
				StartWashCRand3rdGen(ML_STAR, LabwrData::washStation2, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime300,
							0, LabwrData::tFlowRate12, 0, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidOne, hslTrue);

				// 2nd wash step (startWithWashLiquidOne = wash solution)
				StartWashCRand3rdGen(ML_STAR, LabwrData::washStation2, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime1,
							0, LabwrData::tFlowRate12, 0, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidOne, hslTrue);

				// wait for needle wash finished
				WaitUntilAllWashPumpsStopped(ML_STAR, LabwrData::washStation2, hslTrue);

				// new rinse procedure
				MessageBox( StringTable::Load(IDS::dlgWashCrWashRinseText),	StringTable::Load(IDS::dlgWashCrWashRinseTitle),
					hslOKOnly | hslInformation, hslInfinite );

				// 1st and 2nd rinse step (startWithWashLiquidTwo = rinse solution)
				loop(2)
				{
					StartWashCRand3rdGen(ML_STAR, LabwrData::washStation2, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime1,
							0, LabwrData::tFlowRate12, 0, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidOne, hslTrue);
				}

				// wait for needle wash finished
				WaitUntilAllWashPumpsStopped(ML_STAR, LabwrData::washStation2, hslTrue);

				soakTimer.SetTimer(0);
				Join(handles, 0);

				crWashStation_2_CheckState = PS::successful;
		 	}
			else
				crWashStation_2_CheckState = PS::notInstalled;
		}

		// prompt for drain and clean up wash/rinse solution containers
		if ( hslOK != MessageBox(
			StringTable::Load(IDS::dlgWashRinseContEmptyText),
			StringTable::Load(IDS::dlgWashRinseContEmptyTitle),
			hslOKCancel	| hslInformation, hslInfinite ) )
		{
			// set check state to failed, even if maintenance was successful executed
			if(exwashStation1 == 1)
				crWashStation_1_CheckState = PS::failed;
			if(exwashStation2 == 1)
				crWashStation_2_CheckState = PS::failed;

			// Cancel -> end of WashRinseContEmpty procedure
			traceText = StringTable::Load(IDS::dlgWashRinseContEmptyTitle);
			Trace(traceText);
			return;
		}

		return;
	} // end CrWashStationMaintenance


	//-----------------------------------------------------------------------------------------------------
	function CrWashStationMaintenanceDaily( device ML_STAR)
	//-----------------------------------------------------------------------------------------------------
	{
		string traceText;
		variable maintenanceExecuted(hslFalse);

		// set check state to failed
		crWashStation_1_CheckState = PS::failed;
		crWashStation_2_CheckState = PS::failed;

		// prompt for preparing wash/rinse solution containers
		if ( hslOK != MessageBox(
			StringTable::Load(IDS::dlgWashCrWashFullDailyText),
			StringTable::Load(IDS::dlgWashCrWashFullDailyTitle),
			hslOKCancel	| hslInformation, hslInfinite ) )
		{
			// Cancel -> end of WashRinceContFull procedure
			traceText = StringTable::Load(IDS::dlgWashCrWashFullDailyTitle);
			Trace(traceText);
			return;
		}

		// CR Wash Station 1 + 2 installed
		if(exwashStation1 == 1 && exwashStation2 == 1)
		{
			variable handle;
			variable handles[ ];

			handle = Fork("ShowInfiniteSoakTimer");
			handles.AddAsLast(handle);

			// 1st wash step (startWithWashLiquidOne = wash solution)

			// wash station 1
			StartWashCRand3rdGen(ML_STAR, LabwrData::washStation1, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime1,
			 			0, LabwrData::tFlowRate12, 0, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidOne, hslTrue);

			// wash station 2
			StartWashCRand3rdGen(ML_STAR, LabwrData::washStation2, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime1,
						0, LabwrData::tFlowRate12, 0, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidOne, hslTrue);

			// wait for needle wash finished
			WaitUntilAllWashPumpsStopped(ML_STAR, LabwrData::washStation1, hslTrue);
			WaitUntilAllWashPumpsStopped(ML_STAR, LabwrData::washStation2, hslTrue);

			// new rinse procedure
				MessageBox( StringTable::Load(IDS::dlgWashCrWashRinseText),	StringTable::Load(IDS::dlgWashCrWashRinseTitle),
					hslOKOnly	| hslInformation, hslInfinite );

			// 1st and 2nd rinse step (startWithWashLiquidOne = rinse solution)
			loop(2)
			{
				// wash station 1
				StartWashCRand3rdGen(ML_STAR, LabwrData::washStation1, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime1,
						0, LabwrData::tFlowRate12, 0, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidOne, hslTrue);

				// wash station 2
				StartWashCRand3rdGen(ML_STAR, LabwrData::washStation2, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime1,
						0, LabwrData::tFlowRate12, 0, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidOne, hslTrue);
			}

			// wait for needle wash finished
			WaitUntilAllWashPumpsStopped(ML_STAR, LabwrData::washStation1, hslTrue);
			WaitUntilAllWashPumpsStopped(ML_STAR, LabwrData::washStation2, hslTrue);

			soakTimer.SetTimer(0);
			Join(handles, 0);

			crWashStation_1_CheckState = PS::successful;
			crWashStation_2_CheckState = PS::successful;

			maintenanceExecuted = hslTrue;
		}

		if (!maintenanceExecuted)
		{
			// only CR Wash Station 1 installed ?
			if (exwashStation1 == 1)
			{
				variable handle;
				variable handles[ ];

				handle = Fork("ShowInfiniteSoakTimer");
				handles.AddAsLast(handle);

				// 1st wash step (startWithWashLiquidOne = wash solution)

				StartWashCRand3rdGen(ML_STAR, LabwrData::washStation1, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime1,
				 			0, LabwrData::tFlowRate12, 0, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidOne, hslTrue);

				// wait for needle wash finished
				WaitUntilAllWashPumpsStopped(ML_STAR, LabwrData::washStation1, hslTrue);

				// new rinse procedure
				MessageBox( StringTable::Load(IDS::dlgWashCrWashRinseText),	StringTable::Load(IDS::dlgWashCrWashRinseTitle),
					hslOKOnly	| hslInformation, hslInfinite );

				// 1st and 2nd rinse step (startWithWashLiquidOne = rinse solution)
				loop(2)
				{
					StartWashCRand3rdGen(ML_STAR, LabwrData::washStation1, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime1,
							0, LabwrData::tFlowRate12, 0, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidOne, hslTrue);
				}

				// wait for needle wash finished
				WaitUntilAllWashPumpsStopped(ML_STAR, LabwrData::washStation1, hslTrue);

				soakTimer.SetTimer(0);
				Join(handles, 0);

				crWashStation_1_CheckState = PS::successful;
		 	}
			else
				crWashStation_1_CheckState = PS::notInstalled;

			// only CR Wash Station 2 installed ?
			if (exwashStation2 == 1)
			{
				variable handle;
				variable handles[ ];

				handle = Fork("ShowInfiniteSoakTimer");
				handles.AddAsLast(handle);

				// 1st wash step (startWithWashLiquidOne = wash solution)

				StartWashCRand3rdGen(ML_STAR, LabwrData::washStation2, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime1,
							0, LabwrData::tFlowRate12, 0, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidOne, hslTrue);

				// wait for needle wash finished
				WaitUntilAllWashPumpsStopped(ML_STAR, LabwrData::washStation2, hslTrue);

				// new rinse procedure
				MessageBox( StringTable::Load(IDS::dlgWashCrWashRinseText),	StringTable::Load(IDS::dlgWashCrWashRinseTitle),
					hslOKOnly	| hslInformation, hslInfinite );

				// 1st and 2nd rinse step (startWithWashLiquidOne = rinse solution)
				loop(2)
				{
					StartWashCRand3rdGen(ML_STAR, LabwrData::washStation2, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime1,
							0, LabwrData::tFlowRate12, 0, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidOne, hslTrue);
				}

				// wait for needle wash finished
				WaitUntilAllWashPumpsStopped(ML_STAR, LabwrData::washStation2, hslTrue);

				soakTimer.SetTimer(0);
				Join(handles, 0);

				crWashStation_2_CheckState = PS::successful;
		 	}
			else
				crWashStation_2_CheckState = PS::notInstalled;
		}

		// prompt for drain and clean up wash/rinse solution containers
		if ( hslOK != MessageBox(
			StringTable::Load(IDS::dlgWashRinseContEmptyText),
			StringTable::Load(IDS::dlgWashRinseContEmptyTitle),
			hslOKCancel	| hslInformation, hslInfinite ) )
		{
			// set check state to failed, even if maintenance was successful executed
			if(exwashStation1 == 1)
				crWashStation_1_CheckState = PS::failed;
			if(exwashStation2 == 1)
				crWashStation_2_CheckState = PS::failed;

			// Cancel -> end of WashRinseContEmpty procedure
			traceText = StringTable::Load(IDS::dlgWashRinseContEmptyTitle);
			Trace(traceText);
			return;
		}

		return;
	} // end CrWashStationMaintenanceDaily


	//-----------------------------------------------------------------------------------------------------
	function DCWashStationMaintenanceDaily( device ML_STAR)  // Find_DCWashStationMaintenanceDaily
	//-----------------------------------------------------------------------------------------------------
	{
		string traceText;
		variable errCode;									// error code extracted out from firmware result string
		variable parameterPrimeHW,parameterEmtyFillHW,parameterEmtyHW;
		variable parameterPrimeHU,parameterEmtyFillHU,parameterEmtyHU;
		variable parameterPrimeHV,parameterEmtyFillHV,parameterEmtyHV;
		variable nodeIdHW(FimwareNodeID::notInstalled);
		variable nodeIdHU(FimwareNodeID::notInstalled);
		variable nodeIdHV(FimwareNodeID::notInstalled);
		
		if (pumpTypeStation1 == 1)
			if(pumpStation1 == 1)
			{
				nodeIdHW = FimwareNodeID::HW;
				dcWashStation_HW_CheckState = PS::failed;
				parameterPrimeHW      = "ep1";
				parameterEmtyFillHW   = "ep1ee1ef0";
   			parameterEmtyHW       = "ep1ee0ef0";
   			traceText							= "DC WashStation HW installed";
   			Trace(traceText);
			}

		if (pumpTypeStation2 == 1)
			if(pumpStation2 == 1)
			{
				nodeIdHU = FimwareNodeID::HU;
				dcWashStation_HU_CheckState = PS::failed;
				parameterPrimeHU  	  = "ep2";
				parameterEmtyFillHU   = "ep2ee1ef0";
				parameterEmtyHU       = "ep2ee0ef0";
   			traceText							= "DC WashStation HU installed";
   			Trace(traceText);
			}

		if (pumpTypeStation3 == 1)
			if(pumpStation3 == 1)
			{
				nodeIdHV = FimwareNodeID::HV;
				dcWashStation_HV_CheckState = PS::failed;
				parameterPrimeHV      = "ep3";
				parameterEmtyFillHV   = "ep3ee1ef0";
				parameterEmtyHV       = "ep3ee0ef0";
   			traceText							= "DC WashStation HV installed";
   			Trace(traceText);
			}


   	 // "Maintenance - DC Wash Station - Wash procedure");
	    // "Please fill Wash Container with 3l of water and 30ml of Wash Station Cleaner solution.");
		if ( hslOK != MessageBox(
			StringTable::Load(IDS::dlgDailyDCWash1Text),
			StringTable::Load(IDS::dlgDailyDCWash1Title),
			hslOKCancel	| hslInformation, hslInfinite ) )
		{
			// Cancel -> end
			traceText = StringTable::Load(IDS::dlgDailyDCWash1Title);
			Trace(traceText);
			return;
		}

		// Prime (single chamber only)
		if (nodeIdHW != FimwareNodeID::notInstalled)
			 errCode = DCWashStationCommandEF(parameterPrimeHW,ML_STAR );
			 if (errCode != 0) return;
		if (nodeIdHU != FimwareNodeID::notInstalled)
			 errCode = DCWashStationCommandEF(parameterPrimeHU,ML_STAR );
			 if (errCode != 0) return;
		if (nodeIdHV != FimwareNodeID::notInstalled)
			 errCode = DCWashStationCommandEF(parameterPrimeHV,ML_STAR );
			 if (errCode != 0) return;


		// "Maintenance - DC Wash Station - Rinse procedure");
      // "Please empty the DC Wash Station and rinse it with distilled water.
		//  Please fill DC Wash Station with 3l of distilled water.");
		if ( hslOK != MessageBox(
			StringTable::Load(IDS::dlgDailyDCWash2Text),
			StringTable::Load(IDS::dlgDailyDCWash2Title),
			hslOKCancel	| hslInformation, hslInfinite ) )
		{
			// Cancel -> end of WashRinceContFull procedure
			traceText = StringTable::Load(IDS::dlgDailyDCWash2Title);
			Trace(traceText);
			return;
		}

		loop(2)  // 2 x Rinse step
		{
				// Drain & refill (single chamber only)
				if (nodeIdHW != FimwareNodeID::notInstalled)
					 errCode = DCWashStationCommandEE(parameterEmtyFillHW,ML_STAR );
					 if (errCode != 0) return;
				if (nodeIdHU != FimwareNodeID::notInstalled)
					 errCode = DCWashStationCommandEE(parameterEmtyFillHU,ML_STAR );
					 if (errCode != 0) return;
				if (nodeIdHV != FimwareNodeID::notInstalled)
					 errCode = DCWashStationCommandEE(parameterEmtyFillHV,ML_STAR );
					 if (errCode != 0) return;
		}


		// Emty (single chamber only)		
		if (nodeIdHW != FimwareNodeID::notInstalled)
			 errCode = DCWashStationCommandEE(parameterEmtyHW,ML_STAR );
			 if (errCode != 0) return;
		if (nodeIdHU != FimwareNodeID::notInstalled)
			 errCode = DCWashStationCommandEE(parameterEmtyHU,ML_STAR );
			 if (errCode != 0) return;
		if (nodeIdHV != FimwareNodeID::notInstalled)
			 errCode = DCWashStationCommandEE(parameterEmtyHV,ML_STAR );
			 if (errCode != 0) return;

    // "Maintenance - DC Wash Station - Empty procedure");
    // "Please empty the wash container and rinse it with distilled water.
    // "Please empty the waste container and rinse it with distilled water.
		if ( hslOK != MessageBox(
			StringTable::Load(IDS::dlgDailyDCWash3Text),
			StringTable::Load(IDS::dlgDailyDCWash3Title),
			hslOKCancel	| hslInformation, hslInfinite ) )
		{
				// Cancel -> end of WashRinceContFull procedure
				traceText = StringTable::Load(IDS::dlgDailyDCWash3Title);
				Trace(traceText);
				return;
		}

		if(nodeIdHW == FimwareNodeID::HW)
			dcWashStation_HW_CheckState = PS::successful;
		
		if(nodeIdHU == FimwareNodeID::HU)
			dcWashStation_HU_CheckState = PS::successful;

		if(nodeIdHV == FimwareNodeID::HV)
			dcWashStation_HV_CheckState = PS::successful;
			
		return;
	} // end DCWashStationMaintenanceDaily


	//-----------------------------------------------------------------------------------------------------
	function DCWashStationMaintenanceWeekly( device ML_STAR)   // Find_DCWashStationMaintenanceWeekly
	//-----------------------------------------------------------------------------------------------------
	{

		string traceText;
		variable errCode;									// error code extracted out from firmware result string
		variable parameterPrimeHW,parameterEmtyFillHW,parameterEmtyHW;
		variable parameterPrimeHU,parameterEmtyFillHU,parameterEmtyHU;
		variable parameterPrimeHV,parameterEmtyFillHV,parameterEmtyHV;
		variable nodeIdHW(FimwareNodeID::notInstalled);
		variable nodeIdHU(FimwareNodeID::notInstalled);
		variable nodeIdHV(FimwareNodeID::notInstalled);
		variable InstalledWashStation(0);
		
		if (pumpTypeStation1 == 1)
			if(pumpStation1 == 1)
			{
				nodeIdHW = FimwareNodeID::HW;
				dcWashStation_HW_CheckState = PS::failed;
				parameterPrimeHW      = "ep1";
				parameterEmtyFillHW   = "ep1ee1ef0";
   			parameterEmtyHW       = "ep1ee0ef0";
   			traceText							= "DC WashStation HW installed";
   			Trace(traceText);
				
			}

		if (pumpTypeStation2 == 1)
			if(pumpStation2 == 1)
			{
				nodeIdHU = FimwareNodeID::HU;
				dcWashStation_HU_CheckState = PS::failed;
				parameterPrimeHU  	  = "ep2";
				parameterEmtyFillHU   = "ep2ee1ef0";
				parameterEmtyHU       = "ep2ee0ef0";
   			traceText							= "DC WashStation HU installed";
   			Trace(traceText);
			}

		if (pumpTypeStation3 == 1)
			if(pumpStation3 == 1)
			{
				nodeIdHV = FimwareNodeID::HV;
				dcWashStation_HV_CheckState = PS::failed;
				parameterPrimeHV      = "ep3";
				parameterEmtyFillHV   = "ep3ee1ef0";
				parameterEmtyHV       = "ep3ee0ef0";
   			traceText							= "DC WashStation HV installed";
   			Trace(traceText);
			}

   	 // Weekly Maintenance - DC Wash Station - Wash procedure
		 // Please fill Wash Container with 3l of water and 30ml of cleaner solution.");
		if ( hslOK != MessageBox(
			StringTable::Load(IDS::dlgWeeklyDCWash1Text),
			StringTable::Load(IDS::dlgWeeklyDCWash1Title),
			hslOKCancel	| hslInformation, hslInfinite ) )
		{
			// Cancel -> end
			traceText = StringTable::Load(IDS::dlgWeeklyDCWash1Title);
			Trace(traceText);
			return;
		}

		// Prime (single chamber only)
		if (nodeIdHW != FimwareNodeID::notInstalled)
			 errCode = DCWashStationCommandEF(parameterPrimeHW,ML_STAR );
			 if (errCode != 0) return;
		if (nodeIdHU != FimwareNodeID::notInstalled)
			 errCode = DCWashStationCommandEF(parameterPrimeHU,ML_STAR );
			 if (errCode != 0) return;
		if (nodeIdHV != FimwareNodeID::notInstalled)
			 errCode = DCWashStationCommandEF(parameterPrimeHV,ML_STAR );
			 if (errCode != 0) return;

		// Timer 5 Min Warten
      SleepForWash(MtConst::DCWashStationTimerWaitWeekly);
    
		// Drain & refill (single chamber only)
		if (nodeIdHW != FimwareNodeID::notInstalled)
			 errCode = DCWashStationCommandEE(parameterEmtyFillHW,ML_STAR );
			 if (errCode != 0) return;
		if (nodeIdHU != FimwareNodeID::notInstalled)
			 errCode = DCWashStationCommandEE(parameterEmtyFillHU,ML_STAR );
			 if (errCode != 0) return;
		if (nodeIdHV != FimwareNodeID::notInstalled)
			 errCode = DCWashStationCommandEE(parameterEmtyFillHV,ML_STAR );
			 if (errCode != 0) return;

		// Emty (single chamber only)		
		if (nodeIdHW != FimwareNodeID::notInstalled)
			 errCode = DCWashStationCommandEE(parameterEmtyHW,ML_STAR );
			 if (errCode != 0) return;
		if (nodeIdHU != FimwareNodeID::notInstalled)
			 errCode = DCWashStationCommandEE(parameterEmtyHU,ML_STAR );
			 if (errCode != 0) return;
		if (nodeIdHV != FimwareNodeID::notInstalled)
			 errCode = DCWashStationCommandEE(parameterEmtyHV,ML_STAR );
			 if (errCode != 0) return;


		// Weekly Maintenance - DC Wash Station - Rinse procedure
		// Please empty the Wash Container and rinse it with distilled water.
		// Please fill Wash Container with 3l of distilled water.
		if ( hslOK != MessageBox(
			StringTable::Load(IDS::dlgWeeklyDCWash2Text),
			StringTable::Load(IDS::dlgWeeklyDCWash2Title),
			hslOKCancel	| hslInformation, hslInfinite ) )
		{
			// Cancel -> end of WashRinceContFull procedure
			traceText = StringTable::Load(IDS::dlgWeeklyDCWash2Title);
			Trace(traceText);
			return;
		}


		loop(2)  // 2 x Rinse step
		{
				// Drain & refill (single chamber only)
				if (nodeIdHW != FimwareNodeID::notInstalled)
					 errCode = DCWashStationCommandEE(parameterEmtyFillHW,ML_STAR );
					 if (errCode != 0) return;
				if (nodeIdHU != FimwareNodeID::notInstalled)
					 errCode = DCWashStationCommandEE(parameterEmtyFillHU,ML_STAR );
					 if (errCode != 0) return;
				if (nodeIdHV != FimwareNodeID::notInstalled)
					 errCode = DCWashStationCommandEE(parameterEmtyFillHV,ML_STAR );
					 if (errCode != 0) return;
		}

		// Emty (single chamber only)		
		if (nodeIdHW != FimwareNodeID::notInstalled)
			 errCode = DCWashStationCommandEE(parameterEmtyHW,ML_STAR );
			 if (errCode != 0) return;
		if (nodeIdHU != FimwareNodeID::notInstalled)
			 errCode = DCWashStationCommandEE(parameterEmtyHU,ML_STAR );
			 if (errCode != 0) return;
		if (nodeIdHV != FimwareNodeID::notInstalled)
			 errCode = DCWashStationCommandEE(parameterEmtyHV,ML_STAR );
			 if (errCode != 0) return;

		// Weekly Maintenance - DC Wash Station - Empty procedure
		// Please empty the Wash Container and rinse it with distilled water.
		// Please empty Waste Container and rinse it with distilled water.
		if ( hslOK != MessageBox(
			StringTable::Load(IDS::dlgWeeklyDCWash3Text),
			StringTable::Load(IDS::dlgWeeklyDCWash3Title),
			hslOKCancel	| hslInformation, hslInfinite ) )
		{
				// Cancel -> end of WashRinceContFull procedure
				traceText = StringTable::Load(IDS::dlgWeeklyDCWash3Title);
				Trace(traceText);
				return;
		}
		if(nodeIdHW == FimwareNodeID::HW)
			dcWashStation_HW_CheckState = PS::successful;
		
		if(nodeIdHU == FimwareNodeID::HU)
			dcWashStation_HU_CheckState = PS::successful;

		if(nodeIdHV == FimwareNodeID::HV)
			dcWashStation_HV_CheckState = PS::successful;
			
		return;
	} // end DCWashStationMaintenanceWeekly


	//-----------------------------------------------------------------------------------------------------
	function DCWashStationCommandEF(variable Parameter,device ML_STAR )
	//-----------------------------------------------------------------------------------------------------
	{
			variable errCode;
			variable bRepeat(hslTrue);
			variable answer;

			bRepeat = hslTrue;
			while(bRepeat)
			{
				answer = FwCommand( "C0EF",  Parameter, hslFalse, ML_STAR);
				errCode = FirmwareErrorCheck(answer);
				bRepeat = hslFalse;
				if(errCode != 0)
					bRepeat = ErrorRecoveryDCWashStation(errCode,Daily);
			}	
			return(errCode);
	}

	//-----------------------------------------------------------------------------------------------------
	function DCWashStationCommandEE(variable Parameter,device ML_STAR )
	//-----------------------------------------------------------------------------------------------------
	{
			variable errCode;
			variable bRepeat(hslTrue);
			variable answer;

			bRepeat = hslTrue;
			while(bRepeat)
			{
				answer = FwCommand( "C0EE",  Parameter, hslFalse, ML_STAR);
				errCode = FirmwareErrorCheck(answer);
				bRepeat = hslFalse;
				if(errCode != 0)
					bRepeat = ErrorRecoveryDCWashStation(errCode,Daily);
			}	
			return(errCode);
	}




	//-----------------------------------------------------------------------------------------------------
	function WashStation_96_384_MaintenanceDaily( device ML_STAR )  //  Find_WashStation_96_384_MaintenanceDaily
	//-----------------------------------------------------------------------------------------------------
	{
		string traceText;													// HslStarLineMaintMetConst.hs_
		variable Wash_Fluid(MtConst::Wash_Fluid_Chamber);     // static const variable Wash_Fluid_Chamber(0);
   																			// static const variable Wash_Fluid_Chamber(1);
		variable handle;
		variable handles[ ];
		variable nodeIdHW(0);
		variable nodeIdHU(0);
		variable nodeIdHV(0);
		variable InstalledWashStation(0);
		  																			
		if (pumpTypeStation1 == 3)
			if(pumpStation1 == 1)
			{
				nodeIdHW = FimwareNodeID::HW;
				head_96_384_WashStation_HW_CheckState = PS::failed;
				InstalledWashStation = InstalledWashStation + 1;
			}
		if (pumpTypeStation2 == 3)
			if(pumpStation2 == 1)
			{
				nodeIdHU = FimwareNodeID::HU;
				head_96_384_WashStation_HU_CheckState = PS::failed;
				InstalledWashStation = InstalledWashStation + 1;
			}
		if (pumpTypeStation3 == 3)
			if(pumpStation3 == 1)
			{
				nodeIdHV = FimwareNodeID::HV;
				head_96_384_WashStation_HV_CheckState = PS::failed;
				InstalledWashStation = InstalledWashStation + 1;
			}

	   	 //  Daily Maintenance - 96/384 Wash Station - Wash procedure"
	    //  Please fill both Wash Container with 2l of water and 20ml of cleaner solution.
		if ( hslOK != MessageBox(
			StringTable::Load(IDS::dlgDaily_96_384_Wash1Text),
			StringTable::Load(IDS::dlgDaily_96_384_Wash1Title),
			hslOKCancel	| hslInformation, hslInfinite ) )
		{
			// Cancel -> end
			traceText = StringTable::Load(IDS::dlgDaily_96_384_Wash1Title);
			Trace(traceText);
			return;
		}


		loop(2)
		{
			//  Fill chamber (dual chamber only)
			ML_STAR._7AA8FFD8_5CE3_408e_BE52_059EA91D46BE( "d6c09e13_1c5a_4237_96a22ffc81a3efe5" ); // Head384EmptyWasher
			if (InstalledWashStation == 2)
				ML_STAR._19AC7FF8_2C7A_4555_AE3B_3A8CB9466EF3( "aa4a3be4_6a23_4e4f_a1394a2d0435835c" ); // Head96EmptyWasher
		}
		//  Empty chamber (dual chamber only)
		ML_STAR._7AA8FFD8_5CE3_408e_BE52_059EA91D46BE( "d02dce6f_9ea1_4d35_a7c30d74127584e8" ); // Head384EmptyWasher
		if (InstalledWashStation == 2)
			ML_STAR._19AC7FF8_2C7A_4555_AE3B_3A8CB9466EF3( "ad84f5eb_4572_4d68_af4e0e56864ec141" ); // Head96EmptyWasher

		// Daily Maintenance - 96/384 Wash Station - Rinse procedure
		// Please empty both Wash Container and rinse it with distilled water.
		// Please fill Wash Container with 3l of distilled water.
		if ( hslOK != MessageBox(
			StringTable::Load(IDS::dlgDaily_96_384_Wash2Text),
			StringTable::Load(IDS::dlgDaily_96_384_Wash2Title),
			hslOKCancel	| hslInformation, hslInfinite ) )
		{
			// Cancel -> end of procedure
			traceText = StringTable::Load(IDS::dlgDaily_96_384_Wash2Title);
			Trace(traceText);
			return;
		}
		loop(2)
		{	//  Fill chamber (dual chamber only)
			ML_STAR._7AA8FFD8_5CE3_408e_BE52_059EA91D46BE( "1d47fd7b_db88_4997_9c9f8d705a6df99d" ); // Head384EmptyWasher
			if (InstalledWashStation == 2)
				ML_STAR._19AC7FF8_2C7A_4555_AE3B_3A8CB9466EF3( "e3e5a7d5_816f_48f7_88a0c96dd85617f0" ); // Head96EmptyWasher
		
		}
		//  Empty chamber (dual chamber only)
		ML_STAR._7AA8FFD8_5CE3_408e_BE52_059EA91D46BE( "81704c39_f7e6_4cf2_acc271df2c5935bb" ); // Head384EmptyWasher
			if (InstalledWashStation == 2)
				ML_STAR._19AC7FF8_2C7A_4555_AE3B_3A8CB9466EF3( "c9e6e094_22c1_4b2e_b5768d1a0dbca401" ); // Head96EmptyWasher
		// Daily Maintenance - 96/384 Wash Station - Empty procedure
		// Please empty both Wash Container and rinse it with distilled water.
		// Please  empty Waste Container and rinse with distilled water.
		if ( hslOK != MessageBox(
			StringTable::Load(IDS::dlgDaily_96_384_Wash3Text),
			StringTable::Load(IDS::dlgDaily_96_384_Wash3Title),
			hslOKCancel	| hslInformation, hslInfinite ) )
		{
			// Cancel -> end of procedure
			traceText = StringTable::Load(IDS::dlgDaily_96_384_Wash3Title);
			Trace(traceText);
			return;
		}
		
		if(nodeIdHW == FimwareNodeID::HW)
			head_96_384_WashStation_HW_CheckState = PS::successful;
		if(nodeIdHU == FimwareNodeID::HU)
			head_96_384_WashStation_HU_CheckState = PS::successful;
		if(nodeIdHV == FimwareNodeID::HV)
			head_96_384_WashStation_HV_CheckState = PS::successful;

		return;
	} // end head_96_384_WashStationMaintenanceDaily


	//-----------------------------------------------------------------------------------------------------
	function WashStation_96_384_MaintenanceWeekly( device ML_STAR )  // Find_WashStation_96_384_MaintenanceWeekly
	//-----------------------------------------------------------------------------------------------------
	{

		string traceText;													// HslStarLineMaintMetConst.hs_
		variable Wash_Fluid(MtConst::Wash_Fluid_Chamber);     // static const variable Wash_Fluid_Chamber(0);
   						 													// static const variable Wash_Fluid_Chamber(1);
				variable handle;
		variable handles[ ];
		variable nodeIdHW(0);
		variable nodeIdHU(0);
		variable nodeIdHV(0);
		variable InstalledWashStation(0);
		
   																			
		if (pumpTypeStation1 == 3)
			if(pumpStation1 == 1)
			{
				nodeIdHW = FimwareNodeID::HW;
				head_96_384_WashStation_HW_CheckState = PS::failed;
				InstalledWashStation = InstalledWashStation + 1;
			}
		if (pumpTypeStation2 == 3)
			if(pumpStation2 == 1)
			{
				nodeIdHU = FimwareNodeID::HU;
				head_96_384_WashStation_HU_CheckState = PS::failed;
				InstalledWashStation = InstalledWashStation + 1;
			}
		if (pumpTypeStation3 == 3)
			if(pumpStation3 == 1)
			{
				nodeIdHV = FimwareNodeID::HV;
				head_96_384_WashStation_HV_CheckState = PS::failed;
				InstalledWashStation = InstalledWashStation + 1;
			}

   	 //  Weekly Maintenance - 96/384 Wash Station - Wash procedure"
     //  Please fill both Wash Container with 2l of water and 20ml of cleaner solution.
		if ( hslOK != MessageBox(
			StringTable::Load(IDS::dlgWeekly_96_384_Wash1Text),
			StringTable::Load(IDS::dlgWeekly_96_384_Wash1Title),
			hslOKCancel	| hslInformation, hslInfinite ) )
		{
			// Cancel -> end
			traceText = StringTable::Load(IDS::dlgWeekly_96_384_Wash1Title);
			Trace(traceText);
			return;
		}

		loop(2)  
		{
			ML_STAR._7AA8FFD8_5CE3_408e_BE52_059EA91D46BE( "e1b44d50_2fd6_4e0a_9dfff1f39e1676bc" ); // Head384EmptyWasher
			if (InstalledWashStation == 2)
				ML_STAR._19AC7FF8_2C7A_4555_AE3B_3A8CB9466EF3( "2b60f3b3_dba5_430d_93511b8b6bbdb60b" ); // Head96EmptyWasher
		}

		// Timer 5 Min Warten
      SleepForWash(MtConst::Wash_96_384_TimerWaitWeekly);

		//   Emty & Fill chamber (dual chamber only)
		ML_STAR._7AA8FFD8_5CE3_408e_BE52_059EA91D46BE( "b4700e1e_d6b8_4742_a6d9877e3ce7cd44" ); // Head384EmptyWasher
		if (InstalledWashStation == 2)
			ML_STAR._19AC7FF8_2C7A_4555_AE3B_3A8CB9466EF3( "b3f81310_d168_41ec_85bda9330fdc7ade" ); // Head96EmptyWasher

		//   Emty chamber (dual chamber only)
		ML_STAR._7AA8FFD8_5CE3_408e_BE52_059EA91D46BE( "5dd765d1_27a2_4d65_a914a9d042137e7a" ); // Head384EmptyWasher
		if (InstalledWashStation == 2)
			ML_STAR._19AC7FF8_2C7A_4555_AE3B_3A8CB9466EF3( "4b1b8bab_d826_48e4_b87091403bafddc2" ); // Head96EmptyWasher

		// Weekly Maintenance - 96/384 Wash Station - Rinse procedure
		// Please empty both Wash Container and rinse it with distilled water.
		// Please fill Wash Container with 3l of distilled water.
		if ( hslOK != MessageBox(
			StringTable::Load(IDS::dlgWeekly_96_384_Wash2Text),
			StringTable::Load(IDS::dlgWeekly_96_384_Wash2Title),
			hslOKCancel	| hslInformation, hslInfinite ) )
		{
			// Cancel -> end of procedure
			traceText = StringTable::Load(IDS::dlgWeekly_96_384_Wash2Title);
			Trace(traceText);
			return;
		}

		loop(2)  // Chamber 1&2
		{
		// Fill chamber (dual chamber only)
		ML_STAR._7AA8FFD8_5CE3_408e_BE52_059EA91D46BE( "a60112dd_5b25_4287_9b41238022fd6763" ); // Head384EmptyWasher
		if (InstalledWashStation == 2)
			ML_STAR._19AC7FF8_2C7A_4555_AE3B_3A8CB9466EF3( "8e818b29_cff4_4ad1_98bcdebb84bf8eec" ); // Head96EmptyWasher
		}

		// Empty chamber (dual chamber only)
		ML_STAR._7AA8FFD8_5CE3_408e_BE52_059EA91D46BE( "7cc1f2aa_17bd_4ab2_b15e0138bda65b53" ); // Head384EmptyWasher
		if (InstalledWashStation == 2)
			ML_STAR._19AC7FF8_2C7A_4555_AE3B_3A8CB9466EF3( "f5228e26_2eb3_45cd_bdc54a94db560095" ); // Head96EmptyWasher
		// Weekly Maintenance - 96/384 Wash Station - Empty procedure
		// Please empty both Wash Container and rinse it with distilled water.
		// Please  empty Waste Container and rinse with distilled water.
		if ( hslOK != MessageBox(
			StringTable::Load(IDS::dlgWeekly_96_384_Wash3Text),
			StringTable::Load(IDS::dlgWeekly_96_384_Wash3Title),
			hslOKCancel	| hslInformation, hslInfinite ) )
		{
			// Cancel -> end of procedure
			traceText = StringTable::Load(IDS::dlgWeekly_96_384_Wash3Title);
			Trace(traceText);
			return;
		}

		if(nodeIdHW == FimwareNodeID::HW)
			head_96_384_WashStation_HW_CheckState = PS::successful;
		if(nodeIdHU == FimwareNodeID::HU)
			head_96_384_WashStation_HU_CheckState = PS::successful;
		if(nodeIdHV == FimwareNodeID::HV)
			head_96_384_WashStation_HV_CheckState = PS::successful;
			
		return;	
	} // end head_96_384_WashStationMaintenanceWeekly




function initializeBVS(variable pumpID, variable COMPort,
	variable dlgBVSWashText, variable dlgBVSWashTitle) variable
{
    variable bRepeat(1);
	 string traceText;
    while(bRepeat)
    {
      // Maintenance - BVS select COM Port");
      // Please enter COM Port No. where the BVS is connected [1 to 255]
      COMPort = InputBox(StringTable::Load(dlgBVSWashText),StringTable::Load(dlgBVSWashTitle),hslInteger,COMPort);

      if (GetType(COMPort) == "")
        return ( -1 );

      // SCR #1284 (allow COM ports 1-255 i/o only 1-4)
      if ((COMPort <= 255 /*4*/) && (COMPort >= 1))
        bRepeat = 0;
      else
        bRepeat = 1;
    }

    traceText = "";
    StrConcat4(traceText,"BVSInitialize(",StrIStr(pumpID),";");
    StrConcat4(traceText,StrIStr(COMPort),")","");
    Trace(traceText);

	 onerror goto toError;
    HSLStarBVSLib::BVSInitialize(pumpID,COMPort);
	 onerror goto 0;

	 return( 1 );

	 toError:
	 {
	  	 if ( hslOK != MessageBox(
       	 StringTable::Load(IDS::errorDuringBVSInitText),
        	 StringTable::Load(dlgBVSWashTitle),
        	 hslOKCancel | hslInformation, hslInfinite ) )
       {
         // Cancel -> end of procedure
         traceText = StringTable::Load(IDS::dlgExecuteDailyBVSTitle);
         Trace(traceText);
		 	return ( -1 );
       }
		 return( 0 );
	 }
}

	//-----------------------------------------------------------------------------------------------------
	function BVSMaintenanceDaily( device ML_STAR ) variable  //  Find_BVSMaintenanceDaily
	//-----------------------------------------------------------------------------------------------------

	{
	 string traceText;
	 variable COMPort;
	 variable BVSResult;
	 variable pumpID;
	 variable deltaPressure;
	 variable duration;
	 variable openValve;
	 variable threshPressure;
	 variable reachedPressure;
	 variable initResult(0);


	 BVS = PS::Installed;
	 BVS_CheckState = PS::failed;

	 COMPort = MtConst::ActiveComBVS;
	 pumpID = BVS1;
	 while(initResult != 1)
	 {
	 	initResult = initializeBVS(pumpID, COMPort, IDS::dlgDailyBVSWash2Text, IDS::dlgDailyBVSWash2Title);
		if(initResult < 0)
			return (hslTrue);
	 }

	 // Unlock front cover
	 LockCover(ML_STAR, CoverLock::coverUnlock, "", "");

	 // Daily Maintenance - BVS Wash procedure
	 // Please fill BVS Container with 0.5l of water and 5ml of cleaner solution.
	 if ( hslOK != MessageBox(
	     StringTable::Load(IDS::dlgDailyBVSWash1Text),
	     StringTable::Load(IDS::dlgDailyBVSWash1Title),
	     hslOKCancel | hslInformation, hslInfinite ) )
	 {
	     // Cancel -> end of procedure
	     traceText = StringTable::Load(IDS::dlgDailyBVSWash1Title);
	     Trace(traceText);
		  HSLStarBVSLib::BVSTerminate(pumpID);
	  
		  return( LockCover(ML_STAR, CoverLock::coverLock, 
		  						  StringTable::Load(IDS::dlgDailyCloseCoverText), 
								  StringTable::Load(IDS::dlgDailyCloseCoverTitle)) );
	 }

	 // Timer 1 Min Warten
	 SleepForWash(MtConst::BVSTimerWaitDaily);

	 deltaPressure = 100;
	 duration = 60;
	 openValve = 1;
	 threshPressure = 100;

	 BVSResult = HSLStarBVSLib::BVSVacuum(pumpID,deltaPressure,duration,openValve,threshPressure,reachedPressure);
	 // if BVSResult == 1, cannot reach vacuum


	 // Please fill BVS Container with 0.5l of water
	 if ( hslOK != MessageBox(
	     StringTable::Load(IDS::dlgDailyBVSWash3Text),
	     StringTable::Load(IDS::dlgDailyBVSWash3Title),
	     hslOKCancel | hslInformation, hslInfinite ) )
	   {
	     // Cancel -> end of procedure
	     traceText = StringTable::Load(IDS::dlgDailyBVSWash3Title);
	     Trace(traceText);
		  HSLStarBVSLib::BVSTerminate(pumpID);

		  return( LockCover(ML_STAR, CoverLock::coverLock, 
		  						  StringTable::Load(IDS::dlgDailyCloseCoverText), StringTable::Load(IDS::dlgDailyCloseCoverTitle)) );
	   }
 
	 BVSResult = HSLStarBVSLib::BVSVacuum(pumpID,deltaPressure,duration,openValve,threshPressure,reachedPressure);
	 // if BVSResult == 1, cannot reach vacuum

	 //  Daily Maintenance - BVS empty procedure
	 //  Please empty Waste Container and rinse it with distilled water.
	 if ( hslOK != MessageBox(
	     StringTable::Load(IDS::dlgDailyBVSWash4Text),
	     StringTable::Load(IDS::dlgDailyBVSWash4Title),
	     hslOKCancel | hslInformation, hslInfinite ) )
	 {
	     // Cancel -> end of procedure
	     traceText = StringTable::Load(IDS::dlgDailyBVSWash4Title);
	     Trace(traceText);
		  HSLStarBVSLib::BVSTerminate(pumpID);

		  return( LockCover(ML_STAR, CoverLock::coverLock, 
		  						  StringTable::Load(IDS::dlgDailyCloseCoverText), StringTable::Load(IDS::dlgDailyCloseCoverTitle)) );
	 }
	 BVS_CheckState = PS::successful;
	 HSLStarBVSLib::BVSTerminate(pumpID);

	 // Lock front cover and return
	  return( LockCover(ML_STAR, CoverLock::coverLock, 
	  						  StringTable::Load(IDS::dlgDailyCloseCoverText), StringTable::Load(IDS::dlgDailyCloseCoverTitle)) );

	}  // End of BVSMaintenanceDaily()  


	//-----------------------------------------------------------------------------------------------------
	function BVSMaintenanceWeekly( device ML_STAR ) variable //  Find_BVSMaintenanceWeekly
	//-----------------------------------------------------------------------------------------------------

	{
		string traceText;
		variable COMPort;
		variable bRepeat ;
		variable BVSResult;
		variable pumpID;
		variable deltaPressure;
		variable duration;
		variable openValve;
		variable threshPressure;
		variable reachedPressure;
	 	variable initResult(0);

	   BVS = PS::Installed;
	   BVS_CheckState = PS::failed;

	   COMPort = MtConst::ActiveComBVS;
	   pumpID = BVS1;
		while(initResult != 1)
		{
			initResult = initializeBVS(pumpID, COMPort, IDS::dlgWeeklyBVSWash2Text, IDS::dlgWeeklyBVSWash2Title);
			if(initResult < 0)
				return(hslTrue);
		}

		// Unlock front cover
		LockCover(ML_STAR, CoverLock::coverUnlock, "", "");

		// Daily Maintenance - BVS Wash procedure");
		// Please fill BVS Container with 0.5l of water and 5ml of cleaner solution
		if ( hslOK != MessageBox(
				StringTable::Load(IDS::dlgWeeklyBVSWash1Text),
				StringTable::Load(IDS::dlgWeeklyBVSWash1Title),
				hslOKCancel	| hslInformation, hslInfinite ) )
		{
			// Cancel -> end of procedure
			traceText = StringTable::Load(IDS::dlgWeeklyBVSWash1Title);
			Trace(traceText);
			HSLStarBVSLib::BVSTerminate(pumpID);

		  return( LockCover(ML_STAR, CoverLock::coverLock, 
		  						  StringTable::Load(IDS::dlgWeeklyCloseCoverText), StringTable::Load(IDS::dlgWeeklyCloseCoverTitle)) );
		}

		// Timer 5 Min Warten
   	SleepForWash(MtConst::BVSTimerWaitWeekly);

		deltaPressure = 100;
		duration = 60;
		openValve = 1;
		threshPressure = 100;

   	BVSResult = HSLStarBVSLib::BVSVacuum(pumpID,deltaPressure,duration,openValve,threshPressure,reachedPressure);


		// Daily Maintenance - BVS empty procedure
		// Please empty Waste Container and rinse it with distilled water.
		if ( hslOK != MessageBox(
			StringTable::Load(IDS::dlgWeeklyBVSWash3Text),
			StringTable::Load(IDS::dlgWeeklyBVSWash3Title),
			hslOKCancel	| hslInformation, hslInfinite ) )
		{
			// Cancel -> end of procedure
			traceText = StringTable::Load(IDS::dlgWeeklyBVSWash3Title);
			Trace(traceText);
	 		HSLStarBVSLib::BVSTerminate(pumpID);

		  return( LockCover(ML_STAR, CoverLock::coverLock, 
		  						  StringTable::Load(IDS::dlgWeeklyCloseCoverText), StringTable::Load(IDS::dlgWeeklyCloseCoverTitle)) );
		}

 	   BVSResult = HSLStarBVSLib::BVSVacuum(pumpID,deltaPressure,duration,openValve,threshPressure,reachedPressure);

	   // Daily Maintenance - BVS empty procedure
		// Please empty Waste Container and rinse it with distilled water.
		if ( hslOK != MessageBox(
			StringTable::Load(IDS::dlgWeeklyBVSWash4Text),
			StringTable::Load(IDS::dlgWeeklyBVSWash4Title),
			hslOKCancel	| hslInformation, hslInfinite ) )
		{
			// Cancel -> end of procedure
			traceText = StringTable::Load(IDS::dlgWeeklyBVSWash4Title);
			Trace(traceText);
	 		HSLStarBVSLib::BVSTerminate(pumpID);

		  return( LockCover(ML_STAR, CoverLock::coverLock, 
		  						  StringTable::Load(IDS::dlgWeeklyCloseCoverText), StringTable::Load(IDS::dlgWeeklyCloseCoverTitle)) );
		}
 	   BVS_CheckState = PS::successful;
	 	HSLStarBVSLib::BVSTerminate(pumpID);

		// Lock front cover and return
	  return( LockCover(ML_STAR, CoverLock::coverLock, 
	  						  StringTable::Load(IDS::dlgWeeklyCloseCoverText), StringTable::Load(IDS::dlgWeeklyCloseCoverTitle)) );

	}	// End of BVSMaintenanceWeekly()  


	//-----------------------------------------------------------------------------------------------------
	function rd3GenerationMaintenance( device ML_STAR )
	//-----------------------------------------------------------------------------------------------------
	{
		string traceText;
		variable maintenanceExecuted(hslFalse);

		// set check state to failed
		needleWashStation_1_CheckState = PS::failed;
		needleWashStation_2_CheckState = PS::failed;

		// ask for needles within all wash station modules
		if ( hslOK != MessageBox(
			StringTable::Load(IDS::dlgCheckWashModulesText),
			StringTable::Load(IDS::dlgCheckWashModulesTitle),
			hslOKCancel	| hslInformation, hslInfinite ) )
		{
			// Cancel -> end of WashRinceContFull procedure
			traceText = StringTable::Load(IDS::dlgCheckWashModulesTitle);
			Trace(traceText);
			return;
		}

		// prompt for preparing wash/rinse solution containers
		if ( hslOK != MessageBox(
			StringTable::Load(IDS::dlgWash3rdWash1Text),
			StringTable::Load(IDS::dlgWash3rdWash1Title),
			hslOKCancel	| hslInformation, hslInfinite ) )
		{
			// Cancel -> end of WashRinceContFull procedure
			traceText = StringTable::Load(IDS::dlgWash3rdWash1Title);
			Trace(traceText);
			return;
		}

		// 3rd Generation Wash Station 1 + 2 installed
		if( (washStation1 == 1 && exwashStation1 == 0) && (washStation2 == 1 && exwashStation2 == 0) )
		{
			variable handle;
			variable handles[ ];

			handle = Fork("ShowInfiniteSoakTimer");
			handles.AddAsLast(handle);

			// 1st wash step (startWithWashLiquidOne = wash solution)

			// wash station 1
			StartWashCRand3rdGen(ML_STAR, LabwrData::washStation1, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime300,
						0, LabwrData::tFlowRate12, 0, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidOne, hslFalse);

			// wash station 2
			StartWashCRand3rdGen(ML_STAR, LabwrData::washStation2, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime300,
						0, LabwrData::tFlowRate12, 0, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidOne, hslFalse);

			// 2nd wash step (startWithWashLiquidOne = wash solution)

			// wash station 1
			StartWashCRand3rdGen(ML_STAR, LabwrData::washStation1, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime1,
			 			0, LabwrData::tFlowRate12, 0, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidOne, hslFalse);

			// wash station 2
			StartWashCRand3rdGen(ML_STAR, LabwrData::washStation2, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime1,
						0, LabwrData::tFlowRate12, 0, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidOne, hslFalse);

			// wait for needle wash finished
			WaitUntilAllWashPumpsStopped(ML_STAR, LabwrData::washStation1, hslFalse);
			WaitUntilAllWashPumpsStopped(ML_STAR, LabwrData::washStation2, hslFalse);

			// new rinse procedure

			( hslOK != MessageBox( StringTable::Load(IDS::dlgWash3rdWashRinseText), StringTable::Load(IDS::dlgWash3rdWashRinseTitle),
			hslOKOnly	| hslInformation, hslInfinite ) );


			// 1st and 2nd rinse step (startWithWashLiquidTwo = rinse solution)
			loop(2)
			{
				// wash station 1
				StartWashCRand3rdGen(ML_STAR, LabwrData::washStation1, 0, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime1,
						0, LabwrData::tFlowRate12, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidTwo, hslFalse);

				// wash station 2
				StartWashCRand3rdGen(ML_STAR, LabwrData::washStation2, 0, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime1,
						0, LabwrData::tFlowRate12, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidTwo, hslFalse);
			}

			// wait for needle wash finished
			WaitUntilAllWashPumpsStopped(ML_STAR, LabwrData::washStation1, hslFalse);
			WaitUntilAllWashPumpsStopped(ML_STAR, LabwrData::washStation2, hslFalse);

			soakTimer.SetTimer(0);
			Join(handles, 0);

			needleWashStation_1_CheckState = PS::successful;
			needleWashStation_2_CheckState = PS::successful;

			maintenanceExecuted = hslTrue;
		}


		if (!maintenanceExecuted)
		{
			// 3rd Generation Wash Station 1
			if (washStation1 == 1 && exwashStation1 == 0 )
			{
				variable handle;
				variable handles[ ];

				handle = Fork("ShowInfiniteSoakTimer");
				handles.AddAsLast(handle);

				// 1st wash step (startWithWashLiquidOne = wash solution)
				StartWashCRand3rdGen(ML_STAR, LabwrData::washStation1, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime300,
							0, LabwrData::tFlowRate12, 0, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidOne, hslFalse);

				// 2nd wash step (startWithWashLiquidOne = wash solution)
				StartWashCRand3rdGen(ML_STAR, LabwrData::washStation1, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime1,
							0, LabwrData::tFlowRate12, 0, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidOne, hslFalse);

				// wait for needle wash finished
				WaitUntilAllWashPumpsStopped(ML_STAR,LabwrData::washStation1, hslFalse);

				// new rinse procedure

				( hslOK != MessageBox(StringTable::Load(IDS::dlgWash3rdWashRinseText), StringTable::Load(IDS::dlgWash3rdWashRinseTitle),
				hslOKOnly	| hslInformation, hslInfinite ) );


				// 1st and 2nd rinse step (startWithWashLiquidTwo = rinse solution)
				loop(2)
				{
					StartWashCRand3rdGen(ML_STAR, LabwrData::washStation1, 0, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime1,
							0, LabwrData::tFlowRate12, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidTwo, hslFalse);
				}

				// wait for needle wash finished
				WaitUntilAllWashPumpsStopped(ML_STAR,LabwrData::washStation1, hslFalse);

				soakTimer.SetTimer(0);
				Join(handles, 0);

				needleWashStation_1_CheckState = PS::successful;
		 	}
			else
				needleWashStation_1_CheckState = PS::notInstalled;

			// 3rd Generation Wash Station 2
			if (washStation2 == 1 && exwashStation2 == 0)
			{
				variable handle;
				variable handles[ ];

				handle = Fork("ShowInfiniteSoakTimer");
				handles.AddAsLast(handle);

				// 1st wash step (startWithWashLiquidOne = wash solution)
				StartWashCRand3rdGen(ML_STAR, LabwrData::washStation2, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime300,
							0, LabwrData::tFlowRate12, 0, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidOne, hslFalse);

				// 2nd wash step (startWithWashLiquidOne = wash solution)
				StartWashCRand3rdGen(ML_STAR, LabwrData::washStation2, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime1,
							0, LabwrData::tFlowRate12, 0, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidOne, hslFalse);

				// wait for needle wash finished
				WaitUntilAllWashPumpsStopped(ML_STAR, LabwrData::washStation2, hslFalse);

				// new rinse procedure

				( hslOK != MessageBox(StringTable::Load(IDS::dlgWash3rdWashRinseText), StringTable::Load(IDS::dlgWash3rdWashRinseTitle),
					hslOKOnly	| hslInformation, hslInfinite ) );


				// 1st and 2nd rinse step (startWithWashLiquidTwo = rinse solution)
				loop(2)
				{
					StartWashCRand3rdGen(ML_STAR, LabwrData::washStation2, 0, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime1,
							0, LabwrData::tFlowRate12, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidTwo, hslFalse);
				}

				// wait for needle wash finished
				WaitUntilAllWashPumpsStopped(ML_STAR, LabwrData::washStation2, hslFalse);

				soakTimer.SetTimer(0);
				Join(handles, 0);

				needleWashStation_2_CheckState = PS::successful;
		 	}
			else
				needleWashStation_2_CheckState = PS::notInstalled;
		}

		// prompt for drain and clean up wash/rinse solution containers
		if ( hslOK != MessageBox(
			StringTable::Load(IDS::dlgWash3rdWash6Text),
			StringTable::Load(IDS::dlgWash3rdWash6Title),
			hslOKCancel	| hslInformation, hslInfinite ) )
		{
			// set check state to failed, even if maintenance was successful executed
			if(washStation1 == 1)
				needleWashStation_1_CheckState = PS::failed;
			if(washStation2 == 1)
				needleWashStation_2_CheckState = PS::failed;

			// Cancel -> end of WashRinseContEmpty procedure
			traceText = StringTable::Load(IDS::dlgWash3rdWash6Title);
			Trace(traceText);
			return;
		}

		return;
	}	// end rd3GenerationMaintenance


	//-----------------------------------------------------------------------------------------------------
	function rd3GenerationMaintenanceDaily( device ML_STAR )
	//-----------------------------------------------------------------------------------------------------
	{
		string traceText;
		variable maintenanceExecuted(hslFalse);

		// set check state to failed
		needleWashStation_1_CheckState = PS::failed;
		needleWashStation_2_CheckState = PS::failed;

		// ask for needles within all wash station modules
		if ( hslOK != MessageBox(
			StringTable::Load(IDS::dlgCheckWashModulesText),
			StringTable::Load(IDS::dlgCheckWashModulesTitle),
			hslOKCancel	| hslInformation, hslInfinite ) )
		{
			// Cancel -> end of WashRinceContFull procedure
			traceText = StringTable::Load(IDS::dlgCheckWashModulesTitle);
			Trace(traceText);
			return;
		}

		// prompt for preparing wash/rinse solution containers
		if ( hslOK != MessageBox(
			StringTable::Load(IDS::dlgWash3rdWashFullDailyText),
			StringTable::Load(IDS::dlgWash3rdWashFullDailyTitle),
			hslOKCancel	| hslInformation, hslInfinite ) )
		{
			// Cancel -> end of WashRinceContFull procedure
			traceText = StringTable::Load(IDS::dlgWash3rdWashFullDailyTitle);
			Trace(traceText);
			return;
		}

		// 3rd Generation Wash Station 1 + 2 installed
		if( (washStation1 == 1 && exwashStation1 == 0) && (washStation2 == 1 && exwashStation2 == 0) )
		{
			variable handle;
			variable handles[ ];

			handle = Fork("ShowInfiniteSoakTimer");
			handles.AddAsLast(handle);

			// 1st wash step (startWithWashLiquidOne = wash solution)

			// wash station 1
			StartWashCRand3rdGen(ML_STAR, LabwrData::washStation1, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime1,
			 			0, LabwrData::tFlowRate12, 0, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidOne, hslFalse);

			// wash station 2
			StartWashCRand3rdGen(ML_STAR, LabwrData::washStation2, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime1,
						0, LabwrData::tFlowRate12, 0, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidOne, hslFalse);

			// wait for needle wash finished
			WaitUntilAllWashPumpsStopped(ML_STAR, LabwrData::washStation1, hslFalse);
			WaitUntilAllWashPumpsStopped(ML_STAR, LabwrData::washStation2, hslFalse);


			// new rinse procedure

			( hslOK != MessageBox(StringTable::Load(IDS::dlgWash3rdWashRinseText), StringTable::Load(IDS::dlgWash3rdWashRinseTitle),
				hslOKOnly	| hslInformation, hslInfinite ) );


			// 1st and 2nd rinse step (startWithWashLiquidTwo = rinse solution)
			loop(2)
			{
				// wash station 1
				StartWashCRand3rdGen(ML_STAR, LabwrData::washStation1, 0, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime1,
						0, LabwrData::tFlowRate12, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidTwo, hslFalse);

				// wash station 2
				StartWashCRand3rdGen(ML_STAR, LabwrData::washStation2, 0, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime1,
						0, LabwrData::tFlowRate12, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidTwo, hslFalse);
			}

			// wait for needle wash finished
			WaitUntilAllWashPumpsStopped(ML_STAR, LabwrData::washStation1, hslFalse);
			WaitUntilAllWashPumpsStopped(ML_STAR, LabwrData::washStation2, hslFalse);

			soakTimer.SetTimer(0);
			Join(handles, 0);

			needleWashStation_1_CheckState = PS::successful;
			needleWashStation_2_CheckState = PS::successful;

			maintenanceExecuted = hslTrue;
		}


		if (!maintenanceExecuted)
		{
			// 3rd Generation Wash Station 1
			if (washStation1 == 1 && exwashStation1 == 0 )
			{
				variable handle;
				variable handles[ ];

				handle = Fork("ShowInfiniteSoakTimer");
				handles.AddAsLast(handle);

				// 1st wash step (startWithWashLiquidOne = wash solution)
				StartWashCRand3rdGen(ML_STAR, LabwrData::washStation1, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime1,
							0, LabwrData::tFlowRate12, 0, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidOne, hslFalse);

				// wait for needle wash finished
				WaitUntilAllWashPumpsStopped(ML_STAR,LabwrData::washStation1, hslFalse);

				// new rinse procedure

				( hslOK != MessageBox(StringTable::Load(IDS::dlgWash3rdWashRinseText), StringTable::Load(IDS::dlgWash3rdWashRinseTitle),
					hslOKOnly	| hslInformation, hslInfinite ) );


				// 1st and 2nd rinse step (startWithWashLiquidTwo = rinse solution)
				loop(2)
				{
					StartWashCRand3rdGen(ML_STAR, LabwrData::washStation1, 0, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime1,
							0, LabwrData::tFlowRate12, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidTwo, hslFalse);
				}

				// wait for needle wash finished
				WaitUntilAllWashPumpsStopped(ML_STAR,LabwrData::washStation1, hslFalse);

				soakTimer.SetTimer(0);
				Join(handles, 0);

				needleWashStation_1_CheckState = PS::successful;
		 	}
			else
				needleWashStation_1_CheckState = PS::notInstalled;

			// 3rd Generation Wash Station 2
			if (washStation2 == 1 && exwashStation2 == 0)
			{
				variable handle;
				variable handles[ ];

				handle = Fork("ShowInfiniteSoakTimer");
				handles.AddAsLast(handle);

				// 1st wash step (startWithWashLiquidOne = wash solution)
				StartWashCRand3rdGen(ML_STAR, LabwrData::washStation2, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime1,
							0, LabwrData::tFlowRate12, 0, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidOne, hslFalse);

				// wait for needle wash finished
				WaitUntilAllWashPumpsStopped(ML_STAR, LabwrData::washStation2, hslFalse);

				// new rinse procedure

				( hslOK != MessageBox(StringTable::Load(IDS::dlgWash3rdWashRinseText), StringTable::Load(IDS::dlgWash3rdWashRinseTitle),
					hslOKOnly	| hslInformation, hslInfinite ) );


				// 1st and 2nd rinse step (startWithWashLiquidTwo = rinse solution)
				loop(2)
				{
					StartWashCRand3rdGen(ML_STAR, LabwrData::washStation2, 0, LabwrData::tRinseTime60, 0, LabwrData::tSoakTime1,
							0, LabwrData::tFlowRate12, LabwrData::tDrainingTime12, LabwrData::startWithWashLiquidTwo, hslFalse);
				}

				// wait for needle wash finished
				WaitUntilAllWashPumpsStopped(ML_STAR, LabwrData::washStation2, hslFalse);

				soakTimer.SetTimer(0);
				Join(handles, 0);

				needleWashStation_2_CheckState = PS::successful;
		 	}
			else
				needleWashStation_2_CheckState = PS::notInstalled;
		}

		// prompt for drain and clean up wash/rinse solution containers
		if ( hslOK != MessageBox(
			StringTable::Load(IDS::dlgWash3rdWash6Text),
			StringTable::Load(IDS::dlgWash3rdWash6Title),
			hslOKCancel	| hslInformation, hslInfinite ) )
		{
			// set check state to failed, even if maintenance was successful executed
			if(washStation1 == 1)
				needleWashStation_1_CheckState = PS::failed;
			if(washStation2 == 1)
				needleWashStation_2_CheckState = PS::failed;

			// Cancel -> end of WashRinseContEmpty procedure
			traceText = StringTable::Load(IDS::dlgWash3rdWash6Title);
			Trace(traceText);
			return;
		}

		return;
	}	// end rd3GenerationMaintenanceDaily


   //-----------------------------------------------------------------------------------------------------
	function SwitchLoadingIndicators(variable firstPosInt, variable countOfPos, device ML_STAR )
	//-----------------------------------------------------------------------------------------------------
	{
  		variable bitmuster("cl00000000000000cb00000000000000");
		string answer;
		variable errCode;

      if(countOfPos > 0)
      {
         const variable maxHexVal(14);
         const variable maxBitPerHexVal(4);
         variable helpArray[];
         variable i;
         variable a;
   		variable strCl("cl");
   		variable strCb("cb");
         variable helpStr("");
         variable hexStr("");
         variable firstPos(firstPosInt);


         helpArray.SetSize(56);

      	// jedes nibble wird hier gespiegelt 
      	for (i = 0; i < maxHexVal; i++)
      	{
      		for (a = 1; a <= maxBitPerHexVal; a++)
      		{
      			if ((i < (maxHexVal-1)) || ( a < maxBitPerHexVal))
      			{
      				variable parameter(0);

                  if(((i * maxBitPerHexVal + a) >= firstPos) && ((i * maxBitPerHexVal + a) <= firstPos+countOfPos-1))
                     parameter = 1;

      				helpArray[(i * maxBitPerHexVal + maxBitPerHexVal) - a] = parameter;
      			}
      			else
      			{
      				helpArray[(i * maxBitPerHexVal + maxBitPerHexVal) - a] = 0;
      			}
      		}
      	}


      	// alle nibble werden hier in Ziffern ungewandelt
      	for (i = 0; i < maxHexVal; i++)
      	{
      		variable value(0);
            variable strVal("");
		
      		for (a = 0; a < maxBitPerHexVal; a++)
      		{
      			if (helpArray.GetAt(i * maxBitPerHexVal + a) == 1)
      			{
                  if(a == 0) value = value + 8;
                  if(a == 1) value = value + 4;
                  if(a == 2) value = value + 2;
                  if(a == 3) value = value + 1;
      			}
      		}
            // change value to a hex value as string
            if(value > 9)
            {
               if(value == 10) strVal = "A";
               if(value == 11) strVal = "B";
               if(value == 12) strVal = "C";
               if(value == 13) strVal = "D";
               if(value == 14) strVal = "E";
               if(value == 15) strVal = "F";
            }
            else
            {
               strVal = IStr(value);
            }
            // add new hex val at first position
            helpStr = hexStr;
            hexStr = strVal;
            hexStr = hexStr + helpStr;
      	}
         strCl = strCl + hexStr;
         strCb = strCb + hexStr;

        	bitmuster = StrConcat2(strCl,strCb);
      }

      answer = FwCommand("C0CP", bitmuster, hslFalse, ML_STAR);
		errCode = FirmwareErrorCheck(answer);
		return(errCode);
	}


	//-----------------------------------------------------------------------------------------------------
	function Core96HeadWsMaintenance( device ML_STAR, variable nodeId )
	//-----------------------------------------------------------------------------------------------------
	{
		string traceText;
		variable parameterPrime;
		variable parameter1stWashStep;
		variable parameter2ndWashStep;
		variable parameterRinseStep;
		variable parameterDrainingStep;
		variable bRepeat(hslTrue);
		string answer;										// firmware response string
		variable errCode;									// error code extracted out from firmware result string

		if(nodeId == FimwareNodeID::HW)
		{
			head96WashStation_HW_CheckState = PS::failed;

			parameterPrime = "ep1";
			parameter1stWashStep = "ep1ee1ef0";
			parameter2ndWashStep = "ep1ee1ef0";
			parameterDrainingStep = "ep1ee0ef0";
			parameterRinseStep = "ep1ee0ef0";
		}
		else if(nodeId == FimwareNodeID::HU)
		{
			head96WashStation_HU_CheckState = PS::failed;

			parameterPrime = "ep2";
			parameter1stWashStep = "ep2ee1ef0";
			parameter2ndWashStep = "ep2ee1ef0";
			parameterDrainingStep = "ep2ee0ef0";
			parameterRinseStep = "ep2ee0ef0";
		}
		else if(nodeId == FimwareNodeID::HV)
		{
			head96WashStation_HV_CheckState = PS::failed;

			parameterPrime = "ep3";
			parameter1stWashStep = "ep3ee1ef0";
			parameter2ndWashStep = "ep3ee1ef0";
			parameterDrainingStep = "ep3ee0ef0";
			parameterRinseStep = "ep3ee0ef0";
		}
		else
			return;

		// prompt for preparing wash/rinse solution containers (step 1)
		if ( hslOK != MessageBox(
			StringTable::Load(IDS::dlgWash96Wash1Text),
			StringTable::Load(IDS::dlgWash96Wash1Title),
			hslOKCancel	| hslInformation, hslInfinite ) )
		{
			// Cancel -> end of WashRinceContFull procedure
			traceText = StringTable::Load(IDS::dlgWash96Wash1Title);
			Trace(traceText);
			return;
		}

		// prime wash station
		while(bRepeat)
		{
			answer = FwCommand( "C0EF", parameterPrime, hslFalse, ML_STAR);
			errCode = FirmwareErrorCheck(answer);
			bRepeat = hslFalse;

			if(errCode != 0)
				bRepeat = ErrorRecoveryCORE96Head(errCode);
		}

		// 1st wash step (drain and refill)
		bRepeat = hslTrue;
		while(bRepeat)
		{
			answer = FwCommand( "C0EE", parameter1stWashStep, hslFalse, ML_STAR);
			errCode = FirmwareErrorCheck(answer);
			bRepeat = hslFalse;

			if(errCode != 0)
				bRepeat = ErrorRecoveryCORE96Head(errCode);
		}

		// timer 5'
		SoakTimeWait(LabwrData::tSoakTimeWait);

		// 2nd wash step (drain and refill)
		bRepeat = hslTrue;
		while(bRepeat)
		{
			answer = FwCommand( "C0EE", parameter2ndWashStep, hslFalse, ML_STAR);
			errCode = FirmwareErrorCheck(answer);
			bRepeat = hslFalse;

			if(errCode != 0)
				bRepeat = ErrorRecoveryCORE96Head(errCode);
		}

		// 2nd wash step (drain)
		bRepeat = hslTrue;
		while(bRepeat)
		{
			answer = FwCommand( "C0EE", parameterDrainingStep, hslFalse, ML_STAR);
			errCode = FirmwareErrorCheck(answer);
			bRepeat = hslFalse;

			if(errCode != 0)
				bRepeat = ErrorRecoveryCORE96Head(errCode);
		}

		// prompt for preparing wash/rinse solution containers (step 6)
		if ( hslOK != MessageBox(
			StringTable::Load(IDS::dlgWash96Wash6Text),
			StringTable::Load(IDS::dlgWash96Wash6Title),
			hslOKCancel	| hslInformation, hslInfinite ) )
		{
			// Cancel -> end of WashRinceContFull procedure
			traceText = StringTable::Load(IDS::dlgWash96Wash6Title);
			Trace(traceText);
			return;
		}

		// 2 x Rinse step
		loop(2)
		{
			// fill
			bRepeat = hslTrue;
			while(bRepeat)
			{
				answer = FwCommand( "C0EB", parameterPrime, hslFalse, ML_STAR);
				errCode = FirmwareErrorCheck(answer);
				bRepeat = hslFalse;

				if(errCode != 0)
					bRepeat = ErrorRecoveryCORE96Head(errCode);
			}

			// drain
			bRepeat = hslTrue;
			while(bRepeat)
			{
				answer = FwCommand( "C0EE", parameterDrainingStep, hslFalse, ML_STAR);
				errCode = FirmwareErrorCheck(answer);
				bRepeat = hslFalse;

				if(errCode != 0)
					bRepeat = ErrorRecoveryCORE96Head(errCode);
			}
		}

		//prompt for preparing wash/rinse solution containers (step 8)
		if ( hslOK != MessageBox(
			StringTable::Load(IDS::dlgWash96Wash8Text),
			StringTable::Load(IDS::dlgWash96Wash8Title),
			hslOKCancel	| hslInformation, hslInfinite ) )
		{
			// Cancel -> end of WashRinceContFull procedure
			traceText = StringTable::Load(IDS::dlgWash96Wash8Title);
			Trace(traceText);
			return;
		}

		if(nodeId == FimwareNodeID::HW)
			head96WashStation_HW_CheckState = PS::successful;
		else
		if(nodeId == FimwareNodeID::HU)
			head96WashStation_HU_CheckState = PS::successful;
		else
		if(nodeId == FimwareNodeID::HV)
			head96WashStation_HV_CheckState = PS::successful;
	} // end Core96HeadWsMaintenance


	//-----------------------------------------------------------------------------------------------------
	function Core96HeadWsMaintenanceDaily( device ML_STAR, variable nodeId )
	//-----------------------------------------------------------------------------------------------------
	{
		string traceText;
		variable parameterPrime;
		variable parameter1stWashStep;
		variable parameter2ndWashStep;
		variable parameterRinseStep;
		variable parameterDrainingStep;
		variable bRepeat(hslTrue);
		string answer;										// firmware response string
		variable errCode;									// error code extracted out from firmware result string

		if(nodeId == FimwareNodeID::HW)
		{
			head96WashStation_HW_CheckState = PS::failed;

			parameterPrime = "ep1";
			parameter1stWashStep = "ep1ee1ef0";
			parameter2ndWashStep = "ep1ee1ef0";
			parameterDrainingStep = "ep1ee0ef0";
			parameterRinseStep = "ep1ee0ef0";
		}
		else if(nodeId == FimwareNodeID::HU)
		{
			head96WashStation_HU_CheckState = PS::failed;

			parameterPrime = "ep2";
			parameter1stWashStep = "ep2ee1ef0";
			parameter2ndWashStep = "ep2ee1ef0";
			parameterDrainingStep = "ep2ee0ef0";
			parameterRinseStep = "ep2ee0ef0";
		}
		else if(nodeId == FimwareNodeID::HV)
		{
			head96WashStation_HV_CheckState = PS::failed;

			parameterPrime = "ep3";
			parameter1stWashStep = "ep3ee1ef0";
			parameter2ndWashStep = "ep3ee1ef0";
			parameterDrainingStep = "ep3ee0ef0";
			parameterRinseStep = "ep3ee0ef0";
		}
		else
			return;

		// prompt for preparing wash/rinse solution containers (step 1)
		if ( hslOK != MessageBox(
			StringTable::Load(IDS::dlgWash96Wash1Text),
			StringTable::Load(IDS::dlgWash96Wash1Title),
			hslOKCancel	| hslInformation, hslInfinite ) )
		{
			// Cancel -> end of WashRinceContFull procedure
			traceText = StringTable::Load(IDS::dlgWash96Wash1Title);
			Trace(traceText);
			return;
		}

		// prime wash station
		while(bRepeat)
		{
			answer = FwCommand( "C0EF", parameterPrime, hslFalse, ML_STAR);
			errCode = FirmwareErrorCheck(answer);
			bRepeat = hslFalse;

			if(errCode != 0)
				bRepeat = ErrorRecoveryCORE96Head(errCode);
		}

		// 1st wash step (drain and refill)
		bRepeat = hslTrue;
		while(bRepeat)
		{
			answer = FwCommand( "C0EE", parameter2ndWashStep, hslFalse, ML_STAR);
			errCode = FirmwareErrorCheck(answer);
			bRepeat = hslFalse;

			if(errCode != 0)
				bRepeat = ErrorRecoveryCORE96Head(errCode);
		}

		// 1st wash step (drain)
		bRepeat = hslTrue;
		while(bRepeat)
		{
			answer = FwCommand( "C0EE", parameterDrainingStep, hslFalse, ML_STAR);
			errCode = FirmwareErrorCheck(answer);
			bRepeat = hslFalse;

			if(errCode != 0)
				bRepeat = ErrorRecoveryCORE96Head(errCode);
		}

		// prompt for preparing wash/rinse solution containers (step 2)
		if ( hslOK != MessageBox(
			StringTable::Load(IDS::dlgWash96Wash6Text),
			StringTable::Load(IDS::dlgWash96Wash6Title),
			hslOKCancel	| hslInformation, hslInfinite ) )
		{
			// Cancel -> end of WashRinceContFull procedure
			traceText = StringTable::Load(IDS::dlgWash96Wash6Title);
			Trace(traceText);
			return;
		}

		// 2 x Rinse step
		loop(2)
		{
			// fill
			bRepeat = hslTrue;
			while(bRepeat)
			{
				answer = FwCommand( "C0EB", parameterPrime, hslFalse, ML_STAR);
				errCode = FirmwareErrorCheck(answer);
				bRepeat = hslFalse;

				if(errCode != 0)
					bRepeat = ErrorRecoveryCORE96Head(errCode);
			}

			// drain
			bRepeat = hslTrue;
			while(bRepeat)
			{
				answer = FwCommand( "C0EE", parameterDrainingStep, hslFalse, ML_STAR);
				errCode = FirmwareErrorCheck(answer);
				bRepeat = hslFalse;

				if(errCode != 0)
					bRepeat = ErrorRecoveryCORE96Head(errCode);
			}
		}

		//prompt for preparing wash/rinse solution containers (step 6)
		if ( hslOK != MessageBox(
			StringTable::Load(IDS::dlgWash96Wash8Text),
			StringTable::Load(IDS::dlgWash96Wash8Title),
			hslOKCancel	| hslInformation, hslInfinite ) )
		{
			// Cancel -> end of WashRinceContFull procedure
			traceText = StringTable::Load(IDS::dlgWash96Wash8Title);
			Trace(traceText);
			return;
		}

		if(nodeId == FimwareNodeID::HW)
			head96WashStation_HW_CheckState = PS::successful;
		else
		if(nodeId == FimwareNodeID::HU)
			head96WashStation_HU_CheckState = PS::successful;
		else
		if(nodeId == FimwareNodeID::HV)
			head96WashStation_HV_CheckState = PS::successful;
	} // end Core96HeadWsMaintenanceDaily


	//-----------------------------------------------------------------------------------------------------
	static function InitializeProcessCheckStates()
	//-----------------------------------------------------------------------------------------------------
	{
		// set check states of all installed components to open
		instrumentCheckState = PS::open;

		if( 0 != instrNumberOfChannels1000ul )
		{
			tightnessCheckChannel1000ulState = PS::open;
			cLLDCheckChannel1000ulState = PS::open;
		}

		if( 0 != instrNumberOfChannels5ml )
		{
			tightnessCheckChannel5mlState = PS::open;
			cLLDCheckChannel5mlState = PS::open;
		}

		if(washStation1 != 0)
		{
			if(exwashStation1 != 0)
				crWashStation_1_CheckState =  PS::open;
			else
				needleWashStation_1_CheckState =  PS::open;
		}

		if(washStation2 != 0)
		{
			if(exwashStation2 != 0)
				crWashStation_2_CheckState =  PS::open;
			else
				needleWashStation_2_CheckState =  PS::open;
		}

		if(pumpStation1 != 0)	// node HW
		{
			if(pumpTypeStation1 == 0) // CO-RE Head 96 washer pump unit
				head96WashStation_HW_CheckState =  PS::open;
			else
			if(pumpTypeStation1 == 1) // DC Washer pump unit
				dcWashStation_HW_CheckState =  PS::open;
			else
			if(pumpTypeStation1 == 3) // 96/384 Washer pump unit
				head_96_384_WashStation_HW_CheckState =  PS::open;
		}

		if(pumpStation2 != 0)	// node HU
		{
			if(pumpTypeStation2 == 0) // CO-RE Head 96 washer pump unit
				head96WashStation_HU_CheckState =  PS::open;
			else
			if(pumpTypeStation2 == 1) // DC Washer pump unit
				dcWashStation_HU_CheckState =  PS::open;
			else
			if(pumpTypeStation2 == 3) // 96/384 Washer pump unit
				head_96_384_WashStation_HU_CheckState =  PS::open;

		}

		if(pumpStation3 != 0)	// node HV
		{
			if(pumpTypeStation3 == 0) // CO-RE Head 96 washer pump unit
				head96WashStation_HV_CheckState =  PS::open;
			else
			if(pumpTypeStation3 == 1) // DC Washer pump unit
				dcWashStation_HV_CheckState =  PS::open;
					else
			if(pumpTypeStation3 == 3) // 96/384 Washer pump unit
				head_96_384_WashStation_HV_CheckState =  PS::open;
		}

      if(head96TadmHead != 0)
      {
			tightnessCheckChannel96TadmHeadState = PS::open;
      }

      if(easyPuncher == 1 && cardGripper == 1)
      {
			easyPuncherState = PS::open;
      }

		return;
	} 	// end InitializeProcessCheckStates

	//-----------------------------------------------------------------------------------------------------
	function AddAllNeededLabware( device ML_STAR )
	//-----------------------------------------------------------------------------------------------------
	{
		variable labwareDir(GetLabwarePath());
		variable labwarePathFileName;
		variable position[];					// array contains the labware position x,y,z

		// Wash Station 1
		if (washStation1 == 1)
		{
			// positioning of washstation 1 (Track 1 - 6)
			position.SetSize(0);
			position.AddAsLast(100); 		// x-Pos (100 + 0*22.5)
			position.AddAsLast(63);			// y-Pos
			position.AddAsLast(100);		// z-pos

			if (exwashStation1 == 1) // 1=CR
			{
				labwarePathFileName = labwareDir + LabwrData::crWS1FileName;

				ML_STAR.AddLabware(LabwrData::crWS1LabId, labwarePathFileName, position);
			}
			else // it's a 3rd generation washstation
			{
				labwarePathFileName = labwareDir + LabwrData::gen3rdWS1FileName;

				ML_STAR.AddLabware(LabwrData::gen3rdWS1LabId, labwarePathFileName, position);
			}
		}

		// Wash Station 2
		if (washStation2 == 1)
		{
			// positioning of washstation 1 (Track 7 - 12)
			position.SetSize(0);
			position.AddAsLast(235); 		// x-Pos (100 + 6*22.5)
			position.AddAsLast(63);			// y-Pos
			position.AddAsLast(100);		// z-pos

			if (exwashStation2 == 1) // 1=CR
			{
				labwarePathFileName = labwareDir + LabwrData::crWS2FileName;

				ML_STAR.AddLabware(LabwrData::crWS2LabId, labwarePathFileName, position);
			}
			else // it's a 3rd generation washstation
			{
				labwarePathFileName = labwareDir + LabwrData::gen3rdWS2FileName;

				ML_STAR.AddLabware(LabwrData::gen3rdWS2LabId, labwarePathFileName, position);
			}
		}

		// add CO-RE 96 Head labware
		if(leftArmHas96Head == 1)
		{
			variable nodeId(FimwareNodeID::notInstalled);

			if(pumpTypeStation1 == 0)
				nodeId = FimwareNodeID::HW;
			else
			if(pumpTypeStation2 == 0)
				nodeId = FimwareNodeID::HU;
			else
			if(pumpTypeStation3 == 0)
				nodeId = FimwareNodeID::HV;

			if(nodeId != 0)
			{
				// positioning of CO-RE 96 Headwashstation 1 (Track 13 - 20)
				position.SetSize(0);
				position.AddAsLast(370); 		// x-Pos (100 + 12*22.5)
				position.AddAsLast(63);			// y-Pos
				position.AddAsLast(100);		// z-pos

				if(nodeId == FimwareNodeID::HW)
				{
					labwarePathFileName = labwareDir + LabwrData::core96HeadWashstationHW;
					ML_STAR.AddLabware(LabwrData::core96HeadWsHWLabId, labwarePathFileName, position);
				}
				else if(nodeId == FimwareNodeID::HU)
				{
					labwarePathFileName = labwareDir + LabwrData::core96HeadWashstationHU;
					ML_STAR.AddLabware(LabwrData::core96HeadWsHULabId, labwarePathFileName, position);
				}
				else if(nodeId == FimwareNodeID::HV)
				{
					labwarePathFileName = labwareDir + LabwrData::core96HeadWashstationHV;
					ML_STAR.AddLabware(LabwrData::core96HeadWsHVLabId, labwarePathFileName, position);
				}
			}
		}

      if(nanoPipettor == 1 || nanoPipettorPlusN == 1)
      {
     		//*******************************************************************************************
     		// Start set Slot-Postion
   		//*******************************************************************************************
         // Note;
         // HxGruCommand needs the service carrier to init a instrument with installed Nano pipettor.
         // HxGruCommand must make an flush during the initialization if the instrument switched off
         // on the last run before cleanup functionality from HxGruCommand was called.
         // This means, the service carrier must be present for all maintenance routines.
         AddNanoServiceCarrier(ML_STAR);
      }

		{
   	   variable moreThenOneWashStaion;
				
			// positioning of washstation 1 (Track 1 - 6)
			position.SetSize(0);
			position.AddAsLast(100); 		// x-Pos (100 + 0*22.5)
			position.AddAsLast(63);			// y-Pos
			position.AddAsLast(100);		// z-pos
			moreThenOneWashStaion = hslFalse;

		//   Core 384 Head
		if (pumpTypeStation1 == 3)
			if(pumpStation1 == 1)  // FimwareNodeID::HW
			{
				labwarePathFileName = labwareDir + LabwrData::core384HeadDualWashstationHW;
				ML_STAR.AddLabware(LabwrData::core384DualWashstationHWLabId, labwarePathFileName, position);
				moreThenOneWashStaion = hslTrue;
			}


		if (pumpTypeStation2 == 3)
			if(pumpStation2 == 1)  //  FimwareNodeID::HU
			{
				if (moreThenOneWashStaion == hslFalse)
				{
					labwarePathFileName = labwareDir + LabwrData::core384HeadDualWashstationHU;
					ML_STAR.AddLabware(LabwrData::core384DualWashstationHULabId, labwarePathFileName, position);
					moreThenOneWashStaion = hslTrue;
				}
				else
				{                                               
					labwarePathFileName = labwareDir + LabwrData::core96DualWashstationHU;
					ML_STAR.AddLabware(LabwrData::core96DualWashstationHULabId, labwarePathFileName, position);
				}
			}

		if (pumpTypeStation3 == 3)
			if(pumpStation3 == 1)   // FimwareNodeID::HV
			{
				if (moreThenOneWashStaion == hslFalse)
				{
					labwarePathFileName = labwareDir + LabwrData::core384HeadDualWashstationHV;
					ML_STAR.AddLabware(LabwrData::core384DualWashstationHVLabId, labwarePathFileName, position);
				}
				else
				{
					labwarePathFileName = labwareDir + LabwrData::core96DualWashstationHV;
					ML_STAR.AddLabware(LabwrData::core96DualWashstationHVLabId, labwarePathFileName, position);
				}
			}


		//  1 = DC wash station (single chamber rev 02
		if (pumpTypeStation1 == 1)
			if(pumpStation1 == 1)  // FimwareNodeID::HW
			{
				labwarePathFileName = labwareDir + LabwrData::DCWashstationHW;
				ML_STAR.AddLabware(LabwrData::DCWashstationHWLabId, labwarePathFileName, position);
			}

		if (pumpTypeStation2 == 1)
			if(pumpStation2 == 1)  //  FimwareNodeID::HU
			{
				labwarePathFileName = labwareDir + LabwrData::DCWashstationHU;
				ML_STAR.AddLabware(LabwrData::DCWashstationHULabId, labwarePathFileName, position);
			}

		if (pumpTypeStation3 == 1)
			if(pumpStation3 == 1)   // FimwareNodeID::HV

			{
				labwarePathFileName = labwareDir + LabwrData::DCWashstationHV;
				ML_STAR.AddLabware(LabwrData::DCWashstationHVLabId, labwarePathFileName, position);
				                              
			}
		}

	} // End AddAllNeededLabware

	//-----------------------------------------------------------------------------------------------------
	function StartWashCRand3rdGen(device ML_STAR, variable washStationNr, variable rinseTime1, variable rinseTime2,
					variable soakTime1, variable soakTime2, variable flowRate1, variable flowRate2, variable drainingTime,
					variable startWashLiquid, variable isCRwashstation)
	//-----------------------------------------------------------------------------------------------------
	{
		variable i;
		variable washModulId;

		for(i = 1; i <= 3; i++) // important: suppose all washstation have 3 wash modules!
		{
			if(washStationNr == LabwrData::washStation1)
			{
				if(isCRwashstation)
				{
					if(i == 1)
						washModulId = LabwrData::crWS1RackId1;
					else if(i == 2)
						washModulId = LabwrData::crWS1RackId2;
					else if(i == 3)
						washModulId = LabwrData::crWS1RackId3;
				}
				else
				{
					if(i == 1)
						washModulId = LabwrData::gen3rdWS1RackId1;
					else if(i == 2)
						washModulId = LabwrData::gen3rdWS1RackId2;
					else if(i == 3)
						washModulId = LabwrData::gen3rdWS1RackId3;
				}
			}
			else if(washStationNr == LabwrData::washStation2)
			{
				if(isCRwashstation)
				{
					if(i == 1)
						washModulId = LabwrData::crWS2RackId1;
					else if(i == 2)
						washModulId = LabwrData::crWS2RackId2;
					else if(i == 3)
						washModulId = LabwrData::crWS2RackId3;
				}
				else
				{
					if(i == 1)
						washModulId = LabwrData::gen3rdWS2RackId1;
					else if(i == 2)
						washModulId = LabwrData::gen3rdWS2RackId2;
					else if(i == 3)
						washModulId = LabwrData::gen3rdWS2RackId3;
				}
			}

			ML_STAR._BCAAD4F5_0BD2_4d9c_8243_70DD893496CB( "807299d6_1251_44c8_adf40cb0e8852472" ); // WaitNeedleWashed

			ML_STAR._C3B1B9A6_5B2F_4069_B9CB_68A675EC480D( "a18a118f_2149_4e47_a879eacbf21d1c8e" ); // StartNeedleWash
		}
	} // StartWashCRand3rdGen

	//-----------------------------------------------------------------------------------------------------
	function InitializeAndCheckConfiguration( device ML_STAR, variable instrumentNr )
	//-----------------------------------------------------------------------------------------------------
	{
		string s;
	  	variable i(0);

		// initialize library (if necessary)
		InitMaintMetLibrary();

		// instrument name
		instrName = ML_STAR.GetInstrumentViewName();
		s = StringTable::Load(IDS::trcInstrName);
		s = s + instrName;
		Trace( s );

		// sw release
		releaseVersion = ML_STAR.GetReleaseVersion();
		s = StringTable::Load(IDS::trcUserSwVersion);
		s = s + releaseVersion;
		Trace( s );

		// operator
		operatorName = GetUserName();
		s = StringTable::Load(IDS::trcOperator);
		s = s + operatorName;
		Trace( s );

		// installation data
		{
			variable installationData;
			installationData = FwCommand( "C0RI", "", hslTrue, ML_STAR);

			// instrument serial number
			instrSerialNo = StrMid(installationData, 21, 4);
			s = StringTable::Load(IDS::trcInstrSerialNo);
			s = s + instrSerialNo;
			Trace( s );
		}

		// machine configuration
		{
			variable machineConfig;
			machineConfig = FwCommand( "C0RM", "", hslTrue, ML_STAR);

			// number of 1000ul channels (valid values: 0..maxNoOfChannel1000ul)
			instrNumberOfChannels1000ul = ParseFwResult(machineConfig, "kp", 2);
			instrNumberOfChannels1000ul = StrIVal(StrTrimLeft(instrNumberOfChannels1000ul, "0"));
			s = StringTable::Load(IDS::trcInstrNoOfChannels1000ul);
			s = s + IStr(instrNumberOfChannels1000ul);
			Trace( s );

			// Check if auto load and cover locking available
			// Bit 2: Main front cover monitoring 0 = none 1 = installed
			// Bit 3: Auto load                   0 = none 1 = installed

			// Check if Wash Sation1 and Wash Station2 are installed.
			//	Bit 4: Wash Station 1 0 = none 1 = installed
			//	Bit 5: Wash Station 2 0 = none 1 = installed

			{
				variable filterCover(4);
				variable filterAutoLoad(8);
				variable filterWashStation1(16);
				variable filterWashStation2(32);
				variable filterTempControlledCarrier1(64);  // bit 6
				variable filterTempControlledCarrier2(128); // bit 7

				coverLocking = StrMid(machineConfig, 9, 2);
				coverLocking = StrIVal("0x" + coverLocking);
				coverLocking = MthBitwiseAND(filterCover, coverLocking) / filterCover;

				autoLoad = StrMid(machineConfig, 9, 2);
				autoLoad = StrIVal("0x" + autoLoad);
				autoLoad = MthBitwiseAND(filterAutoLoad, autoLoad) / filterAutoLoad;
				 // kb
				washStation1 = StrMid(machineConfig, 9,2);	//extracts a sub-string of length 2.
				washStation1 = StrIVal("0x" + washStation1);	//convert washStation1 string to integer.
				washStation1 = MthBitwiseAND(filterWashStation1, washStation1) / filterWashStation1;

				washStation2 = StrMid(machineConfig, 9,2);
				washStation2 = StrIVal("0x" + washStation2);
				washStation2 = MthBitwiseAND(filterWashStation2, washStation2) / filterWashStation2;

				TempControlledCarrier1 = StrMid(machineConfig, 9,2);
				TempControlledCarrier1 = StrIVal("0x" + TempControlledCarrier1);
				TempControlledCarrier1 = MthBitwiseAND(filterTempControlledCarrier1, TempControlledCarrier1) / filterTempControlledCarrier1;

				TempControlledCarrier2 = StrMid(machineConfig, 9,2);
				TempControlledCarrier2 = StrIVal("0x" + TempControlledCarrier2);
				TempControlledCarrier2 = MthBitwiseAND(filterTempControlledCarrier2, TempControlledCarrier2) / filterTempControlledCarrier2;
			}
		}

		// extended configuration
		{
			variable exmachineConfig;
			exmachineConfig = FwCommand( "C0QM", "", hslTrue, ML_STAR);

			// number of 5ul channels (valid values: 0..8)
			instrNumberOfChannels5ml = ParseFwResult(exmachineConfig, "kc", 1);
			instrNumberOfChannels5ml = StrIVal(instrNumberOfChannels5ml);
			s = StringTable::Load(IDS::trcInstrNoOfChannels5ml);
			s = s + IStr(instrNumberOfChannels5ml);
			Trace( s );

			// check which type of Wash Station1 and Wash Station2 are installed (0=G3, 1=CR)
			// check if Pump Station 1,2,3 are installed. (0=none, 1=installed)
			{
			  	variable filter96TadmHead(2);	               // bit 1
				variable filterPumpStation1(8);	      		// bit 3
				variable filterPumpStation2(16);					// bit 4
				variable filterWashStation1(32);					// bit 5
				variable filterWashStation2(64);					// bit 6
				variable filterPumpStation3(1024);				// bit 10
			  	variable filterNanoPipettor(2048);		  		// bit 11
			  	variable filterNanoPipettorPlusN(131072);	   // bit 17
            // ke parameter bit constant
			  	variable filterCardGripperKe(1);	            // bit 0 of ke parameter
			  	variable filterEasyPuncherKe(2);	            // bit 1 of ke parameter
				variable param_ka_result("");
				variable param_ke_result("");

				param_ka_result = ParseFwResult(exmachineConfig, "ka", 6);

				exwashStation1= StrIVal("0x" + 	param_ka_result);
				exwashStation1= MthBitwiseAND(filterWashStation1, 	exwashStation1) / filterWashStation1; // 0=G3, 1=CR

				exwashStation2= StrIVal("0x" + 	param_ka_result);
				exwashStation2= MthBitwiseAND(filterWashStation2, 	exwashStation2) / filterWashStation2; // 0=G3, 1=CR

			// Bit 3:  pump station 1  0 = none 1 = installed
			// Bit 4:  pump station 2  0 = none 1 = installed
			// Bit 10: pump station 3  0 = none 1 = installed

				pumpStation1 = StrIVal("0x" + param_ka_result);
				pumpStation1 = MthBitwiseAND(filterPumpStation1, pumpStation1) / filterPumpStation1;

				pumpStation2 = StrIVal("0x" + param_ka_result);
				pumpStation2 = MthBitwiseAND(filterPumpStation2, pumpStation2) / filterPumpStation2;

				pumpStation3 = StrIVal("0x" + param_ka_result);
				pumpStation3 = MthBitwiseAND(filterPumpStation3, pumpStation3) / filterPumpStation3;

				nanoPipettor = StrIVal("0x" + param_ka_result);
				nanoPipettor = MthBitwiseAND(filterNanoPipettor, nanoPipettor) / filterNanoPipettor;

				nanoPipettorPlusN = StrIVal("0x" + param_ka_result);
				nanoPipettorPlusN = MthBitwiseAND(filterNanoPipettorPlusN, nanoPipettorPlusN) / filterNanoPipettorPlusN;

            if(nanoPipettor != 0 || nanoPipettorPlusN != 0)	// nano is installed
               RequestNanopipettorSerialNumber(ML_STAR);


            // read CO-RE 96 TADM head
   			s = StringTable::Load(IDS::trcInstr96TadmHead);
            head96TadmHead = StrIVal("0x" + 	param_ka_result);
				head96TadmHead = MthBitwiseAND(filter96TadmHead,	head96TadmHead) / filter96TadmHead; // 0=not installed, 1=installed
            if(head96TadmHead == 1)
            {
               // check for TADM head
      			variable tadmHead("");
   				variable param_qg_result("");
      			param_qg_result = FwCommand( "H0QG", "", hslFalse, ML_STAR);

   				tadmHead = ParseFwResult(param_qg_result, "qg", 1);
   				head96TadmHead = StrIVal(tadmHead);
               if(head96TadmHead != 3)
                  head96TadmHead = 0;
               else
                  head96TadmHead = 1;

            }

            if(1 == head96TadmHead)
               s = s + StringTable::Load(IDS::checkInstalled);
            else
      			s = s + StringTable::Load(IDS::checkNotInstalled);

   			Trace( s );


            // ------------------------------------------------------
            // read ke parameter
            // ------------------------------------------------------
				param_ke_result = ParseFwResult(exmachineConfig, "ke", 8);

            // read card gripper for easy puncher
				cardGripper = StrIVal("0x" + param_ke_result);
				cardGripper = MthBitwiseAND(filterCardGripperKe, cardGripper) / filterCardGripperKe; // 0=not installed, 1=installed

            // read easy puncher
				easyPuncher = StrIVal("0x" + param_ke_result);
				easyPuncher = MthBitwiseAND(filterEasyPuncherKe, easyPuncher) / filterEasyPuncherKe; // 0=not installed, 1=installed

			}

         // search for parameter xt## --> instrument size in slots
			maxDeckSlots = ParseFwResult(exmachineConfig, "xt", 2);
         maxDeckSlots = IVal(maxDeckSlots);

         // search for parameter xa## --> autoload max slots
			deckPosLast = ParseFwResult(exmachineConfig, "xa", 2);
			deckPosLast = IVal(deckPosLast);

			// check left/right arm configuration
			{
				variable filterPIP           (1);	// bit 0
				variable filterISwap         (2);	// bit 1
				variable filter96Head        (4);	// bit 2
				variable filterNanoDispenser (8);	// bit 3
				variable filter384Head       (16);	// bit 4
				variable filterXlChannels    (32);	// bit 5		// added 2010-01-21/cjoerg
				variable filterTubeGripper   (64);	// bit 6		// added 2010-01-21/cjoerg
				variable filterImagingChannel(128);	// bit 7		// added 2010-01-21/cjoerg
            // define parameter for xn / xo parameter
				variable filterEasyPuncher   (4);	// bit 2

				variable param_xl_result(""), xlValue(0);
				variable param_xr_result(""), xrValue(0);
				variable param_xn_result(""), xnValue(0);
				variable param_xo_result(""), xoValue(0);


				// left arm configuration
				param_xl_result = ParseFwResult(exmachineConfig, "xl", 2);
				xlValue = StrIVal("0x" + 	param_xl_result);

				leftArmHasChannel        = MthBitwiseAND(filterPIP,            xlValue) / filterPIP;
				leftArmHasISwap          = MthBitwiseAND(filterISwap,          xlValue) / filterISwap;
				leftArmHas96Head         = MthBitwiseAND(filter96Head,         xlValue) / filter96Head;
				leftArmHasNanoDisp       = MthBitwiseAND(filterNanoDispenser,  xlValue) / filterNanoDispenser;
				leftArmHas384Head        = MthBitwiseAND(filter384Head,        xlValue) / filter384Head;
				leftArmHasXlChannels     = MthBitwiseAND(filterXlChannels,     xlValue) / filterXlChannels;			// added 2010-01-21/cjoerg
				leftArmHasTubeGripper    = MthBitwiseAND(filterTubeGripper,    xlValue) / filterTubeGripper;			// added 2010-01-21/cjoerg
				leftArmHasImagingChannel = MthBitwiseAND(filterImagingChannel, xlValue) / filterImagingChannel;		// added 2010-01-21/cjoerg

				// right arm configuration
				param_xr_result = ParseFwResult(exmachineConfig, "xr", 2);
				xrValue = StrIVal("0x" + 	param_xr_result);

				rightArmHasChannel        = MthBitwiseAND(filterPIP,            xrValue) / filterPIP;
				rightArmHasISwap          = MthBitwiseAND(filterISwap,          xrValue) / filterISwap;
				rightArmHas96Head         = MthBitwiseAND(filter96Head,         xrValue) / filter96Head;
				rightArmHasNanoDisp       = MthBitwiseAND(filterNanoDispenser,  xrValue) / filterNanoDispenser;
				rightArmHas384Head        = MthBitwiseAND(filter384Head,        xrValue) / filter384Head;
				rightArmHasXlChannels     = MthBitwiseAND(filterXlChannels,     xrValue) / filterXlChannels;			// added 2010-01-21/cjoerg
				rightArmHasTubeGripper    = MthBitwiseAND(filterTubeGripper,    xrValue) / filterTubeGripper;		// added 2010-01-21/cjoerg
				rightArmHasImagingChannel = MthBitwiseAND(filterImagingChannel, xrValue) / filterImagingChannel;	// added 2010-01-21/cjoerg


            // ---------------------------------------------------------
            // read parameter xn / xo
            // ---------------------------------------------------------
				// left arm configuration
				param_xn_result = ParseFwResult(exmachineConfig, "xn", 2);
				xnValue = StrIVal("0x" + 	param_xn_result);

				leftArmHasCardGripper     = MthBitwiseAND(filterEasyPuncher,    xnValue) / filterEasyPuncher;


				// right arm configuration
				param_xo_result = ParseFwResult(exmachineConfig, "xo", 2);
				xoValue = StrIVal("0x" + 	param_xo_result);

				rightArmHasCardGripper    = MthBitwiseAND(filterEasyPuncher,    xoValue) / filterEasyPuncher;

			}
		}

		// init members now
		pumpTypeStation1 = -1; // initialization with -1 and not with 0 (because --> 0=CoRe)
		pumpTypeStation2 = -1;
		pumpTypeStation3 = -1;

		if (pumpStation1 == 1)  // pump setting
		{
			variable firmwareAnswer, sTemp, sPumpType;

			// pump station 1
			firmwareAnswer = FwCommand( "C0ET", "ep1", hslFalse, ML_STAR);

			// check type of Pump Station 0 = CoRe 96 wash station (single chamber)
			//										1 = DC wash station (single chamber rev 02
			//										2 = ReReRe (single chamber)
			//										3 = CoRe 96/384 wash station (dual chamber) (96/384 Wash Station)
			//										4 = DC wash station (dual chamber)          (96/384 Wash Station)
			//										5 = ReReRe (dual chamber)                   (96/384 Wash Station)


			sTemp = StrMid(firmwareAnswer, 0, 4);

			if("er00" == sTemp)// er00-->ok  er99-->error
			{
				sPumpType = StrMid(firmwareAnswer, 9, 1);
				s = StringTable::Load(IDS::trcTypeOfPumps);
				s = s + sPumpType;
				Trace(s);
				pumpTypeStation1 = IVal(sPumpType); 
			}
		}

		if (pumpStation2 == 1)  // pump setting
		{
			variable firmwareAnswer, sTemp, sPumpType;
			pumpTypeStation2 = -1; // initialisation with -1 and not with 0 (because --> 0=CoRe)

			// pump station 2
			firmwareAnswer = FwCommand( "C0ET", "ep2", hslFalse, ML_STAR);

			// check type of Pump Station 0 = CoRe 96 wash station (single chamber)
			//										1 = DC wash station (single chamber rev 02
			//										2 = ReReRe (single chamber)
			//										3 = CoRe 96/384 wash station (dual chamber) (96/384 Wash Station)
			//										4 = DC wash station (dual chamber)          (96/384 Wash Station)
			//										5 = ReReRe (dual chamber)                   (96/384 Wash Station)

			sTemp = StrMid(firmwareAnswer, 0, 4);

			if("er00" == sTemp)// er00-->ok  er99-->error
			{
				sPumpType = StrMid(firmwareAnswer, 9, 1);
				s = StringTable::Load(IDS::trcTypeOfPumps);
				s = s + sPumpType;
				Trace(s);
				pumpTypeStation2 = IVal(sPumpType);

			}
		}

		if (pumpStation3 == 1)  // pump setting
		{
			variable firmwareAnswer, sTemp, sPumpType;
			pumpTypeStation3 = -1; // initialisation with -1 and not with 0 (because --> 0=CoRe)

			// pump station 3
			firmwareAnswer = FwCommand( "C0ET", "ep3", hslFalse, ML_STAR);

			// check type of Pump Station 0 = CoRe 96 wash station (single chamber)
			//										1 = DC wash station (single chamber rev 02
			//										2 = ReReRe (single chamber)
			//										3 = CoRe 96/384 wash station (dual chamber) (96/384 Wash Station)
			//										4 = DC wash station (dual chamber)          (96/384 Wash Station)
			//										5 = ReReRe (dual chamber)                   (96/384 Wash Station)

			sTemp = StrMid(firmwareAnswer, 0, 4);

			if("er00" == sTemp)// er00-->ok  er99-->error
			{
				sPumpType = StrMid(firmwareAnswer, 9, 1);
				s = StringTable::Load(IDS::trcTypeOfPumps);
				s = s + sPumpType;
				Trace(s);
				pumpTypeStation3 = IVal(sPumpType);
				
			}
		}

		// initialize Errorbuffers
		MERR::tightnessCheckChannel1000ulError.SetSize(maxNoOfChannel1000ul);
		MERR::cLLDCheckChannel1000ulError.SetSize(maxNoOfChannel1000ul);

		for(i = 0 ; i < maxNoOfChannel1000ul; i++)
		{
			MERR::tightnessCheckChannel1000ulError.SetAt(i,"");
			MERR::cLLDCheckChannel1000ulError.SetAt(i,"");
		}

		// initialize Errorbuffers
		MERR::tightnessCheckChannel5mlError.SetSize(maxNoOfChannel5ml);
		MERR::cLLDCheckChannel5mlError.SetSize(maxNoOfChannel5ml);

		for(i = 0 ; i < maxNoOfChannel5ml; i++)
		{
			MERR::tightnessCheckChannel5mlError.SetAt(i,"");
			MERR::cLLDCheckChannel5mlError.SetAt(i,"");
		}

		// initialize arrays for tightness and cLLD check
		{ 
			variable i;			// loop counter

			// initialize 1000ul maintenance needle data
			instrNumberOfNeedles1000ul = ML_STAR.MaintenanceNeedles.GetTotal();

			// initialize 1000ul channel data
			for (	i=0; i<instrNumberOfChannels1000ul; i++ )
			{
				// assign needle index to channels
				chanNeedleIndex1000ul.AddAsLast( i % instrNumberOfNeedles1000ul);

				// initialize measurement arrays
				chanUPressBeginTimer1000ul.AddAsLast(0);
				chanUPressEndTimer1000ul.AddAsLast(0);
				chanOPressBeginTimer1000ul.AddAsLast(0);
				chanOPressEndTimer1000ul.AddAsLast(0);
				chanDetectLevelAir1000ul.AddAsLast(hslFalse);
				chanDetectLevelBlock1000ul.AddAsLast(hslFalse);
			}

			// initialize 5ml maintenance needle data
			instrNumberOfNeedles5ml = ML_STAR.MaintenanceNeedle5ml.GetTotal();

			// initialize 5ml channel data
			for (	i=0; i<instrNumberOfChannels5ml; i++ )
			{
				// assign needle index to channels
				chanNeedleIndex5ml.AddAsLast( i % instrNumberOfNeedles5ml);

				// initialize measurement arrays
				chanUPressBeginTimer5ml.AddAsLast(0);
				chanUPressEndTimer5ml.AddAsLast(0);
				chanOPressBeginTimer5ml.AddAsLast(0);
				chanOPressEndTimer5ml.AddAsLast(0);
				chanDetectLevelAir5ml.AddAsLast(hslFalse);
				chanDetectLevelBlock5ml.AddAsLast(hslFalse);
			}


		}

      // initialize CO-RE 96 Tadm Head Errorbuffers
		for(i = 0 ; i < maxNoOfChannel96TadmHead; i++)
		{
			MERR::tightnessCheckChannel96TadmHeadError.AddAsLast("");
   		chanUPressBeginTimer96TadmHead.AddAsLast(0);
   		chanUPressEndTimer96TadmHead.AddAsLast(0);
   		chanOPressBeginTimer96TadmHead.AddAsLast(0);
   		chanOPressEndTimer96TadmHead.AddAsLast(0);
		}


		// initialize check position on waste block
		{
			sequence seq; 		// sequence for waste block check position
			variable position[];
			variable value;

			// waste block check position
			seq = ML_STAR.RearVerification;
			ML_STAR.GetLabwarePosition(seq.GetLabwareId(), position, seq.GetPositionId());
			value = MthRound(10.0 * position.GetAt(0), 0);
			checkPosX = StrFillLeft(IStr(value), "0", 5);
			value = MthRound(10.0 * position.GetAt(1), 0);
			checkPosY = StrFillLeft(IStr(value), "0", 4);
			value = MthRound(10.0 * position.GetAt(2), 0);
			checkPosZ = StrFillLeft(IStr(value), "0", 4);
		}

		// calculate parameter zc and zh for 1000ul cLLD check firmware command ZL
		{
			//variable stepsPerMiliMeter(93.217);		// moved to constants, stepsPerMiliMeterChannel1000ul
			//variable needleOffset(4838);
			//variable startOffset(93);	// about 1 mm
			//variable maxImmersion(93);	// about 1 mm
			
			variable needleOffset(maintNeedleLengthChannel1000ul * stepsPerMiliMeterChannel1000ul);
			variable startOffset(1.0 * stepsPerMiliMeterChannel1000ul);
			variable maxImmersion(1.0 * stepsPerMiliMeterChannel1000ul);

			variable zLabwareSteps;
			variable zcSteps;
			variable zhSteps;

			// z-Positions for measurement on waste block
			// calculate steps of labware z position
			zLabwareSteps = IVal(checkPosZ) * stepsPerMiliMeterChannel1000ul / 10.0;
			// paramter zc
			zcSteps = MthRound(zLabwareSteps + needleOffset + startOffset, 0);
			zcParamChannel1000ulBlock = StrFillLeft(IStr(zcSteps), "0", 5);
			// paramter zh
			zhSteps = MthRound(zLabwareSteps + needleOffset - maxImmersion, 0);
			zhParamChannel1000ulBlock = StrFillLeft(IStr(zhSteps), "0", 5);

			// z-Positions for measurement on air
			zLabwareSteps = IVal(traverseHeightForFwCommand) * stepsPerMiliMeterChannel1000ul / 10.0;
			zcSteps = MthRound(zLabwareSteps + needleOffset, 0);
			zcParamChannel1000ulAir = StrFillLeft(IStr(zcSteps), "0", 5);
			zhParamChannel1000ulAir = zcParamChannel1000ulAir;
		}


		// calculate parameter zc and zh for 5ml cLLD check firmware command ZL
		{
			variable needleOffset(maintNeedleLengthChannel5ml * stepsPerMiliMeterChannel5ml);
			variable startOffset (1.0 * stepsPerMiliMeterChannel5ml);
			variable maxImmersion(1.0 * stepsPerMiliMeterChannel5ml);

			variable zLabwareSteps;
			variable zcSteps;
			variable zhSteps;

			// calculate steps of labware z position
			zLabwareSteps = IVal(checkPosZ) * stepsPerMiliMeterChannel5ml / 10.0;
			// paramter zc
			zcSteps = MthRound(zLabwareSteps + needleOffset + startOffset, 0);
			zcParamChannel5mlBlock = StrFillLeft(IStr(zcSteps), "0", 5);
			// paramter zh
			zhSteps = MthRound(zLabwareSteps + needleOffset - maxImmersion, 0);
			zhParamChannel5mlBlock = StrFillLeft(IStr(zhSteps), "0", 5);

			// z-Positions for measurement on air
			zLabwareSteps = IVal(traverseHeightForFwCommand) * stepsPerMiliMeterChannel5ml / 10.0;
			zcSteps = MthRound(zLabwareSteps + needleOffset, 0);
			zcParamChannel5mlAir = StrFillLeft(IStr(zcSteps), "0", 5);
			zhParamChannel5mlAir = zcParamChannel5mlAir;

		}


		// --------------------------------------------------------------------------
		// last run may be aborted --> Restore data
		//
		RestoreParamsFromFile( ML_STAR ) ;		


		// ------------------------------------------------------------------------------------------------
		// Save parameter values to restore after temporary changes
		//
		if ( 0 < instrNumberOfChannels1000ul )
		{
			zhOriginalChannel1000ul = FwCommand( "P1RA", "razh", hslFalse, ML_STAR);
			zcOriginalChannel1000ul = FwCommand( "P1RA", "razc", hslFalse, ML_STAR);
			ziOriginalChannel1000ul = FwCommand( "P1RA", "razi", hslFalse, ML_STAR);
			zjOriginalChannel1000ul = FwCommand( "P1RA", "razj", hslFalse, ML_STAR);
			zvOriginalChannel1000ul = FwCommand( "P1RA", "razv", hslFalse, ML_STAR);
			zlOriginalChannel1000ul = FwCommand( "P1RA", "razl", hslFalse, ML_STAR);
			dpOriginalChannel1000ul = FwCommand( "P1RA", "radp", hslFalse, ML_STAR);
		}
		else
		{
			zhOriginalChannel1000ul = "";
			zcOriginalChannel1000ul = "";
			ziOriginalChannel1000ul = "";
			zjOriginalChannel1000ul = "";
			zvOriginalChannel1000ul = "";
			zlOriginalChannel1000ul = "";
			dpOriginalChannel1000ul = "";
		}

		if ( 0 < instrNumberOfChannels5ml )
		{
			zhOriginalChannel5ml = FwCommand( "L1RA", "razh", hslFalse, ML_STAR);
			zcOriginalChannel5ml = FwCommand( "L1RA", "razc", hslFalse, ML_STAR);
			ziOriginalChannel5ml = FwCommand( "L1RA", "razi", hslFalse, ML_STAR);
			zjOriginalChannel5ml = FwCommand( "L1RA", "razj", hslFalse, ML_STAR);
			zvOriginalChannel5ml = FwCommand( "L1RA", "razv", hslFalse, ML_STAR);
			zlOriginalChannel5ml = FwCommand( "L1RA", "razl", hslFalse, ML_STAR);
			dpOriginalChannel5ml = FwCommand( "L1RA", "radp", hslFalse, ML_STAR);
		}
		else
		{
			zhOriginalChannel5ml = "";
			zcOriginalChannel5ml = "";
			ziOriginalChannel5ml = "";
			zjOriginalChannel5ml = "";
			zvOriginalChannel5ml = "";
			zlOriginalChannel5ml = "";
			dpOriginalChannel5ml = "";
		}

      dqOriginal96TadmHead = "";
      if(1 == head96TadmHead)
      {
         dqOriginal96TadmHead = FwCommand( "H0RA", "radq", hslFalse, ML_STAR);
      }

		if ( 0 < cardGripper )
		{
			zvOriginalCardGripper = FwCommand( "CHRA", "razv", hslFalse, ML_STAR);
			yvOriginalCardGripper = FwCommand( "CHRA", "rayv", hslFalse, ML_STAR);
	   }
      else
      {
			zvOriginalCardGripper = "";
			yvOriginalCardGripper = "";
      }

		// save to file
		// those file will be read in case of a maintenance abort to restore parameter values
		{
			object fso; // File System Object
			file fStarParams;
			variable rw_lastRunAborted;
			string rw_zhParam1000ul;
			string rw_zcParam1000ul;
			string rw_ziParam1000ul;
			string rw_zjParam1000ul;
			string rw_zvParam1000ul;
			string rw_zlParam1000ul;
			string rw_dpParam1000ul;
			string rw_zhParam5ml;
			string rw_zcParam5ml;
			string rw_ziParam5ml;
			string rw_zjParam5ml;
			string rw_zvParam5ml;
			string rw_zlParam5ml;
			string rw_dpParam5ml;
			string rw_dqParam96TadmHead;
			string rw_zvParamCH;
			string rw_yvParamCH;
			string fileName;

			fStarParams.SetDelimiter(hslCSVDelimited);
			fStarParams.AddField("lastRunAborted", rw_lastRunAborted, hslInteger);
			fStarParams.AddField("zhOriginal1000ul", rw_zhParam1000ul, hslString);
			fStarParams.AddField("zcOriginal1000ul", rw_zcParam1000ul, hslString);
			fStarParams.AddField("ziOriginal1000ul", rw_ziParam1000ul, hslString);
			fStarParams.AddField("zjOriginal1000ul", rw_zjParam1000ul, hslString);
			fStarParams.AddField("zvOriginal1000ul", rw_zvParam1000ul, hslString);
			fStarParams.AddField("zlOriginal1000ul", rw_zlParam1000ul, hslString);
			fStarParams.AddField("dpOriginal1000ul", rw_dpParam1000ul, hslString);
			fStarParams.AddField("zhOriginal5ml", rw_zhParam5ml, hslString);
			fStarParams.AddField("zcOriginal5ml", rw_zcParam5ml, hslString);
			fStarParams.AddField("ziOriginal5ml", rw_ziParam5ml, hslString);
			fStarParams.AddField("zjOriginal5ml", rw_zjParam5ml, hslString);
			fStarParams.AddField("zvOriginal5ml", rw_zvParam5ml, hslString);
			fStarParams.AddField("zlOriginal5ml", rw_zlParam5ml, hslString);
			fStarParams.AddField("dpOriginal5ml", rw_dpParam5ml, hslString);
			fStarParams.AddField("dqOriginal96TadmHead", rw_dqParam96TadmHead, hslString);
			fStarParams.AddField("zvOriginalCH", rw_zvParamCH, hslString);
			fStarParams.AddField("yvOriginalCH", rw_yvParamCH, hslString);

			fileName = InstrParam::InstrParamFile;
			StrReplace(fileName, "%s", instrSerialNo);
			fileName = GetLogFilesPath() + fileName;

			fso.CreateObject("Scripting.FileSystemObject");
			if(fso.FileExists(fileName))
			{
				onerror goto FailedToDeleteFile;
				fso.DeleteFile(fileName);
				onerror goto 0;
			}

			fileName = fileName + InstrParam::TableName;

			fStarParams.Open( fileName, hslWrite );

			rw_lastRunAborted = hslFalse;
			rw_zhParam1000ul = zhOriginalChannel1000ul;
			rw_zcParam1000ul = zcOriginalChannel1000ul;
			rw_ziParam1000ul = ziOriginalChannel1000ul;
			rw_zjParam1000ul = zjOriginalChannel1000ul;
			rw_zvParam1000ul = zvOriginalChannel1000ul;
			rw_zlParam1000ul = zlOriginalChannel1000ul;
			rw_dpParam1000ul = dpOriginalChannel1000ul;
			rw_zhParam5ml = zhOriginalChannel5ml;
			rw_zcParam5ml = zcOriginalChannel5ml;
			rw_ziParam5ml = ziOriginalChannel5ml;
			rw_zjParam5ml = zjOriginalChannel5ml;
			rw_zvParam5ml = zvOriginalChannel5ml;
			rw_zlParam5ml = zlOriginalChannel5ml;
			rw_dpParam5ml = dpOriginalChannel5ml;
         rw_dqParam96TadmHead = dqOriginal96TadmHead;
         rw_zvParamCH  = zvOriginalCardGripper;
         rw_yvParamCH  = yvOriginalCardGripper;

			fStarParams.WriteRecord();
			fStarParams.Close();
		}

		// Initialize process check states
		InitializeProcessCheckStates();

		//----------------------------------------------------------------------------------------------
		// Add needed labware to decklayout before init STAR
		//----------------------------------------------------------------------------------------------
		AddAllNeededLabware(ML_STAR);

		//----------------------------------------------------------------------------------------------
		// Init the STAR
		//----------------------------------------------------------------------------------------------
		ML_STAR._1C0C0CB0_7C87_11D3_AD83_0004ACB1DCB2( "e58642ff_bbee_4bb1_9972e7f41e3ce324" ); // Initialize

		return;


		FailedToDeleteFile:
		{
			// do nothing
			resume next;
		}
	} // end InitializeAndCheckConfiguration

	//-----------------------------------------------------------------------------------------------------
	function GetNumberOfPipettingChannel1000ul() variable
	//-----------------------------------------------------------------------------------------------------
	{
		return (instrNumberOfChannels1000ul);
	} // end GetNumberOfPipettingChannel1000ul

	//-----------------------------------------------------------------------------------------------------
	function GetNumberOfPipettingChannel5ml() variable
	//-----------------------------------------------------------------------------------------------------
	{
		return (instrNumberOfChannels5ml);
	} // end GetNumberOfPipettingChannel5ml

	//-----------------------------------------------------------------------------------------------------
	function HasPipettingChannel1000ul() variable
	//-----------------------------------------------------------------------------------------------------
	{
		if( 0 == instrNumberOfChannels1000ul )
			return (hslFalse);

		return (hslTrue);
	} // end HasPipettingChannel1000ul

	//-----------------------------------------------------------------------------------------------------
	function HasPipettingChannel5ml() variable
	//-----------------------------------------------------------------------------------------------------
	{
		if( 0 == instrNumberOfChannels5ml )
			return (hslFalse);

		return (hslTrue);
	} // end HasPipettingChannel5ml

	//-----------------------------------------------------------------------------------------------------
	function Has96TadmHead() variable
	//-----------------------------------------------------------------------------------------------------
	{
		if( 0 == head96TadmHead )
			return (hslFalse);

		return (hslTrue);
	} // end Has96TadmHead

	//-----------------------------------------------------------------------------------------------------
	function HasCRWasher()
	//-----------------------------------------------------------------------------------------------------
	{
		if(washStation1 == 0 && washStation2 == 0)
			return (hslFalse);	// no wash station installed

		if(exwashStation1 == 0 && exwashStation2 == 0) // exwashStation == 1 -> it's a CR wash station
			return (hslFalse);	// no CR wash station installed

		return (hslTrue);
	} // end HasCRWasher

	//-----------------------------------------------------------------------------------------------------
	function Has3rdGenWasher()
	//-----------------------------------------------------------------------------------------------------
	{
		if(washStation1 == 0 && washStation2 == 0)
			return (hslFalse); // no wash station installed

		if((washStation1 == 1 && exwashStation1 == 0) || // exwashStation == 0 -> it's a 3rd gen. wash station
			(washStation2 == 1 && exwashStation2 == 0))
			return (hslTrue);

		return (hslFalse);
	} // end Has3rdGenWasher

	//-----------------------------------------------------------------------------------------------------
	function HasCORE96HeadWasher()
	//-----------------------------------------------------------------------------------------------------
	{
	   // 0 = CoRe 96 wash station (single chamber)
		//	1 = DC wash station (single chamber rev 02)
		//	2 = ReReRe (single chamber)
		//	3 = CoRe 96/384 wash station (dual chamber) (96/384 Wash Station)
		//	4 = DC wash station (dual chamber)          (96/384 Wash Station)
		//	5 = ReReRe (dual chamber)                   (96/384 Wash Station)

		if (pumpTypeStation1 == 0)
			if(pumpStation1 == 1)
				return(FimwareNodeID::HW);

		if (pumpTypeStation2 == 0)
			if(pumpStation2 == 1)
				return(FimwareNodeID::HU);

		if (pumpTypeStation3 == 0)
			if(pumpStation3 == 1)
				return(FimwareNodeID::HV);

		return (FimwareNodeID::notInstalled);
	} // end HasCORE96HeadWasher

	//-----------------------------------------------------------------------------------------------------
	function Has_96_384_Washer()
	//-----------------------------------------------------------------------------------------------------
	{

		//	3 = CoRe 96/384 wash station (dual chamber) (96/384 Wash Station)

		if (pumpTypeStation1 == 3)
			if(pumpStation1 == 1)
					return (hslTrue);

		if (pumpTypeStation2 == 3)
			if(pumpStation2 == 1)
					return (hslTrue);

		if (pumpTypeStation3 == 3)
			if(pumpStation3 == 1)
					return (hslTrue);

		return (hslFalse);

	} 	// End Has_96_384_Washer()


//-----------------------------------------------------------------------------------------------------
	function HasDCWasher()
	//-----------------------------------------------------------------------------------------------------
	{

		if (pumpTypeStation1 == 1)
			if(pumpStation1 == 1)
					return (hslTrue);

		if (pumpTypeStation2 == 1)
			if(pumpStation2 == 1)
					return (hslTrue);

		if (pumpTypeStation3 == 1)
			if(pumpStation3 == 1)
					return (hslTrue);

		return (hslFalse);
	} 	// end HasDCWasher
 
  	//-----------------------------------------------------------------------------------------------------
	function HasEasyPuncher() variable
	//-----------------------------------------------------------------------------------------------------
   {
		if(easyPuncher == 0 || cardGripper == 0)
			return (hslFalse);	// no easy puncher and or cardGripper is installed
		else
		    return (hslTrue);
   }

	//-----------------------------------------------------------------------------------------------------
	function GetProcessState()
	//-----------------------------------------------------------------------------------------------------
	{
		variable notCompleteCount(0);
		variable failureCount(0);

		// 1000ul channels installed?
		if( HasPipettingChannel1000ul() )
		{
			// tightness check
			if(tightnessCheckChannel1000ulState == PS::open)
				notCompleteCount++;
			else
			 if(tightnessCheckChannel1000ulState == PS::failed)
				failureCount++;

			// cLLD check
			if(cLLDCheckChannel1000ulState == PS::open)
				notCompleteCount++;
			else
			 if(cLLDCheckChannel1000ulState == PS::failed)
				failureCount++;
		}

		// 5ml channels installed?
		if( HasPipettingChannel5ml() )
		{
			// tightness check
			if(tightnessCheckChannel5mlState == PS::open)
				notCompleteCount++;
			else
			 if(tightnessCheckChannel5mlState == PS::failed)
				failureCount++;

			// cLLD check
			if(cLLDCheckChannel5mlState == PS::open)
				notCompleteCount++;
			else
			 if(cLLDCheckChannel5mlState == PS::failed)
				failureCount++;
		}

		// CO-RE 96 Tadm Head installed?
		if( Has96TadmHead() )
		{
			// tightness check
			if(tightnessCheckChannel96TadmHeadState == PS::open)
				notCompleteCount++;
			else
			 if(tightnessCheckChannel96TadmHeadState == PS::failed)
				failureCount++;
		}

		// CR and 3rd gen wash stations check
		if(washStation1 != 0)
		{
			if(exwashStation1 == 1) // CR wash station
			{
				if(crWashStation_1_CheckState == PS::open)
					notCompleteCount++;
				else
				if(crWashStation_1_CheckState == PS::failed)
					failureCount++;
			}
			else	// 3rd gen wash station
			{
				if(needleWashStation_1_CheckState == PS::open)
					notCompleteCount++;
				else
				if(needleWashStation_1_CheckState == PS::failed)
					failureCount++;
			}
		}


		if(washStation2 != 0)
		{
			if(exwashStation2 == 1) // CR wash station
			{
				if(crWashStation_2_CheckState == PS::open)
					notCompleteCount++;
				else
				if(crWashStation_2_CheckState == PS::failed)
					failureCount++;
			}
			else	// 3rd gen wash station
			{
				if(needleWashStation_2_CheckState == PS::open)
					notCompleteCount++;
				else
				if(needleWashStation_2_CheckState == PS::failed)
					failureCount++;
			}
		}


		if(pumpStation1 != 0) // node HW
		{
			if(pumpTypeStation1 == 0) // CO-RE Head 96 washer pump unit
			{
				if(head96WashStation_HW_CheckState == PS::open)
					notCompleteCount++;
				else
				if(head96WashStation_HW_CheckState == PS::failed)
					failureCount++;
			}
			if(pumpTypeStation1 == 1) // DC Wash station unit
			{
				if(dcWashStation_HW_CheckState == PS::open)
					notCompleteCount++;
				else
				if(dcWashStation_HW_CheckState == PS::failed)
					failureCount++;
			}
			if(pumpTypeStation1 == 3) // 96/384 Wasch Staion unit
			{
				if(head_96_384_WashStation_HW_CheckState == PS::open)
					notCompleteCount++;
				else
				if(head_96_384_WashStation_HW_CheckState == PS::failed)
					failureCount++;
			}
		}  	// node HW


		if(pumpStation2 != 0)  // node HU
		{
			if(pumpTypeStation2 == 0) // CO-RE Head 96 washer pump unit
			{
				if(head96WashStation_HU_CheckState == PS::open)
					notCompleteCount++;
				else
				if(head96WashStation_HU_CheckState == PS::failed)
					failureCount++;
			}
			if(pumpTypeStation1 == 1) // DC Wash station unit
			{
				if(dcWashStation_HU_CheckState == PS::open)
					notCompleteCount++;
				else
				if(dcWashStation_HU_CheckState == PS::failed)
					failureCount++;
			}
			if(pumpTypeStation1 == 3) // 96/384 Wasch Staion unit
			{
				if(head_96_384_WashStation_HU_CheckState == PS::open)
					notCompleteCount++;
				else
				if(head_96_384_WashStation_HU_CheckState == PS::failed)
					failureCount++;
			}
		} // end node HU


		if(pumpStation3 != 0) // node HV
		{
			if(pumpTypeStation3 == 0) // CO-RE Head 96 washer pump unit
			{
				if(head96WashStation_HV_CheckState == PS::open)
					notCompleteCount++;
				else
				if(head96WashStation_HV_CheckState == PS::failed)
				failureCount++;
			}
			if(pumpTypeStation1 == 1) // DC Wash station unit
			{
				if(dcWashStation_HV_CheckState == PS::open)
					notCompleteCount++;
				else
				if(dcWashStation_HV_CheckState == PS::failed)
					failureCount++;
			}
			if(pumpTypeStation1 == 3) // 96/384 Wasch Staion unit
			{
				if(head_96_384_WashStation_HV_CheckState == PS::open)
					notCompleteCount++;
				else
				if(head_96_384_WashStation_HV_CheckState == PS::failed)
					failureCount++;
			}
		}

		// easyPuncher installed?
		if( HasEasyPuncher() )
		{
			// maintenance
			if(easyPuncherState == PS::open)
				notCompleteCount++;
			else
			if(easyPuncherState == PS::failed)
				failureCount++;
		}


		// Instrument check
		if(instrumentCheckState == PS::open)
			notCompleteCount++;
		else
		if(instrumentCheckState == PS::failed)
			failureCount++;
		// Process Status evaluation
		if(notCompleteCount == 0 && failureCount == 0) // successful
		{
			overallProcessedState = PS::successful;
			return(MPS::mpsSuccessful);
		}
		else
		if(failureCount != 0)	// failed
			return(MPS::mpsFailed);

		return(MPS::mpsIncomplete);
	} // end GetProcessState


	//-----------------------------------------------------------------------------------------------------
	function HasAutoload()
	//-----------------------------------------------------------------------------------------------------
	{
		if(autoLoad == 0)
			return (hslFalse);	// no autoload is installed
		else
		    return (hslTrue);
	} // end HasAutoload


	//-----------------------------------------------------------------------------------------------------
	function HasRightArm()
	//-----------------------------------------------------------------------------------------------------
	{
		if (rightArmHasChannel == 1)    //right X drive configuration bits
		  	return (hslTrue);

		if (rightArmHasISwap == 1)
			return (hslTrue);

		if (rightArmHas96Head == 1)
			return (hslTrue);

		if (rightArmHasNanoDisp == 1)
			return(hslTrue);

		if (rightArmHas384Head == 1)
			return (hslTrue);

		if (rightArmHasXlChannels == 1)
			return (hslTrue);

		if (rightArmHasTubeGripper == 1)
			return(hslTrue);

		if (rightArmHasImagingChannel == 1)
			return (hslTrue);

		if (rightArmHasCardGripper == 1)
			return (hslTrue);

		return (hslFalse);
	} // end HasRightArm


	//-----------------------------------------------------------------------------------------------------
	function HasLeftArm()
	//-----------------------------------------------------------------------------------------------------
	{
		if (leftArmHasChannel == 1)    //left X drive configuration bits
		  	return (hslTrue);

		if (leftArmHasISwap == 1)
			return (hslTrue);

		if (leftArmHas96Head == 1)
			return (hslTrue);

		if (leftArmHasNanoDisp == 1)
			return(hslTrue);

		if (leftArmHas384Head == 1)
			return (hslTrue);

		if (leftArmHasXlChannels == 1)
			return (hslTrue);

		if (leftArmHasTubeGripper == 1)
			return(hslTrue);

		if (leftArmHasImagingChannel == 1)
			return (hslTrue);

		if (leftArmHasCardGripper == 1)
			return (hslTrue);

		return (hslFalse);
	} // end HasLeftArm


	//-----------------------------------------------------------------------------------------------------
	function HasTempControlledCarrier()
	//-----------------------------------------------------------------------------------------------------
	{
		if (TempControlledCarrier1 == 1)   
		  	return (hslTrue);

		if (TempControlledCarrier2 == 1)
			  return (hslTrue);

		return (hslFalse);
	} // End HasTempControlledCarrier


	//-----------------------------------------------------------------------------------------------------
	function OnAbortMaintenance()
	//-----------------------------------------------------------------------------------------------------
	{
		file fStarParams;
		object fso; // File System Object

		string zhParam;
		string zcParam;
		string ziParam;
		string zjParam;
		string zvParam;
		string zlParam;
		string dpParam;

		string node;
		string command;
		string param;
		string fileName;

		variable lastRunAborted;

		// read parameters from file
		fStarParams.SetDelimiter(hslCSVDelimited);

		fStarParams.AddField("lastRunAborted", lastRunAborted, hslInteger);
		// 2008-09-25/cjoerg
		// changed to only add one field, the others are not touched by the update.
		//fStarParams.AddField("zhOriginal", zhParam, hslString);
		//fStarParams.AddField("zcOriginal", zcParam, hslString);
		//fStarParams.AddField("ziOriginal", ziParam, hslString);
		//fStarParams.AddField("zjOriginal", zjParam, hslString);
		//fStarParams.AddField("zvOriginal", zvParam, hslString);
		//fStarParams.AddField("zlOriginal", zlParam, hslString);
		//fStarParams.AddField("dpOriginal", dpParam, hslString);

		fileName = InstrParam::InstrParamFile;
		StrReplace(fileName, "%s", instrSerialNo);
		fileName = GetLogFilesPath() + fileName;

		fso.CreateObject("Scripting.FileSystemObject");
		if(fso.FileExists(fileName))
		{
			if(0 != fStarParams.Open( fileName + InstrParam::TableName, hslAppend ) )
			{
				fStarParams.ReadRecord();
			
				// update abort state
				lastRunAborted = 1;
			
				fStarParams.Seek(0, hslFirst);
			
				fStarParams.UpdateRecord();

				fStarParams.Close();
			}
		}
		return;	
	}


	//-----------------------------------------------------------------------------------------------------
	function MoveLeft( device ML_STAR )    // left arm
	//-----------------------------------------------------------------------------------------------------
	{
		variable param, answer;
		variable minLeft_xDrivePos, minRight_xDrivePos;

		// if installed, move the left arm first
		if( MtcLib::HasLeftArm() )
		{
			// Request maximal ranges of X drives (answer = er##/##ru##### ##### ##### #####)
			answer	= FwCommand( "C0RU" , "", hslTrue, ML_STAR );
			minLeft_xDrivePos = StrMid( answer, 9, 5 );
		
			// move left arm to min left position
			param = StrConcat2("xs", minLeft_xDrivePos );
			FwCommand( "C0KX", param, hslTrue, ML_STAR );
		}

		// if installed, move the right arm
		if( MtcLib::HasRightArm() )
		{
			// Request maximal ranges of X drives (answer = er##/##ru##### ##### ##### #####)
			answer	= FwCommand( "C0RU" , "", hslTrue, ML_STAR );
			minRight_xDrivePos = StrMid( answer, 21, 5 );

			// move right arm to min left position
			param = StrConcat2( "xs", minRight_xDrivePos );
			FwCommand( "C0KR", param, hslTrue, ML_STAR );
		}

		// move autoload to left position (only if autoload is installed)
		if(autoLoad == 1)
			ML_STAR._EA251BFB_66DE_48D1_83E5_6884B4DD8D11( "4db336f0_9789_4cda_9051518e191a3303" ); // MoveAutoLoad

	} // end MoveLeft


	//-----------------------------------------------------------------------------------------------------
	function MoveAutoloadRight( device ML_STAR )
	//-----------------------------------------------------------------------------------------------------
	{
		// move autoload to right most position (only if autoload is installed)
		if( autoLoad == 1 )
			ML_STAR._EA251BFB_66DE_48D1_83E5_6884B4DD8D11( "706753ef_42b6_4340_80029922c4e6a03b" ); // MoveAutoLoad
	} // end MoveAutoloadRight


	//-----------------------------------------------------------------------------------------------------
	function MoveRight( device ML_STAR, variable instrumentNr )
	//-----------------------------------------------------------------------------------------------------
	{
		variable command, param, answer;
		variable maxLeft_xDrivePos, maxRight_xDrivePos;

		// if installed, move the right arm first
		if( MtcLib::HasRightArm() )
		{
			// Request maximal ranges of X drives (answer = er##/##ru##### ##### ##### #####)
			answer	= FwCommand( "C0RU" , "", hslTrue, ML_STAR );
			maxRight_xDrivePos = StrMid( answer, 27, 5 );

			// move right arm to max right position
			param = StrConcat2( "xs", maxRight_xDrivePos );
			FwCommand( "C0KR", param, hslTrue, ML_STAR );
		}

		// if installed, move the left arm
		if( MtcLib::HasLeftArm() )
		{
			// Request maximal ranges of X drives (answer = er##/##ru##### ##### ##### #####)
			answer	= FwCommand( "C0RU" , "", hslTrue, ML_STAR );
			maxLeft_xDrivePos = StrMid( answer, 15, 5 );
		
			// move left arm to max right position
			param = StrConcat2("xs", maxLeft_xDrivePos );
			FwCommand( "C0KX", param, hslTrue, ML_STAR );
		}

		MoveAutoloadRight( ML_STAR );

	} // end MoveRight


	//-----------------------------------------------------------------------------------------------------
	function IsCoverClosed( device ML_STAR )
	//-----------------------------------------------------------------------------------------------------
	{
		string status;

		// initialize library (if necessary)
		InitMaintMetLibrary();

		// check cover status
		status = StrMid( FwCommand("C0RW","",hslTrue, ML_STAR), 9, 1);
		if ( 0 == status.Compare("1") )
		{
			// cover is closed
			return (hslTrue);
		}
		else
		{
			// cover is open
			return (hslFalse);
		}

	} // end IsCoverClosed

	//-----------------------------------------------------------------------------------------------------
	function LockCover( device ML_STAR, variable lockFront, string msg, string title ) variable
	//-----------------------------------------------------------------------------------------------------
	{
		if ( CoverLock::coverUnlock == lockFront )
		{
			ML_STAR._2931977C_E32F_4471_8B68_F31ED1A866F5( "13358f08_1f67_4dcd_ac2dd6c120e15c21" ); // LockFrontCover
		}
		else
		{
			while ( hslFalse == IsCoverClosed( ML_STAR ) )
			{
				if ( hslOK != MessageBox( msg, title, hslOKCancel | hslInformation, hslInfinite) ) 
				{
					// Cancel -> maintenance process end
					return (hslFalse);
				}
			}
			ML_STAR._2931977C_E32F_4471_8B68_F31ED1A866F5( "ca965d5b_e567_47e5_a8d23f2768eee8ec" ); // LockFrontCover
		}
		
		return (hslTrue);
	} // end LockCover

	//-----------------------------------------------------------------------------------------------------
	function IsDeckEmpty( device ML_STAR )
	// --------------------------------------------------------------------------
	{
		variable retVal;
		string lowPosStr("0x"); // hex string for bit 0..27
		string highPosStr("0x"); // hex string for bit 28..30 or 54

		// initialize library (if necessary)
		InitMaintMetLibrary();

		// check for presence of carrier on deck
		retVal = FwCommand("C0RC","",hslTrue, ML_STAR);
		lowPosStr = lowPosStr + StrMid( retVal, 16, 7);
		highPosStr = highPosStr + StrMid( retVal, 9, 7);

		// evaluate hex values of deck positions (bit 0..30 or 54)
		deckLowPos = IVal(lowPosStr); // bit 0..27
		deckHighPos = IVal(highPosStr); // bit 28..30 or 54

		// check if any carrier on loading tray
		if ( 0 == (0xFFFFFFF & deckLowPos) &&
		     0 == (0x3FFFFFF & deckHighPos) ) // only bit 54 may be set (waste block)
		{
			// deck is empty
			return (hslTrue);
		}
		else
		{
			// deck is not empty
			return (hslFalse);
		}
	} // end IsDeckEmpty

	//-----------------------------------------------------------------------------------------------------
	function UnloadDeck( device ML_STAR )
	// --------------------------------------------------------------------------
	{
		variable position; // actual deck position
		variable deckVar;
		string unloadParam;

		// initialize library (if necessary)
		InitMaintMetLibrary();

		// loop all deck positions
		deckVar = deckLowPos; // check first deck position variable
		for ( position = deckPosFirst; position <= deckPosLast; position++ )
		{
			if ( position == deckPosFistHigh )
				deckVar = deckHighPos; // check secound deck position variable

			// check position
			if ( deckVar & 0x1 )
			{
				// unload position
				unloadParam = "cp";
				if ( position < 10 )
					unloadParam = unloadParam + "0";
				unloadParam = unloadParam + IStr(position);
				FwCommand( "C0CW", unloadParam, hslTrue, ML_STAR);
			}

			// shift right (1 bit), to check next position
			deckVar = Floor(deckVar / 2);
		}

	} // end UnloadDeck


	//-----------------------------------------------------------------------------------------------------
	function StoreProcessDataOnInstrument( variable &processId, device ML_STAR )
	//-----------------------------------------------------------------------------------------------------
	{
		string fwCommand;
		string fwParameter;
		string sProcessId;

		sProcessId = IStr(processId);
		StrFillLeft(sProcessId, "0", 2);

		// firmware command and parameter to store verification data
		fwCommand = "C0AV";
		fwParameter = "vo";
		fwParameter = fwParameter + sProcessId;
		fwParameter = fwParameter + "vd";
		fwParameter = fwParameter + GetDate("%Y-%m-%d ");
		fwParameter = fwParameter + GetTime("%H:%M");
		fwParameter = fwParameter + "vs";
		fwParameter = fwParameter + IStr(overallProcessedState);
		FwCommand( fwCommand, fwParameter, hslTrue, ML_STAR);
	} // end StoreProcessDataOnInstrument


	//-----------------------------------------------------------------------------------------------------
	function CreateReportFile( variable &templateFile, variable &reportFileName, variable &reportExcelAreaName)
	//-----------------------------------------------------------------------------------------------------
	{
		object report;
		object reportReadOnly;
		file reportFile;
		variable i;
		variable testSummaryRow(testSummaryFirstRow + 2);
		variable isInstalled;

		// path, file and excel table name of the report
		variable templateFileName, testedFiles;
		variable copyCommand("cmd.exe /c copy \"");

		// Evaluate the template file name respecting the current phoenix langauge.
		templateFileName = GetMethodsPath() + "\\" + templateFile + GetLanguage() + ".xls";	// phoenix specific
		if ("" == SearchPath(templateFileName))
		{
			testedFiles = templateFileName;
			templateFileName = GetMethodsPath() + "\\" + templateFile + "Enu.xls";		// The default language
			if ("" == SearchPath(templateFileName))
			{
				testedFiles = testedFiles + "\n" + templateFileName;
				templateFileName = GetMethodsPath() + "\\" + templateFile + ".xls";		// No language
				if ("" == SearchPath(templateFileName))
				{
					string errorDesc;
					testedFiles = testedFiles + "\n" + templateFileName;
					errorDesc = StringTable::Load(IDE::templateFileNotExist);
					StrReplace(errorDesc, "%s1", GetFileName());
					StrReplace(errorDesc, "%s2", GetLineNumber());
					StrReplace(errorDesc, "%s3", testedFiles);
				   err.Raise( IDE::templateFileNotExist, errorDesc);
				}
			}
		}

		copyCommand = copyCommand + templateFileName + "\" \"" + GetLogFilesPath()+"\\"+reportFileName+"\"";

		// create file by copying template
		if (!Shell(copyCommand, hslHide, hslSynchronous))
		{
			string errorDesc;
			errorDesc = StringTable::Load(IDE::fileCopyFailed);
			StrReplace(errorDesc, "%s1", GetFileName());
			StrReplace(errorDesc, "%s2", GetLineNumber());
		   err.Raise( IDE::fileCopyFailed, errorDesc);
		}

		// open file
		if (!reportFile.Open(GetLogFilesPath()+"\\"+reportFileName + " " + reportExcelAreaName, hslAppend))
		{
			string errorDesc;
			errorDesc = StringTable::Load(IDE::fileOpenFailed);
			StrReplace(errorDesc, "%s1", GetFileName());
			StrReplace(errorDesc, "%s2", GetLineNumber());
		   err.Raise( IDE::fileOpenFailed, errorDesc);
		}

		// update instrument name
		UpdateCellInReportFile( reportFile, instrNameCol, instrNameRow, instrName);

		// update user software version
		UpdateCellInReportFile( reportFile, releaseVersionCol, releaseVersionRow, releaseVersion);

		// update instrument serial number
		UpdateCellInReportFile( reportFile, instrSerialNoCol, instrSerialNoRow, instrSerialNo);

		// update instrument-deck/waste status (performed or not performed)
		UpdateCellInReportFile( reportFile, statusCol, deckAndWasteRow, GetCheckStateAsString(instrumentCheckState));

		//*******************************************************************************************************************************
		// 1000ul Channel's
		//*******************************************************************************************************************************
		// installed or not...
		UpdateCellInReportFile( reportFile, installedFlagCol, title1000ulChannelRow, GetInstallationStateAsString(HasPipettingChannel1000ul()));

		// update channel check (tightness)
		UpdateCellInReportFile( reportFile, statusCol, tightnessChannel1000ulRow, GetCheckStateAsString(tightnessCheckChannel1000ulState));

		// update cLLD check
		UpdateCellInReportFile( reportFile, statusCol, cLLDChannel1000ulRow, GetCheckStateAsString(cLLDCheckChannel1000ulState));
		
		//*******************************************************************************************************************************
		// 5ml Channel's
		//*******************************************************************************************************************************
		// installed or not...
		UpdateCellInReportFile( reportFile, installedFlagCol, title5mlChannelRow, GetInstallationStateAsString(HasPipettingChannel5ml()));

		// update channel check (tightness)
		UpdateCellInReportFile( reportFile, statusCol, tightnessChannel5mlRow, GetCheckStateAsString(tightnessCheckChannel5mlState));

		// update cLLD check
		UpdateCellInReportFile( reportFile, statusCol, cLLDChannel5mlRow, GetCheckStateAsString(cLLDCheckChannel5mlState));

		//*******************************************************************************************************************************
		// 96 Tadm head
		//*******************************************************************************************************************************
		// installed or not...
		UpdateCellInReportFile( reportFile, installedFlagCol, title96TadmHeadRow, GetInstallationStateAsString(Has96TadmHead()));

		// update channel check (tightness)
		UpdateCellInReportFile( reportFile, statusCol, tightness96TadmHeadRow, GetCheckStateAsString(tightnessCheckChannel96TadmHeadState));


		//*******************************************************************************************************************************
		// Needle and CR Wash Station
		//*******************************************************************************************************************************
		// update needle wash station 1 --> installed, not installed
		isInstalled = hslFalse;
		if(washStation1 == 1 && exwashStation1 == 0)
			isInstalled = hslTrue;
		UpdateCellInReportFile( reportFile, installedFlagCol, needleWashStation1Row, GetInstallationStateAsString(isInstalled));
		// update needle wash station 1 status  --> successful, failed, not installed, not performed
		UpdateCellInReportFile( reportFile, statusCol, needleWashStation1Row, GetCheckStateAsString(needleWashStation_1_CheckState));

		// update needle wash station 2 --> installed, not installed
		isInstalled = hslFalse;
		if(washStation2 == 1 && exwashStation2 == 0)
			isInstalled = hslTrue;
		UpdateCellInReportFile( reportFile, installedFlagCol, needleWashStation2Row, GetInstallationStateAsString(isInstalled));
		// update needle wash station 2 status  --> successful,failed,not installed, not performed
		UpdateCellInReportFile( reportFile, statusCol, needleWashStation2Row, GetCheckStateAsString(needleWashStation_2_CheckState));

		// update cr wash station 1 --> installed, else not installed
		UpdateCellInReportFile( reportFile, installedFlagCol, crWashStation1Row, GetInstallationStateAsString(exwashStation1));

		// update cr wash station 1 status --> successful,failed,not installed or not performed
		UpdateCellInReportFile( reportFile, statusCol, crWashStation1Row, GetCheckStateAsString(crWashStation_1_CheckState));

	 	// update cr wash station 2 status--> installed, not installed
		UpdateCellInReportFile( reportFile, installedFlagCol, crWashStation2Row, GetInstallationStateAsString(exwashStation2));

		// update cr wash station 2 status --> successful,failed,not installed or not performed
		UpdateCellInReportFile( reportFile, statusCol, crWashStation2Row, GetCheckStateAsString(crWashStation_2_CheckState));

		//*******************************************************************************************************************************
		// 96 Wash Station
		//*******************************************************************************************************************************
		// update 96 wash station hu --> installed, not installed
		isInstalled = hslFalse;
		if(pumpStation2 == 1 && pumpTypeStation2 == 0)
			isInstalled = hslTrue;
		UpdateCellInReportFile( reportFile, installedFlagCol, hu96WashStationRow, GetInstallationStateAsString(isInstalled));
		// update 96 wash station hu status --> successful,failed,not installed or not performed
		UpdateCellInReportFile( reportFile, statusCol, hu96WashStationRow, GetCheckStateAsString(head96WashStation_HU_CheckState));

		// update 96 wash station hv --> installed, not installed
		isInstalled = hslFalse;
		if(pumpStation3 == 1 && pumpTypeStation3 == 0)
			isInstalled = hslTrue;
		UpdateCellInReportFile( reportFile, installedFlagCol, hv96WashStationRow, GetInstallationStateAsString(isInstalled));
		// update 96 wash station hv status --> successful,failed,not installed or not performed
		UpdateCellInReportFile( reportFile, statusCol, hv96WashStationRow, GetCheckStateAsString(head96WashStation_HV_CheckState));

		// update 96 wash station hw --> installed, not installed
		isInstalled = hslFalse;
		if(pumpStation1 == 1 && pumpTypeStation1 == 0)
			isInstalled = hslTrue;
		UpdateCellInReportFile( reportFile, installedFlagCol, hw96WashStationRow, GetInstallationStateAsString(isInstalled));
		// update 96 wash station hw status --> successful,failed,not installed or not performed
		UpdateCellInReportFile( reportFile, statusCol, hw96WashStationRow, GetCheckStateAsString(head96WashStation_HW_CheckState));


		//*******************************************************************************************************************************
		// DC Wash Station
		//*******************************************************************************************************************************
		//  DC wash station!: update dc wash station hu --> installed, not installed
		isInstalled = hslFalse;
		if(pumpStation2 == 1 && pumpTypeStation2 == 1)
			isInstalled = hslTrue;
		UpdateCellInReportFile( reportFile, installedFlagCol, dcWashStationHuRow, GetInstallationStateAsString(isInstalled));
		// update dc wash station hu status --> successful,failed,not installed or not performed
		UpdateCellInReportFile( reportFile, statusCol, dcWashStationHuRow, GetCheckStateAsString(dcWashStation_HU_CheckState));

		// update dc wash station hv --> installed, not installed
		isInstalled = hslFalse;
		if(pumpStation3 == 1 && pumpTypeStation3 == 1)
			isInstalled = hslTrue;
		UpdateCellInReportFile( reportFile, installedFlagCol, dcWashStationHvRow, GetInstallationStateAsString(isInstalled));
		// update dc wash station hv status --> successful,failed,not installed or not performed
		UpdateCellInReportFile( reportFile, statusCol, dcWashStationHvRow, GetCheckStateAsString(dcWashStation_HV_CheckState));

		// update dc wash station hw --> installed, not installed
		isInstalled = hslFalse;
		if(pumpStation1 == 1 && pumpTypeStation1 == 1)
			isInstalled = hslTrue;
		UpdateCellInReportFile( reportFile, installedFlagCol, dcWashStationHwRow, GetInstallationStateAsString(isInstalled));
		// update dc wash station hw status --> successful,failed,not installed or not performed
		UpdateCellInReportFile( reportFile, statusCol, dcWashStationHwRow, GetCheckStateAsString(dcWashStation_HW_CheckState));


		//*******************************************************************************************************************************
		// 96/384 Wash Station
		//*******************************************************************************************************************************
		//  UpDate 96/384 wash station!: HU --> installed, not installed
		isInstalled = hslFalse;
		if(pumpStation2 == 1 && pumpTypeStation2 == 3)
			isInstalled = hslTrue;
		UpdateCellInReportFile( reportFile, installedFlagCol, hu_96_384_WashStationRow, GetInstallationStateAsString(isInstalled));
		// update dc wash station HUu status --> successful,failed,not installed or not performed
		UpdateCellInReportFile( reportFile, statusCol, hu_96_384_WashStationRow, GetCheckStateAsString(head_96_384_WashStation_HU_CheckState));

		//  UpDate 96/384 wash station!: HV --> installed, not installed
		isInstalled = hslFalse;
		if(pumpStation3 == 1 && pumpTypeStation3 == 3)
			isInstalled = hslTrue;
		UpdateCellInReportFile( reportFile, installedFlagCol, hv_96_384_WashStationRow, GetInstallationStateAsString(isInstalled));
		// update dc wash station HV status --> successful,failed,not installed or not performed
		UpdateCellInReportFile( reportFile, statusCol, hv_96_384_WashStationRow, GetCheckStateAsString(head_96_384_WashStation_HV_CheckState));

		//  UpDate 96/384 wash station!: HW --> installed, not installed
		isInstalled = hslFalse;
		if(pumpStation1 == 1 && pumpTypeStation1 == 3)
			isInstalled = hslTrue;
		UpdateCellInReportFile( reportFile, installedFlagCol, hw_96_384_WashStationRow, GetInstallationStateAsString(isInstalled));
		// update dc wash station HV status --> successful,failed,not installed or not performed
		UpdateCellInReportFile( reportFile, statusCol, hw_96_384_WashStationRow, GetCheckStateAsString(head_96_384_WashStation_HW_CheckState));

		//*******************************************************************************************************************************
		//  BVS
		//*******************************************************************************************************************************
		//  BVS UpDate
		isInstalled = hslFalse;
		if(BVS == PS::Installed)
			 isInstalled = hslTrue;
		UpdateCellInReportFile( reportFile, installedFlagCol, bvsRow, GetInstallationStateAsString(isInstalled));
		// update BVS status --> successful,failed,not installed or not performed
		UpdateCellInReportFile( reportFile, statusCol, bvsRow, GetCheckStateAsString(BVS_CheckState));

		//*******************************************************************************************************************************
		//  easyPunch
		//*******************************************************************************************************************************
		UpdateCellInReportFile( reportFile, installedFlagCol, easyPunchRow, GetInstallationStateAsString(HasEasyPuncher()));
		// update easyPunch status --> successful,failed,not installed or not performed
		UpdateCellInReportFile( reportFile, statusCol, easyPunchRow, GetCheckStateAsString(easyPuncherState));


		//*******************************************************************************************************************************
		//  Overall Process State
		//*******************************************************************************************************************************
		// update processed status
		UpdateCellInReportFile( reportFile, processedStateCol, overallSummaryRow, GetProcessedStateAsString());

		// update processed date
		UpdateCellInReportFile( reportFile, dateCol,           overallSummaryRow, TimGetFormattedDate("%Y-%m-%d"));

		// update processed time
		UpdateCellInReportFile( reportFile, timeCol,           overallSummaryRow, TimGetFormattedTime("%H:%M"));

		// update operator name
		UpdateCellInReportFile( reportFile, operatorNameCol,   overallSummaryRow, operatorName);

		//*******************************************************************************************************************************
		// Error summary report
		//*******************************************************************************************************************************
		if(		 (PS::failed == tightnessCheckChannel1000ulState)
				||  (PS::failed == cLLDCheckChannel1000ulState)
				||  (PS::failed == tightnessCheckChannel5mlState)
				||  (PS::failed == cLLDCheckChannel5mlState)
            ||  (PS::failed == tightnessCheckChannel96TadmHeadState) )
		{
			UpdateCellInReportFile( reportFile, testSummaryCol, testSummaryFirstRow, StringTable::Load(IDS::testSum));

			// Lookup details for 1000ul Channel Check
			for(i = 0; i < instrNumberOfChannels1000ul; i++)
			{
				if(MERR::tightnessCheckChannel1000ulError[i].Compare("") != 0 || MERR::cLLDCheckChannel1000ulError[i].Compare("") != 0)
				{
					if(MERR::tightnessCheckChannel1000ulError[i].Compare("") != 0 )
					{
						UpdateCellInReportFile( reportFile, testSummaryCol, testSummaryRow, StringTable::Load(IDS::channel1000ul) + IStr(i+1) + ": ");
						UpdateCellInReportFile( reportFile, testSummaryCol + 2, testSummaryRow, StringTable::Load(IDS::tightnessCheckFailed));
						testSummaryRow = testSummaryRow + 1;
					}
					if(MERR::cLLDCheckChannel1000ulError[i].Compare("") != 0 )
					{
						UpdateCellInReportFile( reportFile, testSummaryCol, testSummaryRow, StringTable::Load(IDS::channel1000ul) + IStr(i+1) + ": ");
						UpdateCellInReportFile( reportFile, testSummaryCol + 2, testSummaryRow, StringTable::Load(IDS::cLLDCheckFailed));
						testSummaryRow = testSummaryRow + 1;
					}
				}
			}

			// Lookup details for 5ml Channel Check
			for(i = 0; i < instrNumberOfChannels5ml; i++)
			{
				if(MERR::tightnessCheckChannel5mlError[i].Compare("") != 0 || MERR::cLLDCheckChannel5mlError[i].Compare("") != 0)
				{
					if(MERR::tightnessCheckChannel5mlError[i].Compare("") != 0 )
					{
						UpdateCellInReportFile( reportFile, testSummaryCol, testSummaryRow, StringTable::Load(IDS::channel5ml) + IStr(i+1) + ": ");
						UpdateCellInReportFile( reportFile, testSummaryCol + 2, testSummaryRow, StringTable::Load(IDS::tightnessCheckFailed));
						testSummaryRow = testSummaryRow + 1;
					}
					if(MERR::cLLDCheckChannel5mlError[i].Compare("") != 0 )
					{
						UpdateCellInReportFile( reportFile, testSummaryCol, testSummaryRow, StringTable::Load(IDS::channel5ml) + IStr(i+1) + ": ");
						UpdateCellInReportFile( reportFile, testSummaryCol + 2, testSummaryRow, StringTable::Load(IDS::cLLDCheckFailed));
						testSummaryRow = testSummaryRow + 1;
					}
				}
			}

			// Lookup details for 96 Tadm Head
			for(i = 0; i < maxNoOfChannel96TadmHead; i++)
			{
				if(MERR::tightnessCheckChannel96TadmHeadError[i].Compare("") != 0)
				{
					UpdateCellInReportFile( reportFile, testSummaryCol, testSummaryRow, StringTable::Load(IDS::channel96TadmHead) + IStr(i+1) + ": ");
					UpdateCellInReportFile( reportFile, testSummaryCol + 2, testSummaryRow, MERR::tightnessCheckChannel96TadmHeadError[i]);
					testSummaryRow = testSummaryRow + 1;
				}
			}

		}

		// close file
		reportFile.Close();

		//make file read only
		report.CreateObject("Scripting.FileSystemObject");
		reportReadOnly = report.GetFile(GetLogFilesPath()+"\\"+reportFileName);
		reportReadOnly.Attributes = reportReadOnly.Attributes | 1;
		reportReadOnly.ReleaseObject();
		report.ReleaseObject();

	} // end CreateReportFile


	//-----------------------------------------------------------------------------------------------------
	function SetPowerOnValuesForAllChannels1000ul( device ML_STAR )
	//-----------------------------------------------------------------------------------------------------
	{
		string command;
		string param;

		command = "PXAA";
		param = zhOriginalChannel1000ul;
		param = param + zcOriginalChannel1000ul;
		param = param + ziOriginalChannel1000ul;
		param = param + zjOriginalChannel1000ul;
		param = param + zvOriginalChannel1000ul;
		param = param + zlOriginalChannel1000ul;
		param = param + dpOriginalChannel1000ul;
		FwCommand( command, param, hslTrue, ML_STAR);
   } // end SetPowerOnValuesForAllChannels1000ul


	//-----------------------------------------------------------------------------------------------------
	function SetPowerOnValuesForAllChannels5ml( device ML_STAR )
	//-----------------------------------------------------------------------------------------------------
	{
		string command;
		string param;

		command = "LXAA";
		param = zhOriginalChannel5ml;
		param = param + zcOriginalChannel5ml;
		param = param + ziOriginalChannel5ml;
		param = param + zjOriginalChannel5ml;
		param = param + zvOriginalChannel5ml;
		param = param + zlOriginalChannel5ml;
		param = param + dpOriginalChannel5ml;
		FwCommand( command, param, hslTrue, ML_STAR);
   } // end SetPowerOnValuesForAllChannels5ml


	//-----------------------------------------------------------------------------------------------------
	function SetPowerOnValuesFor96TadmHead( device ML_STAR )
	//-----------------------------------------------------------------------------------------------------
	{
		string command;
		string param;

		command = "H0AA";
		param = dqOriginal96TadmHead;
		FwCommand( command, param, hslTrue, ML_STAR);
   } // end SetPowerOnValuesFor96TadmHead


	function RestoreParamsFromFile( device ML_STAR ) variable
	{
		file fStarParams;
		variable rw_lastRunAborted;
		string rw_zhParam1000ul;
		string rw_zcParam1000ul;
		string rw_ziParam1000ul;
		string rw_zjParam1000ul;
		string rw_zvParam1000ul;
		string rw_zlParam1000ul;
		string rw_dpParam1000ul;
		string rw_zhParam5ml;
		string rw_zcParam5ml;
		string rw_ziParam5ml;
		string rw_zjParam5ml;
		string rw_zvParam5ml;
		string rw_zlParam5ml;
		string rw_dpParam5ml;
		string rw_dqParam96TadmHead;
      string rw_zvParamCH;
      string rw_yvParamCH;

		string node;
		string command;
		string param;
		variable i;
		string fileName;

		onerror goto Unexpected;

		// read default parameters from file
		fStarParams.AddField("lastRunAborted",   rw_lastRunAborted, hslInteger);
		fStarParams.AddField("zhOriginal1000ul", rw_zhParam1000ul, hslString);
		fStarParams.AddField("zcOriginal1000ul", rw_zcParam1000ul, hslString);
		fStarParams.AddField("ziOriginal1000ul", rw_ziParam1000ul, hslString);
		fStarParams.AddField("zjOriginal1000ul", rw_zjParam1000ul, hslString);
		fStarParams.AddField("zvOriginal1000ul", rw_zvParam1000ul, hslString);
		fStarParams.AddField("zlOriginal1000ul", rw_zlParam1000ul, hslString);
		fStarParams.AddField("dpOriginal1000ul", rw_dpParam1000ul, hslString);
		fStarParams.AddField("zhOriginal5ml", rw_zhParam5ml, hslString);
		fStarParams.AddField("zcOriginal5ml", rw_zcParam5ml, hslString);
		fStarParams.AddField("ziOriginal5ml", rw_ziParam5ml, hslString);
		fStarParams.AddField("zjOriginal5ml", rw_zjParam5ml, hslString);
		fStarParams.AddField("zvOriginal5ml", rw_zvParam5ml, hslString);
		fStarParams.AddField("zlOriginal5ml", rw_zlParam5ml, hslString);
		fStarParams.AddField("dpOriginal5ml", rw_dpParam5ml, hslString);
		fStarParams.AddField("dqOriginal96TadmHead", rw_dqParam96TadmHead, hslString);
		fStarParams.AddField("zvOriginalCH", rw_zvParamCH, hslString);
		fStarParams.AddField("yvOriginalCH", rw_yvParamCH, hslString);


		fileName = InstrParam::InstrParamFile;
		StrReplace(fileName, "%s", instrSerialNo);
		fileName = GetLogFilesPath() + fileName + InstrParam::TableName;

		if(0 != fStarParams.Open( fileName , hslRead ) )
		{
			fStarParams.ReadRecord();
			fStarParams.Close();
		
			if(rw_lastRunAborted != 0)
			{
				if ( (0 < instrNumberOfChannels1000ul) && (rw_zhParam1000ul.GetLength() > 0) )	// we have 1000ul channels and set a value during previous run
				{
					// loop 1000ul channels
					for ( i = 0; i < instrNumberOfChannels1000ul; i++ )
					{
						node = FwChannelNode1000ul(i);

						command = node + "AA";
						param = rw_zhParam1000ul;
						param = param + rw_zcParam1000ul;
						param = param + rw_ziParam1000ul;
						param = param + rw_zjParam1000ul;
						param = param + rw_zvParam1000ul;
						param = param + rw_zlParam1000ul;
						FwCommand( command, param, hslTrue, ML_STAR);
					}

					// set param "Tip pick up position dispensing drive" back to origin
					FwCommand( "PXAA", rw_dpParam1000ul, hslTrue, ML_STAR);
				}

				if ( (0 < instrNumberOfChannels5ml) && (rw_zhParam5ml.GetLength() > 0))		// we have 1000ul channels and set a value during previous run
				{
					// loop 5ml channels
					for ( i = 0; i < instrNumberOfChannels5ml; i++ )
					{
						node = FwChannelNode5ml(i);

						command = node + "AA";
						param = rw_zhParam5ml;
						param = param + rw_zcParam5ml;
						param = param + rw_ziParam5ml;
						param = param + rw_zjParam5ml;
						param = param + rw_zvParam5ml;
						param = param + rw_zlParam5ml;
						FwCommand( command, param, hslTrue, ML_STAR);
					}

					// set param "Tip pick up position dispensing drive" back to origin
					FwCommand( "LXAA", rw_dpParam5ml, hslTrue, ML_STAR);
				}

            // set 96 Tadm Head
            if(Has96TadmHead() && (rw_dqParam96TadmHead.GetLength() > 0))
            {
					// set param "Tip pick up position dispensing drive" back to origin
					FwCommand( "H0AA", rw_dqParam96TadmHead, hslTrue, ML_STAR);
            }

				if (( 0 < cardGripper) && (rw_zvParamCH.GetLength() > 0))		// we have card gripper and set a value during previous run
				{
					param = rw_zvParamCH;
					param = param + rw_yvParamCH;
					FwCommand( "CHAA", param, hslTrue, ML_STAR);
			   }

			}
		}

		return (hslTrue);

		Unexpected :
		{
			return (hslFalse);
		}		
	} // end RestoreParamsFromFile



	//-----------------------------------------------------------------------------------------------------
	function SetInstrumentCheckState( variable processState )
	//-----------------------------------------------------------------------------------------------------
	{
		instrumentCheckState = processState;
	}


	//-----------------------------------------------------------------------------------------------------
	function TightnessCheckChannel1000ul( device ML_STAR ) void
	//-----------------------------------------------------------------------------------------------------
	{
		variable index;
		variable numberForCheck( instrNumberOfNeedles1000ul );
		variable ichanUPressBeginTimer;
		variable ichanUPressEndTimer;
		variable ichanOPressBeginTimer;
 		variable ichanOPressEndTimer;
		string traceText;
		string traceTextEx;

		// loop channels for measurements
		for ( index=0; index<instrNumberOfChannels1000ul; index=index+numberForCheck)
		{
			// determine if number of channels for next check is reduced
			if ( (instrNumberOfChannels1000ul-index) < instrNumberOfNeedles1000ul )
			{
				numberForCheck = (instrNumberOfChannels1000ul-index);
			}

			// Check tightness
			StartTightnessCheckForChannels1000ul( index, numberForCheck, ML_STAR );
		}

		// Initialize plunger drives
		FwCommand( "PXDI", "", hslTrue, ML_STAR);

		//DumpData(); // for debugging

		// loop channels to analyze measurements
		for ( index=0; index<instrNumberOfChannels1000ul; index++)
		{
			// ------------------------------
			// analyze tightness measurements
			//
			ichanOPressBeginTimer	= chanOPressBeginTimer1000ul.GetAt(index);
			ichanOPressEndTimer		= chanOPressEndTimer1000ul.GetAt(index);
			ichanUPressBeginTimer	= chanUPressBeginTimer1000ul.GetAt(index);
			ichanUPressEndTimer		= chanUPressEndTimer1000ul.GetAt(index);
			// build over pressure
			if ( ichanOPressBeginTimer < minPressureLimit1000ul )
			{
				traceText = StringTable::Load(IDS::buildOverPressure1000ulFailed);
				StrReplace(traceText, "%s", IStr(index+1));

				traceTextEx = StringTable::Load(IDS::reachedPressure);
				StrReplace(traceTextEx, "%s", IStr(ichanOPressBeginTimer));

				Trace(traceText, traceTextEx);

				tightnessCheckChannel1000ulState = PS::failed;
				MERR::tightnessCheckChannel1000ulError.SetAt(index, StringTable::Load(IDS::checkFailed));
			}

			// drop over pressure
			if ( dropLimit1000ul < (ichanOPressBeginTimer-ichanOPressEndTimer) )
			{
				traceText = StringTable::Load(IDS::dropOverPressure1000ulFailed);
				StrReplace(traceText, "%s", IStr(index+1));

				traceTextEx = StringTable::Load(IDS::measuredLeakage);
				StrReplace(traceTextEx, "%s", IStr(ichanOPressBeginTimer-ichanOPressEndTimer));

				Trace(traceText, traceTextEx);

				tightnessCheckChannel1000ulState = PS::failed;
				MERR::tightnessCheckChannel1000ulError.SetAt(index, StringTable::Load(IDS::checkFailed));
			}

			// build under pressure
			if ( ichanUPressBeginTimer < minPressureLimit1000ul )
			{
				variable underPressure;
				underPressure = ichanUPressBeginTimer;

				traceText = StringTable::Load(IDS::buildUnderPressure1000ulFailed);
				StrReplace(traceText, "%s", IStr(index+1));

				// the pressure is stored as an absolute value (unsigned)
				underPressure = (0 - ichanUPressBeginTimer);

				traceTextEx = StringTable::Load(IDS::reachedPressure);
				StrReplace(traceTextEx, "%s", IStr(underPressure));

				Trace(traceText, traceTextEx);

				tightnessCheckChannel1000ulState = PS::failed;
				MERR::tightnessCheckChannel1000ulError.SetAt(index, StringTable::Load(IDS::checkFailed));
			}

			// drop under pressure
			if ( dropLimit1000ul < (ichanUPressBeginTimer-ichanUPressEndTimer) )
			{
				traceText = StringTable::Load(IDS::dropUnderPressure1000ulFailed);
				StrReplace(traceText, "%s", IStr(index+1));

				traceTextEx = StringTable::Load(IDS::measuredLeakage);
				StrReplace(traceTextEx, "%s", IStr(ichanUPressBeginTimer-ichanUPressEndTimer));

				Trace(traceText, traceTextEx);

				tightnessCheckChannel1000ulState = PS::failed;
				MERR::tightnessCheckChannel1000ulError.SetAt(index, StringTable::Load(IDS::checkFailed));
			}
		}

		// if nothing has failed the overall state is successful, until now it was open
		if ( PS::failed != tightnessCheckChannel1000ulState )
		{
			tightnessCheckChannel1000ulState = PS::successful;
		}

		return;
	} // end TightnessCheck1000ul


	//-----------------------------------------------------------------------------------------------------
	function TightnessCheckChannel5ml( device ML_STAR ) void
	//-----------------------------------------------------------------------------------------------------
	{
		variable index;
		variable numberForCheck( instrNumberOfNeedles5ml );
		variable ichanUPressBeginTimer;
		variable ichanUPressEndTimer;
		variable ichanOPressBeginTimer;
 		variable ichanOPressEndTimer;
		string traceText;
		string traceTextEx;

		// loop channels for measurements
		for ( index=0; index<instrNumberOfChannels5ml; index=index+numberForCheck)
		{
			// determine if number of channels for next check is reduced
			if ( (instrNumberOfChannels5ml-index) < instrNumberOfNeedles5ml )
			{
				numberForCheck = (instrNumberOfChannels5ml-index);
			}

			// Check tightness
			StartTightnessCheckForChannels5ml( index, numberForCheck, ML_STAR );
		}

		// Initialize plunger drives
		FwCommand( "LXDI", "", hslTrue, ML_STAR);

		//DumpData(); // for debugging

		// loop channels to analyze measurements
		for ( index=0; index<instrNumberOfChannels5ml; index++)
		{
			// ------------------------------
			// analyze tightness measurements
			//
			ichanOPressBeginTimer	= chanOPressBeginTimer5ml.GetAt(index);
			ichanOPressEndTimer		= chanOPressEndTimer5ml.GetAt(index);
			ichanUPressBeginTimer	= chanUPressBeginTimer5ml.GetAt(index);
			ichanUPressEndTimer		= chanUPressEndTimer5ml.GetAt(index);
			// build over pressure
			if ( ichanOPressBeginTimer < minPressureLimit5ml )
			{
				traceText = StringTable::Load(IDS::buildOverPressure5mlFailed);
				StrReplace(traceText, "%s", IStr(index+1));

				traceTextEx = StringTable::Load(IDS::reachedPressure);
				StrReplace(traceTextEx, "%s", IStr(ichanOPressBeginTimer));

				Trace(traceText, traceTextEx);

				tightnessCheckChannel5mlState = PS::failed;
				MERR::tightnessCheckChannel5mlError.SetAt(index, StringTable::Load(IDS::checkFailed));
			}

			// drop over pressure
			if ( dropLimit5ml < (ichanOPressBeginTimer-ichanOPressEndTimer) )
			{
				traceText = StringTable::Load(IDS::dropOverPressure5mlFailed);
				StrReplace(traceText, "%s", IStr(index+1));

				traceTextEx = StringTable::Load(IDS::measuredLeakage);
				StrReplace(traceTextEx, "%s", IStr(ichanOPressBeginTimer-ichanOPressEndTimer));

				Trace(traceText, traceTextEx);

				tightnessCheckChannel5mlState = PS::failed;
				MERR::tightnessCheckChannel5mlError.SetAt(index, StringTable::Load(IDS::checkFailed));
			}

			// build under pressure
			if ( ichanUPressBeginTimer < minPressureLimit5ml )
			{
				variable underPressure;
				underPressure = ichanUPressBeginTimer;

				traceText = StringTable::Load(IDS::buildUnderPressure5mlFailed);
				StrReplace(traceText, "%s", IStr(index+1));

				// the pressure is stored as an absolute value (unsigned)
				underPressure = (0 - ichanUPressBeginTimer);

				traceTextEx = StringTable::Load(IDS::reachedPressure);
				StrReplace(traceTextEx, "%s", IStr(underPressure));

				Trace(traceText, traceTextEx);

				tightnessCheckChannel5mlState = PS::failed;
				MERR::tightnessCheckChannel5mlError.SetAt(index, StringTable::Load(IDS::checkFailed));
			}

			// drop under pressure
			if ( dropLimit5ml < (ichanUPressBeginTimer-ichanUPressEndTimer) )
			{
				traceText = StringTable::Load(IDS::dropUnderPressure5mlFailed);
				StrReplace(traceText, "%s", IStr(index+1));

				traceTextEx = StringTable::Load(IDS::measuredLeakage);
				StrReplace(traceTextEx, "%s", IStr(ichanUPressBeginTimer-ichanUPressEndTimer));

				Trace(traceText, traceTextEx);

				tightnessCheckChannel5mlState = PS::failed;
				MERR::tightnessCheckChannel5mlError.SetAt(index, StringTable::Load(IDS::checkFailed));
			}
		}

		// if nothing has failed the overall state is successful, until now it was open
		if ( PS::failed != tightnessCheckChannel5mlState )
		{
			tightnessCheckChannel5mlState = PS::successful;
		}

		return;
	} // end TightnessCheck5ml


	//-----------------------------------------------------------------------------------------------------
	function TightnessCheck96TadmHead( device ML_STAR ) void
	//-----------------------------------------------------------------------------------------------------
	{
		variable index;
		variable ichanUPressBeginTimer;
		variable ichanUPressEndTimer;
		variable ichanOPressBeginTimer;
 		variable ichanOPressEndTimer;
      variable checkNegVal(0);
		string traceText;
		string traceTextEx;
      variable failCount(0);



      // check for maintenace tool
      if(!CheckFor96TadmHeadMaintenanceTool( ML_STAR ))
         return;

      // check for correct position of tool
      if(!CheckFor96TadmHeadMaintenanceToolPosition( ML_STAR ))
         return;

		// Check tightness
		StartTightnessCheckFor96TadmHead( ML_STAR );

		// Move plunger drive to 0 position
		FwCommand( "H0PI", "", hslTrue, ML_STAR);

		// loop channels to analyze measurements
		for ( index=0; index < maxNoOfChannel96TadmHead; index++)
		{
         variable chnFail(0);

			// ------------------------------
			// analyze tightness measurements
			//
			ichanOPressBeginTimer	= chanOPressBeginTimer96TadmHead.GetAt(index);
			ichanOPressEndTimer		= chanOPressEndTimer96TadmHead.GetAt(index);
			ichanUPressBeginTimer	= chanUPressBeginTimer96TadmHead.GetAt(index);
			ichanUPressEndTimer		= chanUPressEndTimer96TadmHead.GetAt(index);

			// build over pressure
			if ( ichanOPressBeginTimer < minPressureLimit96TadmHead )
			{
				traceText = StringTable::Load(IDS::buildOverPressure96TadmHeadFailed);
				StrReplace(traceText, "%s", IStr(index+1));

				traceTextEx = StringTable::Load(IDS::reachedPressure);
				StrReplace(traceTextEx, "%s", IStr(ichanOPressBeginTimer));

				Trace(traceText, traceTextEx);

				tightnessCheckChannel96TadmHeadState = PS::failed;
				MERR::tightnessCheckChannel96TadmHeadError.SetAt(index, StringTable::Load(IDS::checkFailed));
            chnFail++;
			}

			// drop over pressure
         // make an ABS value
         checkNegVal = ichanOPressBeginTimer-ichanOPressEndTimer;
         if(checkNegVal < 0)
            checkNegVal = -checkNegVal;
			if ( dropLimit96TadmHead < checkNegVal )
			{
				traceText = StringTable::Load(IDS::dropOverPressure96TadmHeadFailed);
				StrReplace(traceText, "%s", IStr(index+1));

				traceTextEx = StringTable::Load(IDS::measuredLeakage);
				StrReplace(traceTextEx, "%s", IStr(ichanOPressBeginTimer-ichanOPressEndTimer));

				Trace(traceText, traceTextEx);

				tightnessCheckChannel96TadmHeadState = PS::failed;
				MERR::tightnessCheckChannel96TadmHeadError.SetAt(index, StringTable::Load(IDS::checkFailed));
            chnFail++;
			}

			// build under pressure
			if ( ichanUPressBeginTimer > (-minPressureLimit96TadmHead) )
			{
				variable underPressure;
				underPressure = ichanUPressBeginTimer;

				traceText = StringTable::Load(IDS::buildUnderPressure96TadmHeadFailed);
				StrReplace(traceText, "%s", IStr(index+1));

				// the pressure is stored as an absolute value (unsigned)
				underPressure = (0 - ichanUPressBeginTimer);

				traceTextEx = StringTable::Load(IDS::reachedPressure);
				StrReplace(traceTextEx, "%s", IStr(underPressure));

				Trace(traceText, traceTextEx);

				tightnessCheckChannel96TadmHeadState = PS::failed;
				MERR::tightnessCheckChannel96TadmHeadError.SetAt(index, StringTable::Load(IDS::checkFailed));
            chnFail++;
			}

			// drop under pressure
         // make an ABS value
         checkNegVal = ichanUPressBeginTimer-ichanUPressEndTimer;
         if(checkNegVal < 0)
            checkNegVal = -checkNegVal;
			if ( dropLimit96TadmHead < checkNegVal )
			{
				traceText = StringTable::Load(IDS::dropUnderPressure96TadmHeadFailed);
				StrReplace(traceText, "%s", IStr(index+1));

				traceTextEx = StringTable::Load(IDS::measuredLeakage);
				StrReplace(traceTextEx, "%s", IStr(ichanUPressBeginTimer-ichanUPressEndTimer));

				Trace(traceText, traceTextEx);

				tightnessCheckChannel96TadmHeadState = PS::failed;
				MERR::tightnessCheckChannel96TadmHeadError.SetAt(index, StringTable::Load(IDS::checkFailed));
            chnFail++;
			}
         // count failed tighness per channel;
         if(0 < chnFail)
            failCount++;

		}

      // all channel has failed, inform user about correct tool position
      if(failCount == maxNoOfChannel96TadmHead)
      {
         MessageBox( StringTable::Load(IDS::dlg96TadmHeadCheckTool),
                     StringTable::Load(IDS::dlg96TadmHeadTitle),
                     hslOKOnly | hslInformation );
      }

		// if nothing has failed the overall state is successful, until now it was open
		if ( PS::failed != tightnessCheckChannel96TadmHeadState )
		{
			tightnessCheckChannel96TadmHeadState = PS::successful;
		}

		return;
	} // end TightnessCheck96TadmHead


	//-----------------------------------------------------------------------------------------------------
	function CLLDCheckChannel1000ul( device ML_STAR ) void
	//-----------------------------------------------------------------------------------------------------
	{
		variable index;
		variable numberForCheck( instrNumberOfNeedles1000ul );
		string traceText;
		string traceTextEx;

		// loop channels for measurements
		for ( index=0; index<instrNumberOfChannels1000ul; index=index+numberForCheck)
		{
			// determine if number of channels for next check is reduced
			if ( (instrNumberOfChannels1000ul-index) < instrNumberOfNeedles1000ul )
			{
				numberForCheck = (instrNumberOfChannels1000ul-index);
			}

			// Check cLLD
			StartCLLDCheckForChannels1000ul( index, numberForCheck, ML_STAR );
		}

		// Initialize plunger drives
		FwCommand( "PXDI", "", hslTrue, ML_STAR);

		//DumpData(); // for debugging

		// loop channels to analyze measurements
		for ( index=0; index<instrNumberOfChannels1000ul; index++)
		{
			// ------------------------------
			// ananlyze cLLD measurements
			//
			// cLLD air
			if ( hslTrue == chanDetectLevelAir1000ul.GetAt(index) )
			{
				traceText = StringTable::Load(IDS::cLLDcheck1000ulAirFailed);
				StrReplace(traceText, "%s", IStr(index+1));
				Trace(traceText);
				cLLDCheckChannel1000ulState = PS::failed;
				MERR::cLLDCheckChannel1000ulError.SetAt(index, StringTable::Load(IDS::checkFailed));
			}
			// cLLD waste block
			else if ( hslFalse == chanDetectLevelBlock1000ul.GetAt(index) )
			{
				traceText = StringTable::Load(IDS::cLLDcheck1000ulBlockFailed);
				StrReplace(traceText, "%s", IStr(index+1));
				Trace(traceText);
				cLLDCheckChannel1000ulState = PS::failed;
				MERR::cLLDCheckChannel1000ulError.SetAt(index, StringTable::Load(IDS::checkFailed));
			}
		}

		// if nothing has failed the overall state is successful, until now it was open
		if ( PS::failed != cLLDCheckChannel1000ulState )
		{
			cLLDCheckChannel1000ulState = PS::successful;
		}

		return;
	} // end CLLDCheckChannel1000ul


	//-----------------------------------------------------------------------------------------------------
	function CLLDCheckChannel5ml( device ML_STAR ) void
	//-----------------------------------------------------------------------------------------------------
	{
		variable index;
		variable numberForCheck( instrNumberOfNeedles5ml );
		string traceText;
		string traceTextEx;

		// loop channels for measurements
		for ( index=0; index<instrNumberOfChannels5ml; index=index+numberForCheck)
		{
			// determine if number of channels for next check is reduced
			if ( (instrNumberOfChannels5ml-index) < instrNumberOfNeedles5ml )
			{
				numberForCheck = (instrNumberOfChannels5ml-index);
			}

			// Check cLLD
			StartCLLDCheckForChannels5ml( index, numberForCheck, ML_STAR );
		}

		// Initialize plunger drives
		FwCommand( "LXDI", "", hslTrue, ML_STAR);

		//DumpData(); // for debugging

		// loop channels to analyze measurements
		for ( index=0; index<instrNumberOfChannels5ml; index++)
		{
			// ------------------------------
			// ananlyze cLLD measurements
			//
			// cLLD air
			if ( hslTrue == chanDetectLevelAir5ml.GetAt(index) )
			{
				traceText = StringTable::Load(IDS::cLLDcheck5mlAirFailed);
				StrReplace(traceText, "%s", IStr(index+1));
				Trace(traceText);
				cLLDCheckChannel5mlState = PS::failed;
				MERR::cLLDCheckChannel5mlError.SetAt(index, StringTable::Load(IDS::checkFailed));
			}
			// cLLD waste block
			else if ( hslFalse == chanDetectLevelBlock5ml.GetAt(index) )
			{
				traceText = StringTable::Load(IDS::cLLDcheck5mlBlockFailed);
				StrReplace(traceText, "%s", IStr(index+1));
				Trace(traceText);
				cLLDCheckChannel5mlState = PS::failed;
				MERR::cLLDCheckChannel5mlError.SetAt(index, StringTable::Load(IDS::checkFailed));
			}
		}

		// if nothing has failed the overall state is successful, until now it was open
		if ( PS::failed != cLLDCheckChannel5mlState )
		{
			cLLDCheckChannel5mlState = PS::successful;
		}

		return;
	} // end CLLDCheckChannel5ml



	//=====================================================================================================
	// local functions
	//=====================================================================================================

	static function SleepForWash(variable seconds)
	{
		timer WashTimer;
		WashTimer.SetTimer(seconds);
		WashTimer.SetTimerViewName(StringTable::Load(IDS::dlgSleepForWashTime ));
		WashTimer.WaitTimer( hslTrue, hslFalse );
		return;
	}

	//-----------------------------------------------------------------------------------------------------
	static function InitMaintMetLibrary()
	//-----------------------------------------------------------------------------------------------------
	{
		// initializes the Maintenance Methods Library (only once)
		if (!initializedLib)
		{
			StringTable::Init("HslStarLineMaintMetLib");
			//StringTable::Dump();
			initializedLib = hslTrue;
		}
		return(initializedLib);
	}

	//-----------------------------------------------------------------------------------------------------
	static function FwCommand( variable &fwCommand, variable &fwParameter, variable errCheck, device ML_STAR )
	//-----------------------------------------------------------------------------------------------------
	{
		variable arrRetValues[];
		string answer;

		// store verification data
		arrRetValues = ML_STAR._1FB5DA01_3ACB_11d4_AE1F_0004ACB1DCB2( "56ace6c3_272c_4b56_b8e90c6e38cb7e4b" ); // FirmwareCommand
		answer = arrRetValues.GetAt(3);

		// check firmware return value
		if ( hslTrue == errCheck )
		{
			if ( 0 != fwRetOk.Compare(answer.Left(fwRetOkLength)) )
			{
				string errorDesc;
				errorDesc = StringTable::Load(IDE::firmwareCommandFailed);
				StrReplace(errorDesc, "%s1", fwCommand);
				StrReplace(errorDesc, "%s2", fwParameter);
				StrReplace(errorDesc, "%s3", answer);
			   err.Raise( IDE::firmwareCommandFailed, errorDesc);
			}
		}
		return (answer);

	} // end FwCommand

	//-----------------------------------------------------------------------------------------------------
	static function FirmwareErrorCheck(string& result) // result string from firmware
	//-----------------------------------------------------------------------------------------------------
	{
		variable index;

		// lookup for "er" in the result string
		// (note: not all firmware commands response with an error information in the result string)
		// if there is an error information within the result string it starts on index 0 (zero)
		// e.g. "er00"
		index = result.Find("er");
		if(index == 0)
		{
			string errorNr;

			errorNr = result.Mid(2, 2);

			// trim leading zeros
			errorNr = StrTrimLeft(errorNr, "0");

			// look up for slave error
			if(IVal(errorNr) == C0ErrorCode::slaveError)
			{
				index = result.Find(" ");

            // tb Nano N0 has defined an error code as 99 --> if(index >= 0) inserted

            if(index >= 0)
            {
   				errorNr = result.Mid(index+6, 2);

   				// trim leading zeros
   				errorNr = StrTrimLeft(errorNr, "0");
            }
			}

			if(errorNr.Compare("") != 0)
				return (IVal(errorNr));
		}

		return (0);
	}



	//-----------------------------------------------------------------------------------------------------
	static function ParseFwResult(string &fwResult, string &parameter, variable count) variable
	//-----------------------------------------------------------------------------------------------------
	{
		variable index;
		variable result("");

		index = fwResult.Find(parameter);
		if ( 0 > index )
		{
			// parameter not found, generate error
			string errorDesc;
			errorDesc = StringTable::Load(IDE::parseFirmwareCommandFailed);
			StrReplace(errorDesc, "%s1", fwResult);
			StrReplace(errorDesc, "%s2", parameter);
			err.Raise( IDE::parseFirmwareCommandFailed, errorDesc);
		}

		result = fwResult.Mid(index + parameter.GetLength(), count);

		return( result );
	}


	//-----------------------------------------------------------------------------------------------------
	static function GetTipPatternParam(variable fromChannelIndex, variable countOfChannels, variable totalNoOfChannels) variable
	//-----------------------------------------------------------------------------------------------------
	{
		variable index;
		variable result("");

		for (index=0; index < totalNoOfChannels; index++)
		{
			if (0 != index)
			{
				result = result + " ";
			}

			if ( index >= fromChannelIndex && index < fromChannelIndex+countOfChannels )
			{
				result = result + "1";
			}
			else
			{
				result = result + "0";
			}
		}

		return( result );
	}

	//-----------------------------------------------------------------------------------------------------
	static function UpdateCellInReportFile( file &reportFile, variable column, variable row, string &value)
	//-----------------------------------------------------------------------------------------------------
	{
		row = row - 1;
		reportFile.AddField(column, value, hslString, value.GetLength());
		reportFile.Seek(row - 1 ,hslFirst);
		reportFile.UpdateRecord();
		reportFile.RemoveFields();
	} // end UpdateReportFile

	//-----------------------------------------------------------------------------------------------------
	static function GetProcessedStateAsString()
	//-----------------------------------------------------------------------------------------------------
	{
		string stateText;
		variable state;

		state = MtcLib::GetProcessState();

		if( MPS::mpsSuccessful == state )
			stateText = StringTable::Load(IDS::procStateSuccessful);
		else if ( MPS::mpsFailed == state )
			stateText = StringTable::Load(IDS::procStateFailed);
		else
			stateText = StringTable::Load(IDS::procStateIncomplete);

		return (stateText);

	}// end GetProcessedStateAsString


	//-----------------------------------------------------------------------------------------------------
	static function GetCheckStateAsString( variable &state)
	//-----------------------------------------------------------------------------------------------------
	{
		string stateText("---"); // not installed

		if ( state == PS::successful )
			stateText = StringTable::Load(IDS::checkSuccessful);

		else if ( state == PS::failed )
			stateText = StringTable::Load(IDS::checkFailed);

		else if (state == PS::open )
			stateText = StringTable::Load(IDS::checkNotPerformed);

		return (stateText);

	} // end GetCheckStateAsString

	//-----------------------------------------------------------------------------------------------------
	static function GetInstallationStateAsString( variable &state)
	//-----------------------------------------------------------------------------------------------------
	{
		string text(StringTable::Load(IDS::checkNotInstalled));

		if ( state == 1 )
			text = StringTable::Load(IDS::checkInstalled);

		return (text);
	} //end GetInstallationStateAsString


	//-----------------------------------------------------------------------------------------------------
	static function StartTightnessCheckForChannels1000ul( variable fromChannelIndex, variable noOfChannels, device ML_STAR)
	//-----------------------------------------------------------------------------------------------------
	{
		variable chanMask("");
		variable i;
		string param;

		// determine 1000ul channels mask
		for ( i=0; i<instrNumberOfChannels1000ul; i++ )
		{
			if ( i<fromChannelIndex || i>=fromChannelIndex+noOfChannels)
				chanMask = chanMask + "0";
			else
				chanMask = chanMask + "1";
		}

		// pre-strike with dispense plunger and pick up waste block  needles
		FwCommand( "PXAA", "dp20000", hslTrue, ML_STAR );
		ML_STAR._541143FA_7FA2_11D3_AD85_0004ACB1DCB2( "c8b6aca6_ec4e_4419_ad85340ccdbf58e0" ); // TipPickUp

		// over pressure tightness measurement
		MeassureOverPressure1000ul( fromChannelIndex, noOfChannels, ML_STAR);

		// eject maintenance needles
		// REMARK: reload needles to release pressure
		//         (same condition for tight and leaking channels)
		ML_STAR._541143FC_7FA2_11D3_AD85_0004ACB1DCB2( "dacae1e3_f483_42fe_9c1393e193880c25" ); // TipEject


		// pre-strike with dispense plunger and pick up waste block  needles
		FwCommand( "PXAA", "dp05760", hslTrue, ML_STAR);
		ML_STAR._541143FA_7FA2_11D3_AD85_0004ACB1DCB2( "1f5ce379_6ccf_4fa0_b62e39bf9885818c" ); // TipPickUp

		// under pressure tightness measurement
		MeassureUnderPressure1000ul( fromChannelIndex, noOfChannels, ML_STAR );

		// eject maintenance needles
		ML_STAR._541143FC_7FA2_11D3_AD85_0004ACB1DCB2( "92ddd9cc_c125_4fcb_aecae673b982e4e5" ); // TipEject

		// reset all changed parameters to power on values
		SetPowerOnValuesForAllChannels1000ul(ML_STAR);

	} // end StartTightnessCheckForChannels1000ul


	//-----------------------------------------------------------------------------------------------------
	static function StartTightnessCheckForChannels5ml( variable fromChannelIndex, variable noOfChannels, device ML_STAR)
	//-----------------------------------------------------------------------------------------------------
	{
		variable chanMask("");
		variable i;
		string param;

		// determine 5ml channels mask
		for ( i=0; i<instrNumberOfChannels5ml; i++ )
		{
			if ( i<fromChannelIndex || i>=fromChannelIndex+noOfChannels)
				chanMask = chanMask + "0";
			else
				chanMask = chanMask + "1";
		}

		// pre-strike with dispense plunger and pick up waste block  needles
		FwCommand( "LXAA", "dp090000", hslTrue, ML_STAR );
      ML_STAR._AFA41E7B_21AC_4a24_804E_41716114FEC3( "ee5b8ac3_23a7_4f8a_beb49b1c5546aa74" ); // XLTipPickUp

		// over pressure tightness measurement
		MeassureOverPressure5ml( fromChannelIndex, noOfChannels, ML_STAR);

		// eject maintenance needles
		// REMARK: reload needles to release pressure
		//         (same condition for tight and leaking channels)
      ML_STAR._7F970BA7_528E_4283_807A_325DED0C065A( "e3da3b68_f966_4c6c_968bdc534d92bd93" ); // XLTipEject

		// pre-strike with dispense plunger and pick up waste block  needles
		FwCommand( "LXAA", "dp041800", hslTrue, ML_STAR);

		ML_STAR._AFA41E7B_21AC_4a24_804E_41716114FEC3( "3c547b5f_934b_4e5d_bdef33a590275477" ); // XLTipPickUp

		// under pressure tightness measurement
		MeassureUnderPressure5ml( fromChannelIndex, noOfChannels, ML_STAR );

		// eject maintenance needles
      ML_STAR._7F970BA7_528E_4283_807A_325DED0C065A( "2b529cc2_3ee7_45cb_aaf90247bb3bdbd6" ); // XLTipEject

		// reset all changed parameters to power on values
		SetPowerOnValuesForAllChannels5ml(ML_STAR);

	} // end StartTightnessCheckForChannels5ml


	//-----------------------------------------------------------------------------------------------------
	static function StartTightnessCheckFor96TadmHead( device ML_STAR )
	//-----------------------------------------------------------------------------------------------------
	{
      variable toolsPickedUp(hslFalse);
      onerror goto toError;

      // NOTE: Parameter dq has to be set to 64000, but the current firmware version H0 V5.0S don't work with
		// pre-strike with dispense plunger and pick up waste block  needles
		FwCommand( "H0AA", "dq57000", hslTrue, ML_STAR );
      ML_STAR._BD0D210B_0816_4C86_A903_D6B2DF73F78B( "422740b0_7c41_4e54_99200646c065a98d" ); // Head96TipPickUp
      toolsPickedUp = hslTrue;
      SpezialSqueezeFor96TadmHead(3, ML_STAR);

		// over pressure tightness measurement
		MeassureOverPressure96TadmHead( ML_STAR );

		// eject maintenance needles
		// REMARK: reload needles to release pressure
		//         (same condition for tight and leaking channels)
      ML_STAR._2880E77A_3D6D_40FE_AF57_1BD1FE13960C( "6a8bc295_9404_41c2_8660b8810b8f2e15" ); // Head96TipEject
      toolsPickedUp = hslFalse;

		// pre-strike with dispense plunger and pick up waste block  needles
		FwCommand( "H0AA", "dq21730", hslTrue, ML_STAR);
      ML_STAR._BD0D210B_0816_4C86_A903_D6B2DF73F78B( "6a6627c5_b97a_4b49_bf885017b18881f0" ); // Head96TipPickUp
      toolsPickedUp = hslTrue;
      SpezialSqueezeFor96TadmHead(3, ML_STAR);

		// under pressure tightness measurement
		MeassureUnderPressure96TadmHead( ML_STAR );

		// eject maintenance needles
      ML_STAR._2880E77A_3D6D_40FE_AF57_1BD1FE13960C( "453e4c92_2b26_40b2_b89031c303eae985" ); // Head96TipEject
      toolsPickedUp = hslFalse;

		// reset all changed parameters to power on values
		SetPowerOnValuesFor96TadmHead( ML_STAR );

      return;

      // on error, ask for the nano service carrier position
  	   toError:
   	{
  		   // eject maintenance needles
         if(toolsPickedUp)
            ML_STAR._2880E77A_3D6D_40FE_AF57_1BD1FE13960C( "453e4c92_2b26_40b2_b89031c303eae985" ); // Head96TipEject

   		// reset all changed parameters to power on values
   		SetPowerOnValuesFor96TadmHead( ML_STAR );
      }

	} // end StartTightnessCheckFor96TadmHead


	//-----------------------------------------------------------------------------------------------------
	static function StartCLLDCheckForChannels1000ul( variable fromChannelIndex, variable noOfChannels, device ML_STAR)
	//-----------------------------------------------------------------------------------------------------
	{
		variable chanMask("");
		variable i;
		string param;

		// determine 1000ul channels mask
		for ( i=0; i<instrNumberOfChannels1000ul; i++ )
		{
			if ( i<fromChannelIndex || i>=fromChannelIndex+noOfChannels)
				chanMask = chanMask + "0";
			else
				chanMask = chanMask + "1";
		}

		// pick up maintenance needles
		ML_STAR._541143FA_7FA2_11D3_AD85_0004ACB1DCB2( "0cf4005f_a8e9_4fa5_83709933449dbd35" ); // TipPickUp

		// cLLD detection and analyze
		CLLDCheckForChannels1000ul( fromChannelIndex, noOfChannels, ML_STAR );

		// eject maintenance needles
		ML_STAR._541143FC_7FA2_11D3_AD85_0004ACB1DCB2( "16ab9dfd_d90c_477d_ae4c9db5d3f458db" ); // TipEject

	} // end StartCLLDCheckForChannels1000ul



	//-----------------------------------------------------------------------------------------------------
	static function StartCLLDCheckForChannels5ml( variable fromChannelIndex, variable noOfChannels, device ML_STAR)
	//-----------------------------------------------------------------------------------------------------
	{
		variable chanMask("");
		variable i;
		string param;

		// determine 5ml channels mask
		for ( i=0; i<instrNumberOfChannels5ml; i++ )
		{
			if ( i<fromChannelIndex || i>=fromChannelIndex+noOfChannels)
				chanMask = chanMask + "0";
			else
				chanMask = chanMask + "1";
		}

		// pick up 1000ul maintenance needles  MaintenanceNeedle5ml
		ML_STAR._AFA41E7B_21AC_4a24_804E_41716114FEC3( "d1b89312_05fe_45b6_859a591a797cceea" ); // XLTipPickUp

		// cLLD detection and analyze
		CLLDCheckForChannels5ml( fromChannelIndex, noOfChannels, ML_STAR );

		// eject maintenance needles
		ML_STAR._7F970BA7_528E_4283_807A_325DED0C065A( "b0e6cab9_e38c_46e4_bb5170a8c3f10dac" ); // XLTipEject

	} // end StartCLLDCheckForChannels5ml


	//-----------------------------------------------------------------------------------------------------
	static function GetAbsPressureOfChannel1000ul( variable channelIndex, device ML_STAR )
	//-----------------------------------------------------------------------------------------------------
	{
		variable command;
		string retString;
		string absPressure;

		// get channel preassure values from instrument and return it (as absolute value - unsigned)
		command = FwChannelNode1000ul(channelIndex);
		command = command + "RP";
		retString = FwCommand( command, "", hslFalse, ML_STAR); // request measured pressure
		retString = ParseFwResult(retString, "rp", 5);

		absPressure = retString.Right(retString.GetLength()-1);
		return (IVal(absPressure));
	} // end GetAbsPressureOfChannel1000ul


	//-----------------------------------------------------------------------------------------------------
	static function GetAbsPressureOfChannel5ml( variable channelIndex, device ML_STAR )
	//-----------------------------------------------------------------------------------------------------
	{
		variable command;
		string retString;
		string absPressure;

		// get channel preassure values from instrument and return it (as absolute value - unsigned)
		command = FwChannelNode5ml(channelIndex);
		command = command + "RP";
		retString = FwCommand( command, "", hslFalse, ML_STAR); // request measured pressure
		retString = ParseFwResult(retString, "rp", 6);

		absPressure = retString.Right(retString.GetLength()-1);
		return (IVal(absPressure));
	} // end GetAbsPressureOfChannel5ml


	//-----------------------------------------------------------------------------------------------------
	static function SavePressureChannel1000ul( variable &saveArray[], variable fromChannelIndex, variable noOfChannels, device ML_STAR )
	//-----------------------------------------------------------------------------------------------------
	{
		variable i;

		// get channel preassure values from instrument and save them (as absolute value - unsigned) in 'saveArray'
		for ( i=fromChannelIndex; i<(fromChannelIndex+noOfChannels); i++ )
		{
			saveArray.SetAt(i, GetAbsPressureOfChannel1000ul(i, ML_STAR) );
		}

	} // end SavePressureChannel1000ul


	//-----------------------------------------------------------------------------------------------------
	static function SavePressureChannel5ml( variable &saveArray[], variable fromChannelIndex, variable noOfChannels, device ML_STAR )
	//-----------------------------------------------------------------------------------------------------
	{
		variable i;

		// get channel preassure values from instrument and save them (as absolute value - unsigned) in 'saveArray'
		for ( i=fromChannelIndex; i<(fromChannelIndex+noOfChannels); i++ )
		{
			saveArray.SetAt(i, GetAbsPressureOfChannel5ml(i, ML_STAR) );
		}

	} // end SavePressureChannel5ml


	//-----------------------------------------------------------------------------------------------------
	static function PressureDropWait( variable seconds)
	//-----------------------------------------------------------------------------------------------------
	{
		timer pressureDropTimer;

		// set timer and wait for signal
		if ( 0 == pressureDropTimer.SetTimer(seconds))
		{
			err.Raise( IDE::timerSetError, StringTable::Load(IDE::timerSetError));
		}
		if ( 0 == pressureDropTimer.WaitTimer(hslTrue))
		{
			err.Raise( IDE::timerWaitError, StringTable::Load(IDE::timerWaitError));
		}
		return;

	} // end PressureDropWait


	//-----------------------------------------------------------------------------------------------------
	static function SoakTimeWait( variable seconds)
	//-----------------------------------------------------------------------------------------------------
	{
		timer soakTimer;

		// set timer and wait for signal
		if ( 0 == soakTimer.SetTimer(seconds))
		{
			err.Raise( IDE::timerSetError, StringTable::Load(IDE::timerSetError));
		}
		if ( 0 == soakTimer.WaitTimer(hslTrue))
		{
			err.Raise( IDE::timerWaitError, StringTable::Load(IDE::timerWaitError));
		}
		return;

	} // end SoakTimeWait

	//-----------------------------------------------------------------------------------------------------
	static function PressureBuildWait( variable seconds)
	//-----------------------------------------------------------------------------------------------------
	{
		timer pressureBuildTimer;

		// set timer and wait for signal
		if ( 0 == pressureBuildTimer.SetTimer(seconds))
		{
			err.Raise( IDE::timerSetError, StringTable::Load(IDE::timerSetError));
		}
		if ( 0 == pressureBuildTimer.WaitTimer(hslTrue))
		{
			err.Raise( IDE::timerWaitError, StringTable::Load(IDE::timerWaitError));
		}
		return;

	} // end PressureBuildWait


	//-----------------------------------------------------------------------------------------------------
	static function WashTimerWait( variable seconds)
	//-----------------------------------------------------------------------------------------------------
	{
		timer WaschTimer;

		// set timer and wait for signal
		if ( 0 == WaschTimer.SetTimer(seconds))
		{
			err.Raise( IDE::timerSetError, StringTable::Load(IDE::timerSetError));
		}
		if ( 0 == soakTimer.WaitTimer(hslTrue))
		{
			err.Raise( IDE::timerWaitError, StringTable::Load(IDE::timerWaitError));
		}
		return;

	} // end SoakTimeWait



	//-----------------------------------------------------------------------------------------------------
	static function MeassureOverPressure1000ul( variable fromChannelIndex, variable noOfChannels, device ML_STAR)
	//-----------------------------------------------------------------------------------------------------
	{
		// adjust sensor for overpressure measurement
		FwCommand( "PXBP", "bp0", hslTrue, ML_STAR);

		// increase pressure
		{
 			variable i, k;
			variable actPressure;
			string command;
			string param;
			// loop channels
			for ( i=fromChannelIndex; i<(fromChannelIndex+noOfChannels); i++ )
			{
				 // preposition of dispenser drive
				command = FwChannelNode1000ul(i);
				command = command + "DS";
				param = "ds01250dt1";
				FwCommand( command, param, hslTrue, ML_STAR);
				// fine tuning of dispenser drive
				for ( k=0; k<maxPressureIncrease1000ul; k++)
				{
					// get pressure of channel
					actPressure = GetAbsPressureOfChannel1000ul(i, ML_STAR);

					// check if target pressure reached
					if ( actPressure >= targetPressure1000ul )
					{
						break;
					}

					// move dispenser drive
					param = "ds00050dt1";
					FwCommand( command, param, hslTrue, ML_STAR);
				}
			}
		}

		// wait for 2 seconds before get the current over pressure values
		PressureBuildWait(2);

		// save values after increase pressure
		SavePressureChannel1000ul( chanOPressBeginTimer1000ul, fromChannelIndex, noOfChannels, ML_STAR );

		// wait for 20 seconds
		PressureDropWait(20);

		// save values after timeout
		SavePressureChannel1000ul( chanOPressEndTimer1000ul, fromChannelIndex, noOfChannels, ML_STAR );

	} // end MeassureOverPressure1000ul


	//-----------------------------------------------------------------------------------------------------
	static function MeassureOverPressure5ml( variable fromChannelIndex, variable noOfChannels, device ML_STAR)
	//-----------------------------------------------------------------------------------------------------
	{
		// adjust sensor for overpressure measurement
		FwCommand( "LXBP", "bp0", hslTrue, ML_STAR);

		// increase pressure
		{
 			variable i, k;
			variable actPressure;
			string command;
			string param;
			// loop channels
			for ( i=fromChannelIndex; i<(fromChannelIndex+noOfChannels); i++ )
			{
				 // preposition of dispenser drive
				command = FwChannelNode5ml(i);
				command = command + "DS";
				param = "ds012000dt1";
				FwCommand( command, param, hslTrue, ML_STAR);
				// fine tuning of dispenser drive
				for ( k=0; k<maxPressureIncrease5ml; k++)
				{
					// get pressure of channel
					actPressure = GetAbsPressureOfChannel5ml(i, ML_STAR);

					// check if target pressure reached
					if ( actPressure >= targetPressure5ml )
					{
						break;
					}

					// move dispenser drive
					param = "ds000200dt1";
					FwCommand( command, param, hslTrue, ML_STAR);
				}
			}
		}

		// wait before get the current over pressure values
		PressureBuildWait(2);

		// save values after increase pressure
		SavePressureChannel5ml( chanOPressBeginTimer5ml, fromChannelIndex, noOfChannels, ML_STAR );

		// wait for 20 seconds
		PressureDropWait(20);

		// save values after timeout
		SavePressureChannel5ml( chanOPressEndTimer5ml, fromChannelIndex, noOfChannels, ML_STAR );

	} // end MeassureOverPressure5ml


	//-----------------------------------------------------------------------------------------------------
	static function MeassureUnderPressure1000ul( variable fromChannelIndex, variable noOfChannels, device ML_STAR)
	//-----------------------------------------------------------------------------------------------------
	{
		variable i, k;
		variable actPressure;
		string command;
		string param;

		// adjust sensor for underpressure measurement
		FwCommand( "PXBP", "bp1", hslTrue, ML_STAR);

		// loop channels
		for ( i=fromChannelIndex; i<(fromChannelIndex+noOfChannels); i++ )
		{
			 // preposition of dispenser drive
			command = FwChannelNode1000ul(i);
			command = command + "DS";
			param = "ds00800dt0";
			FwCommand( command, param, hslTrue, ML_STAR);
			// fine tuning of dispenser drive
			for ( k=0; k<maxPressureIncrease1000ul; k++)
			{
				// get pressure of channel
				actPressure = GetAbsPressureOfChannel1000ul(i, ML_STAR);

				// check if target pressure reached
				if ( actPressure >= targetPressure1000ul )
				{
					break;
				}

				// move dispenser drive
				param = "ds00020dt0";
				FwCommand( command, param, hslTrue, ML_STAR);
			}
		}

		// wait for 2 seconds before get the current under pressure values
		PressureBuildWait(2);

		// save values after decrease pressure
		SavePressureChannel1000ul( chanUPressBeginTimer1000ul, fromChannelIndex, noOfChannels, ML_STAR );

		// wait for 20 seconds
		PressureDropWait(20);

		// save values after timeout
		SavePressureChannel1000ul( chanUPressEndTimer1000ul, fromChannelIndex, noOfChannels, ML_STAR );

	} // end MeassureUnderPressure1000ul


	//-----------------------------------------------------------------------------------------------------
	static function MeassureUnderPressure5ml( variable fromChannelIndex, variable noOfChannels, device ML_STAR)
	//-----------------------------------------------------------------------------------------------------
	{
		variable i, k;
		variable actPressure;
		string command;
		string param;

		// adjust sensor for underpressure measurement
		FwCommand( "LXBP", "bp1", hslTrue, ML_STAR);

		// loop channels
		for ( i=fromChannelIndex; i<(fromChannelIndex+noOfChannels); i++ )
		{
			 // preposition of dispenser drive
			command = FwChannelNode5ml(i);
			command = command + "DS";
			param = "ds010000dt0";
			FwCommand( command, param, hslTrue, ML_STAR);
			// fine tuning of dispenser drive
			for ( k=0; k<maxPressureIncrease5ml; k++)
			{
				// get pressure of channel
				actPressure = GetAbsPressureOfChannel5ml(i, ML_STAR);

				// check if target pressure reached
				if ( actPressure >= targetPressure5ml )
				{
					break;
				}

				// move dispenser drive
				param = "ds000200dt0";
				FwCommand( command, param, hslTrue, ML_STAR);
			}
		}

		// wait before get the current under pressure values
		PressureBuildWait(2);

		// save values after decrease pressure
		SavePressureChannel5ml( chanUPressBeginTimer5ml, fromChannelIndex, noOfChannels, ML_STAR );

		// wait for 20 seconds
		PressureDropWait(20);

		// save values after timeout
		SavePressureChannel5ml( chanUPressEndTimer5ml, fromChannelIndex, noOfChannels, ML_STAR );

	} // end MeassureUnderPressure5ml



	//-----------------------------------------------------------------------------------------------------
	static function CLLDCheckForChannels1000ul( variable fromChannelIndex, variable noOfChannels, device ML_STAR)
	//-----------------------------------------------------------------------------------------------------
	{
		variable i;
		string node;
		string command;
		string param;
		string status;

		// switch on cLLD measurement
		FwCommand( "PXAL", "al1lc0", hslTrue, ML_STAR);

		// loop channels
		for ( i=fromChannelIndex; i<(fromChannelIndex+noOfChannels); i++ )
		{
			// Position the current channel to the check position
			// the other channels are controlled/moved by the FW if C0JM is used.
			string forAllParamSuffix("&");
			if ( 1 >= instrNumberOfChannels1000ul )
			{
				// 2009-10-21/cjoerg: In case of ONE installed channel the '&' is not allowed to be added - otherwise we
				// get a syntax error from the FW.
				forAllParamSuffix = "";
			}
			command = "C0JM";
			param = "tm";
			param = param + GetTipPatternParam(i, 1, instrNumberOfChannels1000ul);
			param = param + "xp";
			param = param + checkPosX + forAllParamSuffix;
			param = param + "yp";
			param = param + checkPosY + forAllParamSuffix;
			param = param + "th";
			param = param + traverseHeightForFwCommand;
			param = param + "zp";
			param = param + traverseHeightForFwCommand + forAllParamSuffix;
			FwCommand( command, param, hslTrue, ML_STAR);

			// cLLD measurement is done by using slave commands (LX)
			node = FwChannelNode1000ul(i);

			// ***************************
			// cLLD measurement in the air
			command = node + "ZL";
			param = "zh";
			param = param + zhParamChannel1000ulAir;
			param = param + "zc";
			param = param + zcParamChannel1000ulAir;
			param = param + "zi0000zj1";
			FwCommand( command, param, hslFalse, ML_STAR);

			// cLLD request (air measurement)
			command = node + "RN";
			status = ParseFwResult(FwCommand(command,"",hslFalse, ML_STAR), "rn", 1);
			chanDetectLevelAir1000ul.SetAt(i, 0 == status.Compare("1") );

			// *********************************
			// cLLD detection on the waste block
			command = node + "ZL";
			param = "zh";
			param = param + zhParamChannel1000ulBlock;
			param = param + "zc";
			param = param + zcParamChannel1000ulBlock;
			param = param + "zi0020zj1zv04500zl00100";
			FwCommand( command, param, hslFalse, ML_STAR);

			// cLLD request (waste block measurement)
			command = node + "RN";
			status = ParseFwResult(FwCommand(command,"",hslFalse, ML_STAR), "rn", 1);
			chanDetectLevelBlock1000ul.SetAt(i, 0 == status.Compare("1") );

			// move Z to collision free position
			command = "C0KZ";
			param = "pn";
			param = param + StrFillLeft(IStr(i+1), "0", 2);
			param = param + "zj";
			param = param + traverseHeightForFwCommand;
			FwCommand( command, param, hslTrue, ML_STAR);

		} // end loop channels

		// switch off cLLD measurement
		FwCommand( "PXAL", "al0", hslTrue, ML_STAR);

		// reset all changed parameters to power on values
		SetPowerOnValuesForAllChannels1000ul(ML_STAR);

	} // end CLLDCheckForChannels1000ul



	//-----------------------------------------------------------------------------------------------------
	static function CLLDCheckForChannels5ml( variable fromChannelIndex, variable noOfChannels, device ML_STAR)
	//-----------------------------------------------------------------------------------------------------
	{
		variable i;
		string node;
		string command;
		string param;
		string status;

		// switch on cLLD measurement
		FwCommand( "LXAL", "al1lc0", hslTrue, ML_STAR);

		// loop channels
		for ( i=fromChannelIndex; i<(fromChannelIndex+noOfChannels); i++ )
		{
			// Position the current channel to the check position
			// the other channels are controlled/moved by the FW if C0LL is used.
			string forAllParamSuffix("&");
			if ( 1 >= instrNumberOfChannels5ml )
			{
				// 2009-10-21/cjoerg: In case of ONE installed channel the '&' is not allowed to be added - otherwise we
				// get a syntax error from the FW.
				forAllParamSuffix = "";
			}
			command = "C0LL";
			param = "tr";
			param = param + GetTipPatternParam(i, 1, instrNumberOfChannels5ml);
			param = param + "xb";
			param = param + checkPosX + forAllParamSuffix;
			param = param + "yf";
			param = param + checkPosY + forAllParamSuffix;
			param = param + "th";
			param = param + traverseHeightForFwCommand;
			param = param + "pz";
			param = param + traverseHeightForFwCommand + forAllParamSuffix;
			FwCommand( command, param, hslTrue, ML_STAR);

			// cLLD measurement is done by using slave commands (LX)
			node = FwChannelNode5ml(i);

			// ***************************
			// cLLD measurement in the air
			command = node + "ZL";
			param = "zh";
			param = param + zhParamChannel5mlAir;
			param = param + "zc";
			param = param + zcParamChannel5mlAir;
			param = param + "zi0000zj1";
			FwCommand( command, param, hslFalse, ML_STAR);

			// cLLD request (air measurement)
			command = node + "RN";
			status = ParseFwResult(FwCommand(command,"",hslFalse, ML_STAR), "rn", 1);
			chanDetectLevelAir5ml.SetAt(i, 0 == status.Compare("1") );

			// *********************************
			// cLLD detection on the waste block
			command = node + "ZL";
			param = "zh";
			param = param + zhParamChannel5mlBlock;
			param = param + "zc";
			param = param + zcParamChannel5mlBlock;
			param = param + "zi0020zj1zv04500zl00100";
			FwCommand( command, param, hslFalse, ML_STAR);

			// cLLD request (waste block measurement)
			command = node + "RN";
			status = ParseFwResult(FwCommand(command,"",hslFalse, ML_STAR), "rn", 1);
			chanDetectLevelBlock5ml.SetAt(i, 0 == status.Compare("1") );

			// move Z to collision free position
			command = "C0LJ";
			param = "pm";
			param = param + IStr(i+1);
			param = param + "zj";
			param = param + traverseHeightForFwCommand;
			FwCommand( command, param, hslTrue, ML_STAR);

		} // end loop channels

		// switch off cLLD measurement
		FwCommand( "LXAL", "al0", hslTrue, ML_STAR);

		// reset all changed parameters to power on values
		SetPowerOnValuesForAllChannels5ml(ML_STAR);

	} // end CLLDCheckForChannels5ml


	//-----------------------------------------------------------------------------------------------------
	static function SpezialSqueezeFor96TadmHead( variable loopCount, device ML_STAR)
	//-----------------------------------------------------------------------------------------------------
	{
      // spezial squeezing
      // move down to container bottom
      ML_STAR._700BFFB5_1B7F_4b9d_85D9_08ED3AAF7E46( "9b844107_34b9_48ac_a36633525cae7b28" ); // Head96Move
      loop ( loopCount )
      {
         // open / close squeezer drive
         ML_STAR._1FB5DA01_3ACB_11d4_AE1F_0004ACB1DCB2( "7caa10c1_94c7_4526_927fdc489b4c59d7" ); // FirmwareCommand
         ML_STAR._1FB5DA01_3ACB_11d4_AE1F_0004ACB1DCB2( "fdc375a0_c3d2_45ae_96a73fe61288cfe5" ); // FirmwareCommand
      }
      // move up to traverse height
      ML_STAR._700BFFB5_1B7F_4b9d_85D9_08ED3AAF7E46( "efc35729_282d_4b71_98f53528f735c508" ); // Head96Move
   }

	//-----------------------------------------------------------------------------------------------------
	static function MeassureOverPressure96TadmHead( device ML_STAR)
	//-----------------------------------------------------------------------------------------------------
	{
		variable k;
		variable actPressure(0);
		string param;

   	// adjust sensor for overpressure measurement
		FwCommand( "H0BP", "", hslTrue, ML_STAR);


		// fine tuning of dispenser drive
		param = "ds00500dt1";
		for ( k=0; k < maxPressureIncrease96TadmHead; k++)
		{
			// move dispenser drive
			FwCommand( "H0DS", param, hslTrue, ML_STAR);

			// get pressure overage over all channels
			actPressure = Get96TadmHeadPressureOverage(1, ML_STAR);

			// check if target pressure reached
			if ( actPressure >= targetPressure96TadmHead )
			{
				break;
			}

		}

		// wait before get the current over pressure values
		PressureBuildWait(2);

		// save values after increase pressure
      Get96TadmHeadChannelPressure( chanOPressBeginTimer96TadmHead, ML_STAR );

		// wait for 40 seconds
		PressureDropWait(40);

		// save values after timeout
		Get96TadmHeadChannelPressure( chanOPressEndTimer96TadmHead, ML_STAR );

	} // end MeassureOverPressure96TadmHead

	//-----------------------------------------------------------------------------------------------------
	static function MeassureUnderPressure96TadmHead( device ML_STAR)
	//-----------------------------------------------------------------------------------------------------
	{
		variable k;
		variable actPressure;
		string param;

		// adjust sensor for underpressure measurement
		FwCommand( "H0BP", "", hslTrue, ML_STAR);

		 // preposition of dispenser drive
		param = "ds00500dt0";
		// fine tuning of dispenser drive
		for ( k=0; k < maxPressureIncrease96TadmHead; k++)
		{
			// move dispenser drive
   		FwCommand( "H0DS", param, hslTrue, ML_STAR);

			// get pressure of channel
			actPressure = Get96TadmHeadPressureOverage(0, ML_STAR);

			// check if target pressure reached
			if ( actPressure <= (-targetPressure96TadmHead) )
			{
				break;
			}

		}

		// wait before get the current under pressure values
		PressureBuildWait(2);

		// save values after decrease pressure
		Get96TadmHeadChannelPressure( chanUPressBeginTimer96TadmHead, ML_STAR );

		// wait for 40 seconds
		PressureDropWait(40);

		// save values after timeout
		Get96TadmHeadChannelPressure( chanUPressEndTimer96TadmHead, ML_STAR );

	} // end MeassureUnderPressure96TadmHead

   //-----------------------------------------------------------------------------------------------------
   static function Get96TadmHeadPressureOverage(variable positive, device ML_STAR ) variable
   //-----------------------------------------------------------------------------------------------------
   {
		variable chn;
      variable chnPressure[];
      variable totalPressure(0);

      for(chn = 0 ; chn < maxNoOfChannel96TadmHead; chn++)
		{
   		chnPressure.AddAsLast(0);
		}

      Get96TadmHeadChannelPressure(chnPressure, ML_STAR);

      for(chn = 0 ; chn < maxNoOfChannel96TadmHead; chn++)
      {
         totalPressure = totalPressure + ABS(chnPressure.GetAt(chn));
      }
      if(positive == 0)
         totalPressure = -totalPressure;

      // return only the integer value after division
      return ( IVal( IStr( totalPressure / maxNoOfChannel96TadmHead )) );
   }

   //-----------------------------------------------------------------------------------------------------
   static function Get96TadmHeadChannelPressure(variable chnPressure[], device ML_STAR )
   //-----------------------------------------------------------------------------------------------------
   {
		variable chn;
		string retString;
		string retString2;
      variable param("ch01cn48");
      variable start(0);


		// get first packet of channel preassure values from instrument 
		retString = FwCommand( "H0QF", param, hslFalse, ML_STAR); // request measured pressure
		retString = ParseFwResult(retString, "qf", 335); // 48 * (5 digit + ± + space) -1
      // get second packet of channel preassure values from instrument 
      param = "ch49cn48";
		retString2 = FwCommand( "H0QF", param, hslFalse, ML_STAR); // request measured pressure
		retString2 = ParseFwResult(retString2, "qf", 335); // 48 * (5 digit + ± + space) -1

      retString = retString + " ";
      retString = retString + retString2;

      for(chn = 0; chn < maxNoOfChannel96TadmHead; chn++)
      {
         chnPressure[chn] = IVal(StrMid(retString, start, 6));
         start = start + 7;
      }

   }

   //-----------------------------------------------------------------------------------------------------
   static function CheckFor96TadmHeadMaintenanceTool(device ML_STAR)
   //-----------------------------------------------------------------------------------------------------
	{
  		//*******************************************************************************************
  		// Check if exist the CO-RE 96 TADM Head maintenace tool
		//*******************************************************************************************
		variable templNames[];					// array contains all template names
		variable labwNames[];					// array contains all labware names
      variable toolFound(hslFalse);

      onerror goto toError;

      if(ML_STAR.GetTemplateLabwareNames(templNames, labwNames))
      {
         variable index(0);
   		variable propertyKey[];					// array contains the nano service carrier property
   		variable propertyVal[];					// array returns the value of the key

         propertyKey.SetSize(0);
         propertyKey.AddAsLast("IsCore96TadmHeadMaintenanceTool");

         // search for the given properties
         for (index = 0; index < labwNames.GetSize(); index++)
         {
            if(ML_STAR.GetLabwareData(labwNames.GetAt(index), propertyKey, propertyVal))
            {
               // check for value of property IsCore96TadmHeadMaintenanceTool
               if(propertyVal.GetAt(0) == "1")
               {
                  variable toolPos[];
                  variable toolPickUpLabwName;
                  variable toolEjectLabwName;

                  // remember labware name fot move the labware during TipEject
                  toolPickUpLabwName = labwNames.GetAt(index);
                  toolEjectLabwName = StrMid(toolPickUpLabwName, 0, StrGetLength(toolPickUpLabwName)-4);
                  toolEjectLabwName = toolEjectLabwName + "Eject";

                  // set x, y and z position of C=-RE 96 TADM Head maintenance tool
                  if(ML_STAR.GetLabwarePosition(toolPickUpLabwName, toolPos))
                  {
                     object deckLay;
                     object labware;
                     object editLabware;

                     // set x, y and z position of CO-RE 96 TADM Head maintenance tool
                     CoRe96TadmHeadToolX = toolPos[0];
                     CoRe96TadmHeadToolY = toolPos[1];

                     // create sequence to pick up the maintenance tool
                     deckLay = ML_STAR.GetDeckLayoutObject();
                     if(!deckLay.IsNull())
                     {
                        labware = deckLay.Labware(toolPickUpLabwName);
                        if(!labware.IsNull())
                        {
               				labware.GetObject("IEditLabware6", editLabware);
               				if ( !editLabware.IsNull() )
               				{
                              if(editLabware.DefaultSequenceValid())
                              {
                                 object defSeq;
                                 variable i(0);
                                 variable count(0);
                                 variable labwPath;
                                 variable zPos(0.0);

                                 editLabware.DefaultSequence(defSeq);
                                 count = defSeq.Count;
                        			for (i = 1; i <= count; i++)
                        			{
                        				object seqItem;
                        				seqItem = defSeq.Item(i);
                        				CoRe96TadmHeadToolSeq.Add(seqItem.ObjectId, seqItem.PositionId);
                        			}
                        			CoRe96TadmHeadToolSeq.SetCount(CoRe96TadmHeadToolSeq.GetTotal());
                        			CoRe96TadmHeadToolSeq.SetMax(CoRe96TadmHeadToolSeq.GetTotal());
                        			CoRe96TadmHeadToolSeq.SetCurrentPosition(1);

                                 // remember path of current labware to add a new one for tip eject
                                 labwPath = editLabware.FileName();
                                 zPos = toolPos[2];
                                 zPos = zPos - 4.0;
                                 toolPos[2] = zPos;
                                 ML_STAR.AddLabware(toolEjectLabwName, labwPath, toolPos);

                                 // set flag to found the tool and needed sequence
                               //  toolFound = hslTrue;
                              }
                              editLabware.ReleaseObject();
                           }
                           labware.ReleaseObject();
                        }
                        labware = deckLay.Labware(toolEjectLabwName);
                        if(!labware.IsNull())
                        {
               				labware.GetObject("IEditLabware6", editLabware);
               				if ( !editLabware.IsNull() )
               				{
                              if(editLabware.DefaultSequenceValid())
                              {
                                 object defSeq;
                                 variable i(0);
                                 variable count(0);

                                 editLabware.DefaultSequence(defSeq);
                                 count = defSeq.Count;
                        			for (i = 1; i <= count; i++)
                        			{
                        				object seqItem;
                        				seqItem = defSeq.Item(i);
                        				CoRe96TadmHeadToolEjectSeq.Add(seqItem.ObjectId, seqItem.PositionId);
                        			}
                        			CoRe96TadmHeadToolEjectSeq.SetCount(CoRe96TadmHeadToolEjectSeq.GetTotal());
                        			CoRe96TadmHeadToolEjectSeq.SetMax(CoRe96TadmHeadToolEjectSeq.GetTotal());
                        			CoRe96TadmHeadToolEjectSeq.SetCurrentPosition(1);

                                 // set flag to found the tool and needed sequence
                                 toolFound = hslTrue;
                              }
                              editLabware.ReleaseObject();
                           }
                           labware.ReleaseObject();
                        }
                        deckLay.ReleaseObject();
                     }
                  }
               }
            }
         }
      }

      // on error, ask for the nano service carrier position
  	   toError:
   	{
      }
      onerror goto 0;

      if(!toolFound)
      {
			// Enter the correct X-position!
      	MessageBox(StringTable::Load(IDS::dlg96TadmHeadCarrierMissing),
                     StringTable::Load(IDS::dlg96TadmHeadTitle), hslOKOnly | hslError);
      }

      return (toolFound);
   }


   //-----------------------------------------------------------------------------------------------------
   static function CheckFor96TadmHeadMaintenanceToolPosition(device ML_STAR)
   //-----------------------------------------------------------------------------------------------------
	{
  		//*******************************************************************************************
  		// Check if exist the CO-RE 96 TADM Head maintenace tool
		//*******************************************************************************************
		variable templNames[];					// array contains all template names
		variable labwNames[];					// array contains all labware names
      variable toolFound(hslFalse);
      variable param("xs00000xd0yh0000za2450zh2450");
      variable x, y;
      string xPos("xs");
      string yPos("yh");
      variable answer;
      variable errCode(0);
      variable boxAnswer(hslNo);

      onerror goto toError;

      x = CoRe96TadmHeadToolX * 10;
      y = CoRe96TadmHeadToolY * 10;

      if(x < 0)
      {
         StrReplace(param, "xd0", "xd1");
         // make positive value
         x = -x;
      }

      // set x and y position
		xPos = xPos + StrFillLeft(IStr(Floor(x)), "0", 5);
		yPos = yPos + StrFillLeft(IStr(Floor(y)), "0", 4);
      StrReplace(param, "xs00000", xPos);
      StrReplace(param, "yh0000", yPos);

   	answer = FwCommand( "C0EM", param, hslFalse, ML_STAR);
		errCode = FirmwareErrorCheck(answer);
		if(errCode != 0)
		{
         string traceMsg;
		   // Error CO-RE 96 TADM Head cannot move to maintenance tool!
   	 	traceMsg = StringTable::Load(IDS::err96TadmHeadCannotMoveToTool);

			Trace(traceMsg);
      }

      if(errCode == 0)
      {
         boxAnswer =	MessageBox( StringTable::Load(IDS::dlg96TadmHeadCarrierPosition),
                                 StringTable::Load(IDS::dlg96TadmHeadTitle),
                                 hslYesNo | hslQuestion | hslDefButton2 );
      }

      // on error, ask for the nano service carrier position
  	   toError:
   	{
      }
      onerror goto 0;


      return (boxAnswer == hslYes);
   }



	//-----------------------------------------------------------------------------------------------------
	static function FwChannelNode1000ul( variable channelIndex)
	//-----------------------------------------------------------------------------------------------------
	{
		if 	  ( channelIndex == 0 )  return ("P1");
		else if ( channelIndex == 1  ) return ("P2");
		else if ( channelIndex == 2  ) return ("P3");
		else if ( channelIndex == 3  ) return ("P4");
		else if ( channelIndex == 4  ) return ("P5");
		else if ( channelIndex == 5  ) return ("P6");
		else if ( channelIndex == 6  ) return ("P7");
		else if ( channelIndex == 7  ) return ("P8");
		else if ( channelIndex == 8  ) return ("P9");
		else if ( channelIndex == 9  ) return ("PA");
		else if ( channelIndex == 10 ) return ("PB");
		else if ( channelIndex == 11 ) return ("PC");
		else if ( channelIndex == 12 ) return ("PD");
		else if ( channelIndex == 13 ) return ("PE");
		else if ( channelIndex == 14 ) return ("PF");
		else if ( channelIndex == 15 ) return ("PG");
		else err.Raise( IDE::unknownChannel, StringTable::Load(IDE::unknownChannel));
	} // end FwChannelNode1000ul

	//-----------------------------------------------------------------------------------------------------
	static function FwChannelNode5ml( variable channelIndex)
	//-----------------------------------------------------------------------------------------------------
	{
		if 	  ( channelIndex == 0 )  return ("L1");
		else if ( channelIndex == 1  ) return ("L2");
		else if ( channelIndex == 2  ) return ("L3");
		else if ( channelIndex == 3  ) return ("L4");
		else if ( channelIndex == 4  ) return ("L5");
		else if ( channelIndex == 5  ) return ("L6");
		else if ( channelIndex == 6  ) return ("L7");
		else if ( channelIndex == 7  ) return ("L8");
		else err.Raise( IDE::unknownChannel, StringTable::Load(IDE::unknownChannel));
	} // end FwChannelNode5ml


	//-----------------------------------------------------------------------------------------------------
	static function DumpData()
	//-----------------------------------------------------------------------------------------------------
	{
		variable i;
		variable ichanNeedleIndex;

		variable ichanUPressBeginTimer;
		variable ichanUPressEndTimer;
		variable ichanOPressBeginTimer;
		variable ichanOPressEndTimer;

		variable ichanDetectLevelAir;
		variable ichanDetectLevelBlock;

		Trace( "<<<< BEGIN DUMP MAINTENANCE DATA >>>>");
		Trace( "instrNumberOfChannels1000ul = ", instrNumberOfChannels1000ul );
		Trace( "waste block check position X = ", checkPosX, ", Y = ", checkPosY, ", Z = ", checkPosZ);
		Trace( "common 1000ul channel data:");
		Trace( "tightness check data:");
		for (	i=0; i<instrNumberOfChannels1000ul; i++ )
		{
			ichanUPressBeginTimer	= chanUPressBeginTimer1000ul.GetAt(i);
			ichanUPressEndTimer		= chanUPressEndTimer1000ul.GetAt(i);
			ichanOPressBeginTimer	= chanOPressBeginTimer1000ul.GetAt(i);
			ichanOPressEndTimer		= chanOPressEndTimer1000ul.GetAt(i);
			Trace(" -> channel=", i+1, ", UnderPressBegin = ", ichanUPressBeginTimer, ", UnderPressEnd = ", ichanUPressEndTimer, ", UnderPressDrop = ", (ichanUPressBeginTimer-ichanUPressEndTimer), ", OverPressBegin = ", ichanOPressBeginTimer, ", OverPressEnd = ", ichanOPressEndTimer, ", OverPressDrop = ", (ichanOPressBeginTimer-ichanOPressEndTimer));
		}

		Trace( "cLLD check data:");
		for (	i=0; i<instrNumberOfChannels1000ul; i++ )
		{
			ichanDetectLevelAir		= chanDetectLevelAir1000ul.GetAt(i);
			ichanDetectLevelBlock	= chanDetectLevelBlock1000ul.GetAt(i);
			Trace(" -> channel=", i+1, ", chanDetectLevelAir = ", ichanDetectLevelAir, ", ichanDetectLevelBlock = ", ichanDetectLevelBlock);
		}

		Trace( "<<<< BEGIN DUMP MAINTENANCE DATA >>>>");
		Trace( "instrNumberOfChannels5ml = ", instrNumberOfChannels5ml );
		Trace( "common 5ml channel data:");
		Trace( "tightness check data:");
		for (	i=0; i<instrNumberOfChannels5ml; i++ )
		{
			ichanUPressBeginTimer	= chanUPressBeginTimer5ml.GetAt(i);
			ichanUPressEndTimer		= chanUPressEndTimer5ml.GetAt(i);
			ichanOPressBeginTimer	= chanOPressBeginTimer5ml.GetAt(i);
			ichanOPressEndTimer		= chanOPressEndTimer5ml.GetAt(i);
			Trace(" -> channel=", i+1, ", UnderPressBegin = ", ichanUPressBeginTimer, ", UnderPressEnd = ", ichanUPressEndTimer, ", UnderPressDrop = ", (ichanUPressBeginTimer-ichanUPressEndTimer), ", OverPressBegin = ", ichanOPressBeginTimer, ", OverPressEnd = ", ichanOPressEndTimer, ", OverPressDrop = ", (ichanOPressBeginTimer-ichanOPressEndTimer));
		}

		Trace( "cLLD check data:");
		for (	i=0; i<instrNumberOfChannels5ml; i++ )
		{
			ichanDetectLevelAir		= chanDetectLevelAir5ml.GetAt(i);
			ichanDetectLevelBlock	= chanDetectLevelBlock5ml.GetAt(i);
			Trace(" -> channel=", i+1, ", chanDetectLevelAir = ", ichanDetectLevelAir, ", ichanDetectLevelBlock = ", ichanDetectLevelBlock);
		}

		Trace( "<<<< END DUMP MAINTENANCE DATA >>>>");

	} // end DumpData


	//*****************************************************************************************************
	//-----------------------------------------------------------------------------------------------------
	function nanoPipettorMaintenance( device ML_STAR, variable processID )  // Find_nanoPipettorMaintenance
	//-----------------------------------------------------------------------------------------------------
	//*****************************************************************************************************
	{
		string traceText;
		string TempStr;
		variable bRepeat;
		variable errCode;
		string TitleNanopipettor;
		string traceSource;
		string traceAction;
		variable tracestatus;
		string tracesargument;
		variable maintenanceExecuted(hslFalse);
		variable NanoPipettorType;
		variable CO2PresMax;
		variable CO2PresMin;
		variable Channel_8_Head;
		variable Channel_N_Head;
      variable CO2PresDefaultStr;


		// initialize library (if necessary)
		InitMaintMetLibrary();

	  	// Type of installed Nano pipettor (32)
		// 0 Not installed
		// 1 Multi channel
		// 3 Multi and additional channel
		NanoPipettorType = ML_STAR.GetCfgValueWithKey(MtConst::starCfgNanoPipettorKey);


		// set check state to failed
		nanoPipettorCheckState = PS::failed;

      // load Title
		if (processID == PID::dailyMorningMaintNano)
			TitleNanopipettor = StringTable::Load(IDS::dlgCheckNanoPipettorTitleMorning);
		if (processID == PID::startUpMaintNano)
			TitleNanopipettor = StringTable::Load(IDS::dlgCheckNanoPipettorTitleStartUp);
		if (processID == PID::decontaminationMaintNano)
			TitleNanopipettor = StringTable::Load(IDS::dlgCheckNanoPipettorTitleDecontamination);


      // set trace data
		traceSource    = StringTable::Load(IDS::dlgNanoTraceSystem);
		traceAction    = TitleNanopipettor;
		tracestatus    = TraceStatus::start;
		tracesargument = "";
		FormatTrace(traceSource, traceAction, tracestatus, tracesargument);



		//*******************************************************************************************
		//	Start: Please open	the valves of He and	CO2 supply"
		//*******************************************************************************************
		traceSource		= StringTable::Load(IDS::dlgNanoTraceUser);
		traceAction		= TitleNanopipettor;
		tracestatus		= TraceStatus::progress;

		bRepeat = 1;
		while(bRepeat)
		{
			tracesargument	= StringTable::Load(IDS::dlgNanoOpenTheBottleText);
			FormatTrace(traceSource, traceAction, tracestatus,	tracesargument);
			//	Please open	the valves of He and	CO2 supply
			if	( hslCancel == MessageBox( StringTable::Load(IDS::dlgNanoOpenTheBottleText),
											  TitleNanopipettor,
											  hslOKCancel | hslInformation, hslInfinite ))
            abort;

			//	 Please check that the pressure of He is grater	then 20 bar!
			//	 Is the pressure > 20 bar?
			if	( hslYes	==	MessageBox(StringTable::Load(IDS::dlgNanoCheckPressureHe),
											  TitleNanopipettor,
											  hslYesNo	| hslInformation,	hslInfinite	) )
			{
				//	Pressure	of	Helium is >	20	bar!
				tracesargument	= StringTable::Load(IDS::dlgNanoPressureHe30);
				FormatTrace(traceSource, traceAction, tracestatus,	tracesargument);
				bRepeat=	0;
			}
			else //	Please check that	the pressure of He is grater then 20 bar!
			{
				//	Please close the valves	of	Helium supply and	change Helium supply!
				tracesargument	= StringTable::Load(IDS::dlgNanoChangeBottleHe);
				FormatTrace(traceSource, traceAction, tracestatus,	tracesargument);
				if	( hslCancel == MessageBox( StringTable::Load(IDS::dlgNanoChangeBottleHe),
												  TitleNanopipettor,
												  hslOKCancel	| hslInformation,	hslInfinite	))
				   abort;
			}
	   }
		//*******************************************************************************************
		//	End Open	the bottles	He	and CO2 and	H2O water tap
		//*******************************************************************************************

  		//*******************************************************************************************
  		// Start Check pressure of Helium
  		//*******************************************************************************************
  		traceSource    = StringTable::Load(IDS::dlgNanoTraceUser);
		traceAction    = TitleNanopipettor;
  		bRepeat = 1;

		while(bRepeat)
		{
         errCode = GetPressureState(ML_STAR);
		   if (errCode == 0 )
		   {
		    	traceSource = StringTable::Load(IDS::dlgNanoTraceSystem);
		    	tracesargument = StrConcat2(StringTable::Load(IDS::dlgNanoPressureOfHelium),StrIStr(HeliumPressure));
		    	tracesargument = StrConcat2(tracesargument,StringTable::Load(IDS::dlgNanoMBAR));
       		FormatTrace(traceSource, traceAction, tracestatus, tracesargument);

				if (HeliumPressure >= HeliumPressureHigh)
				{
					// The pressure of He (Helium) is to high adjust pressure to 1.8 bar
			    	traceSource    = StringTable::Load(IDS::dlgNanoTraceUser);
			    	tracesargument = StrConcat2(StringTable::Load(IDS::dlgNanoHeIsToHigh),StrIStr(HeliumPressure));
	    			tracesargument = StrConcat2(tracesargument,StringTable::Load(IDS::dlgNanoMBAR));
    				FormatTrace(traceSource, traceAction, tracestatus, tracesargument);
					if	( hslCancel == MessageBox( StringTable::Load(IDS::dlgNanoHeHigh),
		  			   					TitleNanopipettor,
											hslOKCancel | hslInformation, hslInfinite ))
					   abort;

               SwitchNPSolenoidValve(NP_SolenoidValve_R, 1, ML_STAR);
               NanoTimeWait(5, TitleNanopipettor, 0);
               SwitchNPSolenoidValve(NP_SolenoidValve_R, 0, ML_STAR);

               MessageBox( StringTable::Load(IDS::dlgNanoHeHighEndCorrection),	TitleNanopipettor,
											hslOKOnly | hslInformation, hslInfinite );
				}
				else
			   if (HeliumPressure <= HeliumPressureLow)
				{
					// The pressure of He (Helium) is to low adjust pressure to 1.8 bar
			    	traceSource    = StringTable::Load(IDS::dlgNanoTraceUser);
			    	tracesargument = StrConcat2(StringTable::Load(IDS::dlgNanoHeIsToLow),StrIStr(HeliumPressure));
	    			tracesargument = StrConcat2(tracesargument,StringTable::Load(IDS::dlgNanoMBAR));
    				FormatTrace(traceSource, traceAction, tracestatus, tracesargument);
					if	( hslCancel == MessageBox( StringTable::Load(IDS::dlgNanoHeLow),
		  						   		TitleNanopipettor,
											hslOKCancel | hslInformation, hslInfinite ))
					   abort;
				}
				else
			   	bRepeat = 0;
			}  //  if (errCode == 0 )
			else
			{
				nanoPipettorCheckState = PS::failed;
		 		return ;
			}
		}

  		//*******************************************************************************************
  		// Start Check pressure of CO2
  		//*******************************************************************************************
      // read type of nano head
      RequestNanopipettor_High_Low_Viscosity(Channel_8_Head,Channel_N_Head,ML_STAR, traceAction);

		if (Channel_8_Head == 1)
      {
			CO2PresMax = CO2HVPressureHigh;
			CO2PresMin = CO2HVPressureLow;
         CO2PresDefaultStr = FStr(CO2HVPressureDefault, hslTrue, 2);
		}
		else
      {
			CO2PresMax = CO2LVPressureHigh;
			CO2PresMin = CO2LVPressureLow;
         CO2PresDefaultStr = FStr(CO2LVPressureDefault, hslTrue, 2);
		}

  		bRepeat = 1;
		while(bRepeat)
		{
         errCode = GetPressureState(ML_STAR);
		   if (errCode == 0 )
		   {
		    	traceSource = StringTable::Load(IDS::dlgNanoTraceSystem);
		    	tracesargument = StrConcat2(StringTable::Load(IDS::dlgNanoPressureOfCO2),StrIStr(CO2Pressure));
		    	tracesargument = StrConcat2(tracesargument,StringTable::Load(IDS::dlgNanoMBAR));
       		FormatTrace(traceSource, traceAction, tracestatus, tracesargument);

				if (CO2Pressure >= CO2PresMax)
				{
               variable infoStr;
               infoStr = StringTable::Load(IDS::dlgNanoCO2High);
               StrReplace(infoStr, "%s", CO2PresDefaultStr);

					// The pressure of CO2 is to high adjust pressure 500mbar
			    	traceSource    = StringTable::Load(IDS::dlgNanoTraceUser);
			    	tracesargument = StrConcat2(infoStr,StrIStr(CO2Pressure));
	    			tracesargument = StrConcat2(tracesargument,StringTable::Load(IDS::dlgNanoMBAR));
    				FormatTrace(traceSource, traceAction, tracestatus, tracesargument);
					if	( hslCancel == MessageBox( infoStr, TitleNanopipettor, hslOKCancel | hslInformation, hslInfinite ))
					   abort;
				}
				else
				if (CO2Pressure <= CO2PresMin)
				{
               variable infoStr;
               infoStr = StringTable::Load(IDS::dlgNanoCO2Low);
               StrReplace(infoStr, "%s", CO2PresDefaultStr);

					// The pressure of CO2 is to low adjust pressure  500mbar
			    	traceSource    = StringTable::Load(IDS::dlgNanoTraceUser);
			    	tracesargument = StrConcat2(infoStr,StrIStr(CO2Pressure));
	    			tracesargument = StrConcat2(tracesargument,StringTable::Load(IDS::dlgNanoMBAR));
    				FormatTrace(traceSource, traceAction, tracestatus, tracesargument);
					if	( hslCancel == MessageBox( infoStr, TitleNanopipettor, hslOKCancel | hslInformation, hslInfinite ))
					   abort;
				}
				else
			   	bRepeat = 0;
			}  //  if (errCode == 0 )
			else
			{
				nanoPipettorCheckState = PS::failed;
		 		return ;
			}

		}
 		//*******************************************************************************************
  		// End Check pressure of CO2
  		//*******************************************************************************************

		if ((processID == PID::startUpMaintNano) || (processID == PID::dailyMorningMaintNano))
		{

     		//*******************************************************************************************
     		// Start Fill up water reservior
     		//*******************************************************************************************
   		// RefillReservoirLiquidLevelSensor_2    	6th value :	Refill reservoir liquid level sensor LR2
     		//*******************************************************************************************

     		bRepeat = 1;
   		while(bRepeat)
   		{
   			variable SensorWertLevel_LR2;

			  	errCode = RequestLiquidLevelSensors(SensorWertLevel_LR2,RefillReservoirLiquidLevelSensor_2,ML_STAR );
		     	if (errCode == 0 )
		     	{
		        	 if (SensorWertLevel_LR2 == 0 )
				  	 {
			   	   // Fill up water reservior by hand!
	  		    		traceSource = StringTable::Load(IDS::dlgNanoTraceUser);
	   		 		tracesargument = StringTable::Load(IDS::dlgNanoFillUpWaterHand);
 						FormatTrace(traceSource, traceAction, tracestatus, tracesargument);
						if	( hslCancel == MessageBox( StringTable::Load(IDS::dlgNanoFillUpWaterHand),
												TitleNanopipettor, hslOKCancel | hslInformation, hslInfinite ))
						   abort;
					}
					else   // (SensorWertLevel == 0 )
					{
				   	// Water reservior is full!
		   			traceSource = StringTable::Load(IDS::dlgNanoTraceSystem);
	   	 			tracesargument = StringTable::Load(IDS::dlgNanoWaterSystemFull);
 						FormatTrace(traceSource, traceAction, tracestatus, tracesargument);
 						bRepeat= 0;
					}
				}
				else  // if (errCode == 0 )
				{
					nanoPipettorCheckState = PS::failed;
					return;
				}
   		}   // 	while(bRepeat)
     		//*******************************************************************************************
     		// End Fill up water reservior
     		//*******************************************************************************************

      } 	// if ((processID == PID::startUpMaintNano) || (processID == PID::dailyMorningMaintNano))

		//*******************************************************************************************
  		// Start empty waste container
  	  	//*******************************************************************************************
      //  WasteReservoirLiquidLevelSensor_1     Pos 8 5th value :	Refill reservoir liquid level sensor 1
  	  	//*******************************************************************************************

  		bRepeat  = 1;
		while(bRepeat)
		{
			variable SensorWertLevel_LW1;

  			errCode = RequestLiquidLevelSensors(SensorWertLevel_LW1,WasteReservoirLiquidLevelSensor_1,ML_STAR );
			if (errCode == 0 )
  			{
     	 		if (SensorWertLevel_LW1 == 1 )
   	 		{
	   	   	// Empty waste by hand!
		    			traceSource = StringTable::Load(IDS::dlgNanoTraceUser);
		 			tracesargument = StringTable::Load(IDS::dlgNanoWasteContainerHand);
					FormatTrace(traceSource, traceAction, tracestatus, tracesargument);
					if	( hslCancel == MessageBox( StringTable::Load(IDS::dlgNanoWasteContainerHand),
											TitleNanopipettor,
											hslOKCancel | hslInformation, hslInfinite ))
					   abort;
				}
				else   // (SensorWertLevel == 0 )
				{
			   	// Waste is empty!
	 				traceSource = StringTable::Load(IDS::dlgNanoTraceSystem);
		 			tracesargument = StringTable::Load(IDS::dlgNanoWasteContainerIsEmpty);
						FormatTrace(traceSource, traceAction, tracestatus, tracesargument);
						bRepeat= 0;
				}
			} // if (errCode == 0 )
			else
			{
				nanoPipettorCheckState = PS::failed;
				return;
			}
		}  //	while(bRepeat)

		//*******************************************************************************************
  		// End empty waste container
  	  	//*******************************************************************************************


  		//*******************************************************************************************
  		// End set Slot-Postion
		//*******************************************************************************************

		if ((processID == PID::startUpMaintNano) || (processID == PID::dailyMorningMaintNano))
		{
   		//*******************************************************************************************
     		// Start dry helium pump
     	  	//*******************************************************************************************

		   // Drying helium pump
   	 	traceSource    = StringTable::Load(IDS::dlgNanoTraceSystem);
   		tracesargument = StringTable::Load(IDS::dlgNanoDryHeliumPump);
			FormatTrace(traceSource, traceAction, tracestatus, tracesargument);

         // --------------------------------------------------------------
         // Set system and vacuum reservoir to ambient pressure
         // --------------------------------------------------------------
         errCode = SetNanoPressureToAmbient(ML_STAR);
         if(errCode == 0)
			{
            // --------------------------------------------------------------
            // Fill up vacuum reservoir with helium
            // --------------------------------------------------------------
            // Open ventil N 
            errCode = SwitchNPSolenoidValve(NP_SolenoidValve_N, 1, ML_STAR);
            if(errCode == 0)
   			{
               // wait until reservoir is filled up with helium
               NanoTimeWait(20, TitleNanopipettor, 0);

               // Close ventil N 
               errCode = SwitchNPSolenoidValve(NP_SolenoidValve_N, 0, ML_STAR);
               if(errCode == 0)
      			{
                  // get state of pressure devices
                  errCode = GetPressureState(ML_STAR);
               }
            }
         }

         // --------------------------------------------------------------
         // Dry helium pump
         // --------------------------------------------------------------
         if(errCode == 0)
         {
            // Open ventil P
            errCode = SwitchNPSolenoidValve(NP_SolenoidValve_P, 1, ML_STAR);
            if(errCode == 0)
   			{
               // Open ventil Q
               errCode = SwitchNPSolenoidValve(NP_SolenoidValve_Q, 1, ML_STAR);
               if(errCode == 0)
      			{
                  // start vacuum pump
                  errCode = StartNanoVacuumPump(ML_STAR);
                  if(errCode == 0)
         			{
                     variable errCode2(0);

                     // wait for dry the pump
                     NanoTimeWait(50, TitleNanopipettor, 0);

                     // Close ventil P (on error repeat the command)
                     if(SwitchNPSolenoidValve(NP_SolenoidValve_P, 0, ML_STAR) != 0)
                        errCode = SwitchNPSolenoidValve(NP_SolenoidValve_P, 0, ML_STAR);

                     // Close ventil q (on error repeat the command)
                     if(SwitchNPSolenoidValve(NP_SolenoidValve_Q, 0, ML_STAR) != 0)
                        errCode2 = SwitchNPSolenoidValve(NP_SolenoidValve_Q, 0, ML_STAR);

                     if(errCode2 != 0)
                        errCode = errCode2;

                     if(errCode == 0)
            			{
                        // wait until valve are close
                        NanoTimeWait(1, TitleNanopipettor, 0);

                        // stop vacuum pump
                        errCode = StopNanoVacuumPump(ML_STAR);
                     }
                  }
                  else
                  {
                     SwitchNPSolenoidValve(NP_SolenoidValve_P, 0, ML_STAR);
                     SwitchNPSolenoidValve(NP_SolenoidValve_Q, 0, ML_STAR);
                  }
               }
               else
                  SwitchNPSolenoidValve(NP_SolenoidValve_P, 0, ML_STAR);
            }
         }

         // --------------------------------------------------------------
         // Set system and vacuum reservoir to ambient pressure
         // --------------------------------------------------------------
         if(errCode == 0)
			{
            errCode = SetNanoPressureToAmbient(ML_STAR);
         }
         // trace error
         if(errCode != 0)
			{
            SetNanoPressureToAmbient(ML_STAR);

            tracestatus = TraceStatus::completeWithError;

			   // Error helium pump is not dry!
	   	 	traceSource    = StringTable::Load(IDS::dlgNanoTraceSystem);
	   		tracesargument = StringTable::Load(IDS::dlgNanoDryHeliumPumpError);
  				FormatTrace(traceSource, traceAction, tracestatus, tracesargument);
            return;
			}

   		//*******************************************************************************************
     		// End dry helium pump
     	  	//*******************************************************************************************


	  		//*******************************************************************************************
  			// Start "C0NP"
  			// *» Systemreservoir mit Wasser auffüllen
  			// *» Sparging
	  		// *» Drying Multichannel und +n Channel
  			// *» Priming Liquid System
  			// *» Priming Multichannel HV
	  		// *» Priming Multichannel +n Channel HV
	  		// *» Priming Multichannel LV
			//*******************************************************************************************
  	 		traceSource = StringTable::Load(IDS::dlgNanoTraceSystem);
 		 	tracesargument = StringTable::Load(IDS::dlgNanoSparging);
			FormatTrace(traceSource, traceAction, tracestatus, tracesargument);

			{
				variable primeMode(2);

   			//----------------------------------------------------------------------------------------
     			// Make different for start up routine
   			//----------------------------------------------------------------------------------------
				if (processID == PID::startUpMaintNano)
				{
					// 1st value: 8 channel head  1 = high viscosity
					// 1st value: 8 channel head  2 = low volume
					// 2nd value: +n channel head 1 = high viscosity
					// 2nd value: +n channel head 2 = low volume
					if ( Channel_8_Head == 1 || Channel_N_Head == 1)
					   SetTimeNanoPipettor(MtConst::High_Viscosity_Time,ML_STAR, traceAction);

					if ( Channel_8_Head == 2 || Channel_N_Head == 2)
					   SetTimeNanoPipettor(MtConst::Low_Volume_Time,ML_STAR, traceAction);


  					primeMode = 3;

				}


           	// primeMode = 2,
            // Refill = ON,  Sparging = ON,  Dry = OFF, Prime Liq System = ON,  Prime Pipettor = OFF, Flush Pipettor ON
           	// primeMode = 3,
            // Refill = ON,  Sparging = ON,  Dry = ON, Prime Liq System = ON,  Prime Pipettor = ON, Flush Pipettor OFF
   			ML_STAR._ADA99A27_16B3_4a5a_9159_D3BCCF03F78F( "3db46411_d6e6_4361_8f7506cdbbc57dfa" ); // NanoFillSystem

			}
			//-------------------------------------------------------------------------------------------
  			// end "C0NP"
			//-------------------------------------------------------------------------------------------

			//*******************************************************************************************
			// Exchange cleaning liquid at ultrasonic bath
			//*******************************************************************************************

	 		traceSource = StringTable::Load(IDS::dlgNanoTraceSystem);
		 	tracesargument = StringTable::Load(IDS::dlgNanoExchangeCleaningLiquid);
			FormatTrace(traceSource, traceAction, tracestatus, tracesargument);

			ExchangeCleaningLiquidAtUltrsonicBath(ML_STAR);

			//-------------------------------------------------------------------------------------------
			// end Exchange cleaning liquid at ultrasonic bath
			//-------------------------------------------------------------------------------------------


			//*******************************************************************************************
  			// Start "C0NU"
  			// *»  Ultrasonic bath (service carrier) empty (via Waste pump)
  			// *»  Fill ultrasonic bath for 10 seconds switch on and emptyultrasonic bath
  			// *»  Fill ultrasonic bath
  			// *»  Wash ceramic tips (10 seconds in the ultrasonic bath)
			//*******************************************************************************************

	 		traceSource = StringTable::Load(IDS::dlgNanoTraceSystem);
		 	tracesargument = StringTable::Load(IDS::dlgNanoServiceCarrier);
   		FormatTrace(traceSource, traceAction, tracestatus, tracesargument);

			ML_STAR._ACDD4647_8C5C_4764_A11B_8443D9CA6144( "be709d71_0378_42c1_8718c3cb1375a36a" ); // NanoWash

			if (NanoPipettorType == 3)
				ML_STAR._ACDD4647_8C5C_4764_A11B_8443D9CA6144( "0f7e9a9f_fec7_4911_ab383aace5e6050d" ); // NanoWash
			//-------------------------------------------------------------------------------------------
  			// end "C0NP"
			//-------------------------------------------------------------------------------------------


			//*******************************************************************************************
			// Empty ultrasonic bath
			// Parameter: (NPMV)
			//*******************************************************************************************
			traceSource = StringTable::Load(IDS::dlgNanoTraceSystem);
 		 	tracesargument = StringTable::Load(IDS::dlgNanoEmptyWasteChamber);
			FormatTrace(traceSource, traceAction, tracestatus, tracesargument);

			EmptyWasteOnDeck(ML_STAR);
			//-------------------------------------------------------------------------------------------
  			// end Empty ultrasonic bath
			//-------------------------------------------------------------------------------------------

			nanoPipettorCheckState = PS::successful;

		}	// if ((processID == PID::startUpMaintNano) || (processID == PID::dailyMorningMaintNano))


      // decontamination routine
      if(processID == PID::decontaminationMaintNano)
      {
         // empty ultrasonic bath
         EmptyUltrasonicBath(ML_STAR);

         // move nano head to the nano service carrier waste position
         // NOTE: move is needed in case of an dry system (NanoWash and NanoFillSystem() return than an error N002/93)
         // nq0xs01367xd0ny1986mz2450nt2450nz2185 (if carrier on slot position 1..6)

         errCode = NanoMoveToWaste( ML_STAR, Channel_N_Head, traceAction);
   		if(errCode != 0)
            return;


			//*******************************************************************************************
			// Remove water from the whole system incuding the tubes
			//*******************************************************************************************
	 		traceSource = StringTable::Load(IDS::dlgNanoTraceSystem);
		 	tracesargument = StringTable::Load(IDS::dlgNanoRemoveWaterFromSystem);
   		FormatTrace(traceSource, traceAction, tracestatus, tracesargument);

         // drain nano system
         errCode = EmptyAccuAndSeyonic(ML_STAR, TitleNanopipettor, Channel_N_Head);
         if(errCode == 0)
   		{
            // dry seyonics with CO2
            errCode = DrySeyonicSystem(ML_STAR, TitleNanopipettor, Channel_N_Head, NanoDryWaitTime1);
            if(errCode == 0)
   			{
               // empty refill container
               errCode = EmptyRefillContainer(ML_STAR, TitleNanopipettor);
               if(errCode == 0)
      			{
                  errCode = EmptySystemReservoir(ML_STAR, TitleNanopipettor);
                  if(errCode == 0)
         			{
                     errCode = EmptyUltraSonicBathSpecial(ML_STAR, TitleNanopipettor, 0);
                     if(errCode == 0)
            			{
                        errCode = EmptyWasteOnDeck(ML_STAR);
                     }
                  }
               }
            }
         }
         // trace error
         if(errCode != 0)
			{
            tracestatus = TraceStatus::completeWithError;

			   // Error cannot helium pump is not dry!
	   	 	traceSource    = StringTable::Load(IDS::dlgNanoTraceSystem);
	   		tracesargument = StringTable::Load(IDS::dlgNanoRemoveWaterFromSystemError);
  				FormatTrace(traceSource, traceAction, tracestatus, tracesargument);
            return;
			}

			//*******************************************************************************************
			// Decontaminate the system with Ethanol 70%
			//*******************************************************************************************
		 	tracesargument = StringTable::Load(IDS::dlgNanoDecontaminateSystem);
   		FormatTrace(traceSource, traceAction, tracestatus, tracesargument);

         errCode = CleanDecontaminateNanoSystem(ML_STAR, Channel_N_Head,
               TitleNanopipettor, traceAction, StringTable::Load(IDS::dlgNanoFillUpDecontaminateFluid));

         // trace error
         if(errCode != 0)
			{
            tracestatus = TraceStatus::completeWithError;

			   // Error decontamination of nano system failed!
	   	 	traceSource    = StringTable::Load(IDS::dlgNanoTraceSystem);
	   		tracesargument = StringTable::Load(IDS::dlgNanoDecontaminateSystemError);
  				FormatTrace(traceSource, traceAction, tracestatus, tracesargument);
            return;
			}

         // wait for decontamination solution progress end
         if(hslAbort == NanoTimeWait(NanoDecontaminationWaitTime, TitleNanopipettor, 1))
            abort;


			//*******************************************************************************************
			// Remove special fluid from the whole system incuding the tubes
			//*******************************************************************************************
		 	tracesargument = StringTable::Load(IDS::dlgNanoRemoveDecontWaterFromSystem);
   		FormatTrace(traceSource, traceAction, tracestatus, tracesargument);

         // drain nano system
         errCode = EmptyAccuAndSeyonic(ML_STAR, TitleNanopipettor, Channel_N_Head);
         if(errCode == 0)
   		{
            // dry seyonics with CO2
            errCode = DrySeyonicSystem(ML_STAR, TitleNanopipettor, Channel_N_Head, NanoDryWaitTime2);
            if(errCode == 0)
   			{
               if(hslAbort == NanoTimeWait(NanoBeforeEmptyRefillCont1WaitTime, TitleNanopipettor, 1))
                  abort;

               // empty refill container
               errCode = EmptyRefillContainer(ML_STAR, TitleNanopipettor);
               if(errCode == 0)
      			{
                  errCode = EmptySystemReservoir(ML_STAR, TitleNanopipettor);
                  if(errCode == 0)
                     errCode = EmptyUltraSonicBathSpecial(ML_STAR, TitleNanopipettor, 1);
               }
            }
         }
         // trace error
         if(errCode != 0)
			{
            tracestatus = TraceStatus::completeWithError;

			   // Error cannot helium pump is not dry!
	   	 	traceSource    = StringTable::Load(IDS::dlgNanoTraceSystem);
	   		tracesargument = StringTable::Load(IDS::dlgNanoRemoveDecontWaterFromSystemError);
  				FormatTrace(traceSource, traceAction, tracestatus, tracesargument);
            return;
			}


			//*******************************************************************************************
			// Rinse system with water
			//*******************************************************************************************
		 	tracesargument = StringTable::Load(IDS::dlgNanoRinseSystem);
   		FormatTrace(traceSource, traceAction, tracestatus, tracesargument);

         errCode = CleanDecontaminateNanoSystem(ML_STAR, Channel_N_Head,
               TitleNanopipettor, traceAction, StringTable::Load(IDS::dlgNanoFillUpRinseWaterFluid));

         // trace error
         if(errCode != 0)
			{
            tracestatus = TraceStatus::completeWithError;

			   // Error cannot helium pump is not dry!
	   	 	traceSource    = StringTable::Load(IDS::dlgNanoTraceSystem);
	   		tracesargument = StringTable::Load(IDS::dlgNanoRinseSystemError);
  				FormatTrace(traceSource, traceAction, tracestatus, tracesargument);
            return;
			}

         // wait for rinse water progress end
         if(hslAbort == NanoTimeWait(120, TitleNanopipettor, 0))
            abort;

			//*******************************************************************************************
			// Remove rinsing water from the whole system incuding the tubes
			//*******************************************************************************************
		 	tracesargument = StringTable::Load(IDS::dlgNanoRemoveRinseWaterFromSystem);
   		FormatTrace(traceSource, traceAction, tracestatus, tracesargument);

         // drain nano system
         errCode = EmptyAccuAndSeyonic(ML_STAR, TitleNanopipettor, Channel_N_Head);
         if(errCode == 0)
   		{
            // dry seyonics with CO2
            errCode = DrySeyonicSystem(ML_STAR, TitleNanopipettor, Channel_N_Head, NanoDryWaitTime3);
            if(errCode == 0)
   			{
               // empty refill container
               errCode = EmptyRefillContainer(ML_STAR, TitleNanopipettor);
               if(errCode == 0)
                  errCode = EmptySystemReservoir(ML_STAR, TitleNanopipettor);
            }
         }
         // trace error
         if(errCode != 0)
			{
            tracestatus = TraceStatus::completeWithError;

			   // Error cannot helium pump is not dry!
	   	 	traceSource    = StringTable::Load(IDS::dlgNanoTraceSystem);
	   		tracesargument = StringTable::Load(IDS::dlgNanoRemoveRinseWaterFromSystemError);
  				FormatTrace(traceSource, traceAction, tracestatus, tracesargument);
            return;
			}
         // set state to sucessful
			nanoPipettorCheckState = PS::successful;
      }

  		return;
	}	// end nanoPipettorMaintenance


	//*****************************************************************************************************
	//-----------------------------------------------------------------------------------------------------
	function GetProcessStateNano()
	//-----------------------------------------------------------------------------------------------------
	//*****************************************************************************************************
	{
		// nanoPipettor station check
		if(nanoPipettor != 0)	//
		{
			if(nanoPipettorCheckState == PS::successful)
			{
   			overallProcessedState = PS::successful;
	   		return(MPS::mpsSuccessful);
			}
		   if(nanoPipettorCheckState == PS::failed)
				return(MPS::mpsFailed);
		}
		return(MPS::mpsIncomplete);
	} // end GetProcessStateNano

	//*****************************************************************************************************
	//-----------------------------------------------------------------------------------------------------
	function CreateReportFileNano( variable &templateFile, variable &reportFileName, variable &reportExcelAreaName)
	//-----------------------------------------------------------------------------------------------------
	//*****************************************************************************************************
	{
		object report;
		object reportReadOnly;
		file reportFile;


		// path, file and excel table name of the report
		variable templateFileName, testedFiles;
		variable copyCommand("cmd.exe /c copy \"");

		// initialize library (if necessary)
		InitMaintMetLibrary();

		// Evaluate the template file name respecting the current phoenix langauge.
		templateFileName = GetMethodsPath() + "\\" + templateFile + GetLanguage() + ".xls";	// phoenix specific
		if ("" == SearchPath(templateFileName))
		{
			testedFiles = templateFileName;
			templateFileName = GetMethodsPath() + "\\" + templateFile + "Enu.xls";		// The default language
			if ("" == SearchPath(templateFileName))
			{
				testedFiles = testedFiles + "\n" + templateFileName;
				templateFileName = GetMethodsPath() + "\\" + templateFile + ".xls";		// No language
				if ("" == SearchPath(templateFileName))
				{
					string errorDesc;
					testedFiles = testedFiles + "\n" + templateFileName;
					errorDesc = StringTable::Load(IDE::templateFileNotExist);
					StrReplace(errorDesc, "%s1", GetFileName());
					StrReplace(errorDesc, "%s2", GetLineNumber());
					StrReplace(errorDesc, "%s3", testedFiles);
				   err.Raise( IDE::templateFileNotExist, errorDesc);
				}
			}
		}

		copyCommand = copyCommand + templateFileName + "\" \"" + GetLogFilesPath()+"\\"+reportFileName+"\"";

		// create file by copying template
		if (!Shell(copyCommand, hslHide, hslSynchronous))
		{
			string errorDesc;
			errorDesc = StringTable::Load(IDE::fileCopyFailed);
			StrReplace(errorDesc, "%s1", GetFileName());
			StrReplace(errorDesc, "%s2", GetLineNumber());
		   err.Raise( IDE::fileCopyFailed, errorDesc);
		}

		// open file
		if (!reportFile.Open(GetLogFilesPath()+"\\"+reportFileName + " " + reportExcelAreaName, hslAppend))
		{
			string errorDesc;
			errorDesc = StringTable::Load(IDE::fileOpenFailed);
			StrReplace(errorDesc, "%s1", GetFileName());
			StrReplace(errorDesc, "%s2", GetLineNumber());
		   err.Raise( IDE::fileOpenFailed, errorDesc);
		}

		// update instrument name
		UpdateCellInReportFile( reportFile, instrNameCol, instrNameRow, instrName);

		// update user software version
		UpdateCellInReportFile( reportFile, releaseVersionCol, releaseVersionRow, releaseVersion);

		// update instrument serial number
		UpdateCellInReportFile( reportFile, instrSerialNoCol, instrSerialNoRow, instrSerialNo);

		// update nano serial number
		UpdateCellInReportFile( reportFile, nanoSerialNoCol, nanoSerialNoRow, nanoSerialNo);

		// update nano status --> successful,failed, or incomlete
		UpdateCellInReportFile( reportFile, nanoProcessedStateCol, nanoStateRow, GetCheckStateAsString(nanoPipettorCheckState));

		// update processed date
		UpdateCellInReportFile( reportFile, nanoDateCol, nanoStateRow, TimGetFormattedDate("%Y-%m-%d"));

		// update processed time
		UpdateCellInReportFile( reportFile, nanoTimeCol, nanoStateRow, TimGetFormattedTime("%H:%M"));

		// update operator name
		UpdateCellInReportFile( reportFile, nanoOperatorNameCol, nanoStateRow, operatorName);

		// close file
		reportFile.Close();

		//make file read only
		report.CreateObject("Scripting.FileSystemObject");
		reportReadOnly = report.GetFile(GetLogFilesPath()+"\\"+reportFileName);
		reportReadOnly.Attributes = reportReadOnly.Attributes | 1;
		reportReadOnly.ReleaseObject();
		report.ReleaseObject();

	} // end CreateReportFileNano


   //-----------------------------------------------------------------------------------------------------
   function AddNanoServiceCarrier(device ML_STAR)
   //-----------------------------------------------------------------------------------------------------
	{
      string traceTitle;
		string traceSource;
		string tracesargument;
		variable tracestatus;
		variable labwareDir;
		variable labwarePathFileName;
		variable position[];					   // array contains the labware position x,y,z
		variable TempStr1;
		variable TempStr2;
		variable X_Pox_input;
		variable X_Pos;
		variable bRepeat;
		variable X_Pox_LED;
      variable deckRaster;
      variable deckZeroXPoint;
      variable deckZeroYPoint;
      variable deckZeroZPoint;
      variable carrierDelta(5);


      labwareDir = GetLabwarePath();
      traceTitle = StringTable::Load(IDS::dlgNanoAddCarrierTitle);

  		//*******************************************************************************************
  		// Check if exist the nano service carrier
		//*******************************************************************************************
      {
   		variable templNames[];					// array contains all template names
   		variable labwNames[];					// array contains all labware names

         onerror goto toError;

         if(ML_STAR.GetTemplateLabwareNames(templNames, labwNames))
         {
            variable index(0);
            variable washFound(0);
            variable wasteFound(0);
      		variable propertyKey[];					// array contains the nano service carrier property
      		variable propertyVal[];					// array returns the value of the key

            propertyKey.SetSize(0);
            propertyKey.AddAsLast("MlStarIsNanoWashRack");
            propertyKey.AddAsLast("MlStarIsNanoWasteRack");

            // search for the given properties
            for (index = 0; index < labwNames.GetSize(); index++)
            {
               if(ML_STAR.GetLabwareData(labwNames.GetAt(index), propertyKey, propertyVal))
               {
                  // check for value of property MlStarIsNanoWashRack
                  if(propertyVal.GetAt(0) == "1")
                     washFound = 1;
                  // check for value of property MlStarIsNanoWasteRack
                  if(propertyVal.GetAt(1) == "1")
                  {
                     variable wastePos[];

                     wasteFound = 1;

                     // set x, y and z position of nano waste
                     if(ML_STAR.GetLabwarePosition(labwNames.GetAt(index), wastePos))
                     {
                        NanoWasteX = wastePos[0];
                        NanoWasteY = wastePos[1];
                        NanoWasteZ = wastePos[2];
                     }
                  }

                  // Both properties are found, nano service carrier is available
                  if(washFound && wasteFound)
                  {
                     // set x, y and z position of nano waste
                     return;
                  }
               }
            }
         }
         // on error, ask for the nano service carrier position
     	   toError:
      	{
         }
         onerror goto 0;
      }


  		//*******************************************************************************************
  		// Start get Slot-Position
		//*******************************************************************************************
		bRepeat  = 1;
		while(bRepeat)
		{
         variable errCode(0);

         // possible positions (-3, -2, -1, 0, 1, 2, 3, ... maxSlots-5(carrierDelta))

         X_Pox_input = 1000;
         while(X_Pox_input > (maxDeckSlots-carrierDelta) || X_Pox_input < -3)
         {
   			// Enter the correct X-position!
         	X_Pox_input = InputBox(StringTable::Load(IDS::dlgNanoEnterXPosition), traceTitle, hslInteger);

            // user has pressed Cancel
   			if (GetType(X_Pox_input) == "")
   				abort;


     			if (X_Pox_input < -3 || X_Pox_input > (maxDeckSlots-carrierDelta))
            {
               variable msgString;
               msgString = StringTable::Load(IDS::dlgNanoWrongXPosition);

               StrReplace(msgString, "%s", IStr(maxDeckSlots-carrierDelta));

			      MessageBox(msgString, traceTitle, hslOKOnly | hslError, hslInfinite );
            }
         }

         // do not abort the method if function SwitchLoadingIndicators() returns an error
			if (autoLoad == 1)
			{
				//  C0CP Set loading indicators (LED's) to blinking
				errCode = SwitchLoadingIndicators(X_Pox_input, carrierDelta+1, ML_STAR);
         }
         // set text dependent of auto load and blinking leds
         if (autoLoad == 1 && errCode == 0)
         {
	         TempStr1 = StrConcat2(StringTable::Load(IDS::dlgNanoXPositionConform3),StringTable::Load(IDS::dlgNanoXPositionConform1));
				TempStr1 = StrConcat2(TempStr1 ,StrIStr(X_Pox_input));
				TempStr1 = StrConcat2(TempStr1 ,StringTable::Load(IDS::dlgNanoXPositionConform2));
   	   	TempStr1 = StrConcat2(TempStr1,StrIStr(X_Pox_input+carrierDelta));
				if	( hslYes == MessageBox(TempStr1, traceTitle, hslYesNo | hslDefButton2 | hslInformation, hslInfinite))
				   bRepeat=0;

            // switch off loading indicators (LED's) and blinking
            SwitchLoadingIndicators(0, 0, ML_STAR);
			}
			else
			{
            // ask user for correct input range
            TempStr1 = StrConcat2(StringTable::Load(IDS::dlgNanoXPositionConform0),StringTable::Load(IDS::dlgNanoXPositionConform1));
      		TempStr1 = StrConcat2(TempStr1 ,StrIStr(X_Pox_input));
      		TempStr1 = StrConcat2(TempStr1 ,StringTable::Load(IDS::dlgNanoXPositionConform2));
      	   TempStr1 = StrConcat2(TempStr1,StrIStr(X_Pox_input+carrierDelta));
      		if	( hslYes == MessageBox(TempStr1, traceTitle, hslYesNo | hslDefButton2 | hslInformation, hslInfinite	) )
      		   bRepeat=0;
         }
		}

	   traceSource = StringTable::Load(IDS::dlgNanoTraceUser);
  		tracestatus	= TraceStatus::progress;
		TempStr2 = StringTable::Load(IDS::dlgNanoTrackPosition);
		TempStr2 = StrConcat2(TempStr2,StrIStr(X_Pox_input));
		TempStr2 = StrConcat2(TempStr2,StringTable::Load(IDS::dlgNanoTrackPosition1));
 		tracesargument = StrConcat2(TempStr2,StrIStr(X_Pox_input+carrierDelta));
		FormatTrace(traceSource, traceTitle, tracestatus, tracesargument);

      // get deck raster and coordinate of instrument zero point
      deckRaster = ML_STAR.GetCfgValueWithKey(MtConst::starCfgDeckRasterKey);
		deckZeroXPoint = ML_STAR.GetCfgValueWithKey(MtConst::starCfgDeckXOffsetKey);
		deckZeroYPoint = ML_STAR.GetCfgValueWithKey(MtConst::starCfgDeckYOffsetKey);
		deckZeroZPoint = ML_STAR.GetCfgValueWithKey(MtConst::starCfgDeckZOffsetKey);

      // (-3,-2,-1, 0, 1, 2, 3,....)
      if(X_Pox_input >= 0)
         X_Pox_input = X_Pox_input -1;

		X_Pos = deckZeroXPoint + (X_Pox_input * deckRaster);
		position.SetSize(0);
		position.AddAsLast(X_Pos); 	         // x-Pos (100 + ((X_Pox_input-1) * 22.5))
		position.AddAsLast(deckZeroYPoint);		// y-Pos (63)
 		position.AddAsLast(deckZeroZPoint);		// z-pos (100)
		labwarePathFileName = labwareDir + LabwrData::nanoService_carrier;
		ML_STAR.AddLabware(LabwrData::NanoService_CarrierId, labwarePathFileName, position);


  		//*******************************************************************************************
  		// Read x, y and z position of nano waste rack
		//*******************************************************************************************
      {
   		variable templNames[];					// array contains all template names
   		variable labwNames[];					// array contains all labware names

         onerror goto toError2;

         if(ML_STAR.GetTemplateLabwareNames(templNames, labwNames))
         {
            variable index(0);
            variable wasteFound(0);
      		variable propertyKey[];					// array contains the nano service carrier property
      		variable propertyVal[];					// array returns the value of the key

            propertyKey.SetSize(0);
            propertyKey.AddAsLast("MlStarIsNanoWasteRack");

            // search for the given properties
            for (index = 0; index < labwNames.GetSize(); index++)
            {
               if(ML_STAR.GetLabwareData(labwNames.GetAt(index), propertyKey, propertyVal))
               {
                  // check for value of property MlStarIsNanoWasteRack
                  if(propertyVal.GetAt(0) == "1")
                  {
                     variable wastePos[];

                     // set x, y and z position of nano waste
                     if(ML_STAR.GetLabwarePosition(labwNames.GetAt(index), wastePos))
                     {
                        NanoWasteX = wastePos[0];
                        NanoWasteY = wastePos[1];
                        NanoWasteZ = wastePos[2];
                     }

                     return;
                  }
               }
            }
         }
         // on error, ask for the nano service carrier position
     	   toError2:
      	{
         }
         onerror goto 0;
      }
	}

	//-----------------------------------------------------------------------------------------------------
   function NanoMoveToWaste(device ML_STAR, variable Channel_N_Head, variable traceAction)
	//-----------------------------------------------------------------------------------------------------
   {
		string traceSource;
		string tracesargument;
      variable traceStatus(TraceStatus::progress);
		string answer;
		variable errCode;
      variable parameter("nq0xs00000xd0ny0000mz2450nt2450nz0000");
		variable i;
      variable wasteX;
      variable wasteY;
      variable wasteZ;
      string xPosString("");
      string yPosString("");
      string zPosString("");
      string xVar("xs");
      string yVar("ny");
      string zVar("nz");

 		traceSource = StringTable::Load(IDS::dlgNanoTraceSystem);
	 	tracesargument = StringTable::Load(IDS::dlgNanoMoveToWaste);
		FormatTrace(traceSource, traceAction, traceStatus, tracesargument);

      // move nano head to the nano service carrier waste position
      // NOTE: move is needed in case of an dry system (NanoWash and NanoFillSystem() return than an error N002/93)
      // nq0xs01367xd0ny1986mz2450nt2450nz2185 (if carrier on slot position 1..6)

      // set x and y to 1/10 mm
      wasteX = NanoWasteX *10;
      wasteY = NanoWasteY *10;
      wasteZ = (NanoWasteZ + NanoWasteZMoveUpDist) *10;

      if(wasteX < 0)
      {
         StrReplace(parameter, "xd0", "xd1");
         // make positive value
         wasteX = -wasteX;
      }

      // set x and y position
      xPosString = IStr(Floor(wasteX));
      yPosString = IStr(Floor(wasteY));
      zPosString = IStr(Floor(wasteZ));

      for(i = 0; i < 5-xPosString.GetLength(); i++)
         xVar = xVar + "0";

      for(i = 0; i < 4-yPosString.GetLength(); i++)
         yVar = yVar + "0";

      for(i = 0; i < 4-zPosString.GetLength(); i++)
         zVar = zVar + "0";

      xVar = xVar + xPosString;
      yVar = yVar + yPosString;
      zVar = zVar + zPosString;

      StrReplace(parameter, "xs00000", xVar);
      StrReplace(parameter, "ny0000",  yVar);
      StrReplace(parameter, "nz0000",  zVar);

		// firmware response string
		answer = FwCommand("C0NM", parameter, hslFalse, ML_STAR);
		errCode = FirmwareErrorCheck(answer);
		if(errCode != 0)
		{
         traceStatus = TraceStatus::completeWithError;

		   // Error nano pipettor cannot move to waste!
   	 	traceSource    = StringTable::Load(IDS::dlgNanoTraceSystem);
   		tracesargument = StringTable::Load(IDS::dlgNanoMoveToWasteError);
				FormatTrace(traceSource, traceAction, traceStatus, tracesargument);
         return(errCode);
      }

      // if +n channel available, move channel down to same z position than the multi channel
      if(Channel_N_Head > 0)
      {
   		FwCommand("N0NM", "", hslFalse, ML_STAR);
      }

      return(errCode);
   }


	//-----------------------------------------------------------------------------------------------------
	function RequestNanopipettor_High_Low_Viscosity(
         variable &Channel_8_Head, variable &Channel_N_Head , device ML_STAR, string traceAction )
	//-----------------------------------------------------------------------------------------------------
	{
		string answer;
		variable errCode;
      variable traceSource;
		variable strTrace1;
		variable strTrace2;

    	traceSource    = StringTable::Load(IDS::dlgNanoTraceSystem);

      answer="";
		// firmware response string
		answer = FwCommand("N0QU", "", hslFalse, ML_STAR);
		errCode = FirmwareErrorCheck(answer);

		if(errCode == 0)
		{  //             1 2 3 4 5 6 7 8 9 0 +19 Char
			// answer = "au0 0 0 0 0 0 0 0 0 0" 1st value: 8 channel head  0 = none
			// answer = "au1 0 0 0 0 0 0 0 0 0" 1st value: 8 channel head  1 = high viscosity
			// answer = "au2 0 0 0 0 0 0 0 0 0" 1st value: 8 channel head  2 = low volume
			// answer = "au0 0 0 0 0 0 0 0 0 0" 2nd value: +n channel head 0 = none
			// answer = "au0 1 0 0 0 0 0 0 0 0" 2nd value: +n channel head 1 = high viscosity
			// answer = "au0 2 0 0 0 0 0 0 0 0" 2nd value: +n channel head 2 = low volume
			// Pos       1234

			Channel_8_Head = StrIVal(StrMid(answer,2,1));
			Channel_N_Head = StrIVal(StrMid(answer,4,1));
			if (Channel_8_Head == 0)
				strTrace1 = StringTable::Load(IDS::dlgNano8_Channel_Head_not_installed);
			if (Channel_8_Head == 1)
				strTrace1 = StringTable::Load(IDS::dlgNano8_Channel_Head_high_viscosity_installed);
			if (Channel_8_Head == 2)
				strTrace1 = StringTable::Load(IDS::dlgNano8_Channel_Head_low_volume_installed);
			if (Channel_N_Head == 0)
				strTrace2 = StringTable::Load(IDS::dlgNanon_channel_head_not_installed);
			if (Channel_N_Head == 1)
				strTrace2 = StringTable::Load(IDS::dlgNanon_channel_head_high_viscosity_installed);
			if (Channel_N_Head == 2)
				strTrace2 = StringTable::Load(IDS::dlgNanon_channel_head_low_volume_installed);

			FormatTrace(traceSource, traceAction, TraceStatus::progress, strTrace1);
			FormatTrace(traceSource, traceAction, TraceStatus::progress, strTrace2);

		   return(errCode);
		}
	   return(errCode);
	}

   //-----------------------------------------------------------------------------------------------------
   function RequestNanopipettorSerialNumber(device ML_STAR)
   //-----------------------------------------------------------------------------------------------------
   {
		string answer;
		variable errCode;

      nanoSerialNo = "----";
      answer="";
		// firmware response string
		answer = FwCommand("NPQT", "", hslFalse, ML_STAR);
		errCode = FirmwareErrorCheck(answer);
		if(errCode == 0)
		{
			// answer = "qt######/##/####"  Part number / revision / serial number
			nanoSerialNo = StrMid(answer, 2+NanoSerialNoPos, NanoSerialNoLenght);
		   return(errCode);
		}
		return(errCode);
   }

   //-----------------------------------------------------------------------------------------------------
	function SetTimeNanoPipettor(variable TimeNanoPipettor, device ML_STAR, string traceAction )
	//-----------------------------------------------------------------------------------------------------
	{
		string answer;
		variable errCode;
		variable parameter;
		variable strTrace;
      variable traceSource;

    	traceSource    = StringTable::Load(IDS::dlgNanoTraceSystem);

		parameter="";
		parameter = StrConcat2(parameter,StrFillLeft(StrIStr(TimeNanoPipettor),"0",4));
		strTrace  = StrConcat2(StringTable::Load(IDS::dlgNanoDraying_Time),parameter);
		FormatTrace(traceSource, traceAction, TraceStatus::progress, strTrace );
      parameter=StrConcat2("pd", parameter);
		answer = FwCommand("N0AA", parameter, hslFalse, ML_STAR);
		errCode = FirmwareErrorCheck(answer);
		return(errCode);
   }

	//-----------------------------------------------------------------------------------------------------
	function ExchangeCleaningLiquidAtUltrsonicBath(device ML_STAR )
	//-----------------------------------------------------------------------------------------------------
	{
		string answer;
		variable errCode;


		answer = FwCommand("NPMX", "", hslFalse, ML_STAR);
		errCode = FirmwareErrorCheck(answer);
		return(errCode);
	}


	//-----------------------------------------------------------------------------------------------------
	function EmptyWasteOnDeck(device ML_STAR )
	//-----------------------------------------------------------------------------------------------------
	{
		string answer;
		variable errCode;


		answer = FwCommand("NPMV","", hslFalse, ML_STAR);
		errCode = FirmwareErrorCheck(answer);
		return(errCode);
	}



	//-----------------------------------------------------------------------------------------------------
	function EmptyUltrasonicBath(device ML_STAR )
	//-----------------------------------------------------------------------------------------------------
	{
		string answer;
		variable errCode;

		answer = FwCommand("NPMY", "", hslFalse, ML_STAR);
		errCode = FirmwareErrorCheck(answer);
		return(errCode);
	}



   //-----------------------------------------------------------------------------------------------------
	function SwitchNPSolenoidValve(variable ValvePos, variable isOpen, device ML_STAR )
	//-----------------------------------------------------------------------------------------------------
	{
		string answer;
		variable errCode;
      variable command("NPVA");
		variable parameter;

      if(isOpen == 0)
         command = "NPVB";

      parameter=StrConcat2("vn",ValvePos);
		answer = FwCommand(command, parameter, hslFalse, ML_STAR);
		errCode = FirmwareErrorCheck(answer);
		return(errCode);
	}


	//-----------------------------------------------------------------------------------------------------
   function SwitchPipettorValve(variable pipettorHead, variable isOpen, device ML_STAR)
	//-----------------------------------------------------------------------------------------------------
   {
		string answer;
		variable errCode;
      variable command("N0DO");
		variable parameter("ch0cn0");

      if(pipettorHead != pipettorValve_8_Head)
         parameter = "ch1cn0";

      if(isOpen == 0)
         command = "N0DP";

		answer = FwCommand(command, parameter, hslFalse, ML_STAR);
		errCode = FirmwareErrorCheck(answer);
		return(errCode);
   }

	//-----------------------------------------------------------------------------------------------------
   function SwitchN0SolenoidValve(variable valvePos, variable isOpen, device ML_STAR)
	//-----------------------------------------------------------------------------------------------------
   {
		string answer;
		variable errCode;
      variable command("N0VA");
		variable parameter;

      if(isOpen == 0)
         command = "N0VB";

      parameter=StrConcat2("vn",valvePos);
		answer = FwCommand(command, parameter, hslFalse, ML_STAR);
		errCode = FirmwareErrorCheck(answer);
		return(errCode);
   }

	//-----------------------------------------------------------------------------------------------------
	function SetNanoPressureToAmbient( device ML_STAR )
	//-----------------------------------------------------------------------------------------------------
	{
		string answer;
		variable errCode;
		variable parameter("");

		answer = FwCommand("NPMZ", parameter, hslFalse, ML_STAR);
		errCode = FirmwareErrorCheck(answer);
		return(errCode);
	}

	//-----------------------------------------------------------------------------------------------------
	function StartNanoVacuumPump( device ML_STAR )
	//-----------------------------------------------------------------------------------------------------
	{
		string answer;
		variable errCode;
		variable parameter("");

		answer = FwCommand("NPHP", parameter, hslFalse, ML_STAR);
		errCode = FirmwareErrorCheck(answer);
		return(errCode);
	}

	//-----------------------------------------------------------------------------------------------------
	function StopNanoVacuumPump( device ML_STAR )
	//-----------------------------------------------------------------------------------------------------
	{
		string answer;
		variable errCode;
		variable parameter("");

		answer = FwCommand("NPHS", parameter, hslFalse, ML_STAR);
		errCode = FirmwareErrorCheck(answer);
		return(errCode);
	}

	//-----------------------------------------------------------------------------------------------------
	function StartNanoRefillPump( device ML_STAR )
	//-----------------------------------------------------------------------------------------------------
	{
		string answer;
		variable errCode;
		variable parameter("");

		answer = FwCommand("NPFP", parameter, hslFalse, ML_STAR);
		errCode = FirmwareErrorCheck(answer);
		return(errCode);
	}

	//-----------------------------------------------------------------------------------------------------
	function StopNanoRefillPump( device ML_STAR )
	//-----------------------------------------------------------------------------------------------------
	{
		string answer;
		variable errCode;
		variable parameter("");

		answer = FwCommand("NPFS", parameter, hslFalse, ML_STAR);
		errCode = FirmwareErrorCheck(answer);
		return(errCode);
	}

	//-----------------------------------------------------------------------------------------------------
	function RequestLiquidLevelSensors(variable &SensorWertLevel, variable SensorPos,device ML_STAR )
	//-----------------------------------------------------------------------------------------------------

	{
		string answer;
		variable errCode;

      answer="";
		// firmware response string
		answer = FwCommand("NPRL", "", hslFalse, ML_STAR);
		errCode = FirmwareErrorCheck(answer);
		if(errCode == 0)
		{
			// answer = "rl0 0 0 0 0 0 0 0"  LR2 0 nicht voll  6th value	:	Refill reservoir liquid level sensor 2
			// answer = "rl0 0 0 0 0 1 0 0"  LR2 1  voll       6th value	:	Refill reservoir liquid level sensor 2
			// answer = "rl0 0 0 0 0 0 0 0"  LR1 0 leer        5th value	:	Refill reservoir liquid level sensor 1
			// answer = "rl0 0 0 0 1 0 0 0"  LR1 1 nicht leer  5th value	:	Refill reservoir liquid level sensor 1
			// answer = "rl0 0 0 1 0 0 0 0"  LW2 0 voll 	 	   4th value	:	Waste reservoir liquid level sensor 2
			// answer = "rl0 0 0 0 0 0 0 0"  LW2 0 nicht voll  4th value	:	Waste reservoir liquid level sensor 2
			// answer = "rl0 0 0 0 0 0 0 0"  LW1 0 leer        3rd value	:	Waste reservoir liquid level sensor 1
			// answer = "rl0 0 0 1 0 0 0 0"  LW1 1 nicht leer  3rd value	:	Waste reservoir liquid level sensor 1

			SensorWertLevel = StrIVal(StrMid(answer,2 + SensorPos,1));
		   return(errCode);
		}
		return(errCode);
	}

	//-----------------------------------------------------------------------------------------------------
	function GetPressureState(device ML_STAR )
	//-----------------------------------------------------------------------------------------------------
	{
		string answer;
		variable errCode;

		// firmware response string
		answer = FwCommand("NPRP", "", hslFalse, ML_STAR);
		errCode = FirmwareErrorCheck(answer);
		if(errCode == 0)
		{
			// answer = "rp+1200 -0300 +1100 +0300"
			SystemPressure = StrIVal(StrMid(answer,3,4));
			VacuumPressure = StrIVal(StrMid(answer,9,4));
			HeliumPressure = StrIVal(StrMid(answer,15,4));
			CO2Pressure = StrIVal(StrMid(answer,21,4));
		
		   return(errCode);
		}
		return(errCode);
	}

	//-----------------------------------------------------------------------------------------------------
   function EmptyAccuAndSeyonic(
      device ML_STAR, variable TitleNanopipettor, variable Channel_N_Head)
	//-----------------------------------------------------------------------------------------------------
   {
		string answer;
		variable errCode;

		// start pressur control
		answer = FwCommand("N0PA", "pa+0500pq0pb0050ps+0000", hslFalse, ML_STAR);
		errCode = FirmwareErrorCheck(answer);
		if(errCode == 0)
		{
         // start empty of accu and seonic

         // open valve G for 6 seconds
         errCode = SwitchN0SolenoidValve(N0_SolenoidValve_G, 1, ML_STAR);
         if(errCode == 0)
         {
            NanoTimeWait(6, TitleNanopipettor, 0);
            SwitchN0SolenoidValve(N0_SolenoidValve_G, 0, ML_STAR);

            // open valve from head 8 until no liquid is coms out
            errCode = SwitchPipettorValve(pipettorValve_8_Head, 1, ML_STAR);
            if(errCode == 0)
            {
               if(Channel_N_Head > 0)
               {
                  // open valve from head +n until no liquid is coms out
                  errCode = SwitchPipettorValve(pipettorValve_N_Head, 1, ML_STAR);
                  if(errCode != 0)
                  {
                     SwitchPipettorValve(pipettorValve_8_Head, 0, ML_STAR);
                     SwitchPipettorValve(pipettorValve_N_Head, 0, ML_STAR);
                     return (errCode);
                  }
               }
               NanoTimeWait(60, TitleNanopipettor, 0);

               SwitchPipettorValve(pipettorValve_8_Head, 0, ML_STAR);
               SwitchPipettorValve(pipettorValve_N_Head, 0, ML_STAR);
            }
            else
               SwitchPipettorValve(pipettorValve_8_Head, 0, ML_STAR);
         }
         else
            SwitchN0SolenoidValve(N0_SolenoidValve_G, 0, ML_STAR);
		}
		return(errCode);
   }

	//-----------------------------------------------------------------------------------------------------
   function DrySeyonicSystem(device ML_STAR, variable TitleNanopipettor, variable Channel_N_Head, variable dryTime)
	//-----------------------------------------------------------------------------------------------------
   {
		string answer;
		variable errCode;

		// start pressur control
		answer = FwCommand("N0PA", "pa+0100pq0pb0050ps+0000", hslFalse, ML_STAR);
		errCode = FirmwareErrorCheck(answer);
		if(errCode == 0)
		{
         // start empty of accu and seonic

         // open valve G for 1 seconds
         errCode = SwitchN0SolenoidValve(N0_SolenoidValve_G, 1, ML_STAR);
   		if(errCode == 0)
   		{
            NanoTimeWait(1, TitleNanopipettor, 0);
            // open valve F
            errCode = SwitchN0SolenoidValve(N0_SolenoidValve_F, 1, ML_STAR);
      		if(errCode == 0)
      		{
               // open valve L
               errCode = SwitchN0SolenoidValve(N0_SolenoidValve_L, 1, ML_STAR);
         		if(errCode == 0)
         		{
                  // open valve from head 8
                  errCode = SwitchPipettorValve(pipettorValve_8_Head, 1, ML_STAR);
            		if(errCode == 0)
            		{
                     // open valve from head n
                     if(Channel_N_Head > 0)
                        SwitchPipettorValve(pipettorValve_N_Head, 1, ML_STAR);

                     NanoTimeWait(dryTime, TitleNanopipettor, 0);
                  }
               }
            }
         }

         // close all valves
         SwitchPipettorValve(pipettorValve_8_Head, 0, ML_STAR);
         if(Channel_N_Head > 0)
            SwitchPipettorValve(pipettorValve_N_Head, 0, ML_STAR);
         SwitchN0SolenoidValve(N0_SolenoidValve_L, 0, ML_STAR);
         SwitchN0SolenoidValve(N0_SolenoidValve_F, 0, ML_STAR);
         NanoTimeWait(1, TitleNanopipettor, 0);
         SwitchN0SolenoidValve(N0_SolenoidValve_G, 0, ML_STAR);
		}
		return(errCode);
   }

	//-----------------------------------------------------------------------------------------------------
   function EmptyRefillContainer(device ML_STAR, variable TitleNanopipettor)
	//-----------------------------------------------------------------------------------------------------
   {
		string answer;
		variable errCode;
      variable bRepeat(1);
		variable SensorWertLevel_LR1;

      // check for empty refill container
      while(bRepeat)
      {
   		if	( hslCancel == MessageBox( StringTable::Load(IDS::dlgNanoEmptyRefillContainer),
   								TitleNanopipettor, hslOKCancel | hslInformation, hslInfinite ))
            abort;

         // check if the reservois is empty
		  	errCode = RequestLiquidLevelSensors(SensorWertLevel_LR1, RefillReservoirLiquidLevelSensor_1, ML_STAR );
	     	if (errCode == 0 )
	     	{
	        	if (SensorWertLevel_LR1 == 0 )
               bRepeat = 0;
         }
      }

      // empty all tubes
      // open valve Q and I and start the refill pump for 30 seconds
      errCode = SwitchNPSolenoidValve(NP_SolenoidValve_Q, 1, ML_STAR);
		if(errCode == 0)
		{
         errCode = SwitchNPSolenoidValve(NP_SolenoidValve_I, 1, ML_STAR);
      	if(errCode == 0)
      	{
            errCode = StartNanoRefillPump(ML_STAR);
            if(errCode == 0)
            {
               NanoTimeWait(30, TitleNanopipettor, 0);
               StopNanoRefillPump(ML_STAR);
            }
         }
      }

      // close valve Q and I 
      SwitchNPSolenoidValve(NP_SolenoidValve_Q, 0, ML_STAR);
      NanoTimeWait(1, TitleNanopipettor, 0);
      SwitchNPSolenoidValve(NP_SolenoidValve_I, 0, ML_STAR);

      if(errCode != 0)
         abort;
      return (errCode);
   }

	//-----------------------------------------------------------------------------------------------------
   function EmptySystemReservoir(device ML_STAR, variable TitleNanopipettor)
	//-----------------------------------------------------------------------------------------------------
   {
		string answer;
		variable errCode;
      variable makeAbort(0);
      variable bRepeat(1);

      // set ambient pressure
      SetNanoPressureToAmbient(ML_STAR);

		// start pressur control to 0.8 bar
		answer = FwCommand("NPMA", "ps+0800pv-0300", hslFalse, ML_STAR);
		errCode = FirmwareErrorCheck(answer);
		if(errCode == 0)
		{
         // open valve K
         SwitchNPSolenoidValve(NP_SolenoidValve_K, 1, ML_STAR);

         while(bRepeat)
         {
            GetPressureState(ML_STAR);
            if(SystemPressure < 400)
               bRepeat = 0;
            if(bRepeat)
            {
               variable SensorWertLevel(0);

               NanoTimeWait(5, TitleNanopipettor, 0);

               // check for full waste conatiner
               RequestLiquidLevelSensors(SensorWertLevel, WasteReservoirLiquidLevelSensor_2, ML_STAR );
               // waste container is full
         		if(SensorWertLevel != 0)
         		{
                  // close valve K
                  SwitchNPSolenoidValve(NP_SolenoidValve_K, 0, ML_STAR);
                  
            		if	( hslCancel == MessageBox( StringTable::Load(IDS::dlgNanoWasteContainerHand),
            								TitleNanopipettor, hslOKCancel | hslInformation, hslInfinite ))
                     abort;

                  // open valve K
                  SwitchNPSolenoidValve(NP_SolenoidValve_K, 1, ML_STAR);
               }
            }
         }

         NanoTimeWait(5, TitleNanopipettor, 0);
         // close valve K
         SwitchNPSolenoidValve(NP_SolenoidValve_K, 0, ML_STAR);

      }
      return (errCode);
   }

	//-----------------------------------------------------------------------------------------------------
   function EmptyUltraSonicBathSpecial(device ML_STAR, variable TitleNanopipettor, variable onlyTubes)
	//-----------------------------------------------------------------------------------------------------
   {
		string answer;
		variable errCode;
      variable bRepeat(1);
		variable SensorWertLevel(1);


      // check for empty refill container
      while(bRepeat)
      {
         // check for empty refill conatiner
         RequestLiquidLevelSensors(SensorWertLevel, RefillReservoirLiquidLevelSensor_1, ML_STAR );
         // waste container is full
   		if(SensorWertLevel != 0)
   		{
      		if	( hslCancel == MessageBox( StringTable::Load(IDS::dlgNanoRefillContainerNeedsToBeEmpty),
      								TitleNanopipettor, hslOKCancel | hslInformation, hslInfinite ))
               abort;
         }
         else
            bRepeat = 0;
      }

      // empty the tubes
      // open valve T
      errCode = SwitchNPSolenoidValve(NP_SolenoidValve_T, 1, ML_STAR);
      if(errCode == 0)
      {
         errCode = StartNanoRefillPump(ML_STAR);
         if(errCode == 0)
         {
            NanoTimeWait(30, TitleNanopipettor, 0);
            StopNanoRefillPump(ML_STAR);
         }
      }
      // close valve T
      SwitchNPSolenoidValve(NP_SolenoidValve_T, 0, ML_STAR);

      if(errCode != 0)
         abort;
      
      // empty ultra sonic bath ( if needed )
      if(onlyTubes == 0)
         errCode = EmptyUltrasonicBath( ML_STAR );

      return (errCode);
   }

	//-----------------------------------------------------------------------------------------------------
   function CleanDecontaminateNanoSystem(
      device ML_STAR, variable Channel_N_Head,
      variable traceAction, variable TitleNanopipettor, variable msgBoxText)
	//-----------------------------------------------------------------------------------------------------
   {
		string answer;
		variable errCode;
      variable bRepeat(1);
		variable primeMode(2);

      // inform user to fill up the refill container
		if	( hslCancel == MessageBox( msgBoxText, TitleNanopipettor, hslOKCancel | hslInformation, hslInfinite ))
         abort;

      // check sensor level 2 for available refill fluid
      while(bRepeat)
      {
			variable SensorWertLevel_LR2;


		  	errCode = RequestLiquidLevelSensors(SensorWertLevel_LR2, RefillReservoirLiquidLevelSensor_2, ML_STAR );
	     	if (errCode != 0 )
            return(errCode);

        	if (SensorWertLevel_LR2 == 1 )
            bRepeat = 0;
         else
      		if	( hslCancel == MessageBox( msgBoxText, TitleNanopipettor, hslOKCancel | hslInformation, hslInfinite ))
               abort;
      }

     	// primeMode = 2,
      // Refill = ON,  Sparging = ON,  Dry = OFF, Prime Liq System = ON,  Prime Pipettor = OFF, Flush Pipettor ON
      ML_STAR._ADA99A27_16B3_4a5a_9159_D3BCCF03F78F( "58cfec05_9bc7_4645_8217d32d2e0b2d10" ); // NanoFillSystem

      errCode = NanoMoveToWaste( ML_STAR, Channel_N_Head, traceAction);
      return (errCode);
   }

	//-----------------------------------------------------------------------------------------------------
	function NanoTimeWait( variable seconds, variable title, variable cancelAllowed)
	//-----------------------------------------------------------------------------------------------------
	{
		timer nanoTimer;
      variable errCode(0);
      variable withCancelBtn(hslFalse);

      // set timer title
  		nanoTimer.SetTimerViewName(title);
      if(cancelAllowed == 1)
         withCancelBtn = hslTrue;

		// set timer and wait for signal
		if ( 0 == nanoTimer.SetTimer(seconds))
		{
			err.Raise( IDE::timerSetError, StringTable::Load(IDE::timerSetError));
		}
      // 0 = error, != 0 error, or haslAbort if stop timer pressed
      errCode = nanoTimer.WaitTimer(hslTrue, withCancelBtn);
		if ( errCode == 0 )
		{
			err.Raise( IDE::timerWaitError, StringTable::Load(IDE::timerWaitError));
		}
      if(errCode != hslAbort)
         errCode = 0;

		return (errCode);

	} // end NanoTimeWait



	//*****************************************************************************************************
   //
   // function of Easy Puncher
   //
	//*****************************************************************************************************

   //-----------------------------------------------------------------------------------------------------
	function EasyPuncher_MaintenanceDaily( device ML_STAR) variable
   //-----------------------------------------------------------------------------------------------------
   {
      string   titlePuncher;

  		titlePuncher = StringTable::Load(IDS::easyPunchDlgTitle);

      return ( easyPunchDailyMaintenance(ML_STAR, titlePuncher) );
   }

   //-----------------------------------------------------------------------------------------------------
	function EasyPuncher_MaintenanceWeekly( device ML_STAR) variable
   //-----------------------------------------------------------------------------------------------------
   {
      string   titlePuncher;
      string   msgBoxText;
      string   closeCoverTxt;

      // load box title
		titlePuncher = StringTable::Load(IDS::easyPunchDlgWTitle);
      closeCoverTxt = StringTable::Load(IDS::easyPunchCloseFrontCover);

      if( ! easyPunchDailyMaintenance( ML_STAR, titlePuncher ))
         return (hslFalse);

      // execute second part of weekly maintenance
      easyPuncherState = PS::open;

   	// Unlock front cover
   	LockCover(ML_STAR, CoverLock::coverUnlock, "", "");

      // inform user to clean the cleaning punch waste
		msgBoxText = StringTable::Load(IDS::easyPunchDlgCleanDustWaste);
		if	( hslCancel == MessageBox( msgBoxText, titlePuncher, hslOKCancel | hslInformation, hslInfinite ))
      {
      	LockCover(ML_STAR, CoverLock::coverLock, closeCoverTxt, titlePuncher);
         return( hslFalse );
      }

     	if(!LockCover(ML_STAR, CoverLock::coverLock, closeCoverTxt, titlePuncher))
         return( hslFalse );

      // card handler move to front
      FwCommand( "CHYA", "ya025000", hslFalse, ML_STAR);
      // card handler card gripper open
      FwCommand( "CHHP", "hp1", hslFalse, ML_STAR);
      // card handler card gripper horizontal
      FwCommand( "CHGP", "gp1", hslFalse, ML_STAR);

   	// Unlock front cover
   	LockCover(ML_STAR, CoverLock::coverUnlock, "", "");

      // inform user to clean the cleaning punch waste
		msgBoxText = StringTable::Load(IDS::easyPunchDlgCleanGripClamp);
		if	( hslCancel == MessageBox( msgBoxText, titlePuncher, hslOKCancel | hslInformation, hslInfinite ))
      {
         // card handler card gripper park
         FwCommand( "CHMH", "", hslFalse, ML_STAR);
         return( hslFalse );
      }

     	if(!LockCover(ML_STAR, CoverLock::coverLock, closeCoverTxt, titlePuncher))
         return( hslFalse );

      // card handler card gripper park
      FwCommand( "CHMH", "", hslFalse, ML_STAR);

      // check xyz position of card gripper
      if(!executePunchGripperAlignment(ML_STAR, titlePuncher))
      {
         easyPuncherState = PS::failed;
         return (hslFalse);
      }

      easyPuncherState = PS::successful;

		return (hslTrue);
   }

   //-----------------------------------------------------------------------------------------------------
   static function easyPunchMovePuncherHead(device ML_STAR,  variable moveToReplacePosition)
   //-----------------------------------------------------------------------------------------------------
   {
      variable parameter("pp1"); // move puncher head to replace position
      if(moveToReplacePosition == hslFalse)
         parameter = "pp0";      // move puncher head up to init position
      FwCommand( "CPPP", parameter, hslFalse, ML_STAR);
   }

   //-----------------------------------------------------------------------------------------------------
   static function easyPunchDailyMaintenance(device ML_STAR, string title) variable
   //-----------------------------------------------------------------------------------------------------
   {
      string   answer("");
      variable parameter("");
      variable param_result("");
      string   msgBoxText("");
      variable punchCurFwCount(0);
      variable punchUsedCount(0);
      variable punchNextStartCount(0);
      string   puncherSN("");
      string   puncherPN("");
      string   boxPuncherSN("");
      string   boxPuncherPN("");
      variable loopCheck(hslTrue);
      string   closeCoverTxt;


      closeCoverTxt = StringTable::Load(IDS::easyPunchCloseFrontCover);

      // Arm is set already to the right side, position the frame to front right
      parameter = "cp4";
      answer = FwCommand( "CPCP", parameter, hslFalse, ML_STAR);

      // move puncher head to replace position
      easyPunchMovePuncherHead(ML_STAR, hslTrue);
 //     parameter = "pp1";
 //     FwCommand( "CPPP", parameter, hslFalse, ML_STAR);

   	// Unlock front cover
   	LockCover(ML_STAR, CoverLock::coverUnlock, "", "");

      // inform user to clean the cleaning punch waste
		msgBoxText = StringTable::Load(IDS::easyPunchDlgCleanWaste);
		if	( hslCancel == MessageBox( msgBoxText, title, hslOKCancel | hslInformation, hslInfinite ))
      {
      	LockCover(ML_STAR, CoverLock::coverLock, closeCoverTxt, title);
         easyPunchMovePuncherHead(ML_STAR, hslFalse);
         return( hslFalse );
      }

      // inform user to remove and clean the frame
		msgBoxText = StringTable::Load(IDS::easyPunchDlgCleanFrame);
		if	( hslCancel == MessageBox( msgBoxText, title, hslOKCancel | hslInformation, hslInfinite ))
      {
      	LockCover(ML_STAR, CoverLock::coverLock, closeCoverTxt, title);
         easyPunchMovePuncherHead(ML_STAR, hslFalse);
         return( hslFalse );
      }

      // inform user to clean the glass deck
		msgBoxText = StringTable::Load(IDS::easyPunchDlgCleanDeck);
		if	( hslCancel == MessageBox( msgBoxText, title, hslOKCancel | hslInformation, hslInfinite ))
      {
      	LockCover(ML_STAR, CoverLock::coverLock, closeCoverTxt, title);
         easyPunchMovePuncherHead(ML_STAR, hslFalse);
         return( hslFalse );
      }

      // read last punch count of active puncher head (from file)
      punchUsedCount = CalculateUsedPunchCount(ML_STAR, puncherSN, puncherPN);

      // inform user to remove and clean the punch head and view the current punch count
		msgBoxText = StringTable::Load(IDS::easyPunchDlgCleanHead);
  		StrReplace(msgBoxText, "%s", IStr(punchUsedCount));
		if	( hslCancel == MessageBox( msgBoxText, title, hslOKCancel | hslInformation, hslInfinite ))
      {
      	LockCover(ML_STAR, CoverLock::coverLock, closeCoverTxt, title);
         easyPunchMovePuncherHead(ML_STAR, hslFalse);
         return( hslFalse );
      }

      while(loopCheck)
      {
         variable headTotCount(0);
         variable boxRetVal;
         loopCheck = hslTrue;

         boxPuncherSN = "";
         while((boxPuncherSN.GetLength() != 4) )
         {
      		// Enter easyPunch head SN
         	boxRetVal = InputBox(StringTable::Load(IDS::easyPunchDlgInsertSN), title, hslString, puncherSN);
            // check for cancel
            if(GetType(boxRetVal) == "")
            {
            	LockCover(ML_STAR, CoverLock::coverLock, closeCoverTxt, title);
               easyPunchMovePuncherHead(ML_STAR, hslFalse);
               return( hslFalse );
            }

            boxPuncherSN = boxRetVal;
         }
         puncherSN = boxPuncherSN;

         boxPuncherPN = "";
         while(boxPuncherPN.GetLength() != 9)
         {
      		// Enter easyPunch head PN
         	boxRetVal = InputBox(StringTable::Load(IDS::easyPunchDlgInsertPN), title, hslString, puncherPN);
            // check for cancel
            if(GetType(boxRetVal) == "")
            {
            	LockCover(ML_STAR, CoverLock::coverLock, closeCoverTxt, title);
               easyPunchMovePuncherHead(ML_STAR, hslFalse);
               return( hslFalse );
            }

            boxPuncherPN = boxRetVal;
            if(boxPuncherPN.GetLength() > 6)
            {
               if(boxPuncherPN.Mid(6,1) != "/")
                  boxPuncherPN = "";
            }
         }
         puncherPN = boxPuncherPN;

         headTotCount = SetCleanedPunchHead(puncherSN, puncherPN);

         // check current punchHead punching cycles
         if(headTotCount > PuncherCount::PuncherCountHeadLifeCycles)
         {
            string msgBoxText;
            // inform user to mount a new easyPunch head
            // Used easyPunch head (Serial No: %s1, Part No: %s2) has reached the maximum of %s3 punch cycles and should be exchange.\n\nPress Cancel if you want to exchange the easyPunch head");
      		msgBoxText = StringTable::Load(IDS::easyPunchDlgChangeHead);
        		StrReplace(msgBoxText, "%s1", puncherSN);
        		StrReplace(msgBoxText, "%s2", puncherPN);
            StrReplace(msgBoxText, "%s3", PuncherCount::PuncherCountHeadLifeCyclesTxt);
      		if	( hslNo == MessageBox( msgBoxText, title, hslYesNo | hslExclamation, hslInfinite ))
               loopCheck = hslFalse;
         }
         else
            loopCheck = hslFalse;
      }

      // inform user to mount the new head
      // "Please mount the cleaned or new easyPunch head with Serial No: %s1 and Part No: %s2.");
		msgBoxText = StringTable::Load(IDS::easyPunchDlgMountHead);
  		StrReplace(msgBoxText, "%s1", puncherSN);
  		StrReplace(msgBoxText, "%s2", puncherPN);
		if	( hslCancel == MessageBox( msgBoxText, title, hslOKCancel | hslInformation, hslInfinite ))
      {
      	LockCover(ML_STAR, CoverLock::coverLock, closeCoverTxt, title);
         easyPunchMovePuncherHead(ML_STAR, hslFalse);
         return( hslFalse );
      }

     	if(!LockCover(ML_STAR, CoverLock::coverLock, closeCoverTxt, title))
      {
         easyPunchMovePuncherHead(ML_STAR, hslFalse);
         return( hslFalse );
      }

      easyPunchMovePuncherHead(ML_STAR, hslFalse);

      if(!checkIonisatorState(ML_STAR, title))
      {
         easyPuncherState = PS::failed;
         return (hslFalse);
      }
      else
         easyPuncherState = PS::successful;
      
      // monitoring lag error data
      //checkEasyPunchMovements(ML_STAR);

		return (hslTrue);
   }


   //-----------------------------------------------------------------------------------------------------
	static function CalculateUsedPunchCount(device ML_STAR, string &puncherSN, string &puncherPN) variable
   //-----------------------------------------------------------------------------------------------------
	{
  		//*******************************************************************************************
  		// Manage the head punch - count file and calculate the punch count for each puncher head
		//*******************************************************************************************
      variable openRet(0);
		object   fso; // File System Object
		file     fPunchParams;
		file     fPunchHeadParams;
		string   fileName("");
		string   fileHeadName("");
      string   answer;
		string   rw_curSN("0000");
      string   rw_curPN("000000_00");
		variable rw_curStCount(0);
		variable rw_maxHeadCount(0);
		variable fwCount;
		variable usedCount(0);
      variable headTotCount(0);
      variable newHead(hslTrue);

		onerror goto Unexpected;

      // initalize parameter
      puncherSN = "";
      puncherPN = "";
      headTotCount = 0;

      // read punch count from firmware
      answer = FwCommand( "CPRV", "", hslFalse, ML_STAR);
		fwCount = ParseFwResult(answer, "na", 10);
		fwCount = StrIVal(StrTrimLeft(fwCount, "0"));
//      Trace("Test: Punch count: ", fwCount);

		// read default parameters from file
		fPunchParams.AddField("punchSN", rw_curSN, hslString);
		fPunchParams.AddField("punchPN", rw_curPN, hslString);
		fPunchParams.AddField("punchStartCount", rw_curStCount, hslInteger);

		fileName = PuncherCount::PuncherCountFile;
		StrReplace(fileName, "%s", instrSerialNo);
      fileName = GetSystemPath() + fileName;

      // create file if not exist
		fso.CreateObject("Scripting.FileSystemObject");
		if(!fso.FileExists(fileName))
		{
   		fileName = fileName + PuncherCount::PuncherCountCurrentTableName;

         // create the base File with current table
   		if(0 != fPunchParams.Open( fileName , hslAppend ) )
         {
            fPunchParams.WriteRecord();
   			fPunchParams.Close();
         }
      }
      else
      {
		   fileName = fileName + PuncherCount::PuncherCountCurrentTableName;
      }

   
      // read instrument count and head data
      openRet = fPunchParams.Open( fileName , hslRead );
		if(0 != openRet )
		{
			fPunchParams.ReadRecord();
			fPunchParams.Close();

         // read serienumber is set
         if(rw_curSN.Find("0000") < 0)
         {
            // set count of current punch head
      		fPunchHeadParams.AddField("maxHeadCount", rw_maxHeadCount, hslInteger);

            // create head file if not exist
      		fileHeadName = PuncherCount::PuncherCountFile;
      		StrReplace(fileHeadName, "%s", rw_curSN+rw_curPN);
            fileHeadName = GetSystemPath() + fileHeadName;

      		if(!fso.FileExists(fileHeadName))
      		{
               newHead = hslTrue;
           		fileHeadName = fileHeadName + PuncherCount::PuncherCountCurrentTableName;

               // create the base File with current table
         		if(0 != fPunchHeadParams.Open( fileHeadName , hslAppend ) )
               {
                  fPunchHeadParams.WriteRecord();
         			fPunchHeadParams.Close();
               }
            }
            else
            {
           		fileHeadName = fileHeadName + PuncherCount::PuncherCountCurrentTableName;
               newHead = hslFalse;
            }
         }
	
         // read head count if serial number is set
         if(fileHeadName.GetLength() > 0)
         {
            // read count of current punch head
            openRet = fPunchHeadParams.Open( fileHeadName , hslRead );
      		if(0 != openRet )
      		{
      			fPunchHeadParams.ReadRecord();
      			fPunchHeadParams.Close();

               puncherSN = rw_curSN;
               puncherPN = rw_curPN;
               StrReplace(puncherPN, "_", "/");
            }
         }
      }

      // calculate different count (no negative value)
      if(rw_curStCount > fwCount)
         rw_curStCount = fwCount;
      usedCount = fwCount - rw_curStCount;
      headTotCount = rw_maxHeadCount + usedCount;
      usedCount = headTotCount;

      // save the new start and head total count
      openRet = fPunchParams.Open( fileName , hslWrite );
		if(0 != openRet )
		{
			// update current start count
			rw_curStCount = fwCount;

			fPunchParams.WriteRecord();
			fPunchParams.Close();

         // serienumber is set
         if(fileHeadName.GetLength() > 0)
         {
            openRet = fPunchHeadParams.Open( fileHeadName , hslWrite );
      		if(0 != openRet )
      		{
               // update max head count
               rw_maxHeadCount = headTotCount;
      			fPunchHeadParams.WriteRecord();
      			fPunchHeadParams.Close();
            }
         }

      }

		Unexpected :
		{
		}
      // ignore the current puncher count is a new head is installed (usedCount will be view in dialog)
      if(newHead)
         usedCount = 0;

      TraceSTARWatchData(ML_STAR, "CP", STARWatch::easyPunchHeadCount, "Punch head P/N S/N", puncherPN, puncherSN, STARWatch::statusOK,
         "Punch head cycles", "0", PuncherCount::PuncherCountHeadLifeCyclesTxt, IStr(usedCount));

      return (usedCount);
      	
	} // end CalculateUsedPunchCount


   //-----------------------------------------------------------------------------------------------------
	static function SetCleanedPunchHead(variable puncherSN, variable puncherPN) variable
   //-----------------------------------------------------------------------------------------------------
	{
  		//*******************************************************************************************
  		// Set serie and part number af current used puncher head and return the actually used punch count
		//*******************************************************************************************
		object   fso; // File System Object
		file     fPunchParams;
		file     fPunchHeadParams;
		string   fileName("");
		string   rw_curSN;
      string   rw_curPN;
      variable rw_maxHeadCount(0);
      variable openRet(0);


		onerror goto Unexpected;

		// read default parameters from file
		fPunchParams.AddField("punchSN", rw_curSN, hslString);
		fPunchParams.AddField("punchPN", rw_curPN, hslString);

		fileName = PuncherCount::PuncherCountFile;
		StrReplace(fileName, "%s", instrSerialNo);
      fileName = GetSystemPath() + fileName;
		fileName = fileName + PuncherCount::PuncherCountCurrentTableName;

      openRet = fPunchParams.Open( fileName , hslAppend );
		if(0 != openRet )
   	{
			fPunchParams.ReadRecord();
         rw_curSN = puncherSN;
         rw_curPN = puncherPN;
         StrReplace(rw_curPN, "/", "_");

  			fPunchParams.Seek(0, hslFirst);
  			fPunchParams.UpdateRecord();
			fPunchParams.Close();


   		fileName = PuncherCount::PuncherCountFile;
   		StrReplace(fileName, "%s", rw_curSN+rw_curPN);
         fileName = GetSystemPath() + fileName;

         // set count of current punch head
   		fPunchHeadParams.AddField("maxHeadCount", rw_maxHeadCount, hslInteger);

         // create head file if not exist (new head)
   		fso.CreateObject("Scripting.FileSystemObject");
   		if(!fso.FileExists(fileName))
         {
      		fileName = fileName + PuncherCount::PuncherCountCurrentTableName;

            // be sure the table table SN PN is available
            openRet = fPunchHeadParams.Open( fileName , hslAppend );
      		if(0 != openRet )
      		{
      			fPunchHeadParams.WriteRecord();
      			fPunchHeadParams.Close();
            }
         }
         else
         {
      		fileName = fileName + PuncherCount::PuncherCountCurrentTableName;

            // be sure the table table SN PN is available
            openRet = fPunchHeadParams.Open( fileName , hslRead );
      		if(0 != openRet )
      		{
      			fPunchHeadParams.ReadRecord();
      			fPunchHeadParams.Close();
            }
         }
      }

		Unexpected :
		{
		}

      return (rw_maxHeadCount);

	} // end SetCleanedPunchHead


   //-----------------------------------------------------------------------------------------------------
   static function checkIonisatorState(device ML_STAR, string title) variable
   //-----------------------------------------------------------------------------------------------------
   {
  		//*******************************************************************************************
  		// Check ionisator state and meassure the drive lag 
		//*******************************************************************************************
      string parameter;
      string answer;
      variable sensorVal(0);
      variable retVal(hslTrue);
      variable starWatchState(STARWatch::statusOK);
      timer ionisatorTimer;

		onerror goto Unexpected;

      // start ionisator
      FwCommand( "CPIF", "if1", hslFalse, ML_STAR);
      // wait 3 seconds until ionisator is working
      if(ionisatorTimer.SetTimer(3))
         ionisatorTimer.WaitTimer(hslFalse);

      // read ionisator state
      answer = FwCommand( "CPRI", "", hslFalse, ML_STAR);
      // stop ionisator
      FwCommand( "CPIF", "if0", hslFalse, ML_STAR);
  		parameter = ParseFwResult(answer, "ri", 7);
  		answer = ParseFwResult(answer, "ri", 1);
      sensorVal = IVal(answer);

      if(sensorVal > 2)
      {
         string traceText;

         // "Ionisator state check failed expected 1 returned > %s.");
			traceText = StringTable::Load(IDS::easyPunchIonisatorStateFailed);
			StrReplace(traceText, "%s", answer);
			Trace(title, traceText);

         retVal = hslFalse;
         starWatchState = STARWatch::statusFailed;
      }
      TraceSTARWatchData(ML_STAR, "CP", STARWatch::jonisatorState, "", "0000", "00", starWatchState, "Jonisator state", "1", "2", answer);

      return (retVal);

		Unexpected :
		{
         return (hslFalse);
		}


   }


	//------------------------------------------------------------------------------
	private function searchFingerPositions(device ML_STAR, variable ySearchDirection, variable& xPos, variable& yPos, variable& zPos) variable
	//------------------------------------------------------------------------------
   //	Search Finger Positions on PuncherHead
   {
      const variable XStartPos(600);  // [0.1mm] : 60mm
      const variable X_Offset(400);  // [0.1mm]  : 40mm
      const variable ZStartPos(2975); // [0.1mm] : +297.5mm
             
      variable prefix(1.0);
      variable prm(""), yd(""), yd_inv(""), ys("");
      variable response("");
      variable index;

      xPos = yPos = zPos = -99;

      // Synchronize x arm-positions
      FwCommand( "C0RU","", hslTrue, ML_STAR);
      FwCommand( "X0RX","", hslFalse, ML_STAR);
      // Move card handler in front of puncher head  XStartPosition (bc = 60mm)
      FwCommand( "C0BH",StrConcat4("di2bc",XStartPos,"xd0bk000yd0th2850bl000cy000bo0",""), hslTrue, ML_STAR);
      // move card handler -17mm in Z direction
      FwCommand( "CHAA","zv05000", hslTrue, ML_STAR);
      FwCommand( "C0BZ","bl170zd1", hslTrue, ML_STAR);
     
      if(ySearchDirection > 0)
      { // positive direction
         prefix = -1.0;
         yd     = "yd0";
         yd_inv = "yd1";
         ys     = "ys-008000";
      }
      else
      {
         yd     = "yd1";
         yd_inv = "yd0";
         ys     = "ys+008000";
      }
      // move card handler in Y direction : e.g +/- 34.5 mm (my1/2 -3mm)     
      prm = "bk"+ StrFillLeft(IStr(Ceiling(cardGripperYstepResGripper*my1/2.0 -30)), "0", 3) + yd;
      FwCommand( "C0BY",prm, hslTrue, ML_STAR);

      // x pre-position of (left) arm = x position puncher head (pc0) + diverse offset values (mx2,mx0,kq) - 1mm + X_Offset (40mm)
      prm = "xs"+ StrFillLeft(IStr(Ceiling(pc0)+mx2+mx0+kq+X_Offset-10), "0", 5);
  		FwCommand("C0JX",prm,hslTrue, ML_STAR);

      // move card handler  below puncher head  : move arm X_Offset in negative direction
      prm = "xd1bc"+ StrFillLeft(IStr(X_Offset), "0", 3);
      FwCommand( "C0BX",prm, hslTrue, ML_STAR);

      // search Z-Position of front/rear finger 
   	// -----------------------------------------------------------------	
      // switch on LLD
      FwCommand( "CHAL","al1", hslTrue, ML_STAR);
      response = FwCommand( "CHZJ","zs+03000zv00300", hslTrue, ML_STAR);
      // Gripper finger Z position = measured Z position + mz1 
		zPos = cardGripperZstepResGripper * (IVal(StrMid(response, StrReverseFind(response,"rz")+2, 6) ) + mz1); // measured Z value [0.1mm]
      // move card handler -1mm in Z direction
      FwCommand( "CHAA","zv05000", hslTrue, ML_STAR);
      FwCommand( "C0BZ","bl010zd1", hslTrue, ML_STAR);

      // move card handler in Y direction : +/-15 mm 
      FwCommand( "C0BY","bk150"+ yd, hslTrue, ML_STAR);
      // move card handler +2.5mm in Z direction
      FwCommand( "C0BZ","bl025zd0", hslTrue, ML_STAR);

      // search Y-Position of front/rear finger 
   	// -----------------------------------------------------------------	
      response = FwCommand( "CHYJ",ys + "yv000500", hslTrue, ML_STAR);
      // Gripper finger Y position = measured Y position + my0 +/- my/2
		yPos = cardGripperYstepResGripper * (IVal(StrMid(response, StrReverseFind(response,"ry")+2, 6) ) + my0 + prefix * my1/2.0 ); // measured Y value [0.1mm]
      // move card handler +1mm in Y direction
      FwCommand( "CHAA","zv70000yv100000", hslTrue, ML_STAR);
      FwCommand( "C0BY","bk010"+ yd, hslTrue, ML_STAR);

      // search X-Position of front/rear finger 
   	// -----------------------------------------------------------------	
      // move card handler +10mm in X direction
      FwCommand( "C0BX","bc100xd0", hslTrue, ML_STAR);
      // move card handler -/+8mm in Y direction
      FwCommand( "C0BY","bk080" + yd_inv, hslTrue, ML_STAR);

      // switch on LLD
      FwCommand( "CHAL","al1", hslTrue, ML_STAR);
      // Request LLD
      FwCommand( "CHRN","", hslFalse, ML_STAR);

      for(index = 0; index < 500; index++)
      {
         FwCommand( "X0XR","ls00001lt1", hslTrue, ML_STAR);

         response = FwCommand( "CHRN","", hslFalse, ML_STAR);
         if(IVal(StrMid(response, StrReverseFind(response,"rn")+2, 1)) > 0 )
            break;
      }
      if(index < 500)
      {  // Request X-Value
         response = FwCommand( "X0RX","", hslFalse, ML_STAR);
         // Gripper finger X position = measured X position - mx2 -mx0 - kq
		   xPos = IVal(StrMid(response, StrReverseFind(response,"rx")+2, 7) )  - mx2 -mx0 - kq ; // measured X value  [0.1mm]
      }
      // switch off LLD
      FwCommand( "CHAL","al0", hslTrue, ML_STAR);

      // move card handler +40mm in X direction
      FwCommand( "C0BX","bc400xd0", hslTrue, ML_STAR);

      // Synchronize x arm-positions
      FwCommand( "X0RX","", hslFalse, ML_STAR);
      FwCommand( "C0RU","", hslTrue, ML_STAR);

      return(hslTrue);
   } // ---- End of function "searchFingerPositions"

	//------------------------------------------------------------------------------
   static function initPuncherAdjustVariables(device ML_STAR)
	//------------------------------------------------------------------------------
   //	Init Card Handler variables
 	{
      variable response;


      // Get stored adjustment data
   	// -----------------------------------------------------------------
      // Puncher head position values (center puncher) : CPRArapc [increments puncher]
      response = FwCommand( "CPRA","rapc", hslFalse, ML_STAR);

      pc0 = cardGripperXstepResPuncher * FVal(StrMid(response, StrReverseFind(response,"pc")+2, 7) ); // x coordinate [0.1mm] 
      pc1 = cardGripperYstepResPuncher * FVal(StrMid(response, StrReverseFind(response,"pc")+10, 7) ); // y coordinate [0.1mm] 
      pc2 = cardGripperZstepResPuncher * FVal(StrMid(response, StrReverseFind(response,"pc")+18, 7) ); // delta z coordinate [0.1mm]  ; offset between middle of aperture and bottom edge
//Trace("Test: ",GetFunctionName() ," : Get stored puncher head data: pc0 =>",pc0,"[0.1mm]<   pc1 =>",pc1,"[0.1mm]<   pc2 =>",pc2,"[0.1mm]<==");

      // Arm/gripper offset: C0RArakq
      // kq####      2980          Set X-offset X- axis arm <=> Puncher plate gripper center
      response = FwCommand( "C0RA","rakq", hslFalse, ML_STAR);
      kq = IVal(StrMid(response, StrReverseFind(response,"kq")+2, 4) );
      // CHQH Request Gripper Type Geometry Values
      response = FwCommand( "CHQH","", hslFalse, ML_STAR);
      // mx####      0913     mx0: [0.1mm] Middle of Cardgripper to Pos.Marker (Gripfinger horizontal), adjusted value
      mx0 = IVal(StrMid(response, StrReverseFind(response,"mx")+2, 4) );
      //    ####     0533     mx1: [0.1mm] Middle of Cardgripper to CardPickPos (Gripfinger vertical), adjusted value
      mx1 = IVal(StrMid(response, StrReverseFind(response,"mx")+7, 4) );
      //    ####     0365     mx2: [0.1mm] End of Cardgripfinger to Pos.Marker (Gripfinger horizontal)
      mx2 = IVal(StrMid(response, StrReverseFind(response,"mx")+12, 4) );

      // my#####     0        my0: [incr] Mid. of GripperHead to Middle of Cardgripper(Gripper horizontal) , adjusted value
      my0 = IVal(StrMid(response, StrReverseFind(response,"my")+2, 5 ) );
      //    #####    24107    my1: [incr] Cardgripper Witdh between PosMarker (Gripper horizontal):  (24107inc = 75.0mm), adjusted value
      my1 = IVal(StrMid(response, StrReverseFind(response,"my")+8, 5 ) );

      // mz#####     9370     mz0: [incr] Plategripper Peaks to Pos.Marker (Gripper vertical): 36.60 mm => 09370 [inc], adjusted value
      mz0 = IVal(StrMid(response, StrReverseFind(response,"mz")+2, 5 ) );
      //    #####    7398     mz1: [incr] Plategripper Peaks to lower edge CardGripper (Gripper horizontal): 28.9 mm => 7398[inc], adjusted value
      mz1 = IVal(StrMid(response, StrReverseFind(response,"mz")+8, 5 ) );
      //                      
//Trace("Test: ",GetFunctionName() ," : Get stored adjustment data: kq =>",kq,"<  mx0 =>",mx0,"<   mx1 =>",mx1,"<   mx2 =>",mx2,"<   my0 =>",my0,"<    my1 =>",my1,"<    mz0 =>",mz0,"<    mz1 =>",mz1,"<==");

   }

	//------------------------------------------------------------------------------
	static function executePunchGripperAlignment(device ML_STAR, string title) variable
	//------------------------------------------------------------------------------
   //	Check Card Handler Position relative to Punch Head Position
 	{
      const variable puncherRadius(50); // 5mm
      const variable XStartPos(700);  // [0.1mm]  
      const variable ZStartPos(2975); // [0.1mm]  
      const variable frontFinger(1); 
      const variable rearFinger(-1); 

   	variable retVal(hslTrue);
   	variable response("");
      variable prm("");
      variable deltaX(0.0);
      variable deltaY(0.0);
      variable deltaZ(0.0);
      variable deltaP(0.0); // parallel
      variable deltaH(0.0); // horizontal
      variable xPosAtPuncher(""), yPosAtPuncher("");
      variable xPos, yPos, zPos;
   	variable arrNominalPositions[];  // array of calculated nominal positions 
   	variable arrMeasuredPositions[]; // array of meassured X1, X2, Y1, Y2, Z1, Z2 positions
      variable starWatchState(STARWatch::statusOK);
      variable starWatchMin, starWatchMax;
		string param;

		onerror goto errorHandling;

      arrNominalPositions.SetSize( 0 );
      arrMeasuredPositions.SetSize( 0 );
   	// -----------------------------------------------------------------
      loop( 6 ) 
      { // 
         arrMeasuredPositions.AddAsLast( 0.0 );
         arrNominalPositions.AddAsLast( 0.0 );
      }

      initPuncherAdjustVariables(ML_STAR);


      // Calculate nominal positions
      // X-Position for X0RX values: +262.1mm (pc0, center puncher) + 5mm (radius punch matrix)
      arrNominalPositions.SetAt( 0, pc0 + puncherRadius ); // [0.1mm]
      arrNominalPositions.SetAt( 1, arrNominalPositions.GetAt( 0) );

      // Y-Position for CHRY values: +49.7mm (pc1, center puncher) +/-( 5mm (radius punch matrix)  )
      arrNominalPositions.SetAt( 2, pc1 + puncherRadius ); // [0.1mm]
      arrNominalPositions.SetAt( 3, pc1 - puncherRadius );     // [0.1mm]

      // Z-Position for CHRZvalues: +297.5mm (center puncher) (delta z coordinate)
      arrNominalPositions.SetAt( 4, ZStartPos); // [0.1mm]
      arrNominalPositions.SetAt( 5, arrNominalPositions.GetAt( 4) );

      // Pre-position gripper and puncher
   	// -----------------------------------------------------------------	
      // Move card handler in front of puncher head  :bc = 60mm
      FwCommand( "C0BH","di2bc600xd0bk000yd0th2850bl000cy000bo0", hslTrue, ML_STAR);
      FwCommand( "CHGP","gp1", hslTrue, ML_STAR);
      // move puncher head in z position
      FwCommand( "C0BU",StrConcat2("bm",ZStartPos), hslTrue, ML_STAR);
      // move up puncher stamp
      FwCommand( "CPPP","pp0", hslTrue, ML_STAR);

   	//  Search Front Finger Positions of Card Handler 
   	// -----------------------------------------------------------------	
      if( !searchFingerPositions(ML_STAR, frontFinger, xPos, yPos, zPos) )
         return(hslFalse);
      arrMeasuredPositions.SetAt( 0, xPos); // measured X value
      arrMeasuredPositions.SetAt( 2, yPos); // measured Y value
      arrMeasuredPositions.SetAt( 4, zPos); // measured Z value

   	//  Search Rear FingerPositions of Card Handler 
   	// -----------------------------------------------------------------	
      if( !searchFingerPositions(ML_STAR, rearFinger, xPos, yPos, zPos) )
         return(hslFalse);
      arrMeasuredPositions.SetAt( 1, xPos); // measured X value
      arrMeasuredPositions.SetAt( 3, yPos); // measured Y value
      arrMeasuredPositions.SetAt( 5, zPos); // measured Z value

   	// -----------------------------------------------------------------
      // Park card handler
   	// -----------------------------------------------------------------
      // move card handler +50mm in X direction
      FwCommand( "C0BW","", hslTrue, ML_STAR);
      FwCommand( "CHAA","zv35000", hslFalse, ML_STAR);

   	// -----------------------------------------------------------------
      // Calculate gripper alignment deviations
   	// -----------------------------------------------------------------

      // X deviation: delta = (Xmeasrured - Xstored)
      deltaX = 0.1 * 0.5*(arrMeasuredPositions.GetAt(0) + arrMeasuredPositions.GetAt(1)- arrNominalPositions.GetAt(0)- arrNominalPositions.GetAt(1)); //[mm]
//Trace("");
//Trace("Test: X-direction : 1st position: Measured  =>", arrMeasuredPositions.GetAt(0),"<  calculated nominal value =>",arrNominalPositions.GetAt(0),"<=="); 
//Trace("Test: X-direction : 2nd position: Measured  =>", arrMeasuredPositions.GetAt(1),"<  calculated nominal value =>",arrNominalPositions.GetAt(1),"<=="); 
//Trace("Test: Gripper Alignment X deviation  =>",  deltaX);

      // Y deviation: delta = (Y1measrured +Y2measrured)/2 - (Y1stored+Y2stored)/2
      deltaY = 0.1 * 0.5*(arrMeasuredPositions.GetAt(2) + arrMeasuredPositions.GetAt(3)- arrNominalPositions.GetAt(2)- arrNominalPositions.GetAt(3)); // [mm]
//Trace("Test: Y-direction 1st position: Measured  value =>", arrMeasuredPositions.GetAt(2),"<  calculated nominal value =>",arrNominalPositions.GetAt(2),"<=="); 
//Trace("Test: Y-direction 2nd position: Measured  value =>", arrMeasuredPositions.GetAt(3),"<  calculated nominal value =>",arrNominalPositions.GetAt(3),"<=="); 
//Trace("Test: Gripper Alignment Y deviation  =>",  deltaY);

      // Z deviation: delta = (Zmeasrured - Zstored) 
      deltaZ = 0.1*0.5*(arrMeasuredPositions.GetAt(4) + arrMeasuredPositions.GetAt(5)- arrNominalPositions.GetAt(4)- arrNominalPositions.GetAt(5));  // [mm]
//Trace("Test: Z-direction 1st position: Measured  value =>", arrMeasuredPositions.GetAt(4),"<  calculated nominal value =>",arrNominalPositions.GetAt(4),"<=="); 
//Trace("Test: Z-direction 2nd position: Measured  value =>", arrMeasuredPositions.GetAt(5),"<  calculated nominal value =>",arrNominalPositions.GetAt(5),"<=="); 
//Trace("Test: Gripper Alignment Z deviation  =>",  deltaZ);
//Trace("");

      // finger x deviation: delta = (Zfront - Zrear) 
      deltaP = 0.1*(arrMeasuredPositions.GetAt(0)- arrMeasuredPositions.GetAt(1)); 
//Trace("Test: Gripper Alignment finger X deviation  =>",  deltaP);
      // finger Z deviation: delta = (Zfront - Zrear) 
      deltaH = 0.1*(arrMeasuredPositions.GetAt(4)- arrMeasuredPositions.GetAt(5)); 
//Trace("Test: Gripper Alignment finger Z deviation  =>",  deltaH);
//Trace("");


      if(cardGripperJustageTorerance < ABS(deltaX))
      {
         string msg;
         retVal = hslFalse;

         // "Justage %s1 value check has failed tolerance %s2 returned > %s3."
         msg = StringTable::Load(IDS::easyPunchXyzCheckFailed);
		   StrReplace(msg, "%s1", "X");
		   StrReplace(msg, "%s2", FStr(cardGripperJustageTorerance, hslTrue, 2));
		   StrReplace(msg, "%s3", FStr(deltaX, hslTrue, 2));

         Trace(title, msg);
         starWatchState = STARWatch::statusFailed;
      }
      starWatchMin = "-" + FStr(cardGripperJustageTorerance,hslTrue,2);
      starWatchMax = "+" + FStr(cardGripperJustageTorerance,hslTrue,2);
      TraceSTARWatchData(ML_STAR, "CH", STARWatch::easyPunchXJustage, "", "0000", "00", starWatchState,
         "X justage", starWatchMin, starWatchMax, FStr(deltaX, hslTrue, 2));

      starWatchState = STARWatch::statusOK;
      if(cardGripperJustageTorerance < ABS(deltaY))
      {
         string msg;
         retVal = hslFalse;

         // "Justage %s1 value check has failed tolerance %s2 returned > %s3."
         msg = StringTable::Load(IDS::easyPunchXyzCheckFailed);
		   StrReplace(msg, "%s1", "Y");
		   StrReplace(msg, "%s2", FStr(cardGripperJustageTorerance, hslTrue, 2));
		   StrReplace(msg, "%s3", FStr(deltaY, hslTrue, 2));

         Trace(title, msg);
         starWatchState = STARWatch::statusFailed;
      }
      TraceSTARWatchData(ML_STAR, "CH", STARWatch::easyPunchYJustage, "", "0000", "00", starWatchState,
         "Y justage", starWatchMin, starWatchMax, FStr(deltaY, hslTrue, 2));

      starWatchState = STARWatch::statusOK;
      if(cardGripperJustageTorerance < ABS(deltaZ))
      {
         string msg;
         retVal = hslFalse;

         // "Justage %s1 value check has failed tolerance %s2 returned > %s3."
         msg = StringTable::Load(IDS::easyPunchXyzCheckFailed);
		   StrReplace(msg, "%s1", "Z");
		   StrReplace(msg, "%s2", FStr(cardGripperJustageTorerance, hslTrue, 2));
		   StrReplace(msg, "%s3", FStr(deltaZ, hslTrue, 2));

         Trace(title, msg);
         starWatchState = STARWatch::statusFailed;
      }
      TraceSTARWatchData(ML_STAR, "CH", STARWatch::easyPunchZJustage, "", "0000", "00", starWatchState,
         "Z justage", starWatchMin, starWatchMax, FStr(deltaZ, hslTrue, 2));


      // set back original parameter
		param = zvOriginalCardGripper;
		param = param + yvOriginalCardGripper;
		FwCommand( "CHAA", param, hslTrue, ML_STAR );

      return(retVal);

		///////////////////////////////////////////////////
		errorHandling : 
		{
         // set back original parameter
   		param = zvOriginalCardGripper;
   		param = param + yvOriginalCardGripper;
   		FwCommand( "CHAA", param, hslTrue, ML_STAR );

      	// -----------------------------------------------------------------
      	//  Move to (upper) safety position
      	// -----------------------------------------------------------------		
         FwCommand( "C0BM","xs03610xd0zj3100yj5090th2000", hslTrue, ML_STAR);
         FwCommand( "CHGP","gp0", hslTrue, ML_STAR);
         FwCommand( "C0BV","", hslTrue, ML_STAR);

			// If error occurs during execution processing will be  stopped
			return(hslFalse);
		}
   } // ---- End of function "executePunchGripperAlignment"


   //-----------------------------------------------------------------------------------------------------
   static function RunEasyPunchLagError(device ML_STAR, string cmd, string paramStart, string paramEnd, string umParam)
   //-----------------------------------------------------------------------------------------------------
   {
      variable curIndex(0);
      variable maxIndex(7999);
      string aaCmd("CPAA");
      string qlCmd("CPQL");

		onerror goto Unexpected;

      if(cmd.Find("CH") == 0)
      {
         aaCmd = "CHAA";
         qlCmd = "CHQL";
      }

      // move to start position
      FwCommand( cmd, paramStart, hslTrue, ML_STAR);

      // activate each samples
      FwCommand( aaCmd, "us1", hslTrue, ML_STAR);

      // activate lag error recording
      FwCommand( aaCmd, "ud1", hslTrue, ML_STAR);

      // activate drive 
      FwCommand( aaCmd, umParam, hslTrue, ML_STAR);

      // move to end position
      FwCommand( cmd, paramEnd, hslTrue, ML_STAR);

      // deactivate lag error recording
      FwCommand( aaCmd, "ud0", hslTrue, ML_STAR);

      // read lag error data
      while((curIndex+49) <= maxIndex)
      {
         string res("");
         string resCk("");
         string indx;
         string fullIndx("");
         string pm("lj%sln50");
         indx = IStr(curIndex);
         // fill up string with leading 0
         while(fullIndx.GetLength() < (4 - indx.GetLength()))
            fullIndx = fullIndx + "0";
         fullIndx = fullIndx + indx;

     		StrReplace(pm, "%s", fullIndx);

         // activate drive 
         res = FwCommand( qlCmd, pm, hslFalse, ML_STAR);
     		res = ParseFwResult(res, "ql", 50*6-1);

//tb nicht fertig
         //TraceSTARWatchData(ML_STAR, StrMid(qlCmd, 0, 2), STARWatch::easyPunchLagData, cmd+paramEnd, IStr(curIndex), "00", STARWatch::statusTrend, aaCmd+umParam, "", "", res);

         // stop reading if string contains only 00000 values
         resCk = res.SpanExcluding("123456789");
         if(res.GetLength() != resCk.GetLength())
         {
            Trace("Test: Lag error index: ", curIndex, " to index: ", curIndex + 49);
            curIndex = curIndex + 50;
         }
         else
         {
            // res string contains only 00000 values
            curIndex = maxIndex;
         }

      }

		Unexpected :
		{
		}

   }

   //-----------------------------------------------------------------------------------------------------
   private function checkEasyPunchMovements(device ML_STAR) variable
   //-----------------------------------------------------------------------------------------------------
   {
  		//*******************************************************************************************
  		// Check ionisator state and meassure drive lag 
		//*******************************************************************************************
      string parameter;
      string answer;

		onerror goto Unexpected;


      // schleppfehler brechen die maintenance nicht ab

      // puncher full punch
      RunEasyPunchLagError(ML_STAR, "C0BQ", "", "", "um4");
      // puncher move down to up
      RunEasyPunchLagError(ML_STAR, "CPZA", "za1270000", "za1480000", "um3");
      // puncher frame move X left to right
      RunEasyPunchLagError(ML_STAR, "CPXA", "xa20000", "xa27000", "um1");
      // puncher frame move Y front to rear
      RunEasyPunchLagError(ML_STAR, "CPYA", "ya24000", "ya77000", "um2");
      // move frame to front right position
      FwCommand( "CPCP", "cp4", hslFalse, ML_STAR);


      // be sure the gripper is in a correct position
      FwCommand( "CHMH", "", hslFalse, ML_STAR);
      // card handler move rear to front
      RunEasyPunchLagError(ML_STAR, "CHYA", "ya170000", "ya025000", "um1");
      // card handler move Z down to up
      RunEasyPunchLagError(ML_STAR, "CHZA", "za58000", "za80000", "um2");
      // plate handler plate gripper close to open
      RunEasyPunchLagError(ML_STAR, "CHGP", "gp2", "gp1", "um5");
      // card handler card gripper rotation -90 to horizontal
      RunEasyPunchLagError(ML_STAR, "CHFA", "fc12000", "fc32000", "um3");
      // card handler card gripper open to close
      RunEasyPunchLagError(ML_STAR, "CHHP", "hp1", "hp2", "um4");
      // be sure the gripper is in a correct position
      FwCommand( "CHMH", "", hslFalse, ML_STAR);

 
		Unexpected :
		{
		}

      return (hslTrue);
  }


	//-----------------------------------------------------------------------------------------------------
	static function ABS(variable var) variable
   // 
	//-----------------------------------------------------------------------------------------------------
   {
      variable temp(var);

      if(temp < 0)
         temp = -temp;

      return (temp);
   }

	//-----------------------------------------------------------------------------------------------------
	function TraceSTARWatchData(
      device& ML_STAR,
      variable deviceAddress,    // on of the device; E.g. C0, Px, Lx, Ch, CP ...
      variable testType,         // keyword for trace; E.g. STARWatch::jonisatorState, STARWatch::cycleCounter
      variable testCondition,    // 
      variable testID,           // "0000"
      variable testRevision,     // "00"
		variable status,           // test state STARWatch::statusOK, STARWatch::statusFailed, statusTrend
      variable outputParameter,  // Parameter name
      variable lowerLimit,       // Parameter lower limit
      variable upperLimit,       // Parameter upper limit
      variable traceData)        // Parameter value
	// Trace data in com trace for STAR Watch application
	//-----------------------------------------------------------------------------------------------------
	{
		variable fwCmd("");
		variable fwResponse("");
		variable data("..STARWatch ");
		const variable b(" ");     // blank
		const variable d(";");     // delimiter 
	   const variable q("'");     // quotation mark (apostrophe)

		if(STARWatch::deviceAddress != deviceAddress)
      {// get device tech data
		   fwCmd = deviceAddress + "QT"; // request technical data of device
		   fwResponse 	= FwCommand( fwCmd, "", hslFalse, ML_STAR ); //=> QTqt######/##/####

		   STARWatch::techData 	= StrMid(fwResponse, StrFind(fwResponse,"qt") + 2, 14); 
         // Define device type
         STARWatch::deviceType = "NotDefined";
         if(StrFind(deviceAddress,"C0") == 0)    STARWatch::deviceType = "ML-STAR";
         if(StrFind(deviceAddress,"CH") == 0)    STARWatch::deviceType = "STAR_PunchCardGripper";
         if(StrFind(deviceAddress,"CP") == 0)    STARWatch::deviceType = "STAR_Puncher";
         //if(StrFind(deviceAddress,"CG") == 0)    STARWatch::deviceType = "STAR_GelCardGripper";
         //if(StrFind(deviceAddress,"D0") == 0)    STARWatch::deviceType = "STAR_Head384";
         //if(StrFind(deviceAddress,"H0") == 0)    STARWatch::deviceType = "STAR_Head96";
         //if(StrFind(deviceAddress,"I0") == 0)    STARWatch::deviceType = "STAR_Autoload";
         //if(StrFind(deviceAddress,"IC") == 0)    STARWatch::deviceType = "STAR_CameraChannel";
         //if(StrFind(deviceAddress,"N0") == 0)    STARWatch::deviceType = "STAR_NanoDispenser";
         //if(StrFind(deviceAddress,"NP") == 0)    STARWatch::deviceType = "STAR_NanoPressureController";
         //if(StrFind(deviceAddress,"R0") == 0)    STARWatch::deviceType = "STAR_iSWAP";
         //if(StrFind(deviceAddress,"HD") == 0)    STARWatch::deviceType = "STAR_PumpStation";
         //if(StrFind(deviceAddress,"HG") == 0)    STARWatch::deviceType = "STAR_TubeGripper";
         //if(StrFind(deviceAddress,"HW") == 0)    STARWatch::deviceType = "STAR_PumpStation1";
         //if(StrFind(deviceAddress,"HU") == 0)    STARWatch::deviceType = "STAR_PumpStation2";
         //if(StrFind(deviceAddress,"HV") == 0)    STARWatch::deviceType = "STAR_PumpStation3";
         //if(StrFind(deviceAddress,"X0") == 0)    STARWatch::deviceType = "STAR_XDrive";

         //if(StrFind(deviceAddress,"D") == 0)    STARWatch::deviceType = "STAR_Deacapper";
         //if(StrFind(deviceAddress,"P") == 0)    STARWatch::deviceType = "STAR_1000ulPipChannel";
         //if(StrFind(deviceAddress,"L") == 0)    STARWatch::deviceType = "STAR_XL_PipChannel";
         //if(StrFind(deviceAddress,"O") == 0)    STARWatch::deviceType = "STAR_RoboticChannel";
         //if(StrFind(deviceAddress,"T") == 0)    STARWatch::deviceType = "STAR_TCC";
         //if(StrFind(deviceAddress,"W") == 0)    STARWatch::deviceType = "STAR_Washer";
      }
      STARWatch::deviceAddress = deviceAddress;
		data = data + d + q + deviceAddress +q+b+q+ "PN" + STARWatch::techData + q ;

		data = StrConcat8(data, d, "Testdevice="  ,q , STARWatch::deviceType ,q,"","");
		data = StrConcat8(data, b, "Testtype="    ,q , testType              ,q,"","");
      if(StrGetLength(testCondition) > 0)
         data = StrConcat8(data, b, "Testcondition="  ,q ,testCondition ,q,"","");
      if(StrGetLength(testID) > 0)
         data = StrConcat8(data, b, "TestID="         ,q ,testID ,q,"","");
      if(StrGetLength(testRevision) > 0)
         data = StrConcat8(data, b, "Testrevision="   ,q ,testRevision ,q,"","");
      
		data = StrConcat4(data, d,"State=",	status);
      if(StrGetLength(outputParameter) > 0)
         data = StrConcat8(data, d, "Outputparameter="   ,q ,outputParameter ,q,"","");
      lowerLimit = StrConcat2(lowerLimit,"");
      upperLimit = StrConcat2(upperLimit,"");
      if(StrGetLength(lowerLimit) > 0)
      {
         data = StrConcat4(data, d, "Lowerlimit="  ,lowerLimit);
         if(StrGetLength(upperLimit) > 0)
            data = StrConcat4(data, b, "Upperlimit="  ,upperLimit);
      }
      else if(StrGetLength(upperLimit) > 0)
         data = StrConcat4(data, d, "Upperlimit="  ,upperLimit);

      traceData = StrConcat2(traceData,"");
      if(StrGetLength(traceData) > 0)
         data = StrConcat4(data, d, "Data="  ,traceData);

//Trace("Test: TraceSTARWatchData =>",data,"<==");

	  	// Dummy command to trace data but will be return with (syntax) error
      FwCommand( "C0AA", data, hslFalse, ML_STAR);
	} // end TraceSTARWatchData


} // namespace MtcLib


#endif	// HSL_RUNTIME
#endif	// __MaintenanceLibrary_hsl__

// $$author=wbarmettler$$valid=1$$time=2017-03-14 13:14$$checksum=7fc37855$$length=088$$