// This is a part of the Microlab® STAR Pipetting Template Library (PTL).
// Copyright (C) by HAMILTON Bonaduz AG, CH-7402 Bonaduz.
// All rights reserved.
//
// Modification History
// 2001-06-01  bandenmatten : Initial file creation.
// 2001-08-23  bandenmatten : Renamed file HSLPTLLibImpl.hsl -> HSLPTLLibImpl.hs_.
// 2001-10-30  bandenmatten : Added function UpdateSequenceInDeckLayout().
// 2001-10-30  bandenmatten : Synchronized pipetting and loading sequences with corresponding sequences in the deck layout.
// 2001-10-31  bandenmatten : When Copy pattern and Exclude error positions was enabled and the rest volume was dispensed 
//										back to the aspirate sequence, the correction of the used positions of a sequence was not 
//										propagated. Fixed this bug.
// 2001-11-01  bandenmatten : Modified NeedsReload().
// 2001-11-02  bandenmatten : Disabled AlignExcludedPositions() if CopyPatternEnabled is enabled in function 
//										StepReturn::EvaluateEx().
// 2001-11-03  bandenmatten : Disabled initialization of a lodable sequence from the decklayout if the sequence 
//										is not reducible. 
// 2001-11-05  bandenmatten : When Default error recovery was enabled and Copy pattern and Exclude error positions 
//										was disabled nevertheless the error handling was executed. Fixed this bug. 
// 2001-11-05  bandenmatten : Fixed a bug in the alignment of the non-driving sequence during the reload in the case 
//										if the non-driving sequence has less positions than the driving sequence.
// 2001-11-07  bandenmatten : When the user was asked if he wants to reload the driving sequence and the user 
//										selected the No button the tip handling before returning from the pipette was missing.
// 2001-11-07  bandenmatten : When the user didn't reload the non-driving sequence or the tip pickup sequence a 
//										Phoenix Error (no positions found) was generated. Fixd this bug by canceling the 
//										pipetting procedure in this case.
// 2001-11-07  bandenmatten : Modified algorithm used to calculate the number of aliquots. 
// 2001-11-07  bandenmatten : Reduced value of Limits::minNumberOfAliquots from 3 to 0 (disabled degenerated aliquots). 
// 2001-11-19  bandenmatten : Changed order of 'pickup pipetting tips' and 'preload tip pickup sequence' in the
//										function Pipette().
// 2001-11-19  bandenmatten : Changed the value of TipPickupReverseSequenceCount from 96 to 24.
// 2001-11-19  bandenmatten : Added washing functions and control settings.
// 2001-11-23  bandenmatten : Fixed bug in preload of tip pickup sequence by implementing two new functions 
//										PCB::TipPickupSequenceNeedsPreload() and PCB::NeedsTipPickup().
// 2001-12-03  bandenmatten : Disabled recovery option 'Next' in TipPickUp step of NeeedlePickup.
// 2001-12-19  bandenmatten : The method was aborted after a successful error handling in the low level 
//										step 'StartNeedleWash'. The reason for this bug was that the step type 
//										'StartNeedleWash' was missing in the function StepReturn::EvaluateEx().
//										Fixed this bug.
// 2002-01-07  bandenmatten : Replaced references to low level steps by corresponding wrapper functions 
//										supplied by the library HSLMlStarStepLib.hsl.
// 2002-01-18  bandenmatten : Added tip handling functions.
// 2002-01-25  bandenmatten : Removed following washing control settings: 
//											NumberOfAirPulses
//											AirPulseDuration
//											TimeToFirstAirPulse
//											TimeBetweenAirPulses
//										Renamed following washing control settings: 
//											streamIntensity	-> flowRate
//											dryingTime			-> drainingTime
//											startWashSolution	-> startWashLiquid
//										Removed following variables: 
//											WCB::numberOfAirPulsesArr[]
//											WCB::airPulseDurationArr[]
//											WCB::timeToFirstAirPulseArr[]
//											WCB::timeBetweenAirPulsesArr[]
//										Removed following variables: 
//											WCB::numberOfAirPulsesDefault
//											WCB::airPulseDurationDefault
//											WCB::timeToFirstAirPulseDefault
//											WCB::timeBetweenAirPulsesDefault
//										Removed following parameters from function WCB::GetWashParams(): 
//											numberOfAirPulses
//											airPulseDuration
//											timeToFirstAirPulse
//											timeBetweenAirPulses
//										Changed the following defaults:
//											WCB::rinseTime1Default(3)				-> WCB::rinseTime1Default(7)
//											WCB::streamIntensity1Default(120)	-> WCB::flowRate1Default(12)
//											WCB::streamIntensity2Default(0)		-> WCB::flowRate2Default(12)
//											WCB::dryingTimeDefault(30)				-> WCB::drainingTimeDefault(10)
// 2001-02-26  bandenmatten : Added functions GetWashingStateDefault and SetWashingStateDefault.
// 2001-03-06  bandenmatten : Declared washing control settings as global.
// 2002-03-20  bandenmatten : Function PTL::LCB::Load(): Replaced sequenctial search by sequence.LookupPosition().
// 2002-03-20  bandenmatten : Function PTL::ExcludeSequencePositions(): Replaced sequenctial search by sequence.LookupPosition().
// 2002-03-22  bandenmatten : Changed initial value of DispenseRestVolumeFluidHeight from 0 to 10.
// 2002-04-30  bandenmatten : Traced a warning if mixing will be ignored on aspirate or dispense.
// 2002-05-03  bandenmatten : Reset max positions of sequences in FinalizeSequences().
// 2002-05-03  bandenmatten : Replaced AssignUsedPositions() by sequence.SetUsedPositions().
// 2002-05-23  bandenmatten : If the error handling was set to ErrorHandling::continue and the user selected the Cancel button
//										in the recovery options of the low level step, the smart step didn't return with an exption but 
//										continued with the next statements. Fixed this bug by introducing the function EvaluateGenericRecovery().
// 2002-07-01  bandenmatten : Replaced function MlStar::StepTipPickup() by function MlStar::StepTipPickupEx() in function WCB::NeedlePickup().
// 2002-07-17  bandenmatten : Revised loading due to the new interface of the low level step LoadCarrier.
// 2002-07-30  bandenmatten : Reported an error, if falling in a step error handler an none of the step return strings has set an error code greater than 0.
// 2002-07-31  bandenmatten : Queried the field delimiter, used in the barcode read positions string, from the underlying instrument (PTL_Util::CsvToDelimited()).
// 2002-08-07  bandenmatten : Reported an error in function SelectDefaultWaste(), if the default waste queried from the instrument 
//										could not be found in the associated deck layout. In particular there will be no default waste selected 
//										but the default waste configured in the Microlab STAR Configuration Editor.
// 2002-08-22  bandenmatten : Added IDE::emptySequence. 
//										Differentiated error message 'IDE::invalidTipType' reported in function PTL::PCB::SetTipType() into 'IDE::invalidTipType' and 'IDE::emptySequence'.
// 2002-09-11  bandenmatten : SCR#220: Function PTL::Pipette(): If the instrument has already been initialized the return code rc is empty
//										The final tip eject at the end of the function looks whether the return code is empty to decide if tips have to be ejected.
//										Made the return code rc non-empty to prevent an unnecessary tip eject if there is nothing to pipette.
// 2002-09-11  bandenmatten : SCR#210: Function TransferLiquid(): Aligned not only the dispense sequence after the first dispensation of the aliquot,
//										but also the aspirate and the tip pickup sequence.  
// 2002-09-16  bandenmatten : Function InitPipettingDevice(): Queried the initialization state of the instrument to decide if the instrument has to be initialized.
// 2002-09-17  bandenmatten : Function PCB::BackupSequences(): Replaced assignements of defaultWasteSequence to sequences InitializeWasteDestination and TipEjectWasteDestination 
//										by getting a reference to the defaultWasteSequence, so that the command and the library see the same sequence in the 
//										Initialize and TipEject step when the flag useDefaultWaste is enabled.
// 2002-09-19  bandenmatten : Implemented Sample Tracking: Positions excluded by a Smart Step during a liquid transfer have to be tracked erroneous in the sample tracker database.
// 2002-10-28  bandenmatten : Implemented Smart Step 'Pipette' with needles.
// 2002-12-17  bandenmatten : SCR#280: Introduced new constant DispenseRestVolumeConstFluidHeight(10) to dispense the rest volume to the waste at a fixed height.
// 2003-01-20  bandenmatten : SCR#330: Set the original count to get the names of the carries to unload in function LCB::PrepareLoadOfSequences().
// 2003-02-04  bandenmatten : Added new tip types to namespace TipType:		standardVolumeNeedleCut, lowVolumeNeedleCut, highVolumeNeedleCut.
// 2003-02-04  bandenmatten : Added new tip types to namespace TipTypeNum: standardVolumeNeedleCut, lowVolumeNeedleCut, highVolumeNeedleCut.
// 2003-02-04  bandenmatten : Added new tip types to function PCB::SetTipType(): standardVolumeNeedleCut, lowVolumeNeedleCut, highVolumeNeedleCut.
// 2003-02-04  bandenmatten : Added new tip types to function PCB::SetVolume(): standardVolumeNeedleCut, lowVolumeNeedleCut, highVolumeNeedleCut.
// 2003-02-04  bandenmatten : Added new tip types to function WCB::IsWashStation(): standardVolumeNeedleCut, lowVolumeNeedleCut, highVolumeNeedleCut.
// 2003-02-04  bandenmatten : Disabled automatic selection of liquid class in function PCB::SelectLiquidClass().
// 2003-04-08  bandenmatten : SCR#361: Set the maximum number of retries to open kit lot file.
// 2003-05-30  bandenmatten : Updated error recovery functions EvaluateXxxRecovery() corresponding to new command error recovery.
// 2003-05-16  bandenmatten : Fixed the following bug in function TCB::TipeEject():
//							  			The max number of positions of the tip eject waste destination has been aligned with the 
//							  			tip pickup the aspirate and the dispense sequence to prevent errors when redespesing the 
//							  			rest volume into the waste. So we have to re-align the max number of positions of the 
//							  			tip eject waste destination.
// 2003-05-27  bandenmatten : SCR#406: Fixed the following bug in function PCB::FinalizeSequences():
//							  			The max number of positions of the tip eject waste destination has been aligned with the 
//							  			tip pickup the aspirate and the dispense sequence to prevent errors when redespesing the 
//							  			rest volume into the waste. So we have to re-align the max number of positions of the 
//							  			tip eject waste destination.
// 2003-07-17  bandenmatten : SCR#495: Changed tracking error code from SampleTrackerActionState::Warning to SampleTrackerActionState::Error.
// 2003-09-09  bandenmatten : SCR#558: Function TipPickup(): The TCB::TipPickupSequence has been set to tipPickupSequence but reloading requires 
//										PCB::TipPickupSequence to be set to tipPickupSequence as well.
// 2004-01-21  bandenmatten : Implemented support if the number of channels equals to 0.
// 2004-01-22  bandenmatten : Load, Unload, Load with Tip Counter enabled -> Current and Count remain 0 after second Load. Fixed this bug.
// 2004-01-26  bandenmatten : Pipette with Needles: If the instrument configurtion doesn't contain any washer, the step MlStar::StepWaitNeedleWashed(),
//							  			correctly returns an error rc[2]="1[01,01,30,2,,,". Nevertheless the smart step Pipette continues pipetting. Fixed this bug.
// 2004-03-01  bandenmatten : SCR#592: Unnecessary re-load of Carriers in Smart step 'Tip Pickup'. Fixed this bug.
// 2004-06-04  bandenmatten : SCR#553: Improved performance during the evaluation of the error status after a load carrier step (function EvaluateLoadCarrierRecovery()).
// 2005-04-18  ubernhard	 : Use function Read2() and Write2() from HSLTipCountingLib instead of Read() and Write().
// 2005-04-21  cjoerg		 : Added constant DispenseMode::blowoutTip = 9, extended function DispenseMode::AsString().
//										For the MlStar::StepDispense(..) of the 'rest volume' or 'post aliquot volume' use
//										DispenseMode::blowoutTip.
//										Liquid-Class design has changed, new liquid classes are defined
//										for 'jet empty', 'jet part volume', 'surface empty' or 'surface part volume'. Since this 
//										extension basically the used dispense mode must correspond to the dispense mode defined
//										by the liquid class, otherwise a dispense error occur.
//										To enable that the last dispense (e.g. after some 'part volume' dispenses) may be processed by
//										using the same liquid class the DispenseMode::blowoutTip has been added to the low level
//										dispense step.
//										Update function SelectDispenseMode() to work with the extended liquid class modes. For an aliquot
//										and if no rest volume is used the last dispense (aliquot!) must be done with DispenseMode::blowoutTip.
// 2005-05-11  bandenmatten : SCR#449: Missing carrier type in Smart Step Load (and Unload, and Reload).
// 2005-05-11  bandenmatten : SCR#736: No selectable dispense mode for post aliquote of smart step Pipette.
// 									- Introduced new PCB key : DispenseRestVolumeToAspirateSequenceSurface.
// 2005-05-13  bandenmatten : Introduced new function GetTipVolumeFromLiquidClass().
// 2005-05-13  bandenmatten : Function TrackData() : Replaced CreateObject("HAMILTON.HxSampleTracker") by GetSampleTrackerObject().
// 2005-05-21  cjoerg		 : Fixed bug (added 2005-04-21 cjoerg) that if aliquot only the first series of aliquotes is done with
//                            jet-part-volume, the further series are done with mode 'blowout tip'.
//										- Changed enum DispenseMode and PCB-setting "DispenseMode" so that not longer one of the
//                              four modes must set (jetPart, jetEmpty, surfacePart, surfaceEmpty). Newly only set of
//										  the mode jet(0/1) or surface(2/3) is needed. Updated SetState() for key "DispenseMode".
//										- Added enum StarDispenseMode. Changed SelectDispenseMode() to GetDispenseMode(). Returns now
//										  the evaluated StarDispenseMode instead of set the value within member DispenseMode.
//										  The DispenseMode must never be overridden by a StarDispenseMode.
//										- Removed any use of DispenseMode as dispensing parameter. Value returned by GetDispenseMode()
//                              must be used.
// 2005-06-27	ubernhard	 : - Use AddSequence2 for proper support of EditSequences dialog if possible
//										  (not possible for sequences unknown within decklayout)
//										- Use CopyResetSequence to reset the sequence, if sequence was read as "empty" sequence from HxElementCounter database
// 2005-06-28  cjoerg		 : - Remove variables from namespace TipVolume which are used to hold/assign the tip volume
//										  for current tip type. The goal of V4.0 is that the available tip types are defined by HxStarDevices.
//										  The tip volume for actual tip type is evaluated from GetTipVolumeFromLiquidClass each time 
//										  the volume is needed (ValidateParams and PCB::SetVolume)
//	2005-06-29  cjoerg		 :	- From PTL::Pipette changed interpretation of last parameter tipType. This parameter is
//										  not longer used, the tip type is evaluated in all cases from the tip pickup sequence.
//										  From the Smart Steps this parameter is never set, always "".
//										  From ValidateParams() removed last parameter tipType.
//										  From PCB::SetTipType() removed last parameter tipType.
//										- Removed PCB-key "TipPickupTipType". Not longer supported/evaluated by the pipetting library.
//										- Removed PCB::SetTipType() information about tip type is not longer needed,
//										  only isWashSequence is from interesting. -> Added PCB::IsWashSequence.
//										- In InitPipettingLibrary create and initialize the objects objHxStarLiquid and objHxStarTipTypes
//                            - Removed TipTypeNum and TipType's. Not longer used, tip/needle is evaluated by uising
//										  objHxStarTipTypes. Updated WCB::IsWashStation and WCB::IsNeedleRack.
//										- In two functions AskUserForReload replaced the MessageBox with a modeless output dialog.
//                              Play sound HxServicesSoundEnum::soundQuestion.
//										- Added object objHxServicesGeneralSettings2 to namespace Util, init in InitPipettingLibrary().
//										- Updated namespace Sound, Sound::Play need one of HxServicesSoundEnum as parameter.
//										  The sound to play is specified by HxServicesGeneralSettings2:
//										  Sound::question("chord.wav") removed,   -> use Sound::HxServicesSoundEnum::soundLoading
//										  Sound::exclamation("ding.wav") removed, -> use Sound::HxServicesSoundEnum::soundLoading
//	2005-06-30  cjoerg		 : - Changed the following defaults:
//											WCB::rinseTime1Default(7)				-> WCB::rinseTime1Default(5)
//											WCB::soakTime1Default(1)				-> WCB::soakTime1Default(5)
//											WCB::streamIntensity1Default(12)		-> WCB::flowRate1Default(11)
//											WCB::streamIntensity2Default(12)		-> WCB::flowRate2Default(11)
//										- Added WCB::ptlWcbTaskIdArr. Hold the TaskId from the task which has set the 
//										  the wash settings for the labware as last. TaskId is set during WCB::SetState for
//										  keys which are used from step 'Needle Wash Settings'.
//										  Checked during GetWashParams, throws an exception if Wash Settings are not set for
//										  current task explicit.
//	2005-07-04  cjoerg			- Added LCB::ptlLcbTaskIdArr. Hold the TaskId from the task which has set the 
//										  the load settings for the sequence as last. TaskId is set during LCB::SetStateEx for
//										  keys which are used from step 'Advanced Load Settings'.
//										  Checked during LCB::GetStateEx, throws an exception if Load Settings are not set for
//										  current task explicit.
//										- Don't call Sound::Play() if UserResponseTime is zero.
//	2005-07-07  cjoerg			- In PTL::ValidateParams() extend the volume test (...volume <= 0)) to raise the error
//										  only if the pipetteVolume is not zero. If the pipetteVolume is zero the pipette
//										  does nothing, this behaviour is tested by t1053/t3053
//										- Added function TraceWarningIfNotValidated()
//										- If 'Wash Settings' or 'Load Settings' are not explicit set for current task (if scheduling)
//										  (check added 2005-05-30/2005-07-04) changed to not longer throw an exception, only a warning is traced.
//										  By marketing its preferd that a method is running with warning instead of not running because
//										  of an exception.
// 2005-07-08	ubernhard	   - respect value set for 'Start position' and 'Number of positions' as set within Smart Step Load
//										  in relation with function AddSequence2().
//	2005-07-11  cjoerg			- Updated LCB::GetStateEx to trace the warning depending of the new parameter bWarnLoadSettingsNotForTask only.
//										  Extended PrepareReloadOfSequences(), GetCarrierNames() and PrepareLoadOfSequences() by this parameter.
//	2005-07-12  ubernhard		- Corrected support of 'Start position' and 'Number of positions'
//	2005-11-01  ubernhard		- SCR#1108: Wrong Sequence Manipulation of Load Smart Step.
//	2006-02-08  bandenmatten	- SCR#1121: Smart Step Load doesn't support stacked plates.
// 2006-03-09  bandenmatten : - Added function PTL::Pipette2() (supports array for param volume).
// 2006-03-22  bandenmatten : - Added function PTL::Load2() (supports Smart Step 'Load and Match').
// 2006-03-26  bandenmatten : - Modified function PTL::LCB::Load().
// 2006-03-26  bandenmatten : - Added function PTL::LCB::DetectPreloadedCarriers().
// 2006-03-26  bandenmatten : - Added function PTL::LCB::SelectPreloadedCarriers().
// 2006-03-26  bandenmatten : - Added function PTL::LCB::UnloadUnusedSampleTubes().
// 2006-03-26  bandenmatten : - Added function PTL::LCB::BinIStr().
// 2006-04-12  bandenmatten : - Added PTL::IDS::smartStepLoadAndMatch.
// 2006-05-03  bandenmatten : - Added PTL::PCB::SetVolumes().
// 2006-05-03  bandenmatten : - Modified PTL::PCB::TransferLiquid() to transfer individual volumes.
// 2006-05-03  bandenmatten : - Modified PTL::StepReturn::EvaluateEx() to evaluate individual volumes.
// 2006-05-15  bandenmatten : - SCR#433 : Added new error handling option 'ErrorHandling::continue_2'. 
// 2006-05-03  bandenmatten : - Called GetWorkflowFileName() if GetMethodFileName() returned the empty string.
// 2006-06-01  bandenmatten : - Added function PTL::LCB::Split().
// 2006-06-01  bandenmatten : - Added function PTL::LCB::FastLookup().
// 2006-06-01  bandenmatten : - Added function PTL::LCB::GetSerialNumber().
// 2006-06-01  bandenmatten : - Added function PTL::LCB::GetLabwareIdAndPositionId().
// 2006-06-01  bandenmatten : - Added function PTL::LCB::WriteUnusedSampleTubesReport().
// 2006-06-05  bandenmatten : - Added constant PTL::LLDSensitivity::fromLabwareDefinition.
// 2006-06-24  bandenmatten : - Replaced GetSampleTrackerObject() by GetVectorDbTrackerObject().
// 2006-08-09	ubernhard	 : - Fixed bug within static function Load
// 2006-09-13  bandenmatten : - Implemented a workaround in function InitPipettingLibrary() for an old nasty string table file 'HSLPTLStringTableEnu.hs_' 
// 									  that occasionally gets imported from a mehtod package into the Methods directory (//>> 20060913).
// 2006-10-17  bandenmatten : - Added function PTL::LCB::UnassignNotLoadedSampleTubesFromJobs().
// 2006-10-17  bandenmatten : - Removed all calls of VectorDb_Labware::IsLabwareLoadedByLabwareIdPositionId(deckID, labwareId, positionId) for a specific positionId.
// 2006-10-26  bandenmatten : - Tested PTL::Load2() ('Load and Match') on a Microlab STAR Instrument.
//										  Focused on 'Scan autoload tray' option, 'Unload unused sample tubes' option, 'SourceRequired' flag and error handling.
//										  Fixed bugs found during these tests (//>> 20061026).
// 2006-11-22  bandenmatten : - Evaluated return status of firmware command "C0CS" in function PTL::LCB::DetectPreloadedCarriers().
//	2006-11-29  bandenmatten	- Changed implementation of SCR#1121 (Smart Step Load doesn't support stacked plates):
//										  Removed duplicates in the loading positions string instead of passing an empty string.
// 2007-03-05  fgarcia      : - Removed function/calls to UnassignNotLoadedSampleTubesFromJobs()
// 2007-05-23  fgarcia      : SCR #1299:
//                            - static function LoadRequiredSampleTubes():
//                              > make use of new StepLoadCarrierEx2() (error settings for Load and Match)
//                              > do not throw error, if no labID/posID found for given barcode, and make an own list with barcodes only
//                                to show them in the required sample tubes report
//                              > unload (and reload) all carriers if an unknown barcode (flagged as required) is not found
//                            - static function ShowRequiredSampleTubesReport():
//                              > added cancel button to dialog -> throws error if cancel is pressed
//                              > show also barcodes which could not be assigned to any loaded labware (no labID/posID)
//                            - static function UnloadUnusedSampleTubes():
//                              > make use of new StepLoadCarrierEx2() (error settings for Load and Match)
//                            - function LCB::Load():
//                              > use StepLoadCarrierEx2() for Load and Match
//	2007-07-02  fgarcia	    : - Changed implementation of SCR#1121 (Smart Step Load doesn't support stacked plates):
//                              always use PTL_Util::CsvToDelimited2() to remove duplicates in load string before loading
//                              (as otherwise eg. loading a plate with cover caused an error in GruCommand)
//                              and removed no more used function IsNoReadBarcode()
//	2007-10-09  bandenmatten	- Fixed SCR#1330 (Smart Step Pipette causes Phoenix Error) in function TrackData() (//>>20071009).
//	2007-10-17  bandenmatten	- Fixed SCR#1331 (Load and Match - Scan autoload tray when reloading carriers) in function LoadRequiredSampleTubes() (//>>20071017).
//	2007-10-20  bandenmatten	- Fixed SCR#1193 (Strange behaviour in Aliquot procedure) in functions PipetteImpl() and TransferLiquid() (//>>20071019).
//	2007-11-16  bandenmatten	- Updated members of namespace MainError.
//	2007-11-16  bandenmatten	- Handled errors MainError::barcodeMaskError, MainError::barcodeNotUniqueError and MainError::barcodeAlreadyUsedError in 
//                              function EvaluateLoadCarrierRecovery() symmetrically to error MainError::noBarcodeError (//>> 20071116).
// 2007-11-26  bandenmatten : - Replaced function MlStar::StepInitialize() by new function MlStar::StepInitialize2() that has all the default waste parameters removed.
// 2007-11-26  bandenmatten : - Removed call to functions SelectDefaultWaste() and BackupSequences() from the functions Load() and Unload() (//>> 20071126).
// 2009-05-27  cjoerg       : - Fixed SCR#1381 (Smart Step Pipette: Final sequence manipulation)
//                              Updated FinalizeSequences() completely. Looks like several sequence finalizations
//                              was not working properly specially in case if the sequence is loadable or loadable+reducible.
//                              Added AspirateSequenceLoaded/DispenseSequenceLoaded member to remember if a sequence
//                              has been loaded or not.
// 2009-06-09  cjoerg       : - Fixed numberOfAliquots calculation in TransferLiquid()
//                              For some volumes the calculation goes wrong because of decimal precission limit:
//                              e.g. AliquotVolume=7.4 / fill up a 96 plate with 300ul Tips and 8 channels
//                              --> numberOfAliquots = Ceiling(1.0 * AspirateVolume / DispenseVolume) = 13 ! (instead of 12)
//                                  looks like 88.8 / 7.4 results in 12.0000....0001 and Ceiling results in 13 :-(
//                                  Investigated that if no decimals are used for volume (e.g. 21.0ul) we do not
//                                  run into the precisssion problem / aliquot error.
//                              - Changed to use MthRound() instead of ceiling (added include of HSLMthLib).
//                              - Checked also other Ceiling/Floor calls, but looks OK.
// 2009-06-09  cjoerg       : - Removed NumericConstants::liqMaxAspirateVolume and use exported enum from 
//                              HxStarLiquid directly.
// 2009-12-07  cjoerg       : - Replace use of HxStarTipTypes by HxCoreTipTypes because the component HxStarTipTypes
//                              is not longer delivered with 4.3. Init the object with the class ML_STAR. This library
//                              is only written for Star's and we don't have to expect/support instruments of other classes.
//                            - Removed HxStarDevTipClassEnum - use values of enum HxCoreDevTipClassEnum exported from
//                              HxCoreTipTypes directly.
//                            - Replace use of HxStarLiquids by HxCoreLiquids because this component has been moved to Phoenix.
//                            - Removed 'manual' PlaySound just before .EditSequence() because since the change of the
//                              EditSequence to use the 3D engine the dialog has been shown delayed by some seconds.
//                              Pass the sound-file to play to the EditSequence() call instead which handles the play more
//                              convenient.
// 2009-12-16  cjoerg       : - IncludeSequencePositions(): Fixed bug if the element has to be included at the end of the sequence.
//                              In this case position equals to count+1 and we must use the Add() function instead of the InsertAt().
//                            - TransferLiquid(): For the dispense of the pre- or post-volume check for any active channel 
//                              before trying to redispense. This prevents a dispense error because of empty source sequence
//                              in case of prevois Aspirate Error with enabled 'copy pattern' or 'exclude error positions'
//                              (SCR #1445).
//                            - StepReturn::SetData: Changed to not longer handle an Asp/Disp error recoverd with 'repeat'
//                              as an error. Recovering with repeat is a successful recovery for which no exclude or tip
//                              exchange should be done (SCR #1470).
// 2010-08-10  ubernhard:     - Fixed SCR#1503: Use the comma character always as position delimiter for LoadCarrier parameter "Positions of labware itmes to be used"
// 2016-10-06  ubernhard:     - include HSLGCCMlStarStepLib.hs_ instead of HSLMlStarStepLib.hs_
//                            - Replaced function MlStar::StepInitialize2() by new function MlStarSteps::StepInitialize_cer() allows customizable error revovery
//										- Replaced function MlStar::StepTipPickup() by new function MlStarSteps::StepTipPickup_cer() allows customizable error revovery
//										- Replaced function MlStar::StepTipPickupEx() by new function MlStarSteps::StepTipPickupEx_cer() allows customizable error revovery
//										- Replaced function MlStar::StepTipEject() by new function MlStarSteps::StepTipEject_cer() allows customizable error revovery
//										- Replaced function MlStar::StepAspirate() by new function MlStarSteps::StepAspirate_cer() allows customizable error revovery
//										- Replaced function MlStar::StepAspirateEx() by new function MlStarSteps::StepAspirateEx_cer() allows customizable error revovery
//										- Replaced function MlStar::StepDispense() by new function MlStarSteps::StepDispense_cer() allows customizable error revovery
//										- Replaced function MlStar::StepDispenseEx() by new function MlStarSteps::StepDispenseEx_cer() allows customizable error revovery
//										- Replaced function MlStar::StepLoadCarrierEx() by new function MlStarSteps::StepLoadCarrierEx_cer() allows customizable error revovery
//										- Replaced function MlStar::StepLoadCarrierEx2() by new function MlStarSteps::StepLoadCarrierEx2_cer() allows customizable error revovery
//										- Replaced function MlStar::StepUnloadCarrier() by new function MlStarSteps::StepUnloadCarrier_cer() allows customizable error revovery
//										- Replaced function MlStar::StepCalibrate1536Plate() by new function MlStarSteps::StepCalibrate1536Plate_cer() allows customizable error revovery
//										- Replaced function MlStar::StepWaitNeedleWashed() by new function MlStarSteps::StepWaitNeedleWashed_cer() allows customizable error revovery
//										- Replaced function MlStar::StepStartNeedleWash() by new function MlStarSteps::StepStartNeedleWash_cer() allows customizable error revovery										
//                            - Implemented function MapCustomStepErrorHandling()
//                            - Implemented functions PTL::Pipette3() and PTL::Pipette4(), (supports sequence merging for given for asp/disp sequences)
//                            - renamed namespace Util to PTL_Util
// 2016-11-11  ubernhard:     - added delimiterBarcodeError in namespace MainError
//                            - Handled errors MainError::noLabwareError, MainError::unexpectedLabwareError, MainError::wrongLabwareError
//                              and MainError::delimiterBarcodeError in function EvaluateLoadCarrierRecovery()
//
//                              
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef __HSLPTLLibImpl_hsl__
#define __HSLPTLLibImpl_hsl__	1

#ifndef __HSLStrLib_hsl__
#include "HSLStrLib.hsl"
#endif

//>>2009-06-09/CJ
#ifndef __HSLMthLib_hsl__
#include "HSLMthLib.hsl"
#endif
//<<2009-06-09/CJ

#ifndef __HSLTipCountingLib_hsl__
#include "HSLTipCountingLib.hsl"
#endif

#ifndef __HSLMlStarStepReturnLib_hsl__
#include "HSLMlStarStepReturnLib.hsl"
#endif

#ifndef __HSLGCCMlStarStepLib_hs___
#include "HSLGCCMlStarStepLib.hs_"
#endif

#ifndef __HSLMlStarCfgKeys_hs___
#include "HSLMlStarCfgKeys.hs_"
#endif

#ifndef __HSLSeqLib_hsl__
#include "HSLSeqLib.hsl"
#endif

#ifndef __HSLSynLib_hsl__
#include "HSLSynLib.hsl"
#endif

#ifndef __HSLKitLotLib_hsl__
#include "HSLKitLotLib.hsl"
#endif

#ifndef __HSLMlStarDeckDef_hs___
#include "HSLMlStarDeckDef.hs_"
#endif

#ifndef __HSLVectorDbWorklistManagement_hsl__
#include "HSLVectorDbWorklistManagement.hsl"
#endif

#ifndef __HSLVectorDbWorklistManagementDefs_hs___
#include "HSLVectorDbWorklistManagementDefs.hs_"
#endif

#ifndef __HSLVectorDbTracking_hsl__
#include "HSLVectorDbTracking.hsl"
#endif

#ifndef __HSLVectorDbTrackingDefs_hs___
#include "HSLVectorDbTrackingDefs.hs_"
#endif

#ifndef __HSLTrcLib_hs___
#include "HSLTrcLib.hsl"
#endif

//device ML_STAR;

namespace PTL
{
   #ifndef __HSLMappingReportImpl_hs___
   #include "HSLMappingReportImpl.hs_"
   #endif

	#ifndef __HSLStringTableLib_hsl__
	#include "HSLStringTableLib.hs_"
	#endif

	// --------------------------------------------------------------------------------------
	// Debugging
	// --------------------------------------------------------------------------------------

	//#define _DEBUG		1														// specifies the debug version of the pipetting library
	//#define _DEBUG_TIPHANDLING 1											// specifies the debug version of the pipetting library
	//#define _DEBUG_POSITIONSLABWARENAMES 1								// specifies the debug version of the pipetting library

	// --------------------------------------------------------------------------------------
	// Error Handling
	// --------------------------------------------------------------------------------------

	namespace ErrorHandling
	{
		static const variable first(1);									// guard
		static const variable abort_(first);							// error handling
		static const variable cancel(first + 1);						// error handling
		static const variable continue(first + 2);					// error handling
		static const variable continue_2(first + 3);					// error handling
      static const variable custom(first + 4);					   // error handling
		static const variable last(first + 4);							// guard

		// functions
		static function AsString(variable errorHandling);			// returns the string representation of a ErrorHandling member
      static function MapCustomStepErrorHandling(variable errorHandling, variable customStepID);
   }

   namespace CustomStepID
   {
      static const variable first(-2);									// guard
		static const variable stepErrorHandlingAbort(first);
		static const variable stepErrorHandlingAbortCancel(first + 1);
		static const variable stepErrorHandlingDefault(first + 2);
      static const variable last(first + 2);							// guard
   }

	// --------------------------------------------------------------------------------------
	// Tip Types
	// --------------------------------------------------------------------------------------

	namespace TipType
	{
		static object objHxStarTipTypes;				// The HxCoreTipTypes component - initialized for ML_STAR,
																// used to query if a tip type is needle or tip.
	}

	// --------------------------------------------------------------------------------------
	// Driving Modes
	// --------------------------------------------------------------------------------------

	namespace DrivingMode
	{
		static const variable undefined(0);								// undefined driving mode
		static const variable first(undefined + 1);					// guard
		static const variable aspirateDriven(first);					// aspirate driven mode
		static const variable dispenseDriven(first + 1);			// dispense driven mode
		static const variable last(first + 1);							// guard

		// functions

		static function AsString(variable drivingMode);				// returns the string representation of a DrivingMode member
	}

	// --------------------------------------------------------------------------------------
	// Volumes
	// --------------------------------------------------------------------------------------

	namespace TipVolume
	{
		static object objHxStarLiquid;							// The HxCoreLiquid component - initialized for ML_STAR,
																			// used to query max tip volumes given a liquid class name
	}

	// --------------------------------------------------------------------------------------
	// Limits
	// --------------------------------------------------------------------------------------

	namespace Limits
	{
		static const variable maxTimeInterval(24*24*60*60);		// max time interval
		static const variable channelInnerBound(8);					// channel inner bound
		static const variable channelUpperBound(16);					// channel upper bound
		static const variable minVolume(0.05);							// min volume [ul]
		static const variable minNumberOfAliquots(0);				// min number of aliquots
		static const variable reverseSequenceCount(24);				// count of reverse tip pickup sequence
		static const variable channelVariable16("1111111111111111");// channel variable (0 = unused, 1 = used)
		// ba 2002-04-08 begin (SCR#361)
		static const variable maxKitLotOpenRetries(4);				// maximum number of retries to open kit lot file
		// end
	}

	// --------------------------------------------------------------------------------------
	// Rest Volume Destination
	// --------------------------------------------------------------------------------------

	namespace RestVolumeDestination
	{
		static const variable first(0);									// guard
		static const variable waste(first);								// waste sequence
		static const variable aspirate(first + 1);					// aspirate sequence
		static const variable last(first + 1);							// guard

		// functions

		static function AsString(variable restVolumeDestination);// returns the string representation of a RestVolumeDestination member
	}

	// --------------------------------------------------------------------------------------
	// Sequence Counting
	// --------------------------------------------------------------------------------------

	namespace SequenceCounting
	{
		static const variable first(0);									// guard
		static const variable manually(first);							// sequence counting
		static const variable automatic(first + 1);					// sequence counting
		static const variable last(first + 1);							// guard

		// functions

		static function AsString(variable sequenceCounting);		// returns the string representation of a SequenceCounting member
	}

	// --------------------------------------------------------------------------------------
	// Channel Use
	// --------------------------------------------------------------------------------------

	namespace ChannelUse
	{
		static const variable first(1);									// guard
		static const variable allSequencePositions(first);			// channel use
		static const variable channelPattern(first + 1);			// channel use
		static const variable last(first + 1);							// guard

		// functions

		static function AsString(variable channelUse);				// returns the string representation of a ChannelUse member
	}


	// --------------------------------------------------------------------------------------
	// Pipette Order
	// --------------------------------------------------------------------------------------

	namespace PipetteOrder
	{
		static const variable first(1);									// guard
		static const variable aspiration(first);        			// aspiration
		static const variable dispensation(first + 1);  			// dispensation
		static const variable last(first + 1);							// guard
	}

	// --------------------------------------------------------------------------------------
	// Aspirate Mode
	// --------------------------------------------------------------------------------------

	namespace AspirateMode
	{
		static const variable first(0);									// guard
		static const variable aspiration(first);						// aspirate mode
		static const variable consecutiveAspiration(first + 1);	// aspirate mode
		static const variable emptyCupAspiration(first + 2);		// aspirate mode
		static const variable last(first + 2);							// guard

		// functions

		static function AsString(variable aspirateMode);			// returns the string representation of an AspirateMode member
	}

	// --------------------------------------------------------------------------------------
	// Dispense Mode (provided on the interface of the Pipetting Library)
	// --------------------------------------------------------------------------------------

	namespace DispenseMode
	{
		static const variable first(0);							// guard
		static const variable jet     (first);					// dipense mode (published as jetModePartVolume(0) before V4.0)
		static const variable jet_    (first + 1);			// same as jet, for compatibility only (published as jetModeEmptyTip(1) before V4.0)
		static const variable surface (first + 2);			// dipense mode (published as jetModeEmptyTip(2) before V4.0)
		static const variable surface_(first + 3);			// same as surface, for compatibility only (published as jetModeEmptyTip(3) before V4.0)
		static const variable last    (first + 3);			// guard

		// functions
		static function AsString(variable dispenseMode);			// returns the string representation of a DispenseMode member
	}

	// --------------------------------------------------------------------------------------
	// Dispense Mode (used by the ML_STAR dispense) internal used only
	// --------------------------------------------------------------------------------------
	namespace StarDispenseMode
	{
		static const variable first(0);										// guard
		static const variable jetPartVolume(first);						// dipense mode
		static const variable jetEmptyTip(first + 1);					// dipense mode
		static const variable surfacePartVolume(first + 2);			// dipense mode
		static const variable surfaceEmptyTip(first + 3);				// dipense mode
		// (first + 4)		// unused
		// ...
		// (first + 8)		// unused
		static const variable blowoutTip(first + 9);						// dipense mode
		static const variable last(first + 9);								// guard

		// functions

		static function AsString(variable dispenseMode);			// returns the string representation of a StarDispenseMode member
	}

	// --------------------------------------------------------------------------------------
	// Dispense Type (internaly used only)
	// --------------------------------------------------------------------------------------
   namespace DispenseType
   {
		static const variable first(1);									// guard
		static const variable regularDispense(first);				// dispense type
		static const variable preDispense(first + 1);      		// dispense type
		static const variable postDispense(first + 2);				// dispense type
		static const variable last(first + 2);							// guard
   }

	// --------------------------------------------------------------------------------------
	// LLD Sensitivity
	// --------------------------------------------------------------------------------------

	namespace LLDSensitivity
	{
		static const variable first(0);									// guard
		static const variable off(first);								// LLD sensitivity
		static const variable veryHigh(first + 1);					// LLD sensitivity
		static const variable high(first + 2);							// LLD sensitivity
		static const variable middle(first + 3);						// LLD sensitivity
		static const variable low(first + 4);							// LLD sensitivity
		static const variable fromLabwareDefinition(first + 5);	// LLD sensitivity
		static const variable last(first + 5);							// guard

		// functions

		static function AsString(variable lldSensitivity);			// returns the string representation of a LLDSensitivity member
	}



	// --------------------------------------------------------------------------------------
	// Main Error (see HxGruCommand.chm)
	// --------------------------------------------------------------------------------------

	namespace MainError
	{
		static const variable noError(0);								// No error.
		static const variable syntaxError(1);							// There is a wrong set of parameters or parameter ranges.
		static const variable hardwareError(2);						// Steps lost on one or more hardware components, or component not initialized or not functioning.
		static const variable commandNotCompletedError(3);			// There was an error in previous part command.
		static const variable clotError(4);								// Blood clot detected.
		static const variable noBarcodeError(5);						// Barcode could not be read or is missing.
		static const variable insufficientError(6);			      // Not enough liquid available.
		static const variable pickUpError(7);							// A tip has already been picked up.
		static const variable noTipError(8);							// Tip is missing or not picked up.
		static const variable noCarrierError(9);						// No carrier present for loading.
		static const variable executionError(10);						// A step or a part of a step could not be processed.
		static const variable lldError(11);								// A dispense with pressure liquid level detection is not allowed.
		static const variable noTeachInSignalError(12);				// No capacitive signal detected during carrier calibration procedure.
		static const variable loadingClapError(13);					// Not possible to unload the carrier due to occupied loading tray position.
		static const variable pressureLLDError(14);					// Pressure liquid level detection in a consecutive aspiration is not allowed.
		static const variable parameterCombinationError(15);		// Dispense in jet mode with pressure liquid level detection is not allowed.
		static const variable coverError(16);							// Cover not closed or can not be locked.
		static const variable improperAspirationError(17);			// The pressure-based aspiration / dispensation control reported an error ( not enough liquid ).
		static const variable washerError(18);							// Waste full or no more wash liquid available.
		static const variable incubationError(19);					// Incubator temperature out of range.
		static const variable TADMError(20);							// Overshot of limits during aspirate or dispense. On aspirate this error is returned as main error 17. On dispense this error is returned as main error 4.
		static const variable plateNotGrippedError(21);				// Labware not available.
		static const variable plateStillHoldError(22);				// Labware already gripped.
		static const variable plateLostError(23);						// Labware lost during transport.
		static const variable illegalTargetPlatePositionError(24);// Cannot place plate, plate was gripped in a wrong direction.
		static const variable illegalUserAccessError(25);			// Cover was opened or a carrier was removed manually.
		static const variable TADMMeasurementError(26);				// Undershot of limits during aspirate or dispense. On aspirate this error is returned as main error 4. On dispense this error is returned as main error 17.
		static const variable iSWAPError(27);							// The position is out of range.
      static const variable unexpectedCLLDError(28);           // The cLLD detected a liquid level above start height of liquid level search.
		static const variable slaveError(99);							// Slave error.
		static const variable wrongCarrierError(100);				// Wrong carrier barcode detected.
		static const variable noCarrierBarcodeError(101);			// Carrier barcode could not be read or is missing.
		static const variable lldNotFoundError(102);					// Liquid surface not detected.
		static const variable carrierNotAtEndError(103);			// Carrier not detected at deck end position.
		static const variable notAspiratedError(104);			   // Dispense volume exceeds the aspirated volume.
		static const variable improperDispensationError(105);		// The dispensed volume is out of tolerance (may only occur for Nano Pipettor Dispense steps).
		static const variable noLabwareError(106);			      // The labware to be loaded was not detected by autoload module. May only occur on a Reload Carrier step if the labware property 'MlStarCarPosAreRecognizable' is set to 1.
		static const variable unexpectedLabwareError(107);			// The labware contains unexpected barcode (may only occur on a Reload Carrier step).
		static const variable wrongLabwareError(108);			   // The labware to be reloaded contains wrong barcode (may only occur on a Reload Carrier step).
		static const variable barcodeMaskError(109);			      // The barcode read doesn't match the barcode mask defined.
		static const variable barcodeNotUniqueError(110);		   // The barcode read is not unique. Previously loaded labware with same barcode was loaded without unique barcode check.
		static const variable barcodeAlreadyUsedError(111);		// The barcode read is already loaded as unique barcode (it's not possible to load the same barcode twice).
		static const variable kitLotExpiredError(112);			   // Kit Lot expired.
      static const variable delimiterBarcodeError(113);			// The barcode contains character which is used as delimiter in result string.
	}

	// --------------------------------------------------------------------------------------
	// Recovery Button
	// --------------------------------------------------------------------------------------

	namespace RecoveryButton
	{
		static const variable abort_(1);									// recovery button
		static const variable cancel(2);									// recovery button
		static const variable initialize(3);							// recovery button
		static const variable repeat(4);									// recovery button
		static const variable exclude(5);								// recovery button
		static const variable waste(6);									// recovery button
		static const variable air(7);										// recovery button
		static const variable bottom(8);									// recovery button
		static const variable continue(9);								// recovery button
		static const variable barcode(10);								// recovery button
		static const variable next_(11);									// recovery button
		static const variable available(12);								// recovery button
	}

	// --------------------------------------------------------------------------------------
	// Sample Tracker Action State
	// --------------------------------------------------------------------------------------

	namespace SampleTrackerActionState
	{
		 static const variable NoError(0);
		 static const variable Fatal(1);
		 static const variable Error(2);
		 static const variable Warning(3);
	}

	// --------------------------------------------------------------------------------------
	// Sequence Initialization
	// --------------------------------------------------------------------------------------

	namespace SequenceInitialization
	{
		static const variable first(-10);								// guard
		static const variable none(first);								// initialization
		static const variable reset(first + 1);						// initialization
		static const variable last(first + 1);							// guard

		// functions

		static function AsString(variable initialization);			// returns the string representation of an SequenceInitialization member
	}

	// --------------------------------------------------------------------------------------
	// Sequence Finalization
	// --------------------------------------------------------------------------------------

	namespace SequenceFinalization
	{
		static const variable first(-10);								// guard        (2009-05-27/cj: added descriptions below)
		static const variable none(first);								// finalization (keep the current/count as it is after pipette)
		static const variable reset(first + 1);						// finalization (reset the current/count to first/total sequence positions)
		static const variable initial(first + 2);						// finalization (move the current/count to the position as it was at the beginning of the pipette)
		static const variable final(first + 3);						// finalization (move the current to first unused pos after pipette / count to last used pos within pipette)
		static const variable last(first + 3);							// guard        (Note: from the generated code (Smart Step Pipette) only the following compinations are
																					//                     currently in use for Aspirate/Dispense sequence:
																					//                     - for 'sequence to range remainging after step:
																					//                       -->> CurrentFinalization = -7 (final)
																					//                            CountFinalization   = -8 (initial)
																					//                     - for 'sequence to range used within this step:
																					//                       -->> CurrentFinalization = -8 (initial)
																					//                            CountFinalization   = -7 (final)
																					//                      For tip sequence this setting is not explicit defined from
																					//                      pipette generated code so the defaults (-10=none) is used for current/count finalization)

		// functions

		static function AsString(variable finalization);			// returns the string representation of an SequenceFinalization member

		static function CurrentToNone(									// finalizes the current position of the specified sequence to 'none'
			sequence& pipSequence,											// i: pipetting sequence
			variable orgCurrent,												// i: current position of original sequence
			variable actCurrent,												// i: current position of actual sequence
			variable orgCount,												// i: count position of original sequence
			variable actCount);												// i: count position of actual sequence

		static function CurrentToFinal(									// finalizes the current position of the specified sequence to 'final'
			sequence& pipSequence,											// i: pipetting sequence
			variable orgCurrent,												// i: current position of original sequence
			variable actCurrent,												// i: current position of actual sequence
			variable orgCount,												// i: count position of original sequence
			variable actCount);												// i: count position of actual sequence

// 2009-05-27/cj: not longer used. Moved previous implementation to CountToFinal.
//		static function CountToNone(										// finalizes the count position of the specified sequence to 'none'
//			sequence& pipSequence,											// i: pipetting sequence
//			variable orgCurrent,												// i: current position of original sequence
//			variable actCurrent,												// i: current position of actual sequence
//			variable orgCount,												// i: count position of original sequence
//			variable actCount);												// i: count position of actual sequence

		static function CountToFinal(										// finalizes the count position of the specified sequence to 'final'
			sequence& pipSequence,											// i: pipetting sequence
			variable orgCurrent,												// i: current position of original sequence
			variable actCurrent,												// i: current position of actual sequence
			variable orgCount,												// i: count position of original sequence
			variable actCount);												// i: count position of actual sequence
	}

	// --------------------------------------------------------------------------------------
	// Error Ids
	// --------------------------------------------------------------------------------------

	namespace IDE
	{
		static const variable first(0);											// guard
		static const variable noError(first);									// No error.
		static const variable invalidParameter(first + 1);					// The parameter is incorrect.
		static const variable invalidPCBKey(first + 2);						// The key of the pipetting control setting is invalid.
		static const variable invalidPCBValue(first + 3);					// The value of the pipetting control setting is invalid.
		static const variable invalidLCBKey(first + 4);						// The key of the loading control setting is invalid.
		static const variable invalidLCBValue(first + 5);					// The value of the loading control setting is invalid.
		static const variable invalidUCBKey(first + 6);						// The key of the unloading control setting is invalid.
		static const variable invalidUCBValue(first + 7);					// The value of the unloading control setting is invalid.
		static const variable invalidLLDMode(first + 8);					// The liquid level detection mode is invalid.
		static const variable invalidDrivingMode(first + 9);				// The driving mode is invalid.
		static const variable invalidTipType(first + 10);					// The tip type is invalid.
		static const variable invalidSequenceCounting(first + 11);		// The sequence counting setting is invalid.
		static const variable invalidTipCounting(first + 12);				// The tip counting setting is invalid.
		static const variable invalidChannelUse(first + 13);				// The channel use setting is invalid.
		static const variable invalidAspirateMode(first + 14);			// The aspirate mode setting is invalid.
		static const variable invalidDispenseMode(first + 15);			// The dispense mode setting is invalid.
		static const variable invalidLLDSensitivity(first + 16);			// The LLD sensitivity setting is invalid.
		static const variable invalidMultiplicity1(first + 17);			// Not both of the multiplicities can be greater than one.
		static const variable invalidMultiplicity2(first + 18);			// The multiplicity must be greater than or eaqual to one.
		static const variable invalidVolume(first + 19);					// The volume is invalid.
		static const variable invalidRestVolume(first + 20);				// The rest volume is invalid.
		static const variable invalidPrePostVolume(first + 21);			// The volume of the pre- or post-aliquot is invalid.
		static const variable invalidMixVolume(first + 22);				// The mix volume is invalid.
		static const variable invalidRenewalCycle(first + 23);			// The tip renewal cycle is invalid.
		static const variable invalidInitialization(first + 24);			// The sequence initialization is invalid.
		static const variable invalidFinalization(first + 25);			// The sequence finalization is invalid.
		static const variable invalidErrorHandling(first + 26);			// The error handling is invalid.
		static const variable invalidRestVolumeDestination(first + 27);// The rest volume destination is invalid.
		static const variable invalidLiquidClass(first + 28);				// The liquid class is invalid.
		static const variable invalidTipCountingIdentifier(first + 29);// The tip counting identifier is invalid.
		static const variable invalidFirst(first + 30);						// The first sequence position is invalid.
		static const variable invalidLast(first + 31);						// The last sequence position is invalid.
		static const variable loadingCanceled(first + 32);					// The loading was canceled by the user.
		static const variable unloadingCanceled(first + 33);				// The unloading was canceled by the user.
		static const variable methodAborted(first + 34);					// The method was aborted by the user.
		static const variable invalidWCBKey(first + 35);					// The key of the washing control setting is invalid.
		static const variable invalidWCBValue(first + 36);					// The value of the washing control setting is invalid.
		static const variable invalidTCBKey(first + 37);					// The key of the tip handling control setting is invalid.
		static const variable invalidTCBValue(first + 38);					// The value of the tip handling control setting is invalid.
		static const variable advancedLoadSettingsConflict(first + 39);// Conflict in advanced load settings for carrier '%s'.
		static const variable unexpectedStepReturn(first + 40);			// Step '%s' returned an unexpected number of return values.
		static const variable invalidStepType(first + 41);					// The step type '%s' is invalid for the specified function.
		static const variable noKitLotInBarcodeMask(first + 42);			// The kit lot was not found in the barcode mask '%s'.
		static const variable invalidBarcodeValueOrBarcodeMask(first + 43);// The barcode value or the barcode mask is invalid: '%s'.
		static const variable kitLotNotDefined(first + 44);				// The kit lot '%s' was not found in the kit lot file.
		static const variable defaultWasteNotFound(first + 45);			// The default waste '%s' specified in the Microlab STAR Configuration Editor was not found in the instruments deck layout.
		static const variable emptySequence(first + 46);					// The sequence '%s' must not be empty.
		static const variable kitLotFileNotFound(first + 47);				// The kit lot file '%s' was not found.
		static const variable failedToDispenseRestVolume(first + 48);	// Failed to dispense the rest volume back to the aspirate sequence.
		static const variable createObjectFailed(first + 49);				// Failed to create an object '%s'
		static const variable queryInterfaceFailed(first + 50);			// Failed to query for interface '%s'
		//>> 20060503
		static const variable invalidMultiplicity3(first + 51);			// Both of the multiplicities must be equal to 1 (Pipette Simple only).
		static const variable aliquotingMustBeDisabled(first + 52);		// Aliquoting must be disabled.
		static const variable tooFewVolumes(first + 53);					// The number of available volumes must be be greater than or equal to the number of available pipetting positions.
		//<< 20060503
		static const variable fileOpenFailed(first + 54);					// Failed to open the specified file.
		
      // < SCR 1299:
      //static const variable noLabIdPosIdFoundForRequiredSource(first + 55);// No labware id and / or position id found for required source.
      static const variable requiredSamplesDlgCancelled(first + 55);// Required samples dialog is cancelled
		// >
      
      static const variable last(first + 55);								// guard
	}

	// --------------------------------------------------------------------------------------
	// String Ids
	// --------------------------------------------------------------------------------------

	namespace IDS
	{
		// private
		static const variable first(IDE::last + 1);							// guard
		static const variable errorTitle(first);								// error
		static const variable errorText(first + 1);							// text
		static const variable traceSource(first + 2);						// source for formated trace
		static const variable editSequenceTitle(first + 3);				// title for edit sequence dialog
		static const variable editTipPickupSequencePrompt(first + 4);	// prompt for edit sequence dialog
		static const variable unloadSequenceTitle(first + 5);				// title for unload sequence dialog
		static const variable unloadSequencePrompt(first + 6);			// prompt for unload sequence dialog
		static const variable loadSequenceTitle(first + 7);				// title for load sequence dialog
		static const variable loadSequencePrompt(first + 8);				// prompt for load sequence dialog
		static const variable helpFileName(first + 9);						// help file name
		static const variable aliquotDisabled(first + 10);					// trace for transition from aliquot to simple pipette
		static const variable askUserForReloadTitle(first + 11);			// ask user for reload title
		static const variable askUserForReloadText(first + 12);			// ask user for reload text
		static const variable askUserForReloadText2(first + 13);			// ask user for reload text
		static const variable openingBracket(first + 14);					// opening bracket 
		static const variable closingBracket(first + 15);					// closing bracket
		static const variable period(first + 16);								// period (.)
		static const variable mixingOnAspirateIgnored(first + 17);		// trace to warn that mixing on aspirate is ignored
		static const variable mixingOnDispenseIgnored(first + 18);		// trace to warn that mixing on dispense is ignored
		static const variable expiredKitLotPrompt(first + 19);			// prompt for unload sequence dialog
		static const variable questionMark(first + 20);						// question mark (?)
		static const variable traceWarning(first + 21);						// trace a warning, "Warning: <some text>"
		static const variable washSettingsNotForCurrentTaskId(first + 22);	// Warn if wash settings are not set for current task
		static const variable loadSettingsNotForCurrentTaskId(first + 23);	// Warn if load settings are not set for current task
		static const variable actionNeedleWash(first + 24);				// Action needle washing
		static const variable actionLoad(first + 25);						// Action load/reload
		static const variable carrierNameColumnName(first + 26);			// Carrier name coulmn name
		static const variable carrierBarcodeColumnName(first + 27);		// Carrier barcode coulmn name
		static const variable labwarePositionColumnName(first + 28);	// Labware position coulmn name
		static const variable labwareBarcodeColumnName(first + 29);		// Labware barcode coulmn name
		static const variable unusedSampleTubesReportText(first + 30);	// Unused Sample Tubes Report text
		static const variable unusedSampleTubesReportTitle(first + 31);// Unused Sample Tubes Report title
		static const variable requiredSampleTubesReportText(first + 32);// Required Sample Tubes Report text1
      static const variable requiredSampleTubesReportText2(first + 33); // Required Sample Tubes Report text2
		static const variable requiredSampleTubesReportTitle(first + 34);// Required Sample Tubes Report title
      static const variable sourceBarcodeColumnName(first + 35);     // Source Barcode column name
      static const variable requiredAtAnyFreePos(first + 36);     // Sample loadable at any free pos  
		
		// public
		static const variable smartStepPipetteWithTips(first + 37);		// action for formated trace (obsolete)
		static const variable smartStepAdvancedLoadSettings(first + 38);// action for formated trace
		static const variable smartStepLoad(first + 39);					// action for formated trace
		static const variable smartStepUnload(first + 44);					// action for formated trace
		static const variable smartStepNeedleWashSettings(first + 41);	// action for formated trace
		static const variable smartStepNeedlePickup(first + 42);			// action for formated trace
		static const variable smartStepNeedleEject(first + 43);			// action for formated trace
		static const variable smartStepTipPickup(first + 44);				// action for formated trace
		static const variable smartStepTipEject(first + 45);				// action for formated trace
		static const variable smartStepRuntimeError(first + 46);			// smart step runtime error 
		static const variable smartStepUnspecifiedError(first + 47);	// smart step unspecified error 
		static const variable smartStepFailed(first + 48);					// smart step failed 
		static const variable smartStepPipette(first + 49);				// action for formated trace
		static const variable smartStepLoadAndMatch(first + 50);			// action for formated trace
	}

	// --------------------------------------------------------------------------------------
	// String Constants
	// --------------------------------------------------------------------------------------

	namespace StringConstants
	{
		// data
		static const variable cr("\013");											// carriage return
		static const variable lf("\010");											// linefeed 
		static const variable crlf("\013\010");									// carriage return linefeed combination
		static const variable newLine("\010");										// new line
		static const variable tab("\009");											// horizontal tab
		static const variable csvDelimiter(",");									// delimiter for comma separated values
		static const variable csvDelimiter2(", ");								// delimiter for comma separated values
		static const variable barcodeFileExt("_Barcodes.txt");				// extension of barcode file
		static const variable helpFileExt(".hlp");								// extension of help file
		static const variable carIsLoadableKey("MlStarCarIsLoadable");		// key for labware data
		static const variable carCalibrateXKey("MlStarCarCalibrateX");		// key for labware data
		static const variable tipRackKey("MlStarTipRack");						// key for labware data
		static const variable needleWashRackKey("MlStarNeedleWashRack");	// key for labware data
		static const variable carWidthTKey("MlStarCarWidthAsT");				// key for labware data
		static const variable carCountOfBCPosKey("MlStarCarCountOfBCPos");// key for labware data
		static const variable carFirstBCPosKey("MlStarCarFirstBCPos");		// key for labware data
		static const variable carBCReadWidthKey("MlStarCarBCReadWidth");	// key for labware data
		static const variable carRasterWidthKey("MlStarCarRasterWidth");	// key for labware data
		static const variable carLabelName("MlStarCarLabelName");			// Key for labware data
		//>> 20060208 (SCR#1121)
		static const variable carNoReadBarcode("MlStarCarNoReadBarcode");	// Key for labware data
		//<< 20060208
		static const variable templateDefaultName("default");					// template default name
		static const variable tipCountingId("TipCount");						// tip count identifier
		static const variable kitLotJokerKey("KitLot");							// kit lot joker key
		// ba 2002-04-08 begin (SCR#361)
		static const variable kitLotFileName("KitLot.xls");					// kit lot file name
		// end
		// 20050513 begin
		static const variable mlStarInstrumentKey("ML_STAR");					// the microlab star instrument class name
		// 20050513 end
		static const variable carrierNameColumnName("Carrier name");								// carrier name coulmn name
		static const variable carrierBarcodeColumnName("Carrier barcode");						// carrier barcode coulmn name
		static const variable labwareNameColumnName("Labware name");								// labware name coulmn name
		static const variable labwarePositionColumnName("Labware position");						// labware position coulmn name
		static const variable labwareBarcodeColumnName("Labware barcode");						// Labware barcode coulmn name
		static const variable unusedSampleTubesReportTableName("UnusedSampleTubesReport");	// unused sample tubes report table name
		static const variable unusedSampleTubesInfoTableName("UnusedSampleTubesInfo");		// unused sample tubes info table name
		static const variable unusedSampleTubesReportFileNameExtension("UnusedSampleTubesReport.xls");// unused sample tubes report file name extension
		static const variable operatorColumnName("Operator");											// Operator coulmn name
		static const variable laboratoryColumnName("Laboratory");									// Labratory coulmn name
		static const variable instrumentNameColumnName("Instrument Name");						// Instrument Name coulmn name
		static const variable instrumentSerialNumberColumnName("Instrument Serial Number");	// Instrument Serial Number coulmn name
		static const variable dateColumnName("Date");													// Date coulmn name
		//>> 20100810 (SCR#1503)
		static const variable barcodePosDelimiter(",");	                  // delimiter used for ML_STAR.LoadCarrier Step parameter "Positions of labware items to be used"
		//<< 20100810
		static const variable fileNameSeqMerged("MlStarSmartStepSequenceMerged.xls"); // helper file used for sequence merge
	}

	// 20050513 begin
	// --------------------------------------------------------------------------------------
	// Numeric Constants
	// --------------------------------------------------------------------------------------

	namespace NumericConstants
	{
		// data
		static variable longMax(2147483647);										// Maximum (signed) long value
	}
	// 20050513 end

   namespace ProbeHeadParsKeys
   {
      const variable probeHeadRows       ( -433455096);
      const variable probeHeadColumns    ( -433455095);
      const variable probeTipDeltaColumn ( -433455094);
      const variable probeTipDeltaRow    ( -433455093);
      const variable probeTipRowStart    ( -433455092);
      const variable probeTipColStart    ( -433455091);
      const variable probeTipOrderByCol  ( -433455090);
      const variable probeTipSerpentine  ( -433455089);
      const variable probeTipDeltaXMin   ( -433455080);
      const variable probeTipDeltaXMax   ( -433455079);
      const variable probeTipDeltaYMin   ( -433455078);
      const variable probeTipDeltaYMax   ( -433455077);
   }

	// --------------------------------------------------------------------------------------
	// Pipetting Control Block (namespace PTL)
	// --------------------------------------------------------------------------------------

		// data

		// general settings 

		static variable UserResponseTime(Limits::maxTimeInterval);					// user response time [s]
		static variable ErrorHandling(ErrorHandling::continue);						// error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue, 4 = continue_2 , 5 = custom)
		static variable TipCountingEnabled(hslFalse);									// tip counting enabled flag
		static variable TipCountingIdentifier(StringConstants::tipCountingId);	// tip count identifier
		static variable CopyPatternEnabled(hslFalse);									// copy pattern enabled flag
		static variable ExcludeErrorPositionsEnabled(hslFalse);						// exclude error positions enabled flag
		//>> 20060519
		static variable ExcludeRecoveryOptionEnabled(hslTrue);						// exclude recovery option enabled flag
		//<< 20060519
		static variable TipPresence[](Limits::channelUpperBound);					// tip presence (hslFalse = not present, hslTrue = present)

		// aliquot settings 

		// public, read / write
		static variable AliquotEnabled(hslFalse);											// aliquot enabled flag
		static variable AliquotEnabledBak(hslFalse);										// backup of aliquot enabled flag
		static variable AliquotPreAspirateVolume(0);										// aspirate pre-aliquot volume [ul]
		static variable AliquotAspirateDefaultMixingEnabled(hslTrue);				// aspirate pre-aliquot default mixing enabled flag

		// private, read only
		// aspirate pre-aliquot settings 
		static const variable AliquotPreAspiratePrerinsingMixCycles(3);			// prerinsing / mix cycles 
		static const variable AliquotPreAspiratePrerinsingMixPosition(2);			// prerinsing / mix position [mm]
		static const variable AliquotPreAspiratePrerinsingMixVolumeMultiplier(1);// prerinsing / mix volume multiplier

		// initialize settings 

		static variable InitializeUseDefaultWaste(hslTrue);							// indicates whether to use the default waste (0 = off, 1 = on)
		static sequence InitializeWasteDestination;										// original initialize waste destination
		static variable InitializeChannelVariable(Limits::channelVariable16);	// channel variable (0 = unused, 1 = used)
		static variable InitializeSequenceCounting(SequenceCounting::manually);	// sequence counting (0 = manually, 1 = automatic)
		static variable InitializeChannelUse(ChannelUse::allSequencePositions);	// channel use (1 = all sequence positions, 2 = channel pattern)
		static variable InitializeAlways(hslFalse);										// initialize always flag
		static variable InitializeEnabled(hslTrue);										// initialize enabled flag (0 = disabled, 1 = enabled)
		static variable InitializeWasteDestinationReloadable(hslFalse);			// waste destination reloadable flag 
		static variable InitializeWasteDestinationReducible(hslFalse);				// waste destination reducible flag
      static variable InitializeCustomStepID(CustomStepID::stepErrorHandlingDefault); // custom step identifier

		// load carrier settings

		static variable LoadCarrierBarcodeFileName("");									// load carrier barcode file name, defaults to MethodPathName.txt
      static variable LoadCarrierCustomStepID(CustomStepID::stepErrorHandlingDefault); // custom step identifier

		// unload carrier settings

      static variable UnloadCarrierCustomStepID(CustomStepID::stepErrorHandlingDefault); // custom step identifier

		// calibrate carrier settings

		static variable CalibrateCarrierChannel(0);										// calibrate carrier channel, defaults to rightmost active channel
      static variable CalibrateCarrierCustomStepID(CustomStepID::stepErrorHandlingDefault); // custom step identifier

		// tip pickup settings

		static sequence TipPickupSequence;													// original tip pickup sequence
		static variable TipPickupChannelVariable(Limits::channelVariable16);		// channel variable (0 = unused, 1 = used)
		static variable TipPickupSequenceCounting(SequenceCounting::manually);	// sequence counting (0 = manually, 1 = automatic)
		static variable TipPickupChannelUse(ChannelUse::allSequencePositions);	// channel use (1 = all sequence positions, 2 = channel pattern)
		static variable TipPickupEnabled(hslTrue);										// tip pickup enabled flag (0 = disabled, 1 = enabled)
		static variable TipPickupSequenceReloadable(hslTrue);							// sequence reloadable flag
		static variable TipPickupSequenceReducible(hslTrue);							// sequence reducible flag
		static variable TipPickupSequenceCurrentInitialization(SequenceInitialization::none);// sequence initialization (-10 = none, -9 = reset, n = SetCurrentPosition(n)) 
		static variable TipPickupSequenceCurrentFinalization(SequenceFinalization::none);// sequence finalization (-10 = none, -9 = reset, -8 = set to initial, -7 = set to final, n = SetCurrentPosition(n)) 
		static variable TipPickupSequenceCountInitialization(SequenceInitialization::none);// sequence initialization (-10 = none, -9 = reset, n = SetCount(n)) 
		static variable TipPickupSequenceCountFinalization(SequenceFinalization::none);// sequence finalization (-10 = none, -9 = reset, -8 = set to initial, -7 = set to final, n = SetCount(n)) 
		static variable TipPickupReverseSequenceCount(Limits::reverseSequenceCount);// count of reverse tip pickup sequence
      static variable TipPickupCustomStepID(CustomStepID::stepErrorHandlingDefault); // custom step identifier

		// tip eject settings 

		static variable TipEjectUseDefaultWaste(hslTrue);								// indicates whether to use the default waste (0 = off, 1 = on)
		static sequence TipEjectWasteDestination;											// original tip eject waste destination
		static variable TipEjectChannelVariable(Limits::channelVariable16);		// channel variable (0 = unused, 1 = used)
		static variable TipEjectChannelUse(ChannelUse::allSequencePositions);	// channel use (1 = all sequence positions, 2 = channel pattern)
		static variable TipEjectSequenceCounting(SequenceCounting::manually);	// sequence counting (0 = manually, 1 = automatic)
		static variable TipEjectWasteDestinationReloadable(hslFalse);				// waste destination reloadable flag 
		static variable TipEjectWasteDestinationReducible(hslFalse);				// waste destination reducible flag 
      static variable TipEjectCustomStepID(CustomStepID::stepErrorHandlingDefault); // custom step identifier

		// aspirate settings 

		static sequence AspirateSequence;													// read / write original aspirate sequence (ev. WITH excluded positions)
		static sequence AspirateSequenceOriginal;											// readonly original aspirate sequence (WITHOUT excluded positions)
		static variable AspirateSequenceCounting(SequenceCounting::manually);	// sequence counting (0 = manually, 1 = automatic)
		static variable AspirateChannelUse(ChannelUse::allSequencePositions);	// channel use (1 = all sequence positions, 2 = channel pattern)
		static variable AspirateMode(AspirateMode::aspiration);						// aspirate mode (0 = aspiration, 1 = consecutive aspiration, 2 = empty cup aspiration)
		static variable AspirateCLLDSensitivity(LLDSensitivity::off);				// capacitive liquid level detection (0 = off, 1 = very high, 2 = high, 3 = middle, 4 = low)
		static variable AspirateFluidHeight(0);											// liquid height from bottom if liquid level detection is disabled
		static variable AspirateSubmergeDepth(2);											// submerge depth after the liquid level detection [mm]
		static variable AspirateVolume(0);													// aspirate volume [ul]
		static variable AspirateVolumes[];													// individual aspirate volumes [ul]
		static variable AspirateRestVolume(0);												// aspirate rest volume [ul]
		static variable AspirateChannelVariable(Limits::channelVariable16);		// channel variable (0 = unused, 1 = used)
		static variable AspirateMaxHeightDiff(0);											// the maximum difference between the two liquid level detection measurements [mm]
		static variable AspiratePLLDSensitivity(LLDSensitivity::off);				// pressure liquid level detection (0 = off, 1 = very high, 2 = high, 3 = middle, 4 = low)
		static variable AspirateLiquidFollowing(hslTrue);								// liquid following during aspirate and mix (0 = disabled, 1 = enabled)
		static variable AspiratePrerinsingMixCycles(0);									// prerinsing / mix cycles 
		static variable AspiratePrerinsingMixPosition(2);								// prerinsing / mix position [mm]
		static variable AspiratePrerinsingMixVolume(0);									// prerinsing / mix volume [ul]
		static variable AspirateUserDefinedLiquidClass("");							// liquid class, will be automatically selected if not explicitly set
		static variable AspirateSequenceReloadable(hslTrue);							// sequence reloadable flag 
		static variable AspirateSequenceReducible(hslTrue);							// sequence reducible flag 
		static variable AspirateSequenceCurrentInitialization(SequenceInitialization::reset);// sequence initialization (-10 = none, -9 = reset, n = SetCurrentPosition(n)) 
		static variable AspirateSequenceCurrentFinalization(SequenceFinalization::initial);// sequence finalization (-10 = none, -9 = reset, -8 = set to initial, -7 = set to final, n = SetCurrentPosition(n)) 
		static variable AspirateSequenceCountInitialization(SequenceInitialization::none);// sequence initialization (-10 = none, -9 = reset, n = SetCount(n)) 
		static variable AspirateSequenceCountFinalization(SequenceFinalization::none);// sequence finalization (-10 = none, -9 = reset, -8 = set to initial, -7 = set to final, n = SetCount(n)) 
		static variable AspirateSequenceCalibration(hslTrue);							// sequence calibration flag
      static variable AspirateCustomStepID(CustomStepID::stepErrorHandlingDefault); // custom step identifier
		// private, read / write
		static variable AspirateSequenceCurrentAlignPos(0);							// last alignment position in aspirate sequence
		static variable AspirateSequenceReloaded(hslFalse);							// set if the aspirate sequence IS reloaded during processing

		// dispense settings 

		static sequence DispenseSequence;													// original dispense sequence
		static sequence DispenseSequenceOriginal;											// readonly original dispense sequence (WITHOUT excluded positions)
		static variable DispenseSubmergeDepth(2);											// submerge depth after the liquid level detection [mm]
		static variable DispenseChannelVariable(Limits::channelVariable16);		// channel variable (0 = unused, 1 = used)
		static variable DispenseVolume(0);													// dispense volume [ul]
		static variable DispenseVolumes[];													// individual dispense volumes [ul]
		static variable DispenseRestVolume(0);												// dispense rest volume [ul]
		static variable DispenseRestVolumeDestination(RestVolumeDestination::waste);// dispense rest volume destination (0 = waste, 1 = aspirate sequence)
		static variable DispenseRestVolumeFluidHeight(10);								// liquid height from bottom to dispense rest volume or pre-aliquot respectively
		static const variable DispenseRestVolumeConstFluidHeight(10);				// liquid height from bottom to dispense rest volume to the waste 
		// ba 20050511 begin (SCR#736)
		static variable DispenseRestVolumeToAspirateSequenceSurface(hslFalse);	// indicates whether to dispense the rest volume to the surface of the rest volume
		// ba 20050511 end (SCR#736)
		static variable DispenseChannelUse(ChannelUse::allSequencePositions);	// channel use (1 = all sequence positions, 2 = channel pattern)
		static variable DispenseCLLDSensitivity(LLDSensitivity::off);				// capacitive liquid level detection (0 = off, 1 = very high, 2 = high, 3 = middle, 4 = low)
		static variable DispenseSequenceCounting(SequenceCounting::manually);	// sequence counting (0 = manually, 1 = automatic)
		static variable DispenseFluidHeight(0);											// liquid height from bottom if liquid level detection is disabled
		static variable DispenseMode(DispenseMode::jet);								// dispense mode (0/1 = jet, 2/3 = surface)
		static variable DispenseLiquidFollowing(hslTrue);								// liquid following during dispense and mix (0 = disabled, 1 = enabled)
		static variable DispensePrerinsingMixCycles(0);									// prerinsing / mix cycles 
		static variable DispensePrerinsingMixPosition(2);								// prerinsing / mix position [mm]
		static variable DispensePrerinsingMixVolume(0);									// prerinsing / mix volume [ul]
		static variable DispenseUserDefinedLiquidClass("");							// liquid class, will be automatically selected if not explicitly set
		static variable DispenseSequenceReloadable(hslTrue);							// sequence reloadable flag 
		static variable DispenseSequenceReducible(hslTrue);							// sequence reducible flag 
		static variable DispenseSequenceCurrentInitialization(SequenceInitialization::reset);// sequence initialization (-10 = none, -9 = reset, n = SetCurrentPosition(n)) 
		static variable DispenseSequenceCurrentFinalization(SequenceFinalization::initial);// sequence finalization (-10 = none, -9 = reset, -8 = set to initial, -7 = set to final, n = SetCurrentPosition(n)) 
		static variable DispenseSequenceCountInitialization(SequenceInitialization::none);// sequence initialization (-10 = none, -9 = reset, n = SetCount(n)) 
		static variable DispenseSequenceCountFinalization(SequenceFinalization::none);// sequence finalization (-10 = none, -9 = reset, -8 = set to initial, -7 = set to final, n = SetCount(n)) 
		static variable DispenseSequenceCalibration(hslTrue);							// sequence calibration flag
      static variable DispenseCustomStepID(CustomStepID::stepErrorHandlingDefault); // custom step identifier for regular dispense step
      static variable PreDispenseCustomStepID(CustomStepID::stepErrorHandlingDefault); // custom step identifier for pre-dispense step
      static variable PostDispenseCustomStepID(CustomStepID::stepErrorHandlingDefault); // custom step identifier for post-diepense step
		// private, read / write
		static variable DispenseSequenceCurrentAlignPos(0);							// last alignment position in dispense sequence
		static variable DispenseSequenceReloaded(hslFalse);							// set if the dispense sequence IS reloaded during processing

      // Start Needle Wash settings      

      static variable StartNeedleWashCustomStepID(CustomStepID::stepErrorHandlingDefault); // custom step identifier

      // Wait Needle Wash settings      

      static variable WaitNeedleWashCustomStepID(CustomStepID::stepErrorHandlingDefault); // custom step identifier

	namespace PCB
	{
		// data
		static variable pcbControlSettingsBak[];						// place to hold backup of PCB control settings 
		static sequence pcbControlSequencesBak[];						// place to hold backup PCB control sequences 

		// functions

		static function Dump();												// dumps the settings in the pipetting control block

		static function DumpSequences();									// dumps the sequences in the pipetting control block

		static function DumpSequence(										// dumps the given sequences 
			sequence& sequenceObj,											// i: the sequence object
			variable indexesOnly);											// i: specifies whether only indexes should be dumped

		static function Validate();										// validates the settings in the pipetting control block

		static function GetState(											// gets the state for a specified pipetting control setting
			variable& pcbKey,													// i: the name of the pipetting control setting
			variable& pcbValue);												// o: a reference to a variable to retrieve the value of the pipetting control setting

		static function GetPipSequence(									// gets the state for a specified pipetting sequence
			variable& pcbKey,													// i: the name of the pipetting sequence
			sequence& pcbValue);												// o: the value of the pipetting sequence

		static function SetState(											// sets the state for a specified pipetting control setting
			variable& pcbKey,													// i: the name of the pipetting control setting
			variable& pcbValue);												// i: the value of the pipetting control setting

		static function BindStates(										// binds all pipetting control setting which have not yet been set to a reasonable value
			device& ML_STAR);													// i: pipetting device

		static function SetPipSequence(									// sets the state for a specified pipetting sequence
			variable& pcbKey,													// i: the name of the pipetting sequence
			sequence& pcbValue);												// i: the value of the pipetting sequence

		static function IsWashSequence(									// returns true if passed sequence is a wash sequence
			device& ML_STAR,													// i: the device 
			sequence& sequenceToTest) variable;							// i: a sequence, e.g a TipPickUpSequence


		static function CheckAspirateMode();							// checks the aspirate mode

		static function CheckDispenseMode(								// checks the passed star-dispense mode
			variable starDispenseMode) void;								// i: One of the StarDispenseMode's

		static function GetDispenseMode(									// Returns the StarDispenseMode dependant of the current aliquot and the total number of aliquots
			variable currentAliquot,										// i: current aliquot (1-based)
			variable numberOfAliquots) variable;						// i: number of aliquot

		static function BackupSequences(									// backups the tip pickup, the aspirate and the dispense sequences
			device& ML_STAR,													// i: pipetting device
			sequence& tipPickupSequence,									// i: tip pickup sequence
			sequence& aspirateSequence,									// i: aspirate sequence
			sequence& dispenseSequence,									// i: dispense sequence
			sequence& defaultWasteSequence,								// i: default waste sequence
			variable& controlBlock);										// i: control block (string), one of {"PCB", "TCB"}

		static function RestoreSequences(								// restores the tip pickup, the aspirate and the dispense sequences
			sequence& tipPickupSequence,									// i: tip pickup sequence
			sequence& aspirateSequence,									// i: aspirate sequence
			sequence& dispenseSequence,									// i: dispense sequence
			sequence& defaultWasteSequence);								// i: default waste sequence

		static function InitializeSequences(							// initializes the tip pickup, the aspirate and the dispense sequences
			sequence& tipPickupSequence,									// i: tip pickup sequence
			sequence& aspirateSequence,									// i: aspirate sequence
			sequence& dispenseSequence);									// i: dispense sequence

		static function FinalizeSequences(								// finalizes the tip pickup, the aspirate and the dispense sequences
			device& ML_STAR,													// i: pipetting device
			sequence& tipPickupSequence,									// i: tip pickup sequence
			sequence& aspirateSequence,									// i: aspirate sequence
			sequence& dispenseSequence,									// i: dispense sequence
			variable drivingMode);											// i: driving mode

		static function InitializeSequenceFromDeckLayout(			// initializes given sequence from the deck layout file, returns 'true' if the sequence was found in the deck layout, otherwise 'false'
			device& ML_STAR,													// i: pipetting device
			sequence& deckSequence);										// i: sequence

		static function UpdateSequenceInDeckLayout(					// updates given sequence in the deck layout file, returns 'true' if the sequence was found in the deck layout, otherwise 'false'
			device& ML_STAR,													// i: pipetting device
			sequence& deckSequence);										// i: sequence

		static function AlignSequenceCounts(							// aligns the aspirate and dispense sequence counts
			sequence& aspirateSequence,									// i: aspirate sequence
			sequence& dispenseSequence,									// i: dispense sequence
			variable aspirateMultiplicity,								// i:	aspirate multiplicity 
			variable dispenseMultiplicity,								// i:	dispense multiplicity
			variable drivingMode,											// i: driving mode
			variable continueAlignment);									// i: continue alignment flag (hslTrue or False)

		static function UnalignSequences(								// unaligns the aspirate and dispense sequences
			sequence& aspirateSequence,									// i: aspirate sequence
			sequence& dispenseSequence,									// i: dispense sequence
			variable drivingMode);											// i: driving mode

		static function IncrementSequences(								// increments the aspirate and dispense sequences 
			sequence& aspirateSequence,									// i: aspirate sequence
			sequence& dispenseSequence,									// i: dispense sequence
			//>> 20060503
			variable incrementIndividualVolumes,						// i: indicates whether to increment individual volumes (0 = single volume, 1 = increment individual volumes)
			variable& volumes_1[],											// i: volumes to restore
			variable& volumes_2[],											// i: volumes to restore
			//<< 20060503
			variable aspirateMultiplicity,								// i:	aspirate multiplicity 
			variable dispenseMultiplicity,								// i:	dispense multiplicity
			variable currentMultiplicity,									// i:	current multiplicity
			variable drivingMode);											// i: driving mode

		static function NeedsTipPickup(									// evaluates the tip pickup condition and returns true if tips need to be picked up
			variable& sequenceCycle,										// i: current cycle in the sequence loop
			variable& multiplicityCycle,									// i: current cycle in the multiplicity loop
			variable& volumeCycle,											// i: current cycle in the volume loop
			variable tipRenewalCycleSeq,									// i:	tip renewal cycle in the sequence loop (integer)
			variable tipRenewalCycleMul,									// i:	tip renewal cycle in the multiplicity loop (integer)
			variable tipRenewalCycleVol);									// i:	tip renewal cycle in the volume loop (integer)

		static function NeedsReload(										// evaluates the reload condition and returns true if any of the sequences needs to be reloaded
			sequence& tipPickupSequence,									// i: tip pickup sequence
			sequence& aspirateSequence,									// i: aspirate sequence
			sequence& dispenseSequence,									// i: dispense sequence
			variable aspirateMultiplicity,								// i:	aspirate multiplicity 
			variable dispenseMultiplicity,								// i:	dispense multiplicity
			variable drivingMode,											// i: driving mode
			variable deferTipPickupSequence);							// i: if true, the reload of the tip pickup sequence is defered

		static function DrivingSequenceNeedsReload(					// evaluates the reload condition and returns true if the driving sequence needs to be reloaded
			sequence& aspirateSequence,									// i: aspirate sequence
			sequence& dispenseSequence,									// i: dispense sequence
			variable drivingMode);											// i: driving mode

		static function TipPickupSequenceNeedsPreload(				// evaluates the preload condition of the tip pickup sequence and returns true if the sequence needs to be preloaded
			sequence& tipPickupSequence,									// i: tip pickup sequence
			sequence& aspirateSequence,									// i: aspirate sequence
			sequence& dispenseSequence,									// i: dispense sequence
			variable drivingMode);											// i: driving mode

		static function AskUserForReload(								// asks the user for reload
			sequence& aspirateSequence,									// i: aspirate sequence
			sequence& dispenseSequence,									// i: dispense sequence
			variable drivingMode);											// i: driving mode

		static function ReloadWasCanceled(								// returns true if the reload of the tipPickupSequence or the non-driving was canceled by the user 
			sequence& tipPickupSequence,									// i: tip pickup sequence
			sequence& aspirateSequence,									// i: aspirate sequence
			sequence& dispenseSequence,									// i: dispense sequence
			variable drivingMode);											// i: driving mode

		static function ReloadSequences(									// evaluates reload conditions and reloads the pipetting sequences 
			device& ML_STAR,													// i: pipetting device
			sequence& tipPickupSequence,									// i: tip pickup sequence
			sequence& aspirateSequence,									// i: aspirate sequence
			sequence& dispenseSequence,									// i: dispense sequence
			variable aspirateMultiplicity,								// i:	aspirate multiplicity 
			variable dispenseMultiplicity,								// i:	dispense multiplicity
			variable drivingMode,											// i: driving mode
			variable isWashSequence);										// i: if 'true', tip pickup sequence is a wash sequence

		static function PrepareReloadOfSequences(						// prepares reload of given pipetting sequences
			device& ML_STAR,													// i: pipetting device
			sequence& tipPickupSequence,									// i: tip pickup sequence
			sequence& aspirateSequence,									// i: aspirate sequence
			sequence& dispenseSequence,									// i: dispense sequence
			variable aspirateMultiplicity,								// i:	aspirate multiplicity 
			variable dispenseMultiplicity,								// i:	dispense multiplicity
			variable drivingMode,											// i: driving mode
			variable prepareReloadMode,									// i: prepare reload mode (0 = prepare for unload, 1 = prepare for reduce, 2 = prepare for load)
			variable errorHandling,											// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
			variable& carrierNames[],										// i/o: a reference to an array of variables to retrieve the carrier names
			variable& carrierCalibrateFlags[],							// i/o: a reference to an array of variables to retrieve the carrier calibrate flags
			variable& carrierBarcodeReadPositions[],					// i/o: a reference to an array of variables to retrieve the carrier barcode read positions
			variable& carrierBarcodeReadLabwareNames[],				// i/o: a reference to an array of variables to retrieve the carrier barcode read labware names
			variable& carrierBarcodeReadPositionNames[],				// i/o: a reference to an array of variables to retrieve the carrier barcode read position names
			variable& carrierRecoveryOptionContinue[],				// i/o: visibility of recovery option Continue (0 = invisible, 1 = visible)
			variable& carrierRecoveryOptionExclude[],					// i/o: visibility of recovery option Exclude (0 = invisible, 1 = visible)
			variable& carrierRecoveryOptionDefault[],					// i/o: default of recovery options Continue and Exclude (0 = Continue, 1 = Exclude) 
			variable& carrierKitLotCheckEnabled[],						// i/o: kit lot check enabled flag
			variable& prompt,													// i/o: user prompt
			variable bWarnLoadSettingsNotForTask);						// i: If true a warning is traced if the load settings are not defined for current task

		static function GetCarrierNames(									// collects names of loadable carriers given a sequence 
			device& ML_STAR,													// i: pipetting device
			sequence& pipSequence,											// i: pipetting sequence
			variable sequenceCalibrationFlag,							// i: sequence calibration flag
			variable errorHandling,											// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
			variable& carrierNames[],										// i/o: a reference to an array of variables to retrieve the carrier names
			variable& carrierCalibrateFlags[],							// i/o: a reference to an array of variables to retrieve the carrier calibrate flags
			variable& carrierBarcodeReadPositions[],					// i/o: a reference to an array of variables to retrieve the carrier barcode read positions
			variable& carrierBarcodeReadLabwareNames[],				// i/o: a reference to an array of variables to retrieve the carrier barcode read labware names
			variable& carrierBarcodeReadPositionNames[],				// i/o: a reference to an array of variables to retrieve the carrier barcode read position names
			variable& carrierRecoveryOptionContinue[],				// i/o: visibility of recovery option Continue (0 = invisible, 1 = visible)
			variable& carrierRecoveryOptionExclude[],					// i/o: visibility of recovery option Exclude (0 = invisible, 1 = visible)
			variable& carrierRecoveryOptionDefault[],					// i/o: default of recovery options Continue and Exclude (0 = Continue, 1 = Exclude) 
			variable& carrierKitLotCheckEnabled[],						// i/o: kit lot check enabled flag
			variable bWarnLoadSettingsNotForTask);						// i: If true a warning is traced if the load settings are not defined for current task

		static function GetCurrentPos(									// gets the current position of the aspirate or dispense sequence 
			sequence& aspirateSequence,									// i: aspirate sequence
			sequence& dispenseSequence,									// i: dispense sequence
			variable drivingMode);											// i: driving mode

		static function SetVolume(											// sets the volume of the aspirate or dispense sequence 
			sequence& dispenseSequence,									// i: dispense sequence
			variable totalVolume,											// i: total pipetting volume
			variable currentVolume,											// i: current pipetting volume
			variable& preVolume,												// i: volume of pre-aliquot (if any)
			variable& restVolume);											// i: rest volume

		//>> 20060503
		static function SetVolumes(										// sets the individual volumes of the aspirate or dispense sequence 
			sequence& aspirateSequence,									// i: aspirate sequence
			sequence& dispenseSequence,									// i: dispense sequence
			variable drivingMode,											// i: driving mode
			variable& totalVolumes[],										// i: total pipetting volumes
			variable& currentVolumes[],									// i: current pipetting volumes
			variable& restVolume);											// i: rest volume
		//<< 20060503

		static function GetPreVolume();									// gets the volume of pre-aliquot (if any) 

		static function SelectLiquidClass();							// automatically selects and sets the liquid class 

		static function SelectDefaultWaste(								// selects the default waste 
			device& ML_STAR,													// i: pipetting device
			sequence& defaultWasteSequence);								// i/o: default waste

		static function SetTipPresence(									// sets the presence of the tips on the given channels 
			string& channelPattern,											// i:	channel pattern
			variable numberOfChannels,										// i: number of channels 
			variable presence);												// i: presence specifier (hslFalse = not present, hslTrue = present)

		//>> 20060524
		static function SetTipPresence2(									// sets the presence of the tips according to the given tip pickup step return value
			variable& stepReturn) variable;								// i:	step return (string)
		//<< 20060524

		static function GetTipPresence();								// returns the presence of the tips on the channels as channel pattern

		static function BackupControlSettingsAndSequences();		// backups the PCB control settings and sequences which are relevant for the reloading procedure

		static function RestoreControlSettingsAndSequences();		// restores the PCB control settings and sequences which are relevant for the reloading procedure

		//>> 20060519
		//static function MapErrorHandlingContinue(variable errorHandling) variable;	// maps error handling option ErrorHandling::continue
		//<< 20060519

      static function MapErrorHandlingContinue(variable errorHandling, variable customStepID) variable;	// maps error handling option ErrorHandling::continue

		namespace Inner
		{
			static function Init(											// (re)initializes the settings in the pipetting control block (optionally from an hsl config file)
				string& cfgFile);												// i: the name of a file that specifies one or more values of the pipetting control settings (string; may be empty)
			static function InitFromConfig(								// (re)initializes the settings in the pipetting control block 
				string& cfgFile);												// i: the name of a file that specifies one or more values of the pipetting control settings 
		}
	}

	// --------------------------------------------------------------------------------------
	// Loading Control Block
	// --------------------------------------------------------------------------------------

	// --------------------------------------------------------------------------------------
	// Sequence Initialization
	// --------------------------------------------------------------------------------------

	namespace LoadingSequenceInitialization
	{
		static const variable first(-10);								// guard
		static const variable reset(first);								// initialization
		static const variable last(first);								// guard

		// functions

		static function AsString(variable initialization);			// returns the string representation of an SequenceInitialization member
	}

	namespace LCB
	{
		// data

		// general settings 
		static variable UserResponseTime(Limits::maxTimeInterval);// user response time [s]
		static variable ErrorHandling(ErrorHandling::continue);	 // error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue, 4 = continue_2, 5 = custom);
		static variable InitializeCustomStepID(CustomStepID::stepErrorHandlingDefault);
      static variable LoadCarrierCustomStepID(CustomStepID::stepErrorHandlingDefault);
      static variable CalibrateCarrierCustomStepID(CustomStepID::stepErrorHandlingDefault);

		// calibrate carrier settings
   	static variable CalibrateCarrierChannel(0);					// calibrate carrier channel, defaults to rightmost active channel

		// private data

		// Remark: The data is held per unique instrument sequence pair.

		// advanced load settings 
		static global variable ptlLcbInstrumentIdArr[];				// instrument id
		static global variable ptlLcbSequenceIdArr[];				// sequence id

		// 20050704 cjoerg added 
		static global variable ptlLcbTaskIdArr[];						// Task id for which the load settings are set explicit (OptionContinue, OptionExclude, OptionDefault, ...)

		static global variable ptlLcbRecoveryOptionContinueArr[];// visibility of recovery option Continue (0 = invisible, 1 = visible)
		static global variable ptlLcbRecoveryOptionExcludeArr[];	// visibility of recovery option Exclude (0 = invisible, 1 = visible)
		static global variable ptlLcbRecoveryOptionDefaultArr[];	// default of recovery options Continue and Exclude (0 = Continue, 1 = Exclude) 
		static global variable ptlLcbKitLotCheckEnabledArr[];		// kit lot check enabled flag

		static sequence sequenceObjArr[];								// the sequence objects
		static sequence sequenceObjCopyArr[];							// copies of the sequence objects
		static variable resetSequenceFlagArr[];						// holds the information if an empty sequence (read from HxElementCounter database) was reseted or not
		static variable firstArr[];										// the first positions in the sequences
		static variable lastArr[];											// the last positions in the sequences
		static variable editableArr[];									// specifies whether sequence editing by the user is enabled 
		static variable ioTipCountArr[];									// specifies whether to read / write the tip count (hslTrue or hslFalse)
		static variable tipCountIdentifierArr[];						// tip count identifiers

		// default loading settings 
		static variable recoveryOptionContinueDefault(1);			// visibility of recovery option Continue (0 = invisible, 1 = visible)
		static variable recoveryOptionExcludeDefault(1);			// visibility of recovery option Exclude (0 = invisible, 1 = visible)
		static variable recoveryOptionDefaultDefault(0);			// default of recovery options Continue and Exclude (0 = Continue, 1 = Exclude) 
		static variable kitLotCheckEnabledDefault(0);				// kit lot check enabled flag

		// functions

		static function DumpSequences();									// dumps the sequences in the pipetting control block

		static function Dump();												// dumps the state in the loading control block
		
		function GetStateEx(													// retrives the loading information for a specified loading control setting
			device& ML_STAR,													// i: the loading device (a Microlab® STAR)
			sequence& sequenceObj,											// i: the loading sequence
			variable& lcbKey, 												// i: the key of the loading control setting (string)
			variable& lcbValue,												// i: a reference to a variable to retrieve the values of the loading control setting (integer, float, or string)
			variable bWarnLoadSettingsNotForTask);						// i: If true a warning is traced if the load settings are not defined for current task

		function SetStateEx(													// sets the loading information for a specified loading control setting
			device& ML_STAR, 													// i: the loading device (a Microlab® STAR)
			sequence& sequenceObj, 											// i: the loading sequence
			variable& lcbKey, 												// i: the key of the loading control setting (string)
			variable& lcbValue);												// i: the value of the loading control setting (integer, float, or string)

		function ValidateStateEx();										// validates the loading information

		static function GetState(											// gets the state for a specified loading control setting
			variable& lcbKey,													// i: the name of the loading control setting
			variable& lcbValue);												// o: a reference to a variable to retrieve the value of the loading control setting

		static function SetState(											// sets the state for a specified loading control setting
			variable& lcbKey,													// i: the name of the loading control setting
			variable& lcbValue);												// i: the value of the loading control setting

		static function GetStateDefault(									// sets the default state for a specified loading control setting
			variable& lcbKey,													// i: the name of the loading control setting
			variable& lcbValue);												// o: a reference to a variable to retrieve the value of the loading control setting

		static function SetStateDefault(									// sets the default state for a specified loading control setting
			variable& lcbKey,													// i: the name of the loading control setting
			variable& lcbValue);												// i: the value of the loading control setting

		static function Setsize(											// establishes the loading size
			variable newSize);												// i: the new loading size (number of sequences)

		static function Getsize();											// returns the loading size

		static function SetSequence(										// sets the sequence to load at the specified index
			variable index,													// i: an integer index that is greater than or equal to 0 and less than the value returned by GetLoadSize()
			sequence& sequenceObj,											// i: the sequence object 
			variable first,													// i: the first position in the sequence (integer)
			variable last,														// i: the last position in the sequence (integer)
			variable editable,												// i: specifies whether sequence editing by the user is enabled (hslTrue or hslFalse)
			variable readTipCount,											// i: specifies whether to read the tip count (hslTrue or hslFalse)
			variable& tipCountIdentifier);								// i: tip count identifier (string)

		static function Getsequence(										// gets the sequence loaded at the specified index
			variable index,													// i: an integer index that is greater than or equal to 0 and less than the value returned by GetLoadSize()
			sequence& sequenceObj);											// i: a reference to a sequence to retrieve the sequence loaded at the specified index

		static function BinIStr(											// helper function to convert an integer number into the corresponding binary character string
			variable number) variable;										// i: number to convert

		static function DetectPreloadedCarriers(						// detects preloaded carriers on the autoload tray, returns the number of preloaded carriers on the autoload tray.
			device& ML_STAR,													// i: Specifies the device context.
			variable& preloadedCarriers[]) variable;					// o: Place to retrieve presence of preloaded carriers.

		static function SelectPreloadedCarriers(						// selects preloaded carriers 
			device& ML_STAR,													// i: specifies the device context.
			variable& preloadedCarriers[],								// i: presence of preloaded carriers (hslFalse = not present, hslTrue = present)
			variable& carrierNames[],										// i/o: a reference to an array of variables to retrieve the carrier names
			variable& carrierCalibrateFlags[],							// i/o: a reference to an array of variables to retrieve the carrier calibrate flags
			variable& carrierBarcodeReadPositions[],					// i/o: a reference to an array of variables to retrieve the carrier barcode read positions
			variable& carrierBarcodeReadLabwareNames[],				// i/o: a reference to an array of variables to retrieve the carrier barcode read labware names
			variable& carrierBarcodeReadPositionNames[],				// i/o: a reference to an array of variables to retrieve the carrier barcode read position names
			variable& carrierRecoveryOptionContinue[],				// i/o: visibility of recovery option Continue (0 = invisible, 1 = visible)
			variable& carrierRecoveryOptionExclude[],					// i/o: visibility of recovery option Exclude (0 = invisible, 1 = visible)
			variable& carrierRecoveryOptionDefault[],					// i/o: default of recovery options Continue and Exclude (0 = Continue, 1 = Exclude) 
			variable& carrierKitLotCheckEnabled[]) void;				// i/o: kit lot check enabled flag

		static function UnloadUnusedSampleTubes(						// unloads unused sample tubes
			device& ML_STAR,													// i: specifies the device context
			sequence& fullSampleSequence,									// i: sequence containing the full range of possible sample tubes
			sequence& loadedSampleSequence) void;						// i: sequence containing the range of loaded sample tubes

		static function LoadRequiredSampleTubes(						// loads required sample tubes, returns the number of jobs, that have not been assigned but that are required
			device& ML_STAR,													// i: specifies the device context
			variable scanAutoloadTray,										// i: indicates whether to scan the autoload try and to load only those carriers that have been detected
			sequence& fullSampleSequence,									// i: sequence containing the full range of possible sample tubes
			sequence& loadedSampleSequence) variable;					// i: sequence containing the range of loaded sample tubes

/*		static function UnassignNotLoadedSampleTubesFromJobs(		// Unassigns not loaded sample tubes from jobs. Remark: This is a workaround as long as the Microlab STAR and the VectorDb are not able to handle not loaded sample tubes correctly.
			device& ML_STAR,													// i: specifies the device context
			sequence& fullSampleSequence,									// i: sequence containing the full range of possible sample tubes
			sequence& loadedSampleSequence) variable;					// i: sequence containing the range of loaded sample tubes
*/
		static function Load(												// loads all sequences previously set via the SetLoadSequence 
			device& ML_STAR,													// i: the loading device 
			variable calibrateSequences,									// i: indicates whether carriers should be calibrated (if supported)
			variable scanAutoloadTray,										// i: indicates whether to scan the autoload try and to load only those carriers that have been detected
			variable loadRequiredSampleTubes,							// i: indicates whether to load required sample tubes 
			variable unloadUnusedSampleTubes) variable[];			// i: indicates whether to unload unused sample tubes 

		static function Unload(												// unloads all sequences previously set via the SetUnloadSequence 
			device& ML_STAR);													// i: the unloading device 

		static function PrepareLoadOfSequences(						// prepares load of given pipetting sequences
			device& ML_STAR,													// i: pipetting device
			variable calibrateSequences,									// i: indicates whether carriers should be calibrated (if supported)
			variable prepareLoadMode,										// i: prepare load mode (1 = prepare for reduce, 2 = prepare for load)
			variable errorHandling,											// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
			variable& carrierNames[],										// i/o: a reference to an array of variables to retrieve the carrier names
			variable& carrierCalibrateFlags[],							// i/o: a reference to an array of variables to retrieve the carrier calibrate flags
			variable& carrierBarcodeReadPositions[],					// i/o: a reference to an array of variables to retrieve the carrier barcode read positions
			variable& carrierBarcodeReadLabwareNames[],				// i/o: a reference to an array of variables to retrieve the carrier barcode read labware names
			variable& carrierBarcodeReadPositionNames[],				// i/o: a reference to an array of variables to retrieve the carrier barcode read position names
			variable& carrierRecoveryOptionContinue[],				// i/o: visibility of recovery option Continue (0 = invisible, 1 = visible)
			variable& carrierRecoveryOptionExclude[],					// i/o: visibility of recovery option Exclude (0 = invisible, 1 = visible)
			variable& carrierRecoveryOptionDefault[],					// i/o: default of recovery options Continue and Exclude (0 = Continue, 1 = Exclude) 
			variable& carrierKitLotCheckEnabled[],						// i/o: kit lot check enabled flag
			variable& prompt,													// i/o: user prompt
			variable bWarnLoadSettingsNotForTask);						// i: If true a warning is traced if the load settings are not defined for current task

		static function Init();												// (re)initializes the settings in the loading control block 

		static function InitEx(												// (re)initializes the loading information of all advanced loading control settings of the specified sequence to their default values
			device& ML_STAR,													// i: the loading device (a Microlab® STAR)
			sequence& sequenceObj);											// i: the loading sequence

		static function CheckKitLot(										// checks the kit lot for the given positions and return values of the LoadCarrier step, returns a list (csv) of expired kit lots
			variable& qualifiedExcludePositions[],						// (qualified) positions of elements which should be excluded from the loading sequences
			variable& rc[]);													// i: step return values of the LoadCarrier step

		static function AskUserForReload(								// asks the user for reload
			variable& expiredKitLots,										// i: list of expired kit lots (csv)
			variable& carrierName,											// i: carrier name
			variable& userResponseTime);									// i: user response time

/*
		//>> 20070702 (SCR#1121)
		static function IsNoReadBarcode(									// returns 'true', if given carrier has labware property MlStarCarNoReadBarcode set to 1, otherwise 'false'
			device& ML_STAR, 													// i: the loading device (a Microlab® STAR)
			variable carrierName);											// i: carrier name
*/
		//<< 20070702

		//>> 20061129 (SCR#1121)
		static function Split(												// splits given string into substings 
			variable& str, 													// i: string to split
			variable& delimiter, 											// i: character specifying the delimiter (string)
			variable& substrings[]) void;									// o: place to retrieve substrings (array of variables)
		//<< 20061129 
	}

	// --------------------------------------------------------------------------------------
	// Unloading Control Block
	// --------------------------------------------------------------------------------------

	namespace UCB
	{
		// data

		// general settings 

		static variable UserResponseTime(Limits::maxTimeInterval);// user response time [s]
		static variable ErrorHandling(ErrorHandling::continue);	// error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue, 4 = continue_2, 5 = custom)
  		static variable InitializeCustomStepID(CustomStepID::stepErrorHandlingDefault);
      static variable UnloadCarrierCustomStepID(CustomStepID::stepErrorHandlingDefault);

		// private data 

		// shared with LCB

		// functions

		static function GetState(											// gets the state for a specified unloading control setting
			variable& ucbKey,													// i: the name of the unloading control setting
			variable& ucbValue);												// o: a reference to a variable to retrieve the value of the unloading control setting

		static function SetState(											// sets the state for a specified unloading control setting
			variable& ucbKey,													// i: the name of the unloading control setting
			variable& ucbValue);												// i: the value of the unloading control setting

		static function Init();												// (re)initializes the settings in the unloading control block 

		// rest shared with LCB
	}

	// --------------------------------------------------------------------------------------
	// Washing Control Block
	// --------------------------------------------------------------------------------------

	namespace WCB
	{
		// data

		// Remark: The data is held per unique instrument labware pair.

		// actual washing settings 
		static global variable ptlWcbInstrumentIdArr[];				// instrument id
		static global variable ptlWcbLabwareIdArr[];					// labware id

		// 20050630 cjoerg added 
		static global variable ptlWcbTaskIdArr[];						// Task id for which the wash params are set explicit (RinseTime, SoakTime, FlowRate, ...)

		static global variable ptlWcbUserResponseTimeArr[];		// user response time [s]
		static global variable ptlWcbErrorHandlingArr[];			// error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue, 4 = custom)
		static global variable ptlWcbInitializeCustomStepIDArr[];
      static global variable ptlWcbTipPickupCustomStepIDArr[];
      static global variable ptlWcbTipEjectCustomStepIDArr[];
      static global variable ptlWcbStartNeedleWashCustomStepIDArr[];
      static global variable ptlWcbWaitNeedleWashCustomStepIDArr[];
		
		static global variable ptlWcbNeedlePickupChannelVariableArr[];	// channel variable (0 = unused, 1 = used)
		static global variable ptlWcbNeedleEjectChannelVariableArr[];	// channel variable (0 = unused, 1 = used)

		static global variable ptlWcbRinseTime1Arr[];				// rinse time [s]
		static global variable ptlWcbSoakTime1Arr[];					// soak time [s]
		static global variable ptlWcbFlowRate1Arr[];					// flow rate [ml/s]
		static global variable ptlWcbRinseTime2Arr[];				// rinse time [s]
		static global variable ptlWcbSoakTime2Arr[];					// soak time [s]
		static global variable ptlWcbFlowRate2Arr[];					// flow rate [ml/s]
		static global variable ptlWcbDrainingTimeArr[];				// draining time [s]
		static global variable ptlWcbStartWashLiquidArr[];			// start wash liquid

		// default washing settings 
		static variable rinseTime1Default(5);							// rinse time [s]
		static variable soakTime1Default(5);							// soak time [s]
		static variable flowRate1Default(11);							// flow rate [ml/s]
		static variable rinseTime2Default(0);							// rinse time [s]
		static variable soakTime2Default(0);							// soak time [s]
		static variable flowRate2Default(11);							// flow rate [ml/s]
		static variable drainingTimeDefault(10);						// draining time [s]
		static variable startWashLiquidDefault(0);					// start wash liquid

		namespace NeedleRackType
		{
			static const variable washStation(0);						// rack type wash station
			static const variable needleRack(1);						// rack type needle rack
		}

		// functions

		static function Dump();												// dumps the state in the washing control block

		static function GetState(											// gets the state for a specified washing control setting
			device& ML_STAR,													// i: the washing device 
			sequence& washSequence,											// i: wash sequence
			variable firstOnly,												// i: if 'true', the function returns after the first found hit 
			variable& wcbKey,													// i: the name of the washing control setting
			variable& wcbValue[],											// o: a reference to an array of variables to retrieve the values of the washing control setting per wash station
			variable& wcbLabId[]);											// o: a reference to an array of variables to retrieve the labware ids of the wash station

		static function SetState(											// sets the state for a specified washing control setting
			device& ML_STAR,													// i: the washing device 
			sequence& washSequence,											// i: wash sequence
			variable& wcbKey,													// i: the name of the washing control setting
			variable& wcbValue);												// i: the value of the washing control setting

		static function GetStateDefault(									// sets the default state for a specified washing control setting
			variable& wcbKey,													// i: the name of the washing control setting
			variable& wcbValue);												// o: a reference to a variable to retrieve the value of the washing control setting

		static function SetStateDefault(									// sets the default state for a specified washing control setting
			variable& wcbKey,													// i: the name of the washing control setting
			variable& wcbValue);												// i: the value of the washing control setting

		static function Init(												// (re)initializes the settings in the washing control block
			device& ML_STAR,													// i: the washing device 
			sequence& washSequence);										// i: the wash sequence

		static function WaitForNeedleWasher(							// waits for needle washer
			device& ML_STAR,													// i: the washing device 
			sequence& washSequence,											// i: wash sequence
			sequence& WashSequence,											// o: clipping wash sequence
			variable& channelPattern,										// o: channel pattern
			variable& errorHandling,										// o: error handling
			variable& userResponseTime,									// o: user response time [s]
			variable& currentPos,											// o: current position [s]
			variable waitingStepType);										// i: waiting step type, needlePickup or needleEject

		static function NeedlePickup(										// picks up needls from the given wash sequence
			device& ML_STAR,													// i: the washing device 
			sequence& washSequence,											// i/o: wash sequence
			variable autoIncrement);										// i: specifies whether the wash sequence should be incremented automatically (hslTrue or hslFalse)

		static function NeedleEject(										// ejects needls to the given wash sequence
			device& ML_STAR,													// i: the washing device 
			sequence& washSequence,											// i/o: wash sequence
			variable startWash);												// i: specifies whether the needls should be washed after they have been ejected (hslTrue or hslFalse)

		static function IsWashStation(									// returns true if given labware is a wash station
			device& ML_STAR,													// i: the washing device 
			variable& labId);													// i: labware id

		static function IsNeedleRack(										// returns true if given labware is a needle rack
			device& ML_STAR,													// i: the washing device 
			variable& labId);													// i: labware id

		static function GetWashParams(									// gets the params for a specified wash station
			device& ML_STAR,													// i: the washing device 
			variable& washStation,											// i: labware id of wash station
			variable& rinseTime1,											// o: rinse time [s]									
			variable& soakTime1,												// o: soak time [s]
			variable& flowRate1, 											// o: flow rate [ml/s]
			variable& rinseTime2, 											// o: rinse time [s]
			variable& soakTime2,												// o: soak time [s]
			variable& flowRate2, 											// o: flow rate [ml/s]
			variable& drainingTime, 											// o: draining time [s]
			variable& startWashLiquid);									// o: start wash liquid

		static function GetCountFilterByRackType(						// gets the count of the wash sequence filtered by a rack type (needleWashRack or needleTipRack)
			device& ML_STAR,													// i: the washing device 
			sequence& washSequence,											// i: wash sequence
			variable needleRackTpye);										// i: rack type (washStation or needle rack)
	}

	// --------------------------------------------------------------------------------------
	// Tip Handling Control Block
	// --------------------------------------------------------------------------------------

	namespace TCB
	{

		// data

		// general settings 

		static variable UserResponseTime(Limits::maxTimeInterval);					// user response time [s]
		static variable ErrorHandling(ErrorHandling::continue);						// error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue, 4 = continue_2 , 5 = custom)
		static variable TipCountingEnabled(hslFalse);									// tip counting enabled flag
		static variable TipCountingIdentifier(StringConstants::tipCountingId);	// tip count identifier
		static variable InitializeCustomStepID(CustomStepID::stepErrorHandlingDefault);

		// tip pickup settings 

		static sequence TipPickupSequence;													// original tip pickup sequence
		static variable TipPickupChannelVariable(Limits::channelVariable16);		// channel variable (0 = unused, 1 = used)
		static variable TipPickupSequenceCounting(SequenceCounting::manually);	// sequence counting (0 = manually, 1 = automatic)
		static variable TipPickupChannelUse(ChannelUse::allSequencePositions);	// channel use (1 = all sequence positions, 2 = channel pattern)
		static variable TipPickupSequenceReloadable(hslTrue);							// sequence reloadable flag 
		static variable TipPickupSequenceReducible(hslTrue);							// sequence reducible flag 
		static variable TipPickupReverseSequenceCount(Limits::reverseSequenceCount);// count of reverse tip pickup sequence
      static variable TipPickCustomStepID(CustomStepID::stepErrorHandlingDefault);

		// tip eject settings 

		static variable TipEjectUseDefaultWaste(hslTrue);								// indicates whether to use the default waste (0 = off, 1 = on)
		static sequence TipEjectWasteDestination;											// original tip eject waste destination
		static variable TipEjectChannelVariable(Limits::channelVariable16);		// channel variable (0 = unused, 1 = used)
		static variable TipEjectChannelUse(ChannelUse::allSequencePositions);	// channel use (1 = all sequence positions, 2 = channel pattern)
		static variable TipEjectSequenceCounting(SequenceCounting::manually);	// sequence counting (0 = manually, 1 = automatic)
		static variable TipEjectWasteDestinationReloadable(hslFalse);				// waste destination reloadable flag 
		static variable TipEjectWasteDestinationReducible(hslFalse);				// waste destination reducible flag
      static variable TipEjectCustomStepID(CustomStepID::stepErrorHandlingDefault);

		// private data
		static sequence TipPickupSequence17;												// 

		// functions

		static function Dump();												// dumps the state in the tip handling control block

		static function GetState(											// gets the state for a specified tip handling control setting
			variable& tcbKey,													// i: the name of the tip handling control setting
			variable& tcbValue);												// o: a reference to a variable to retrieve the value of the tip handling control setting 

		static function SetState(											// sets the state for a specified tip handling control setting
			variable& tcbKey,													// i: the name of the tip handling control setting
			variable& tcbValue);												// i: the value of the tip handling control setting

		static function Init();												// (re)initializes the settings in the tip handling control block

		static function TipPickup(											// picks up tips from the given tip pickup sequence
			device& ML_STAR,													// i: the tip handling device 
			sequence& tipPickupSequence);									// i/o: tip pickup sequence

		static function TipEject(											// ejects tips to the default waste destination
			device& ML_STAR);													// i: the tip handling device 

		static function SetPCBControlSettingsAndSequences();		// sets the PCB control settings and sequences which are relevant for the reloading procedure
	}

	// --------------------------------------------------------------------------------------
	// Sound
	// --------------------------------------------------------------------------------------

	namespace Sound
	{
		static const dialog dlg;											// dialog object to play sound

		// functions
		static function GetSoundFile(										// Get the sound file for specified type
			variable hxServicesSoundEnum) variable;					// i: one of the HxServicesSoundEnum to play

		static function Play(												// plays the sound specified
			variable hxServicesSoundEnum) variable;					// i: one of the HxServicesSoundEnum to play
		static function Stop() variable;									// stops any currently playing waveform sound
	}

	// --------------------------------------------------------------------------------------
	// Traceing
	// --------------------------------------------------------------------------------------

	namespace TraceStatus
	{
		static const variable start(1);									// action status for formated trace
		static const variable complete(2);								// action status for formated trace
		static const variable error_(3);									// action status for formated trace
		static const variable progress(4);								// action status for formated trace
		static const variable completeWithError(5);					// action status for formated trace
	}

	// --------------------------------------------------------------------------------------
	// Device Initialization 
	// --------------------------------------------------------------------------------------

	static function InitPipettingDevice(								// initializes the pipetting device (only once)
		device& ML_STAR,														// i: pipetting device
		variable errorHandling,                                  // i: error handling, one of ErrorHandling
      variable initCustomStepID);										// i: step idientifier for custom error handling

	static global variable ptlInitializedPipettingDevices[];		// place to hold names of initialized pipetting devices

	// --------------------------------------------------------------------------------------
	// Tip Pickup
	// --------------------------------------------------------------------------------------

	static function PickupPipettingTips(								// encapsulates tip pickup
		device& ML_STAR,														// i: pipetting device
		sequence& tipPickupSequence,										// i/o: tip pickup sequence
		variable& sequenceCycle,											// i/o: current cycle in the sequence loop
		variable& multiplicityCycle,										// i/o: current cycle in the multiplicity loop
		variable& volumeCycle,												// i/o: current cycle in the volume loop
		variable tipRenewalCycleSeq,										// i:	tip renewal cycle in the sequence loop (integer)
		variable tipRenewalCycleMul,										// i:	tip renewal cycle in the multiplicity loop (integer)
		variable tipRenewalCycleVol,										// i:	tip renewal cycle in the volume loop (integer)
		variable isWashSequence);											// i: if 'true', tip pickup sequence is a wash sequence

	static function NumberOfActiveChannels(							// returns the number of active channels
		string& channelPattern);											// i:	channel pattern

	static function RightmostActiveChannel(							// returns the rightmost active channel
		string& channelPattern,												// i:	channel pattern
		string& rightmostActiveChannelPattern);						// i/o: rightmost active channel pattern

	static function SelectChannelPattern(								// selects the specified channel in the channel pattern, returns channel
		string& channelPattern,												// i:	channel pattern
		string& selectedChannelPattern,									// i/o: selected channel pattern
		variable channel);													// i: channel to select 

	static function ReverseSequence(										// reverses the order of positions in the sequence that it copies
		sequence& originalSequence,										// i: original sequence
		sequence& reverseSequence,											// i/o: reverse sequence
		variable start,														// i:	position where to start reversion
		variable copyCount,													// i:	number of positions to copy
		variable reverseCount);												// i:	number of positions to reverse

	static function ExcludeSequencePositions(							// excludes positions from a sequence 
		sequence& fromSequence,												// i/o: sequence where to exclude positions
		//>> 20060503
		variable excludeIndividualVolumes,								// i: indicates whether to exclude individual volumes (0 = single volume, 1 = exclude individual volumes)
		variable& individualVolumes_1[],									// i/o: individual pipetting volumes, ignored if excludeIndividualVolumes == 0
		variable& individualVolumes_2[],									// i/o: individual pipetting volumes, ignored if excludeIndividualVolumes == 0
		//<< 20060503
		variable  startPos,													// i:	position where to start exclusion
		variable& updatePos,													// i/o: position to update during exclusion
		variable& labIds[],													// i/o: labware ids of positions to exclude
		variable& posIds[],													// i/o: position ids of positions to exclude
		//>> 20060503
		variable& volumes_1[],												// i/o: volumes of positions to exclude
		variable& volumes_2[],												// i/o: volumes of positions to exclude
		//<< 20060503
		variable& excludePos[],												// o:	indexes of excluded positions 
		variable& currentInc[],												// o:	increments of current positions during exclusion
		variable& trackLabIds[],											// o:	labware ids of positions which have been excluded
		variable& trackPosIds[]);											// o:	position ids of positions which have been excluded

	static function IncludeSequencePositions(							// excludes positions from a sequence 
		sequence& toSequence,												// i/o: sequence where to include positions
		//>> 20060503
		variable includeIndividualVolumes,								// i: indicates whether to include individual volumes (0 = single volume, 1 = include individual volumes)
		variable& toVolumes_1[],											// i/o: volumes where to include positions
		variable& toVolumes_2[],											// i/o: volumes where to include positions
		//<< 20060503
		variable& labIds[],													// i:	labware ids of positions to include
		variable& posIds[],													// i:	position ids of positions to include
		//>> 20060503
		variable& volumes_1[],												// i:	volumes of positions to include
		variable& volumes_2[],												// i:	volumes of positions to include
		//<< 20060503
		variable& includePos[],												// i:	indexes of positions to include
		variable& currentInc[]);											// i:	increments of current positions during inclusion

	static function ExcludePositions(									// excludes positions from a list of positions (csv) 
		string& fromPositions,												// i/o: list of positions where to exclude positions
		variable& excludePositions[]);									// i:	values of positions to be excluded from list of positions

	// --------------------------------------------------------------------------------------
	// Pipetting
	// --------------------------------------------------------------------------------------

	static function TransferLiquid(										// encapsulates any liquid transfer
		device& ML_STAR,														// i: pipetting device
		sequence& tipPickupSequence,										// i/o: tip pickup sequence
		sequence& aspirateSequence,										// i/o: aspirate sequence
		sequence& dispenseSequence,										// i/o: dispense sequence
		variable aspirateMultiplicity,									// i:	aspirate multiplicity 
		variable dispenseMultiplicity,									// i:	dispense multiplicity
		variable currentMultiplicity,										// i:	current multiplicity
		//>> 20060503
		variable transferIndividualVolumes,								// i: indicates whether to transfer individual volumes (0 = single volume, 1 = transfer individual volumes)
		variable& totalVolumes[],											// i: individual total volumes, ignored if transferIndividualVolumes == 0
		variable& currentVolumes[],										// i: individual current volumes, ignored if transferIndividualVolumes == 0
		//<< 20060503
		variable currentVolume,												// i: current volume
		variable drivingMode,												// i: driving mode
		variable isWashSequence,											// i: if 'true', tip pickup sequence is a wash sequence
		variable errorHandlingEnabled);									// i:	error handling enabled flag

	// --------------------------------------------------------------------------------------
	// Tip Eject
	// --------------------------------------------------------------------------------------

	static function EjectPipettingTips(									// encapsulates tip eject
		device& ML_STAR,														// i: pipetting device
		variable& sequenceCycle,											// i/o: current cycle in the sequence loop
		variable& multiplicityCycle,										// i/o: current cycle in the multiplicity loop
		variable& volumeCycle,												// i/o: current cycle in the volume loop
		variable tipRenewalCycleSeq,										// i:	tip renewal cycle in the sequence loop (integer)
		variable tipRenewalCycleMul,										// i:	tip renewal cycle in the multiplicity loop (integer)
		variable tipRenewalCycleVol,										// i:	tip renewal cycle in the volume loop (integer)
		sequence& tipPickupSequence,										// i/o: tip pickup sequence
		variable isWashSequence);											// i: if 'true', tip pickup sequence is a wash sequence

	// --------------------------------------------------------------------------------------
	// Library Initialization 
	// --------------------------------------------------------------------------------------

	static variable initializedLib(hslFalse);							// initialization state of the pipetting library
	static function InitPipettingLibrary();							// initializes the pipetting library (only once)

	// --------------------------------------------------------------------------------------
	// Library Synchronization 
	// --------------------------------------------------------------------------------------

	static global variable ptlCs(0);										// critical section
	static global object ptlScriptControl;								// Script Control, used to evaluate VBScript expressions

	// --------------------------------------------------------------------------------------
	// Utilities
	// --------------------------------------------------------------------------------------

	namespace PTL_Util
	{
		// functions

		static function Min(													// returns the lesser of two numeric (or string) expressions 
			variable number1,													// i: expression 1
			variable number2);												// i: expression 2

		static function Max(													// returns the greater of two numeric (or string) expressions 
			variable number1,													// i: expression 1
			variable number2);												// i: expression 2

		static function Lookup(												// returns true if the array of variables contains the value specified 
			variable& varArr[],												// i: array of variables
			variable& value,													// i: value to lookup
			variable& index);													// o: zero based index of value found

		static function IsString(											// returns true if the variable value is a string
			variable var);														// i: variable

		static function IsNumber(											// returns true if the variable value is a number
			variable var);														// i: variable

		static function IsInteger(											// returns true if the variable value is an integer
			variable var);														// i: variable

		static function IsFloat(											// returns true if the variable value is a float
			variable var);														// i: variable

		static function IsNegative(										// returns true if the number is negative
			variable number);													// i: number

		static function Abs(													// returns a value of the same type that is passed to it specifying the absolute value of a number
			variable number);													// i: number

		static function CsvToDelimited(									// returns the input string with all comma delimiter replaced by the delimiter queried from the instrument 
			device& ML_STAR,													// i: pipetting device
			variable csv);														// i(byVal): comma separeted values

		//>> 20061129 (SCR#1121)
		static function CsvToDelimited2(									// removes all duplicates from the input string and returns them
			device& ML_STAR,													// i: pipetting device
			variable csv);														// i(byVal): comma separeted values
		//<< 20061129
	
		static function TraceWarningIfNotValidated(					// Traces a warning. If file validation is enabled and the file is valid no trace is done
																					// The trace is formatted like "Smart Steps : <action> - progress; Warning: <Some Text>"
			variable& strAction,												// i: trace action (e.g StepName)											
			variable& strSomeText) void;									// i: the warning trace

		static object objHxServicesGeneralSettings2;					// HxServicesGeneralSettings2 component, used to get timout and sound-values.
	}

	// --------------------------------------------------------------------------------------
	// Step Return 
	// --------------------------------------------------------------------------------------

	namespace StepReturn
	{
		// data (extensions to the namespace StepReturn defined in the Microlab® STAR Step Return Library)

		namespace StepType
		{
			static const variable initialize("Initialize");			// step type
			static const variable tipPickup("TipPickUp");			// step type
			static const variable tipEject("TipEject");				// step type
			static const variable aspirate("Aspirate");				// step type
			static const variable dispense("Dispense");				// step type
			static const variable loadCarrier("LoadCarrier");		// step type
			static const variable unloadCarrier("UnloadCarrier");	// step type
			static const variable calibrate1536Plate("Calibrate1536Plate");// step type
			static const variable waitNeedleWashed("WaitNeedleWashed");// step type
			static const variable startNeedleWash("StartNeedleWash");// step type
			static const variable unspecified("");						// step type
		}

		static variable aspirateLabIds[];								// place to hold labware ids of excluded aspirate positions 
		static variable aspiratePosIds[];								// place to hold position ids of excluded aspirate positions 
		//>> 20060503
		static variable aspirateVolumes_1[];							// place to hold volumes of excluded aspirate positions 
		static variable aspirateVolumes_2[];							// place to hold volumes of excluded aspirate positions 
		//<< 20060503
		static variable aspirateExcludePos[];							// place to hold indexes of excluded aspirate positions 
		static variable aspirateCurrentInc[];							// place to hold increments of current position during aspirate exclusion
		static variable aspirateUsedPositions;							// 
		static variable dispenseLabIds[];								// place to hold labware ids of excluded dispense positions 
		static variable dispensePosIds[];								// place to hold position ids of excluded dispense positions 
		//>> 20060503
		static variable dispenseVolumes_1[];							// place to hold volumes of excluded dispense positions 
		static variable dispenseVolumes_2[];							// place to hold volumes of excluded dispense positions 
		//<< 20060503
		static variable dispenseExcludePos[];							// place to hold indexes of excluded dispense positions 
		static variable dispenseCurrentInc[];							// place to hold increments of current position during dispense exclusion
		static variable dispenseUsedPositions;							// 
		static variable copyPattern("");									// channel pattern used to execute the next step(s) if the copy pattern option is enabled
		static variable prevCopyPattern("");							// channel pattern used to execute the previous step(s) if the copy pattern option is enabled
		//>> 20060529
		static variable prevTipPresence("");							// channel pattern used to execute the previous tip pickup step
		//<< 20060529
		static variable trackLabIds[];									// place to hold labware ids of positions to be tracked as erroneous
		static variable trackPosIds[];									// place to hold position ids of positions to be tracked as erroneous
		static variable trackLabIdsBak[];								// place to hold backup of labware ids of positions to be tracked as erroneous
		static variable trackPosIdsBak[];								// place to hold backup of position ids of positions to be tracked as erroneous
		static variable errorLabIds[];									// place to hold labware ids of erroneous positions (not to be tracked)
		static variable errorPosIds[];									// place to hold position ids of erroneous positions (not to be tracked)

		// functions (extensions to the namespace StepReturn defined in the Microlab® STAR Step Return Library)

		static function Empty(												// (re)initializes the step return 
			variable& rc[]);													// i: step return 

		static function IsEmpty(											// returns true if the step return is empty
			variable& rc[]);													// i: step return 

		static function Bind(												// binds the error data to the step return 
			variable& rc[]);													// i: step return 

		static function Check(												// checks the error data in the step return 
			variable& rc[]);													// i: step return 

		static function Evaluate(											// evaluates the value returned by non-liquid handlig steps, i.e. 
			device& ML_STAR,													// i: pipetting device
			variable& rc[],													// i: step return 
			variable errorHandling);										// i: error handling, one of ErrorHandling

		static function EvaluateEx(										// evaluates the value returned by liquid handling steps, i.e. Aspirate and Dispense
			device& ML_STAR,													// i: pipetting device
			variable& rc[],													// i: step return 
			variable errorHandling,											// i: error handling, one of ErrorHandling
			sequence& aspirateSequence,									// i/o: aspirate sequence
			sequence& dispenseSequence,									// i/o: dispense sequence
			variable aspirateMultiplicity,								// i:	aspirate multiplicity 
			variable dispenseMultiplicity,								// i:	dispense multiplicity
			variable drivingMode,											// i: driving mode
			//>> 20060503
			variable evaluateIndividualVolumes,							// i: indicates whether to evaluate individual volumes (0 = single volume, 1 = evaluate individual volumes)
			variable& currentVolumes_1[],									// i: current individual volumes, ignored if evaluateIndividualVolumes == 0
			variable& currentVolumes_2[],									// i: current individual volumes, ignored if evaluateIndividualVolumes == 0
			//<< 20060503
			variable currentVolume,											// i: current volume
			variable stepType,												// i: step type, overwrites step type rc[1], StepType::unspecified or StepType::aspirate or StepType::dispense
			variable propagate);												// i: if true propagate the exclusion of positions from a sequence 
																					//		if an error occured and copy pattern has been enabled

		static function EvaluateExx(										// evaluates the value returned by load steps for a given load sequence, i.e. LoadCarrier
			device& ML_STAR,													// i: pipetting device
			variable& rc[],													// i: step return 
			variable errorHandling,											// i: error handling, one of ErrorHandling
			variable& positions,												// i: comma separated list of barcode read positions 
			variable& labwareNames,											// i: comma separated list of barcode read labware names 
			variable& positionNames,										// i: comma separated list of barcode read position names 
			variable& excludePositions[],									// i/o: place to retrieve positions of elements to be excluded
			variable& excludeLabwareNames[],								// i/o: place to retrieve labware names of elements to be excluded
			variable& excludePositionNames[]);							// i/o: place to retrieve position names of elements to be excluded

		static function Dump(												// dumps the step return 
			variable& rc[]);													// i: step return 

		static function GetChannelPattern();							// returns the channel pattern used to execute the next step(s) if the copy pattern option is enabled

		static function GetPrevChannelPattern();						// returns the channel pattern used to execute the previous step(s) if the copy pattern option is enabled

		static function XorChannelPattern(								// intersects given channel pattern with the channel pattern used to execute the next step(s) if the copy pattern option is enabled
			string& channelPattern);										// i: channel pattern

		static function GetUsedPos(										// gets the correction of the used positions of a sequence if an error occured and copy pattern has been enabled
			variable stepType);												// i: step type, aspirate or dispense

		static function SetUsedPos(										// sets the correction of the used positions of a sequence if an error occured and copy pattern has been enabled
			variable stepType,												// i: step type, aspirate or dispense
			variable usedPositions);										// i: used positions

		static function IsRecovering();									// returns true if the StepReturn is recovering from an error
		//>> 20060529
		static function IsRecovering2();									// returns true if the StepReturn is recovering from an error
		//<< 20060529

		static function DumpData();										// dumps the  internal data of the StepReturn 

		static function SetData(											// sets the internal data of the StepReturn. Returns hslFalse if an error is detected
			variable& stepReturn,											// i: step return
			sequence& aspirateSequence,									// i: aspirate sequence
			sequence& dispenseSequence,									// i: dispense sequence
			string& channelPattern,											// i: channel pattern
			variable stepType) variable;									// i: step type, aspirate or dispense

		static function ResetData(											// resets the internal data of the StepReturn 
			variable aspirateData,											// i: reset aspirate data flag
			variable dispenseData);											// i: reset dispense data flag

		static function TrackData(											// tracks the internal sample tracker data of the StepReturn 
			device& ML_STAR);													// i: pipetting device

		static function BackupTrackerData();							// backups the internal tracker data of the StepReturn 

		static function RestoreTrackerData();							// restores the internal tracker data of the StepReturn 

		static function ResetTrackerData(								// resets the internal tracker data of the StepReturn 
			variable resetAll);												// i: reset all flag (inclusive backup)

		static function RestoreData(										// restores the temporarily excluded aspirate and dispense sequence positions contained in the internal data of the StepReturn 
			sequence& aspirateSequence,									// i: aspirate sequence
			sequence& dispenseSequence,									// i: dispense sequence
			//>> 20060503
			variable restoreIndividualVolumes,							// i: indicates whether to restore individual volumes (0 = single volume, 1 = restore individual volumes)
			variable& volumes_1[],											// i: volumes to restore
			variable& volumes_2[],											// i: volumes to restore
			//<< 20060503
			variable aspirateMultiplicity,								// i:	aspirate multiplicity 
			variable dispenseMultiplicity,								// i:	dispense multiplicity
			variable currentMultiplicity);								// i:	current multiplicity

		static function RestoreData2(										// restores the temporarily excluded dispense sequence positions contained in the internal data of the StepReturn 
			sequence& dispenseSequence,									// i: dispense sequence
			//>> 20060503
			variable restoreIndividualVolumes,							// i: indicates whether to restore individual volumes (0 = single volume, 1 = restore individual volumes)
			variable& volumes_1[],											// i: volumes to restore
			variable& volumes_2[],											// i: volumes to restore
			//<< 20060503
			variable dispenseMultiplicity,								// i:	dispense multiplicity
			variable currentMultiplicity);								// i:	current multiplicity

		static function EvaluateGenericRecovery(						// generic evaluation of error recovery
			variable& stepReturn);											// i: step return

		static function EvaluateAspirateRecovery(						// evaluates aspirate recovery
			variable& stepReturn,											// i: step return
			string& channelPattern);										// i: channel pattern

		static function EvaluateDispenseRecovery(						// evaluates dispense recovery
			variable& stepReturn,											// i: step return
			string& channelPattern);										// i: channel pattern

		static function EvaluateLoadCarrierRecovery(					// evaluates load carrier recovery
			variable& stepReturn3,											// i: step return 3 (0-based)
			variable& stepReturn5,											// i: step return 5 (0-based)
			string positions,													// i(byVal): comma separated list of barcode read positions 
			string labwareNames,												// i(byVal): comma separated list of barcode read labware names 
			string positionNames,											// i(byVal): comma separated list of barcode read position names 
			variable& excludePositions[],									// i/o: place to retrieve positions of elements to be excluded
			variable& excludeLabwareNames[],								// i/o: place to retrieve labware names of elements to be excluded
			variable& excludePositionNames[]);							// i/o: place to retrieve position names of elements to be excluded

		static function PropagateExcludedPositions(					// propagates excluded positions of a sequence if an error occured and copy pattern has been enabled
			sequence& pipSequence,											// i: pipetting sequence
			string& channelPattern,											// i: channel pattern
			variable stepType);												// i: step type, aspirate or dispense

		static function PersistExcludedPositions(						// persists excluded positions of a sequence if an error occured and exclude error positions has been enabled
			sequence& orgSequence,											// i/o: original pipetting sequence, aspirate or dispense sequence
			sequence& actSequence,											// i/o: actual pipetting sequence, aspirate or dispense sequence
			//>> 20060503
			variable excludeIndividualVolumes,							// i: indicates whether to exclude individual volumes (0 = single volume, 1 = exclude individual volumes)
			variable& individualVolumes_1[],								// i/o: individual pipetting volumes, ignored if excludeIndividualVolumes == 0
			variable& individualVolumes_2[],								// i/o: individual pipetting volumes, ignored if excludeIndividualVolumes == 0
			//<< 20060503
			variable stepType,												// i: step type, aspirate or dispense
			variable setUsed);												// i: if true, the correction of the used positions of the sequence if an error occured and copy pattern has been enabled will be set

		static function AlignExcludedPositions(						// aligns excluded positions of a sequence if an error occured and exclude error positions has been enabled
			sequence& aspirateSequence,									// i: aspirate sequence
			sequence& dispenseSequence,									// i: dispense sequence
			variable aspirateMultiplicity,								// i:	aspirate multiplicity 
			variable dispenseMultiplicity,								// i:	dispense multiplicity
			variable drivingMode);											// i: driving mode

		static function HandleError(										// handles an error
			device& ML_STAR,													// i: pipetting device
			sequence& tipPickupSequence,									// i/o: tip pickup sequence
			variable isWashSequence,										// i: indicates whether tipPickupSequence is a wash sequence or not
			variable stepType,												// i: step type, aspirate or dispense
			variable propagate);												// i: if true propagate the correction of the used positions of a sequence 
																					//		if an error occured and copy pattern has been enabled
	}

	// --------------------------------------------------------------------------------------
	// Debugging
	// --------------------------------------------------------------------------------------
	
	// The Assert function evaluates its argument.
	// In the the debug version of the pipetting library, 
	// if the result is 0, the function displays a diagnostic 
	// message and aborts the method. If the condition is nonzero, 
	// it does nothing.
	// In the the release version of the pipetting library, 
	// the function does nothing.

	static function Assert(
		variable expr,															// i: specifies a numeric expression that evaluates to nonzero or 0
		variable location);													// i: location (string or number)

	// --------------------------------------------------------------------------------------
	// Exception handling
	// --------------------------------------------------------------------------------------

	namespace Error
	{
		static function Raise(												// raises a runtime error
			variable errorId,													// i: error id, one of IDE
			variable& fileName,												// i: file name
			variable& funcName,												// i: function name
			variable& lineNumber);											// i: line number

		static function RaiseEx(											// raises a runtime error
			variable errorId,													// i: error id, one of IDE
			variable errorDesc,												// i: error description
			variable& fileName,												// i: file name
			variable& funcName,												// i: function name
			variable& lineNumber);											// i: line number

		static function RaiseLast();										// re-throws the last runtime error

		static function Display();											// displays a runtime error in a message box
	}

	// --------------------------------------------------------------------------------------
	// Implementation 
	// --------------------------------------------------------------------------------------

	// --------------------------------------------------------------------------------------
	// Washing (Part I: Defines the exported functions. Located here because pipetting uses 
	//				the washing functions)
	// --------------------------------------------------------------------------------------

	function GetWashingState(
		device& ML_STAR,
		sequence& washSequence,
		variable& wcbKey,
		variable& wcbValue[],
		variable& wcbLabId[])
	{
		// initialize pipetting library
		InitPipettingLibrary();

		// validate input
		if (!PTL_Util::IsString(wcbKey))
			// wcbKey must be a string
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());

		return(WCB::GetState(ML_STAR, washSequence, hslFalse, wcbKey, wcbValue, wcbLabId));
	}

	function SetWashingState(
		device& ML_STAR,
		sequence& washSequence,
		variable& wcbKey,
		variable& wcbValue,
		variable wcbStatus)
	{
		variable traceSource;										// source for formated trace
		variable traceAction;										// action for formated trace
		variable status;

		// activate error handler
		onerror goto Unexpected;

		// initialize pipetting library
		InitPipettingLibrary();

		// check params to be valid
		if (!PTL_Util::IsString(wcbKey))
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());
		if (!PTL_Util::IsNumber(wcbStatus))
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());
		if (!PTL_Util::IsInteger(wcbStatus))
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());
		if (wcbStatus < 0 || 2 < wcbStatus)
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());

		// trace start of needle wash settings
		traceSource = StringTable::Load(IDS::traceSource);
		traceAction = StringTable::Load(IDS::smartStepNeedleWashSettings);
		if (0 == wcbStatus)
		{
			FormatTrace(traceSource, traceAction, TraceStatus::start);
		}

		status = WCB::SetState(ML_STAR, washSequence, wcbKey, wcbValue);

		// trace completion of needle wash settings
		if (2 == wcbStatus)
		{
			variable size;													// array size
			variable index;												// array index
			variable labId("");											// labware id
			variable labwareIds[];										// place to hold unique labware ids of the sequence 
			variable details("");										// trace details

			washSequence.GetLabwareIds(labwareIds);
			size = labwareIds.GetSize();
			
			// iterate over unique labware ids of the sequence 
			for (index = 0; index < size; index++)
			{
				labId = labwareIds.GetAt(index);

				// check if the labware is a wash station or a needle rack
				if (WCB::IsWashStation(ML_STAR, labId) || WCB::IsNeedleRack(ML_STAR, labId))
				{
					if ("" == details)
						details = labId;
					else
						details = details + ", " + labId;
				}
			}
			FormatTrace(traceSource, traceAction, TraceStatus::complete, " > ", details);
		}

		return(status);

		Unexpected:
		{
			// trace completion with error of needle pickup
			FormatTrace(traceSource, traceAction, TraceStatus::completeWithError);

			Error::RaiseLast();
		}
	}

	function ResetWashingState(
		device& ML_STAR,
		sequence& washSequence)
	{
		// initialize pipetting library
		InitPipettingLibrary();
	
		return(WCB::Init(ML_STAR, washSequence));
	}

	function GetWashingStateDefault(
		variable& wcbKey,
		variable& wcbValue)
	{
		// initialize pipetting library
		InitPipettingLibrary();

		// check params to be valid
		if (!PTL_Util::IsString(wcbKey))
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());

		return(WCB::GetStateDefault(wcbKey, wcbValue));
	}

	function SetWashingStateDefault(
		variable& wcbKey,
		variable& wcbValue)
	{
		// initialize pipetting library
		InitPipettingLibrary();

		// check params to be valid
		if (!PTL_Util::IsString(wcbKey))
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());

		return(WCB::SetStateDefault(wcbKey, wcbValue));
	}

	function NeedlePickup(
		device& ML_STAR,
		sequence& washSequence,
		variable autoIncrement)
	{
		variable rc[];													// step return 
		variable traceSource;										// source for formated trace
		variable traceAction;										// action for formated trace
		sequence null;													// null sequence
		sequence defaultWasteSequence;							// default waste, Waste or Waste16
		variable errorHandling(ErrorHandling::continue);	// error handling, one of ErrorHandling
		variable wcbValue[];											// place to hold WCB values
		variable wcbLabId[];											// place to hold labware ids
      variable initCustomStepID(CustomStepID::stepErrorHandlingDefault); // custom step identifier of initialize step

		// activate error handler
		onerror goto Unexpected;

		// initialize pipetting library
		InitPipettingLibrary();

		// trace start of needle pickup
		traceSource = StringTable::Load(IDS::traceSource);
		traceAction = StringTable::Load(IDS::smartStepNeedlePickup);
		FormatTrace(traceSource, traceAction, TraceStatus::start);

		// check params to be valid
		if (!PTL_Util::IsNumber(autoIncrement))
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());
		if (PTL_Util::IsFloat(autoIncrement))
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());

		// bind all pipetting control setting which have not yet been set to a reasonable value
		PCB::BindStates(ML_STAR);

		// select a default waste
		PCB::SelectDefaultWaste(ML_STAR, defaultWasteSequence);

		// backup default waste
		PCB::BackupSequences(ML_STAR, null, null, null, defaultWasteSequence, "PCB");

		// get error handling
		WCB::GetState(ML_STAR, washSequence, hslTrue, "ErrorHandling", wcbValue, wcbLabId);
		if (0 < wcbValue.GetSize())
			errorHandling = wcbValue.GetAt(0);

      // get init custom step ID
		WCB::GetState(ML_STAR, washSequence, hslTrue, "InitializeCustomStepID", wcbValue, wcbLabId);
		if (0 < wcbValue.GetSize())
			initCustomStepID = wcbValue.GetAt(0);

		// initialize pipetting device
		rc = InitPipettingDevice(ML_STAR, errorHandling, initCustomStepID);

		// pickup needles
		WCB::NeedlePickup(ML_STAR, washSequence, autoIncrement);

		// trace completion of needle pickup
		FormatTrace(traceSource, traceAction, TraceStatus::complete);

		return(hslTrue);

		Unexpected:
		{
			// trace completion with error of needle pickup
			FormatTrace(traceSource, traceAction, TraceStatus::completeWithError);

			Error::RaiseLast();
		}
	}

	function NeedleEject(
		device& ML_STAR,
		sequence& washSequence,
		variable startWash)
	{
		variable rc[];													// step return 
		variable traceSource;										// source for formated trace
		variable traceAction;										// action for formated trace
		sequence null;													// null sequence
		sequence defaultWasteSequence;							// default waste, Waste or Waste16
		variable errorHandling(ErrorHandling::continue);	// error handling, one of ErrorHandling
		variable wcbValue[];											// place to hold WCB values
		variable wcbLabId[];											// place to hold labware ids
      variable initCustomStepID(CustomStepID::stepErrorHandlingDefault); // custom step identifier of initialize step

		// activate error handler
		onerror goto Unexpected;

		// initialize pipetting library
		InitPipettingLibrary();

		// trace start of needle eject
		traceSource = StringTable::Load(IDS::traceSource);
		traceAction = StringTable::Load(IDS::smartStepNeedleEject);
		FormatTrace(traceSource, traceAction, TraceStatus::start);

		// check params to be valid
		if (!PTL_Util::IsNumber(startWash))
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());
		if (PTL_Util::IsFloat(startWash))
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());

		// bind all pipetting control setting which have not yet been set to a reasonable value
		PCB::BindStates(ML_STAR);

		// select a default waste
		PCB::SelectDefaultWaste(ML_STAR, defaultWasteSequence);

		// backup default waste
		PCB::BackupSequences(ML_STAR, null, null, null, defaultWasteSequence, "PCB");

		// get error handling
		WCB::GetState(ML_STAR, washSequence, hslTrue, "ErrorHandling", wcbValue, wcbLabId);
		if (0 < wcbValue.GetSize())
			errorHandling = wcbValue.GetAt(0);

      // get init custom step ID
		WCB::GetState(ML_STAR, washSequence, hslTrue, "InitializeCustomStepID", wcbValue, wcbLabId);
		if (0 < wcbValue.GetSize())
			initCustomStepID = wcbValue.GetAt(0);

		// initialize pipetting device
		rc = InitPipettingDevice(ML_STAR, errorHandling, initCustomStepID);

		// eject needles
		WCB::NeedleEject(ML_STAR, washSequence, startWash);

		// trace completion of needle eject
		FormatTrace(traceSource, traceAction, TraceStatus::complete);

		return(hslTrue);

		Unexpected:
		{
			// trace completion with error of needle eject
			FormatTrace(traceSource, traceAction, TraceStatus::completeWithError);

			Error::RaiseLast();
		}
	}
	// end

	static function Assert(variable expr, variable location)
	{
		#ifdef _DEBUG
		if (!expr)
		{
			if (PTL_Util::IsInteger(location))
				location = IStr(location);
			if (PTL_Util::IsFloat(location))
				location = FStr(location);
			FormatTrace("DEBUG", "Assert()", TraceStatus::progress, "Debug Assertion failed, Debug Error - " + location);
			MessageBox("Debug Assertion failed", "Debug Error - " + location, hslError|hslOKOnly, UserResponseTime);
			abort;
		}
		#endif
	}

	static function Error::Raise(variable errorId, variable& fileName, variable& funcName, variable& lineNumber)
	{
		variable description("");

		// set error description
		description = fileName + "(" + lineNumber + ") : " + funcName + "()\n" + StringTable::Load(errorId);
		err.SetDescription(description);

		// raise error
		err.Raise(errorId, err.GetDescription(), StringTable::Load(IDS::helpFileName));
	}

	static function Error::RaiseEx(
		variable errorId,
		variable errorDesc,
		variable& fileName,
		variable& funcName,
		variable& lineNumber)
	{
		variable description("");

		// set error description
		description = fileName + "(" + lineNumber + ") : " + funcName + "()\n" + errorDesc;
		err.SetDescription(description);

		// raise error
		err.Raise(errorId, err.GetDescription(), StringTable::Load(IDS::helpFileName));
	}

	static function Error::RaiseLast()
	{
		// re-raise error
		err.Raise();
	}

	static function Error::Display()
	{
		// display error
		return(MessageBox(err.GetDescription() + StringTable::Load(IDS::errorText), 
								StringTable::Load(IDS::errorTitle) + "   " + IStr(err.GetId()), 
								hslError|hslYesNo|hslDefButton1, 
								UserResponseTime));
	}

	static function PTL_Util::Min(variable number1, variable number2)
	{
		if (number1 <= number2)
			return(number1);
		return(number2);
	}

	static function PTL_Util::Max(variable number1, variable number2)
	{
		if (number1 <= number2)
			return(number2);
		return(number1);
	}

	static function PTL_Util::IsString(variable var)
	{
		return(hslString.Compare(GetType(var)) == 0);
	}

	static function PTL_Util::IsNumber(variable var)
	{
		variable type;
		type = GetType(var);
		return(hslString.Compare(type) != 0 && "" != type);
	}

	static function PTL_Util::IsInteger(variable var)
	{
		return(hslInteger.Compare(GetType(var)) == 0);
	}

	static function PTL_Util::IsFloat(variable var)
	{
		return(hslFloat.Compare(GetType(var)) == 0);
	}

	static function PTL_Util::IsNegative(variable number)
	{
		return(number < 0);
	}

	static function PTL_Util::Abs(variable number)
	{
		if (number < 0)
			return(- number);
		return(number);
	}

	static function PTL_Util::CsvToDelimited(
		device& ML_STAR,
		variable csv)
	{
		variable fieldDelimiter("");

		fieldDelimiter = ML_STAR.GetCfgValueWithKey(MlStarCfgKey::wordSeparator);
		if (fieldDelimiter != StringConstants::csvDelimiter)
		{
			StrReplace(csv, StringConstants::csvDelimiter, fieldDelimiter);
		}
		return(csv);
	}

	//>> 20061129 (SCR#1121)
	static function PTL_Util::CsvToDelimited2(
		device& ML_STAR,
		variable csv)
	{
		variable substrings[];
		variable substring;
		variable size(0);
		variable i(0);
		object dictionary;
	
		dictionary.CreateObject("Scripting.Dictionary");
		LCB::Split(csv, StringConstants::csvDelimiter, substrings);
		csv = "";
		size = substrings.GetSize();
		for (i = 0; i < size; i++)
		{
			substring = substrings.ElementAt(i);
			if (!dictionary.Exists(substring))
			{
				if (0 < i)
				{
					csv = csv + StringConstants::csvDelimiter;
				}
				csv = csv + substring;
				dictionary.Add(substring, i);
			}
		}
		return(csv); // SCR#1503: return(PTL_Util::CsvToDelimited(ML_STAR,csv));
	}
	//<< 20061129

	static function PTL_Util::Lookup(variable& varArr[], variable& value, variable& index)
	{
		variable found(hslFalse);									// gets true if value was found in varArr
		variable size(0);												// the size of varArr

		// do a sequential search
		size = varArr.GetSize();
		for (index = 0; index < size; index++)
		{
			if (varArr.GetAt(index) == value)
			{
				found = hslTrue;
				break;
			}
		}
		if (!found)
			index =  0;
		return(found);
	}


	static function PTL_Util::TraceWarningIfNotValidated(
			variable& strAction,											
			variable& strSomeText) void
	{
		variable isFileValidationEnabled(-1);
		object hxRegistryPtr;

		if ( 0 == hxRegistryPtr.CreateObject("HXREGLib.HxRegistry") )
		{
			variable errorDesc;
			errorDesc = StringTable::Load(IDE::createObjectFailed);
			StrReplace(errorDesc, "%s", "HXREGLib.HxRegistry");
			Error::RaiseEx(IDE::createObjectFailed, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
		}
		isFileValidationEnabled = hxRegistryPtr.FileValidation();
		hxRegistryPtr.ReleaseObject();

		if ( 0 != isFileValidationEnabled)
		{
			// File validation is enabled, check if the method file is valid because in this case we must not trace a warning
			variable methodFileName("");
			variable fileValidFlag(-1);
			object hxSecurityComPtr;
			object hxSecurityFileComPtr;
			// definition of enum from HxSecurityCom
			//const variable HxSecurityCOMValidation_validationInvalid    (0);
			  const variable HxSecurityCOMValidation_validationValid      (1);
			//const variable HxSecurityCOMValidation_validationIrrelevant (2);

			if ( 0 == hxSecurityComPtr.CreateObject("Hamilton.HxSecurityCom") )
			{
				variable errorDesc;
				errorDesc = StringTable::Load(IDE::createObjectFailed);
				StrReplace(errorDesc, "%s", "Hamilton.HxSecurityCom");
				Error::RaiseEx(IDE::createObjectFailed, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
			}
			if ( 0 == hxSecurityComPtr.GetObject("IHxSecurityFileCom", hxSecurityFileComPtr) )
			{
				variable errorDesc;
				errorDesc = StringTable::Load(IDE::queryInterfaceFailed);
				StrReplace(errorDesc, "%s", "IHxSecurityFileCom");
				Error::RaiseEx(IDE::queryInterfaceFailed, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
			}
			//>> 20060523
			//hxSecurityFileComPtr.GetFileValidation(GetMethodFileName(), fileValidFlag);
			methodFileName = GetMethodFileName();
			if ("" == methodFileName)
			{
				methodFileName = GetWorkflowFileName();
			}
			hxSecurityFileComPtr.GetFileValidation(methodFileName, fileValidFlag);
			//<< 20060523
			hxSecurityFileComPtr.ReleaseObject();
			hxSecurityComPtr.ReleaseObject();

			if ( HxSecurityCOMValidation_validationValid == fileValidFlag )
			{
				// Validation is enabled and file is valid -> no warning trace
				return;
			}
		}

		// Trace the warning string
		FormatTrace(StringTable::Load(IDS::traceSource), strAction, TraceStatus::progress,
						StringTable::Load(IDS::traceWarning), strSomeText);
	}


	namespace Sound
	{
		static function GetSoundFile(variable hxServicesSoundEnum) variable
		{
			variable strSound("");
			strSound = PTL_Util::objHxServicesGeneralSettings2.GetSound(hxServicesSoundEnum);
			return(strSound);
		}

		static function Play(variable hxServicesSoundEnum) variable
		{
			variable strSound("");
			strSound = GetSoundFile(hxServicesSoundEnum);
			return(dlg.PlaySound(strSound));
		}

		static function Stop() variable
		{
			return(dlg.PlaySound(""));
		}
	}

	namespace StepReturn
	{

		static function Empty(variable& rc[])
		{
			rc.SetSize(0);
		}

		static function IsEmpty(variable& rc[])
		{
			return(rc.GetSize() == 0);
		}

		static function Bind(variable& rc[])
		{
			variable data[];
			data = err.GetData();
			if (0 < data.GetSize())
			{
				rc = data;
				Check(rc);
			}
			else
				// re-throw error
				Error::RaiseLast();
		}

		static function Check(variable& rc[])
		{
				variable size(0);
				variable index(0);

				// if we are recovering from an error and if none of the step return strings has 
				// an error set it must be a software programming error
				size = rc.GetSize();
				for (index = 0; index < size; index++)
				{
					variable errorCode(0);
					errorCode = StepReturn::GetErrorCode(rc.ElementAt(index));
					if (0 != errorCode)
						break;
				}
				if (index == size)
					// none of the step return strings has an error set, 
					// that must be a software programming error,
					// re-throw error
					Error::RaiseLast();
		}

		static function Evaluate(
			device& ML_STAR,
			variable& rc[],
			variable errorHandling)
		{
			sequence null;
			variable volumes_1[];
			variable volumes_2[];
			return(EvaluateEx(ML_STAR, rc, errorHandling, null, null, 0, 0, 0, 0, volumes_1, volumes_2, 0, StepType::unspecified, hslTrue));
		}

		static function EvaluateEx(
			device& ML_STAR,
			variable& rc[],
			variable errorHandling,
			sequence& aspirateSequence,
			sequence& dispenseSequence,
			variable aspirateMultiplicity,
			variable dispenseMultiplicity,
			variable drivingMode,
			//>> 20060503
			variable evaluateIndividualVolumes,
			variable& currentVolumes_1[],
			variable& currentVolumes_2[],
			//<< 20060503
			variable currentVolume,
			variable stepType,
			variable propagate)
		{
			variable status(hslTrue);					// evaluation status
			variable numberOfStepReturnValues(0);	// number of step return values

			#ifdef _DEBUG
			Dump(rc);
			#endif

			numberOfStepReturnValues = rc.GetSize();
			if (1 < numberOfStepReturnValues)
			{
				if (StepType::unspecified == stepType)
					stepType = rc.GetAt(1);
			}

			if (2 < numberOfStepReturnValues)
			{
				// handle steps returning at least three step return values

				variable stepReturn;					// step return (string)
				variable errorCode;					// error code (integer)

				// initialize field and block delimiters used in step returns 
				// from this device's configuration file 
				StepReturn::SetBlockDelimiterEx(ML_STAR);
				StepReturn::SetFieldDelimiterEx(ML_STAR);

				stepReturn = rc.GetAt(2);
				errorCode = StepReturn::GetErrorCode(stepReturn);

				if (0 == errorCode)
				{
					// no error

					// set status
					status = hslTrue;
				}
				if (1 == errorCode)
				{
					// recoverable error

					variable invalidStepType(hslTrue);	// indicates whether the step type is invalid

					// switch over step types
					if (StepType::initialize == stepType)
					{
						// initialize error
						// set status
						if (ErrorHandling::continue == errorHandling || ErrorHandling::custom == errorHandling)
						{
							// evaluate generic recovery
							EvaluateGenericRecovery(stepReturn);
							status = hslTrue;
						}
						else
							status = hslFalse;
						invalidStepType = hslFalse;
					}
					if (StepType::tipPickup == stepType)
					{
						// tip pickup error
						// set status
						if (ErrorHandling::continue == errorHandling || ErrorHandling::custom == errorHandling)
						{
							//>> 20060529
							// set tip presence according to given step return value
							PCB::SetTipPresence2(stepReturn);
							//<< 20060529

							// evaluate generic recovery
							EvaluateGenericRecovery(stepReturn);
							status = hslTrue;
						}
						else
						{
							status = hslFalse;
						}
						invalidStepType = hslFalse;
					}
					if (StepType::tipEject == stepType)
					{
						// tip eject error
						// set status
						if (ErrorHandling::continue == errorHandling || ErrorHandling::custom == errorHandling)
						{
							// evaluate generic recovery
							EvaluateGenericRecovery(stepReturn);
							status = hslTrue;
						}
						else
							status = hslFalse;
						invalidStepType = hslFalse;
					}

					// aspirate step
					if (StepType::aspirate == stepType)
					{
						// aspirate error

						variable channelPattern;
						variable setDataStatus;		// Added 2009-12-16/cjoerg

						// set the channel pattern
						if (IsRecovering2())
							// we are recovering from an error
							channelPattern = GetChannelPattern();
						else
							// we are not recovering from an error
							channelPattern = AspirateChannelVariable;

						// check if we have any channels
						if (0 == ML_STAR.GetCfgValueWithKey(MlStarCfgKey::numberOfChannels))
							// no channels
							Error::RaiseLast();

						// evaluate aspirate recovery
						EvaluateAspirateRecovery(stepReturn, channelPattern);

						// set internal data
						setDataStatus = SetData(stepReturn, aspirateSequence, dispenseSequence, channelPattern, StepType::aspirate);

						// we have the channel pattern that should be used to execute the 
						// next step(s) if the copy pattern option is enabled and we have 
						// the positions to exclude (temporarily or persistent)

						// check if error positions should be excluded persistently
						if (ExcludeErrorPositionsEnabled)
						{
							variable volumes[];

							BackupTrackerData();
							//>> 20060503
							if (DrivingMode::aspirateDriven == drivingMode)
								PersistExcludedPositions(AspirateSequence, aspirateSequence, evaluateIndividualVolumes, currentVolumes_1, currentVolumes_2, StepType::aspirate, hslTrue);
							else
								PersistExcludedPositions(AspirateSequence, aspirateSequence, 0, volumes, volumes, StepType::aspirate, hslTrue);
							//<< 20060503
							ResetTrackerData(hslFalse);
							RestoreTrackerData();

							// check if error positions should also be excluded 
							// persistently from the dependent sequence
							if (CopyPatternEnabled && propagate)
							{
								//>> 20060503
								if (DrivingMode::dispenseDriven == drivingMode)
									PersistExcludedPositions(DispenseSequence, dispenseSequence, evaluateIndividualVolumes, currentVolumes_1, currentVolumes_2, StepType::dispense, hslFalse);
								else
									PersistExcludedPositions(DispenseSequence, dispenseSequence, 0, volumes, volumes, StepType::dispense, hslFalse);
								//<< 20060503
							}

							// align sequences because of persistently excluded positions 
							if (!CopyPatternEnabled)
								AlignExcludedPositions(aspirateSequence, dispenseSequence, 
															  aspirateMultiplicity, dispenseMultiplicity,drivingMode);
						}

						// check if error positions should be excluded temporarily
						if (CopyPatternEnabled)
						{
							// exclude error positions temporarily
							variable startPos(0);			// position where to start exclusion

							// if error positions have not already been excluded persistently,
							if (!ExcludeErrorPositionsEnabled)
							{
								variable volumes[];

								// exclude error positions temporarily from the aspirate sequence
								BackupTrackerData();
								startPos = aspirateSequence.GetCurrentPosition();
								//>> 20060503
								if (DrivingMode::aspirateDriven == drivingMode)
								{
									ExcludeSequencePositions(aspirateSequence, 
																	 evaluateIndividualVolumes, currentVolumes_1, currentVolumes_2, 
																	 startPos, 0,
																	 aspirateLabIds, aspiratePosIds, 
																	 aspirateVolumes_1, aspirateVolumes_2, 
																	 aspirateExcludePos, aspirateCurrentInc,
																	 trackLabIds, trackPosIds);
								}
								else
								{
									ExcludeSequencePositions(aspirateSequence, 
																	 0, volumes, volumes, 
																	 startPos, 0,
																	 aspirateLabIds, aspiratePosIds, 
																	 volumes, volumes, 
																	 aspirateExcludePos, aspirateCurrentInc,
																	 trackLabIds, trackPosIds);
								}
								//<< 20060503
								ResetTrackerData(hslFalse);
								RestoreTrackerData();

								if (propagate)
								{
									// exclude error positions temporarily from the dispense sequence
									startPos = dispenseSequence.GetCurrentPosition();
									//>> 20060503
									if (DrivingMode::dispenseDriven == drivingMode)
									{
										ExcludeSequencePositions(dispenseSequence, 
																		 evaluateIndividualVolumes, currentVolumes_1, currentVolumes_2, 
																		 startPos, 0,
																		 dispenseLabIds, dispensePosIds,
																		 dispenseVolumes_1, dispenseVolumes_2, 
																		 dispenseExcludePos, dispenseCurrentInc,
																		 trackLabIds, trackPosIds);
									}
									else
									{
										ExcludeSequencePositions(dispenseSequence, 
																		 0, volumes, volumes, 
																		 startPos, 0,
																		 dispenseLabIds, dispensePosIds,
																		 volumes, volumes, 
																		 dispenseExcludePos, dispenseCurrentInc,
																		 trackLabIds, trackPosIds);
									}
									//<< 20060503
								}
							}
						}

						// set status
						if ((ErrorHandling::continue == errorHandling || ErrorHandling::custom == errorHandling) && (CopyPatternEnabled || ExcludeErrorPositionsEnabled))
						{
							//status = hslFalse;
							status = setDataStatus;		// 2009-12-16/cjoerg: Return the erro status as evaluated by SetData
																// to prevent any further error handling if an error has been successfully
																// recovered.
						}
						else
						{
							status = hslTrue;
							// reset any internal state of StepReturn 
							ResetData(hslTrue, hslTrue);

							// reset any sample tracker data of the StepReturn 
							StepReturn::ResetTrackerData(hslTrue);
						}
						invalidStepType = hslFalse;

						// dump internal state of StepReturn
						#ifdef _DEBUG
						DumpData();
						#endif
					}

					// dispense step
					if (StepType::dispense == stepType)
					{
						// dispense error

						variable channelPattern; 
						variable setDataStatus;		// 2009-12-16/cjoerg

						// set the channel pattern
						if (IsRecovering2())
							// we are recovering from an error
							channelPattern = GetChannelPattern();
						else
							// we are not recovering from an error
							channelPattern = DispenseChannelVariable;

						// check if we have any channels
						if (0 == ML_STAR.GetCfgValueWithKey(MlStarCfgKey::numberOfChannels))
							// no channels
							Error::RaiseLast();

						// evaluate dispense recovery
						EvaluateDispenseRecovery(stepReturn, channelPattern);

						// set internal data
						setDataStatus = SetData(stepReturn, aspirateSequence, dispenseSequence, channelPattern, StepType::dispense);

						// we have the channel pattern that should be used to execute the 
						// next step(s) if the copy pattern option is enabled and we have 
						// the positions to exclude (temporarily or persistent)

						// check if error positions should be excluded persistently
						if (ExcludeErrorPositionsEnabled)
						{
							variable volumes[];

							BackupTrackerData();
							//>> 20060503
							if (DrivingMode::dispenseDriven == drivingMode)
								PersistExcludedPositions(DispenseSequence, dispenseSequence, evaluateIndividualVolumes, currentVolumes_1, currentVolumes_2, StepType::dispense, hslTrue);
							else
								PersistExcludedPositions(DispenseSequence, dispenseSequence, 0, volumes, volumes, StepType::dispense, hslTrue);
							//<< 20060503
							ResetTrackerData(hslFalse);
							RestoreTrackerData();

							// check if error positions should also be excluded 
							// persistently from the dependent sequence
							if (CopyPatternEnabled && propagate)
							{
									BackupTrackerData();
									//>> 20060503
									if (DrivingMode::aspirateDriven == drivingMode)
										PersistExcludedPositions(AspirateSequence, aspirateSequence, evaluateIndividualVolumes, currentVolumes_1, currentVolumes_2, StepType::aspirate, hslTrue);
									else
										PersistExcludedPositions(AspirateSequence, aspirateSequence, 0, volumes, volumes, StepType::aspirate, hslTrue);
									//<< 20060503
									// reset tracker data if we are in the last volume loop and 
									// we are in the pipetting mode 'simple' or 'pooling'
									if (0 == currentVolume && 
										 aspirateMultiplicity >= dispenseMultiplicity)
										ResetTrackerData(hslFalse);
									RestoreTrackerData();
							}

							// align sequences because of persistently excluded positions 
							if (!CopyPatternEnabled)
								AlignExcludedPositions(aspirateSequence, dispenseSequence, 
															  aspirateMultiplicity, dispenseMultiplicity,drivingMode);
						}

						// check if error positions should be excluded temporarily
						if (CopyPatternEnabled)
						{
							// exclude error positions temporarily
							variable startPos(0);			// position where to start exclusion

							// if error positions have not already been excluded persistently,
							if (!ExcludeErrorPositionsEnabled)
							{
								variable volumes[];

								// exclude error positions temporarily from the dispense sequence
								BackupTrackerData();
								startPos = dispenseSequence.GetCurrentPosition();
								//>> 20060503
								if (DrivingMode::dispenseDriven == drivingMode)
								{
									ExcludeSequencePositions(dispenseSequence, 
																	 evaluateIndividualVolumes, currentVolumes_1, currentVolumes_2, 
																	 startPos, 0,
																	 dispenseLabIds, dispensePosIds,
																	 dispenseVolumes_1, dispenseVolumes_2, 
																	 dispenseExcludePos, dispenseCurrentInc,
																	 trackLabIds, trackPosIds);
								}
								else
								{
									ExcludeSequencePositions(dispenseSequence, 
																	 0, volumes, volumes, 
																	 startPos, 0,
																	 dispenseLabIds, dispensePosIds,
																	 volumes, volumes, 
																	 dispenseExcludePos, dispenseCurrentInc,
																	 trackLabIds, trackPosIds);
								}
								//<< 20060503
								ResetTrackerData(hslFalse);
								RestoreTrackerData();

								if (propagate)
								{
									// exclude error positions temporarily from the aspirate sequence
									BackupTrackerData();
									startPos = aspirateSequence.GetCurrentPosition();
									//>> 20060503
									if (DrivingMode::aspirateDriven == drivingMode)
									{
										ExcludeSequencePositions(aspirateSequence, 
																		 evaluateIndividualVolumes, currentVolumes_1, currentVolumes_2, 
																		 startPos, 0,
																		 aspirateLabIds, aspiratePosIds, 
																	 	 aspirateVolumes_1, aspirateVolumes_2, 
																		 aspirateExcludePos, aspirateCurrentInc,
																		 trackLabIds, trackPosIds);
									}
									else
									{
										ExcludeSequencePositions(aspirateSequence, 
																		 0, volumes, volumes, 
																		 startPos, 0,
																		 aspirateLabIds, aspiratePosIds, 
																	 	 volumes, volumes, 
																		 aspirateExcludePos, aspirateCurrentInc,
																		 trackLabIds, trackPosIds);
									}
									//<< 20060503
									// reset tracker data if we are in the last volume loop and 
									// we are in the pipetting mode 'simple' or 'pooling'
									if (0 == currentVolume && 
										 aspirateMultiplicity >= dispenseMultiplicity)
										ResetTrackerData(hslFalse);
									RestoreTrackerData();
								}
							}
						}

						// set status
						if ((ErrorHandling::continue == errorHandling || ErrorHandling::custom == errorHandling) && (CopyPatternEnabled || ExcludeErrorPositionsEnabled))
						{
							//status = hslFalse;
							status = setDataStatus;		// 2009-12-16/cjoerg: Return the erro status as evaluated by SetData
																// to prevent any further error handling if an error has been successfully
																// recovered.
						}
						else
						{
							status = hslTrue;
							// reset any internal state of StepReturn 
							ResetData(hslTrue, hslTrue);

							// reset any sample tracker data of the StepReturn 
							StepReturn::ResetTrackerData(hslTrue);
						}
						invalidStepType = hslFalse;

						// dump internal state of StepReturn
						#ifdef _DEBUG
						DumpData();
						#endif
					}
					if (StepType::loadCarrier == stepType)
					{
						// load carrier error
						// set status
						if (ErrorHandling::continue == errorHandling || ErrorHandling::custom == errorHandling)
						{
							// evaluate generic recovery
							EvaluateGenericRecovery(stepReturn);
							status = hslTrue;
						}
						else
							status = hslFalse;
						invalidStepType = hslFalse;
					}
					if (StepType::unloadCarrier == stepType)
					{
						// unload carrier error
						// set status
						if (ErrorHandling::continue == errorHandling || ErrorHandling::custom == errorHandling)
						{
							// evaluate generic recovery
							EvaluateGenericRecovery(stepReturn);
							status = hslTrue;
						}
						else
							status = hslFalse;
						invalidStepType = hslFalse;
					}
					if (StepType::calibrate1536Plate == stepType)
					{
						// calibrate 1536 plate error
						// set status
						if (ErrorHandling::continue == errorHandling || ErrorHandling::custom == errorHandling)
						{
							// evaluate generic recovery
							EvaluateGenericRecovery(stepReturn);
							status = hslTrue;
						}
						else
							status = hslFalse;
						invalidStepType = hslFalse;
					}
					if (StepType::waitNeedleWashed == stepType)
					{
						// wait needle washed error
						// set status
						if (ErrorHandling::continue == errorHandling || ErrorHandling::custom == errorHandling)
						{
							// evaluate generic recovery
							EvaluateGenericRecovery(stepReturn);
							status = hslTrue;
						}
						else
							status = hslFalse;
						invalidStepType = hslFalse;
					}
					if (StepType::startNeedleWash == stepType)
					{
						// start needle washe error

						// set status
						if (ErrorHandling::continue == errorHandling || ErrorHandling::custom == errorHandling)
						{
							// evaluate generic recovery
							EvaluateGenericRecovery(stepReturn);
							status = hslTrue;
						}
						else
							status = hslFalse;
						invalidStepType = hslFalse;
					}

					if (invalidStepType)
					{
						variable errorDesc;
						errorDesc = StringTable::Load(IDE::invalidStepType);
						StrReplace(errorDesc, "%s", stepType);
						Error::RaiseEx(IDE::invalidStepType, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
					}

				}
				if (2 == errorCode)
				{
					// unrecoverable error,
					// re-throw error
					Error::RaiseLast();
				}
			}

			if (status && 3 < numberOfStepReturnValues)
			{
				// handle steps returning at least four step return values

				variable stepReturn;					// step return (string)
				variable errorCode;					// error code (integer)

				// initialization of field and block delimiters used in step returns 
				// from this device's configuration file has already been done

				stepReturn = rc.GetAt(3);
				errorCode = StepReturn::GetErrorCode(stepReturn);

				if (StepType::loadCarrier != stepType)
				{
					// the load carrier step is the only step which is 
					// allowed to have five step return fields
					variable errorDesc;
					errorDesc = StringTable::Load(IDE::unexpectedStepReturn);
					StrReplace(errorDesc, "%s", stepType);
					Error::RaiseEx(IDE::unexpectedStepReturn, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				}

				if (0 == errorCode)
				{
					// no error

					// set status
					status = hslTrue;
				}
				if (1 == errorCode)
				{
					// recoverable error

					variable invalidStepType(hslTrue);	// indicates whether the step type is invalid

					// switch over step types
					if (StepType::loadCarrier == stepType)
					{
						// load carrier error
						// set status
						if (ErrorHandling::continue == errorHandling || ErrorHandling::custom == errorHandling)
						{
							// evaluate generic recovery
							EvaluateGenericRecovery(stepReturn);
							status = hslTrue;
						}
						else
							status = hslFalse;
						invalidStepType = hslFalse;
					}

					if (invalidStepType)
					{
						variable errorDesc;
						errorDesc = StringTable::Load(IDE::invalidStepType);
						StrReplace(errorDesc, "%s", stepType);
						Error::RaiseEx(IDE::invalidStepType, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
					}
				}
				if (2 == errorCode)
				{
					// unrecoverable error,
					// re-throw error
					Error::RaiseLast();
				}
			}

			if (status && 4 < numberOfStepReturnValues)
			{
				// handle steps returning at least five step return values

				variable stepReturn;					// step return (string)
				variable errorCode;					// error code (integer)

				// initialization of field and block delimiters used in step returns 
				// from this device's configuration file has already been done

				stepReturn = rc.GetAt(4);

				if (StepType::loadCarrier != stepType)
				{
					// the load carrier step is the only step which is 
					// allowed to have five step return fields
					variable errorDesc;
					errorDesc = StringTable::Load(IDE::unexpectedStepReturn);
					StrReplace(errorDesc, "%s", stepType);
					Error::RaiseEx(IDE::unexpectedStepReturn, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				}
			}
			return(status);
		}

		static function EvaluateGenericRecovery(
			variable& stepReturn)
		{
			variable index(0);					// loop index
			variable length(0);					// string length
			variable mainError(0);				// main error code
			variable recoveryButton(0);		// recovery button
			variable numberOfPositions(0);	// number of positions in step return

			// iterate over positons
			numberOfPositions = StepReturn::GetNumberOfPositions(stepReturn);
			for (index = 0; index < numberOfPositions; index++)
			{
				// get main error 
				mainError = StepReturn::GetMainError(index + 1, stepReturn);

				if (MainError::noError != mainError)
				{
					// channel has an error,
					// get recovery option
					recoveryButton = StepReturn::GetRecoveryButton(index + 1, stepReturn);

					// handle recovery options Abort and Cancel which are 
					// common to all main errors 
					if (RecoveryButton::abort_ == recoveryButton)
					{
						// user selected Abort button,
						// abort the method
						// Remark 1: we should never land here, because the executor 
						// already should have aborted the method.
						// Remark 2: a request to abort the method is signaled 
						// by raising the 'methodAborted ' error id
						Error::Raise(IDE::methodAborted, GetFileName(), GetFunctionName(), GetLineNumber());
					}
					if (RecoveryButton::cancel == recoveryButton)
					{
						// user selected Cancel button,
						// re-throw error
						Error::RaiseLast();
					}
				}
			}
		}

		static function EvaluateAspirateRecovery(
			variable& stepReturn,
			string& channelPattern)
		{
			variable index(0);				// loop index
			variable length(0);				// string length
			variable mainError(0);			// main error code
			variable recoveryButton(0);	// recovery button

			// iterate over channels
			length = channelPattern.GetLength();
			for (index = 0; index < length; index++)
			{
				if ("1" == channelPattern.Mid(index, 1))
				{
					// channel is active,
					// get main error 
					mainError = StepReturn::GetMainError(index + 1, stepReturn);

					// check if the channel has an error
					if (MainError::noError != mainError)
					{
						// channel has an error,
						// get recovery option
						recoveryButton = StepReturn::GetRecoveryButton(index + 1, stepReturn);

						// handle recovery options Abort and Cancel which are 
						// common to all main errors 
						if (RecoveryButton::abort_ == recoveryButton)
						{
							// user selected Abort button,
							// abort the method
							// Remark 1: we should never land here, because the executor 
							// already should have aborted the method.
							// Remark 2: a request to abort the method is signaled 
							// by raising the 'methodAborted ' error id
							Error::Raise(IDE::methodAborted, GetFileName(), GetFunctionName(), GetLineNumber());
						}
						if (RecoveryButton::cancel == recoveryButton)
						{
							// user selected Cancel button,
							// re-throw error
							Error::RaiseLast();
						}

						// switch over main errors

						if (MainError::hardwareError == mainError)
						{
							// handle recovery option Repeat
							if (RecoveryButton::repeat == recoveryButton)
							{
								// user selected Repeat button
							}
						}

						if (MainError::commandNotCompletedError == mainError)
						{
							// handle recovery option Repeat
							if (RecoveryButton::repeat == recoveryButton)
							{
								// user selected Repeat button
							}
						}

						if (MainError::clotError == mainError ||
							MainError::TADMMeasurementError == mainError)
						{
							// handle recovery options Continue, Waste, Repeat
							if (RecoveryButton::continue == recoveryButton)
							{
								// user selected Continue button
							}
							if (RecoveryButton::waste == recoveryButton)
							{
								// user selected Waste button
							}
							if (RecoveryButton::repeat == recoveryButton)
							{
								// user selected Repeat button
							}
						}

						if (MainError::insufficientError == mainError)
						{
							// handle recovery options Bottom, Repeat, Air, Available
							if (RecoveryButton::bottom == recoveryButton)
							{
								// user selected Bottom button
							}
							if (RecoveryButton::repeat == recoveryButton)
							{
								// user selected Repeat button
							}
							if (RecoveryButton::air == recoveryButton)
							{
								// user selected Air button
							}
							if (RecoveryButton::available == recoveryButton)
							{
								// user selected Available button
							}
						}

						if (MainError::lldNotFoundError == mainError)
						{
							// handle recovery options Bottom, Repeat, Air
							if (RecoveryButton::bottom == recoveryButton)
							{
								// user selected Bottom button
							}
							if (RecoveryButton::repeat == recoveryButton)
							{
								// user selected Repeat button
							}
							if (RecoveryButton::air == recoveryButton)
							{
								// user selected Air button
							}
						}

						if (MainError::noTipError == mainError)
						{
							// nothing to do
						}

						if (MainError::executionError == mainError)
						{
							// handle recovery option Repeat 
							if (RecoveryButton::repeat == recoveryButton)
							{
								// user selected Repeat button
							}
						}

						if (MainError::improperAspirationError == mainError ||
							MainError::TADMError == mainError)
						{
							// handle recovery options Bottom, Continue, Repeat, Waste
							if (RecoveryButton::bottom == recoveryButton)
							{
								// user selected Bottom button
							}
							if (RecoveryButton::continue == recoveryButton)
							{
								// user selected Continue button
							}
							if (RecoveryButton::repeat == recoveryButton)
							{
								// user selected Repeat button
							}
							if (RecoveryButton::air == recoveryButton)
							{
								// user selected Air button
							}
							if (RecoveryButton::waste == recoveryButton)
							{
								// user selected Waste button
							}
						}
					}
				}
			}
		}

		static function EvaluateDispenseRecovery(
			variable& stepReturn,
			string& channelPattern)
		{
			variable index(0);				// loop index
			variable length(0);				// string length
			variable mainError(0);			// main error code
			variable recoveryButton(0);	// recovery button

			// iterate over channels
			length = channelPattern.GetLength();
			for (index = 0; index < length; index++)
			{
				if ("1" == channelPattern.Mid(index, 1))
				{
					// channel is active,
					// get main error 
					mainError = StepReturn::GetMainError(index + 1, stepReturn);

					// check if the channel has an error
					if (MainError::noError != mainError)
					{
						// channel has an error,
						// get recovery option
						recoveryButton = StepReturn::GetRecoveryButton(index + 1, stepReturn);

						// handle recovery options Abort and Cancel which are 
						// common to all main errors 
						if (RecoveryButton::abort_ == recoveryButton)
						{
							// user selected Abort button,
							// abort the method
							// Remark 1: we should never land here, because the executor 
							// already should have aborted the method.
							// Remark 2: a request to abort the method is signaled 
							// by raising the 'methodAborted ' error id
							Error::Raise(IDE::methodAborted, GetFileName(), GetFunctionName(), GetLineNumber());
						}
						if (RecoveryButton::cancel == recoveryButton)
						{
							// user selected Cancel button,
							// re-throw error
							Error::RaiseLast();
						}

						// switch over main errors

						if (MainError::commandNotCompletedError == mainError)
						{
							// handle recovery option Repeat
							if (RecoveryButton::repeat == recoveryButton)
							{
								// user selected Repeat button
							}
						}

						if (MainError::clotError == mainError ||
							MainError::TADMError == mainError)
						{
							// nothing to do
						}

						if (MainError::lldNotFoundError == mainError)
						{
							// handle recovery options Bottom, Repeat
							if (RecoveryButton::bottom == recoveryButton)
							{
								// user selected Bottom button
							}
							if (RecoveryButton::repeat == recoveryButton)
							{
								// user selected Repeat button
							}
						}

						if (MainError::insufficientError == mainError)
						{
							// nothing to do
						}

						if (MainError::noTipError == mainError)
						{
							// nothing to do
						}

						if (MainError::executionError == mainError)
						{
							// handle recovery option Repeat 
							if (RecoveryButton::repeat == recoveryButton)
							{
								// user selected Repeat button
							}
						}

						if (MainError::lldError == mainError)
						{
							// handle recovery options Bottom
							if (RecoveryButton::bottom == recoveryButton)
							{
								// user selected Bottom button
							}
						}

						if (MainError::improperAspirationError == mainError ||
							MainError::TADMMeasurementError == mainError)
						{
							// nothing to do
						}
					}
				}
			}
		}

		static function EvaluateLoadCarrierRecovery(
			variable& stepReturn3,
			variable& stepReturn5,
			string positions,
			string labwareNames,
			string positionNames,
			variable& excludePositions[],
			variable& excludeLabwareNames[],
			variable& excludePositionNames[])
		{
			variable index1(0);					// loop index
			variable index2(0);					// loop index
			variable numberOfPositions1(0);	// number of positions in step return 3
			variable numberOfPositions2(0);	// number of positions in step return 5
			variable mainError(0);				// a main error code in a step return
			variable position(0);				// a position value in a step return
			variable recoveryButton(0);		// recovery button
			variable parsed(hslFalse);			// if 'true', comma separated lists have already been parsed
			variable length;						// string length
			variable size;							// array size
			variable positionsArr[];
			variable labwareNamesArr[];
			variable positionNamesArr[];
			//ba 2004-06-04 begin (SCR#553)
			variable position2(0);				// a position value in a step return
			variable parsed2(hslFalse);		// if 'true', return strings have already been parsed
			variable positionsArr2[];
			variable barcodePositionArr2[];
			//end

			// iterate over positons
			numberOfPositions1 = StepReturn::GetNumberOfPositions(stepReturn3);
			//ba 2004-06-04 begin (SCR#553)
			numberOfPositions2 = StepReturn::GetNumberOfPositions(stepReturn5);
			//end
			for (index1 = 0; index1 < numberOfPositions1; index1++)
			{
				// get main error 
				mainError = StepReturn::GetMainError(index1 + 1, stepReturn3);

				// get position 
				position = StepReturn::GetPosition(index1 + 1, stepReturn3);

				// check if the position has an error
				if (MainError::noError != mainError)
				{
					// position has an error,
					// get recovery option
					recoveryButton = StepReturn::GetRecoveryButton(index1 + 1, stepReturn3);

					// handle recovery options Abort and Cancel which are 
					// common to all main errors 
					if (RecoveryButton::abort_ == recoveryButton)
					{
						// user selected Abort button,
						// abort the method
						// Remark 1: we should never land here, because the executor 
						// already should have aborted the method.
						// Remark 2: a request to abort the method is signaled 
						// by raising the 'methodAborted ' error id
						Error::Raise(IDE::methodAborted, GetFileName(), GetFunctionName(), GetLineNumber());
					}
					if (RecoveryButton::cancel == recoveryButton)
					{
						// user selected Cancel button,
						// re-throw error
						Error::RaiseLast();
					}

					// switch over main errors

					if (MainError::hardwareError == mainError || 
						 MainError::commandNotCompletedError == mainError)
					{
						// handle recovery option Repeat
						if (RecoveryButton::repeat == recoveryButton)
						{
							// user selected Repeat button
						}
					}

					if (MainError::noBarcodeError == mainError 
                  //>> 20071116
                  || MainError::barcodeMaskError == mainError 
                  || MainError::barcodeNotUniqueError == mainError 
                  || MainError::barcodeAlreadyUsedError == mainError 
                  //<< 20071116
                  || MainError::noLabwareError == mainError
                  || MainError::unexpectedLabwareError == mainError
                  || MainError::wrongLabwareError == mainError
                  || MainError::delimiterBarcodeError == mainError)
					{
						// handle recovery options Continue, Repeat, Barcode, Exclude 
						if (RecoveryButton::continue == recoveryButton)
						{
							// user selected Continue button
						}
						if (RecoveryButton::repeat == recoveryButton)
						{
							// user selected Repeat button
						}
						if (RecoveryButton::barcode == recoveryButton)
						{
							// user selected Barcode button
						}
						if (RecoveryButton::exclude == recoveryButton)
						{
							// user selected Exclude button,

							// parse comma separated lists once only
							if (!parsed)
							{
								// parse comma separated list of positons
								index2 = positions.Find(StringConstants::csvDelimiter);
								length = positions.GetLength();
								while (0 <= index2)
								{
									positionsArr.AddAsLast(positions.Left(index2)); 
									positions = positions.Mid(index2 + 1, length);
									index2 = positions.Find(StringConstants::csvDelimiter);
									length = positions.GetLength();
								}
								if (0 < length)
									positionsArr.AddAsLast(positions);

								// parse comma separated list of labware names
								index2 = labwareNames.Find(StringConstants::csvDelimiter);
								length = labwareNames.GetLength();
								while (0 <= index2)
								{
									labwareNamesArr.AddAsLast(labwareNames.Left(index2)); 
									labwareNames = labwareNames.Mid(index2 + 1, length);
									index2 = labwareNames.Find(StringConstants::csvDelimiter);
									length = labwareNames.GetLength();
								}
								if (0 < length)
									labwareNamesArr.AddAsLast(labwareNames);

								// parse comma separated list of position names
								index2 = positionNames.Find(StringConstants::csvDelimiter);
								length = positionNames.GetLength();
								while (0 <= index2)
								{
									positionNamesArr.AddAsLast(positionNames.Left(index2)); 
									positionNames = positionNames.Mid(index2 + 1, length);
									index2 = positionNames.Find(StringConstants::csvDelimiter);
									length = positionNames.GetLength();
								}
								if (0 < length)
									positionNamesArr.AddAsLast(positionNames);
								//ba 2004-06-04 begin (SCR#553)
								parsed = hslTrue;
								//end
							}
							
							// align collection containing position names
							size = positionsArr.GetSize();
							for (index2 = positionNamesArr.GetSize(); index2 < size; index2++)
							{
								positionNamesArr.AddAsLast("");
							}
							#ifdef _DEBUG
							Assert(size == labwareNamesArr.GetSize(), GetFunctionName());
							Assert(size == positionNamesArr.GetSize(), GetFunctionName());
							#endif

							// collect elements to be excluded from loading sequences
							// example:
							// stepReturn3 = 1[01,00,00,0,aaaa,,[02,00,00,0,,,[03,00,00,0,cccc,,[04,00,00,0,,,[05,00,00,0,eeee,,[06,00,00,0,,,[07,00,00,0,gggg,,[08,00,00,0,,,[09,00,00,0,,,[10,00,00,0,,,[11,00,00,0,,,[12,00,00,0,,,[13,00,00,0,,,[14,00,00,0,,,[15,00,00,0,,,[16,00,00,0,,,[17,00,00,0,,,[18,00,00,0,rrrr,,[19,00,00,0,,,[20,00,00,0,tttt,,[21,00,00,0,,,[22,00,00,0,vvvv,,[23,00,00,0,,,[24,00,00,0,xxxx,,
							// stepReturn4 = [01,1**#[03,3**#[05,***#[07,***#[18,***#[20,***#[22,***#[24,***#
							// stepReturn5 = [01,1.A1[01,1.A2[01,1.A3[03,3[05,5[07,7[18,18[20,20[22,22[24,24
							//ba 2004-06-04 begin (SCR#553)
							//numberOfPositions2 = StepReturn::GetNumberOfPositions(stepReturn5);
							//end
							for (index2 = 0; index2 < numberOfPositions2; index2++)
							{
								//ba 2004-06-04 begin (SCR#553)
								if (!parsed2)
								{
									positionsArr2.AddAsLast(StepReturn::GetPosition(index2 + 1, stepReturn5));
									barcodePositionArr2.AddAsLast(StepReturn::GetBarcodePosition(index2 + 1, stepReturn5));
								}
								position2 = positionsArr2.ElementAt(index2);
								if (position2 == position)
								//if (StepReturn::GetPosition(index2 + 1, stepReturn5) == position)
								//end
								{
									variable idx(-1);
									variable arrayIndex;
									string barcodePosition;
									string labwareName;
									string positionName;

									//ba 2004-06-04 begin (SCR#553)
									barcodePosition = barcodePositionArr2.ElementAt(index2);
									//barcodePosition = StepReturn::GetBarcodePosition(index2 + 1, stepReturn5);
									//end
									idx = barcodePosition.Find(".");
									if (0 <= idx)
									{
										// qualified barcode position 
										if (PTL_Util::Lookup(positionsArr, barcodePosition.Mid(0, idx), arrayIndex))
										{
											labwareName = labwareNamesArr.ElementAt(arrayIndex);
										}
										positionName = barcodePosition.Mid(idx + 1, barcodePosition.GetLength());
									}
									else
									{
										// unqualified barcode position 
										if (PTL_Util::Lookup(positionsArr, barcodePosition, arrayIndex))
										{
											labwareName = labwareNamesArr.ElementAt(arrayIndex);
											positionName = positionNamesArr.ElementAt(arrayIndex);
										}
									}
									excludePositions.AddAsLast(barcodePosition);
									excludeLabwareNames.AddAsLast(labwareName);
									excludePositionNames.AddAsLast(positionName);
								}
							}
							//ba 2004-06-04 begin (SCR#553)
							parsed2 = hslTrue;
							//end
						}
					}

					if (MainError::executionError == mainError)
					{
						// handle recovery option Repeat
						if (RecoveryButton::repeat == recoveryButton)
						{
							// user selected Repeat button
						}
					}

					if (MainError::carrierNotAtEndError == mainError)
					{
						// handle recovery option Repeat
						if (RecoveryButton::repeat == recoveryButton)
						{
							// user selected Repeat button
						}
					}

					if (MainError::noCarrierBarcodeError == mainError)
					{
						// handle recovery options Continue, Repeat, Barcode
						if (RecoveryButton::continue == recoveryButton)
						{
							// user selected Continue button
						}
						if (RecoveryButton::repeat == recoveryButton)
						{
							// user selected Repeat button
						}
						if (RecoveryButton::barcode == recoveryButton)
						{
							// user selected Barcode button
						}
					}

					if (MainError::noCarrierError == mainError)
					{
						// handle recovery option Repeat
						if (RecoveryButton::repeat == recoveryButton)
						{
							// user selected Repeat button
						}
					}

					if (MainError::wrongCarrierError == mainError)
					{
						// handle recovery options Continue, Repeat 
						if (RecoveryButton::continue == recoveryButton)
						{
							// user selected Continue button
						}
						if (RecoveryButton::repeat == recoveryButton)
						{
							// user selected Repeat button
						}
					}
				}
			}
		}

		static function EvaluateExx(
			device& ML_STAR,
			variable& rc[],
			variable errorHandling,
			variable& positions,
			variable& labwareNames,
			variable& positionNames,
			variable& excludePositions[],
			variable& excludeLabwareNames[],
			variable& excludePositionNames[])
		{
			variable status(hslTrue);						// evaluation status
			variable numberOfStepReturnValues(0);		// number of step return values
			variable stepType(StepType::unspecified);	// step type 

			numberOfStepReturnValues = rc.GetSize();
			if (1 < numberOfStepReturnValues)
			{
				stepType = rc.GetAt(1);
			}

			if (StepType::loadCarrier != stepType)
			{
				variable errorDesc;
				errorDesc = StringTable::Load(IDE::invalidStepType);
				StrReplace(errorDesc, "%s", stepType);
				Error::RaiseEx(IDE::invalidStepType, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
			}

			if (5 < numberOfStepReturnValues)
			{
				// handle steps returning at least four step return values

				variable stepReturn3;				// step return 3 (string)
				variable stepReturn5;				// step return 3 (string)
				variable errorCode;					// error code (integer)

				// initialize field and block delimiters used in step returns 
				// from this device's configuration file 
				StepReturn::SetBlockDelimiterEx(ML_STAR);
				StepReturn::SetFieldDelimiterEx(ML_STAR);

				stepReturn3 = rc.GetAt(3);
				stepReturn5 = rc.GetAt(5);
				errorCode = StepReturn::GetErrorCode(stepReturn3);

				if (0 == errorCode)
				{
					// no error

					// set status
					status = hslTrue;
				}
				if (1 == errorCode)
				{
					// recoverable error

					// switch over step types
					if (StepType::loadCarrier == stepType)
					{
						// set status
						if (ErrorHandling::continue == errorHandling || ErrorHandling::custom == errorHandling)
						{

							// evaluate aspirate recovery
							EvaluateLoadCarrierRecovery(stepReturn3, stepReturn5, positions, labwareNames, positionNames, 
																 excludePositions, excludeLabwareNames, excludePositionNames);
							status = hslTrue;
						}
						else
						{
							status = hslFalse;
						}
					}
				}
				if (2 == errorCode)
				{
					// unrecoverable error,
					// re-throw error
					Error::RaiseLast();
				}
			}
			return(status);
		}

		static function SetData(
			variable& stepReturn,
			sequence& aspirateSequence,
			sequence& dispenseSequence,
			string& channelPattern,
			variable stepType) variable
		{
			variable index(0);				// loop index
			variable length(0);				// string length
			variable mainError(0);			// main error code
			variable activeChannel(0);		// active channel number
			variable status(hslTrue);  // 2009-12-16/cjoerg: added to return/indicate that a channel error has been found

			// 2009-12-16/cjoerg: Added to ensure that never called for other steps
			if (		StepType::aspirate != stepType
					&& StepType::dispense != stepType )
			{
				variable errorDesc;
				errorDesc = StringTable::Load(IDE::invalidStepType);
				StrReplace(errorDesc, "%s", stepType);
				Error::RaiseEx(IDE::invalidStepType, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
			}

			// update previous copy pattern 
			prevCopyPattern = copyPattern;
			// reset the copy pattern
			copyPattern = "";

			// iterate over channels
			length = channelPattern.GetLength();
			for (index = 0; index < length; index++)
			{
				if ("1" == channelPattern.Mid(index, 1))
				{
					// channel is active,
					// get main error 
					mainError = StepReturn::GetMainError(index + 1, stepReturn);

					// check if the channel has an error
					if (MainError::noError != mainError)
					{
						// 2009-12-16/cjoerg
						// Updated to not longer handle Asp/Disp errors recovered with repeat as an error.
						// This error handling is interpreted as succesfully and no more exclude/tip exchange
						// should be done. See SCR#1470.
						
						variable recoveryButton(0);
						// channel has an error - get the (last) used recovery button
						// (get the button only in case of error to save time (parsing of strings is slow))
						recoveryButton = StepReturn::GetRecoveryButton(index + 1, stepReturn);
						
						if ( RecoveryButton::repeat != recoveryButton )			// 2009-12-16/cjoerg: Added check for used button
						{
							// check if error positions should be excluded (temporarily or persistently)
							if (CopyPatternEnabled || ExcludeErrorPositionsEnabled)
							{
								variable aspirateCurrentPosBak;			// backup of current position of aspirate sequence
								variable dispenseCurrentPosBak;			// backup of current position of dispense sequence

								status = hslFalse;							// 2009-12-16/cjoerg: added

								// backup of current position of aspirate sequence
								aspirateCurrentPosBak = aspirateSequence.GetCurrentPosition();

								// error positions should be excluded,
								// store labware and position ids of aspirate sequence
								aspirateSequence.SetCurrentPosition(aspirateCurrentPosBak + activeChannel);
								aspirateLabIds.AddAsLast(aspirateSequence.GetLabwareId());
								aspiratePosIds.AddAsLast(aspirateSequence.GetPositionId());

								if (StepType::aspirate == stepType)
								{
									errorLabIds.AddAsLast(aspirateSequence.GetLabwareId());
									errorPosIds.AddAsLast(aspirateSequence.GetPositionId());
								}

								// restore current position of aspirate sequence
								aspirateSequence.SetCurrentPosition(aspirateCurrentPosBak);

								// backup of current position of dispense sequence
								dispenseCurrentPosBak = dispenseSequence.GetCurrentPosition();

								// store labware and position ids of dispense sequence
								dispenseSequence.SetCurrentPosition(dispenseCurrentPosBak + activeChannel);
								dispenseLabIds.AddAsLast(dispenseSequence.GetLabwareId());
								dispensePosIds.AddAsLast(dispenseSequence.GetPositionId());

								if (StepType::dispense == stepType)
								{
									errorLabIds.AddAsLast(dispenseSequence.GetLabwareId());
									errorPosIds.AddAsLast(dispenseSequence.GetPositionId());
								}

								// restore current position of dispense sequence
								dispenseSequence.SetCurrentPosition(dispenseCurrentPosBak);
							}

							// channel is active and channel has an error 
							// update copyPattern by disabling channel
							copyPattern = copyPattern + "0";
						}
						else
						{
							// channel is active, has no error but recovered with repeat
							// update copyPattern
							copyPattern = copyPattern + "1";
						}
					}
					else
					{
						// channel is active and has no error,
						// update copyPattern
						copyPattern = copyPattern + "1";
					}

					// increment active channel number
					activeChannel++;

				}
				else
				{
					// channel isn't active,
					// update copyPattern
					copyPattern = copyPattern + "0";
				}
			}

			return( status );
		}

		static function ResetData(
			variable aspirateData,
			variable dispenseData)
		{
			if (aspirateData)
			{
				aspirateLabIds.SetSize(0);
				aspiratePosIds.SetSize(0);
				//>> 20060503
				aspirateVolumes_1.SetSize(0);
				aspirateVolumes_2.SetSize(0);
				//<< 20060503
				aspirateExcludePos.SetSize(0);
				aspirateCurrentInc.SetSize(0);
				aspirateUsedPositions = 0;
			}
			if (dispenseData)
			{
				dispenseLabIds.SetSize(0);
				dispensePosIds.SetSize(0);
				//>> 20060503
				dispenseVolumes_1.SetSize(0);
				dispenseVolumes_2.SetSize(0);
				//<< 20060503
				dispenseExcludePos.SetSize(0);
				dispenseCurrentInc.SetSize(0);
				dispenseUsedPositions = 0;
			}
			if (aspirateData && dispenseData)
			{
				copyPattern = "";
				prevCopyPattern = "";
				//>> 20060529
				prevTipPresence = "";
				//<< 20060529
				errorLabIds.SetSize(0);
				errorPosIds.SetSize(0);
			}
		}

		static function TrackData(
			device& ML_STAR)
		{
			object tracker2;
			variable trackSize;
			variable index;
			variable instrumentName;
			variable elementName;
			variable elementVolume;
			variable templateNames[];									// place to hold template names 
			variable labwareNames[];									// place to hold labware names 
			variable labId("");											// labware id
			variable posId("");											// position id
			variable arrIndex;											// array index

			trackSize = trackLabIds.GetSize();
			if (0 < trackSize)
			{
				// get Vector Database Tracker
				tracker2 = GetVectorDbTrackerObject();

				// get instrument name
				instrumentName = ML_STAR.GetInstrumentName();

				// get labware names with associated template name
				ML_STAR.GetTemplateLabwareNames(templateNames, labwareNames);

				for (index = 0; index < trackSize; index++)
				{
					variable templateName("");
					variable errorSize;							// array size
					variable errorIndex;							// loop counter
					variable errorFound;							// indicates whether the position is already contained in the tracker data

					labId = trackLabIds.ElementAt(index);
					posId = trackPosIds.ElementAt(index);

					errorFound = hslFalse;
					errorSize = errorLabIds.GetSize();
					for (errorIndex = 0; errorIndex < errorSize; errorIndex++)
					{
						if ((errorLabIds.ElementAt(errorIndex) == labId) && (errorPosIds.ElementAt(errorIndex) == posId))
						{
							errorFound = hslTrue;
							break;
						}
					}
					if (!errorFound)
					{
						// lookup associated template name
						if (PTL_Util::Lookup(labwareNames, labId, arrIndex))
						{
							// found an associated template name
							templateName = templateNames.ElementAt(arrIndex);
							if (StringConstants::templateDefaultName == templateName)
							{
								// not really a template
								templateName = "";
							}
						}

						// setup element name
						elementName = instrumentName + "\\";
						if ("" != templateName)
							elementName = elementName + templateName + "\\" + labId + "\\" + posId;
						else 
							elementName = elementName + labId + "\\" + posId;

						#ifdef _DEBUG
						{
						variable source;
						variable action;
						source = "DEBUG";
						action = GetFunctionName();
						FormatTrace(source, action, TraceStatus::progress, "elementName = ", elementName);
						}
						#endif

						//>> 20060725
						//// get element volume 
						//elementVolume = tracker2.GetElementVolume(elementName);

						//// get element volume and set element state to 'Error'
						//tracker2.SetElementVolume(elementName, elementVolume, SampleTrackerActionState::Error);
						{
						object actionSetLabwareState;
						actionSetLabwareState.CreateObject("HXPARAMSLib.HxPars");
						actionSetLabwareState.Add(	1, tracker2.HxVectorDbParsKey_ActionPars_ActionCount);
						actionSetLabwareState.Add(	elementName,
															tracker2.HxVectorDbParsKey_ActionPars_Actions, 1, tracker2.HxVectorDbParsKey_ActionPars_Target);
						//>> 20071009 (check if labware (position) has been loaded (created))
						if (0 != tracker2.IsLabwareLoaded(elementName))
						{
						//<< 20071009
							actionSetLabwareState.Add(	tracker2.HxVectorDbLabwareHandling_IfNotExists_Error,
																tracker2.HxVectorDbParsKey_ActionPars_Actions, 1, tracker2.HxVectorDbParsKey_ActionPars_TargetLabwareHandling);
						//>> 20071009 (check if labware (position) has been loaded (created))
						}
						else
						{
							actionSetLabwareState.Add(	tracker2.HxVectorDbLabwareHandling_IfNotExists_Create,
																tracker2.HxVectorDbParsKey_ActionPars_Actions, 1, tracker2.HxVectorDbParsKey_ActionPars_TargetLabwareHandling);
						}
						//<< 20071009
						actionSetLabwareState.Add(	tracker2.HxVectorDbLabwareState_Error,
															tracker2.HxVectorDbParsKey_ActionPars_Actions, 1, tracker2.HxVectorDbParsKey_ActionPars_LabwareState);
						actionSetLabwareState.Add(	tracker2.HxVectorDbActionState_NoError ,
															tracker2.HxVectorDbParsKey_ActionPars_Actions, 1, tracker2.HxVectorDbParsKey_ActionPars_ActionState);
						actionSetLabwareState.Add(	hslFalse, 
															tracker2.HxVectorDbParsKey_ActionPars_Actions, 1, tracker2.HxVectorDbParsKey_ActionPars_ErrorAvailable);
						tracker2.TrackAction_SetLabwareState(actionSetLabwareState);
						}
						//<< 20060725
					}
				}

				// release Vector Database Tracker
				tracker2.ReleaseObject();
			}
		}

		static function BackupTrackerData()
		{
			trackLabIdsBak = trackLabIds;
			trackPosIdsBak = trackPosIds;
		}

		static function RestoreTrackerData()
		{
			variable index;
			variable size;
			size = trackLabIdsBak.GetSize();
			for (index = 0; index < size; index++)
			{
				trackLabIds.AddAsLast(trackLabIdsBak.ElementAt(index));
				trackPosIds.AddAsLast(trackPosIdsBak.ElementAt(index));
			}
		}

		static function ResetTrackerData(
			variable resetAll)
		{
			trackLabIds.SetSize(0);
			trackPosIds.SetSize(0);
			if (resetAll)
			{
				trackLabIdsBak.SetSize(0);
				trackPosIdsBak.SetSize(0);
			}
		}

		static function RestoreData(
			sequence& aspirateSequence,
			sequence& dispenseSequence,
			//>> 20060503
			variable restoreIndividualVolumes,
			variable& volumes_1[],
			variable& volumes_2[],
			//<< 20060503
			variable aspirateMultiplicity,
			variable dispenseMultiplicity,
			variable currentMultiplicity)
		{
			// if we are recovering from an error and the copy pattern option is enabled 
			// and the exclude error positions option is disabled we restore the temporarily 
			// excluded sequence positions contained in the internal data of the StepReturn 
			if (IsRecovering() && 
				 CopyPatternEnabled && 
				!ExcludeErrorPositionsEnabled)
			{
				// include excluded error positions 
				if (1 < aspirateMultiplicity && 
					 0 < currentMultiplicity && currentMultiplicity < aspirateMultiplicity)
				{
					IncludeSequencePositions(aspirateSequence,
													 restoreIndividualVolumes, volumes_1, volumes_2,
													 aspirateLabIds, aspiratePosIds, 
													 aspirateVolumes_1, aspirateVolumes_2, 
													 aspirateExcludePos, aspirateCurrentInc);
				}
				else if (0 == currentMultiplicity)
				{
					IncludeSequencePositions(aspirateSequence, 
													 restoreIndividualVolumes, volumes_1, volumes_2,
													 aspirateLabIds, aspiratePosIds, 
													 aspirateVolumes_1, aspirateVolumes_2, 
													 aspirateExcludePos, aspirateCurrentInc);
				}
				RestoreData2(dispenseSequence, 
								 restoreIndividualVolumes, volumes_1, volumes_2, 
								 dispenseMultiplicity, currentMultiplicity);
			}
		}

		static function RestoreData2(
			sequence& dispenseSequence,
			//>> 20060503
			variable restoreIndividualVolumes,
			variable& volumes_1[],
			variable& volumes_2[],
			//<< 20060503
			variable dispenseMultiplicity,
			variable currentMultiplicity)
		{
			// if we are recovering from an error and the copy pattern option is enabled 
			// and the exclude error positions option is disabled we restore the temporarily 
			// excluded sequence positions contained in the internal data of the StepReturn 
			if (IsRecovering() && 
				 CopyPatternEnabled && 
				!ExcludeErrorPositionsEnabled)
			{
				// include excluded error positions 
				if (1 < dispenseMultiplicity && 
					 0 < currentMultiplicity && currentMultiplicity < dispenseMultiplicity)
				{
					IncludeSequencePositions(dispenseSequence, 
													 restoreIndividualVolumes, volumes_1, volumes_2,
													 dispenseLabIds, dispensePosIds, 
													 dispenseVolumes_1, dispenseVolumes_2, 
													 dispenseExcludePos, dispenseCurrentInc);
				}
				else if (0 == currentMultiplicity)
				{
					IncludeSequencePositions(dispenseSequence, 
													 restoreIndividualVolumes, volumes_1, volumes_2,
													 dispenseLabIds, dispensePosIds, 
													 dispenseVolumes_1, dispenseVolumes_2, 
													 dispenseExcludePos, dispenseCurrentInc);
				}
			}
		}

		static function Dump(variable& rc[])
		{
			#ifdef _DEBUG
			variable index(0);
			variable source;
			variable action;

			source = "DEBUG";
			action = GetFunctionName();

			for (index = 0; index < rc.GetSize(); index++)
				FormatTrace(source, action, TraceStatus::progress, "rc[", index, "] = ", rc.GetAt(index));
			#endif
		}

		static function IsRecovering()
		{
			return("" != copyPattern);
		}

		//>> 20060529
		static function IsRecovering2()
		{
			return("" != copyPattern || "" != prevTipPresence);
		}
		//<< 20060529

		static function GetChannelPattern()
		{
			//>> 20060529
			//			return(copyPattern);
			if ("" == copyPattern)
			{
				return(prevTipPresence);
			}
			else if ("" == prevTipPresence)
			{
				return(copyPattern);
			}
			else
			{
				variable index(0);				// loop index
				variable length(0);				// string length
				variable xorPattern("");		// xor pattern

				// iterate over channels
				length = PTL_Util::Min(StrGetLength(copyPattern), StrGetLength(prevTipPresence));
				for (index = 0; index < length; index++)
				{
					if ("0" == StrMid(prevTipPresence, index, 1))
						xorPattern = xorPattern + "0";
					else
						xorPattern = xorPattern + StrMid(copyPattern, index, 1);
				}
				return(xorPattern);
			}
			//<< 20060529
		}

		static function GetPrevChannelPattern()
		{
			return(prevCopyPattern);
		}

		static function XorChannelPattern(
			string& channelPattern)
		{
			variable index(0);				// loop index
			variable length(0);				// string length
			variable xorPattern("");		// xor pattern
			string   cpyPattern;				// copy pattern

			// iterate over channels
			cpyPattern = copyPattern;
			length = PTL_Util::Min(channelPattern.GetLength(), cpyPattern.GetLength());
			for (index = 0; index < length; index++)
			{
				if ("1" == channelPattern.Mid(index, 1) && "0" == cpyPattern.Mid(index, 1))
					xorPattern = xorPattern + "1";
				else
					xorPattern = xorPattern + "0";
			}
			return(xorPattern);
		}

		static function GetUsedPos(
			variable stepType)
		{
			if (StepType::aspirate == stepType)
				return(aspirateUsedPositions);
			if (StepType::dispense == stepType)
				return(dispenseUsedPositions);
			return(0);
		}

		static function SetUsedPos(
			variable stepType,
			variable usedPositions)
		{
			if (StepType::aspirate == stepType)
				aspirateUsedPositions = usedPositions;
			if (StepType::dispense == stepType)
				dispenseUsedPositions = usedPositions;
			#ifdef _DEBUG
			{
			variable source;
			variable action;
			source = "DEBUG";
			action = GetFunctionName();
			FormatTrace(source, action, TraceStatus::progress, "aspirateUsedPositions = ", aspirateUsedPositions);
			FormatTrace(source, action, TraceStatus::progress, "dispenseUsedPositions = ", dispenseUsedPositions);
			}
			#endif
		}

		static function PropagateExcludedPositions(
			sequence& pipSequence,
			string& channelPattern,
			variable stepType)
		{
			// check if error positions should be excluded temporarily
			if (CopyPatternEnabled && IsRecovering())
			{
				// exclude error positions temporarily
				variable index(0);					// loop index
				variable length(0);					// string length
				variable startPos(0);				// position where to start exclusion
				string xorPattern("");				// failed channels (xor combination of channelPattern and StepReturn::copyPattern)
				variable activeChannel(0);			// active channel number

				// unrecoverable error on channels which are active in xorPattern
				xorPattern = XorChannelPattern(channelPattern);

				// iterate over failed channels
				length = channelPattern.GetLength();
				for (index = 0; index < length; index++)
				{
					if ("1" == channelPattern.Mid(index, 1))
					{
						// channel is active
						if ("1" == xorPattern.Mid(index, 1))
						{
							// channel has an error
							variable currentPosBak;			// backup of current position of sequence

							// backup of current position of sequence
							currentPosBak = pipSequence.GetCurrentPosition();

							// store labware and position ids of aspirate sequence
							pipSequence.SetCurrentPosition(currentPosBak + activeChannel);
							if (StepType::aspirate == stepType)
							{
								aspirateLabIds.AddAsLast(pipSequence.GetLabwareId());
								aspiratePosIds.AddAsLast(pipSequence.GetPositionId());
							}
							if (StepType::dispense == stepType)
							{
								dispenseLabIds.AddAsLast(pipSequence.GetLabwareId());
								dispensePosIds.AddAsLast(pipSequence.GetPositionId());
							}

							// restore current position of aspirate sequence
							pipSequence.SetCurrentPosition(currentPosBak);
						}

						// increment active channel number
						activeChannel++;
					}
				}

				if (StepType::aspirate == stepType)
				{
					// check if error positions should be excluded persistently
					if (ExcludeErrorPositionsEnabled)
					{
						variable volumes[];

						PersistExcludedPositions(AspirateSequence, pipSequence, 0, volumes, volumes, stepType, hslTrue);
					}
					else
					{
						variable volumes[];

						// exclude error positions temporarily from the sequence
						startPos = pipSequence.GetCurrentPosition();
						ExcludeSequencePositions(pipSequence, 
														 0, volumes, volumes, 
														 startPos, 0,
														 aspirateLabIds, aspiratePosIds, 
														 volumes, volumes,
														 aspirateExcludePos, aspirateCurrentInc,
														 trackLabIds, trackPosIds);
					}
				}
				if (StepType::dispense == stepType)
				{
					// check if error positions should be excluded persistently
					if (ExcludeErrorPositionsEnabled)
					{
						variable volumes[];

						PersistExcludedPositions(DispenseSequence, pipSequence, 0, volumes, volumes, stepType, hslTrue);
					}
					else
					{
						variable volumes[];

						// exclude error positions temporarily from the sequence
						startPos = pipSequence.GetCurrentPosition();
						ExcludeSequencePositions(pipSequence, 
														 0, volumes, volumes, 
														 startPos, 0,
														 dispenseLabIds, dispensePosIds, 
														 volumes, volumes,
														 dispenseExcludePos, dispenseCurrentInc,
														 trackLabIds, trackPosIds);
					}
				}

				// dump internal state of StepReturn
				#ifdef _DEBUG
				DumpData();
				#endif
			}
		}

		static function PersistExcludedPositions(
			sequence& orgSequence,
			sequence& actSequence,
			//>> 20060503
			variable excludeIndividualVolumes,
			variable& individualVolumes_1[],
			variable& individualVolumes_2[],
			//<< 20060503
			variable stepType,
			variable setUsed)
		{
			variable startPos(0);			// position where to start exclusion
			variable orgCurrent;				// current of original sequence
			variable orgCount;				// count of original sequence
			variable actCurrent;				// current of actual sequence
			variable actCount;				// count of actual sequence
			string xorPattern("");			// failed channels (xor combination of channelPattern and StepReturn::copyPattern)

			// backup current and count of actual and original dispense sequences
			orgCurrent = orgSequence.GetCurrentPosition();
			orgCount = orgSequence.GetCount();
			actCurrent = actSequence.GetCurrentPosition();
			actCount = actSequence.GetCount();

			// map current position from actual sequence to original sequence 
			SequenceFinalization::CurrentToFinal(orgSequence, 
															 orgCurrent, actCurrent, 
															 orgCount, actCount);

			// exclude error positions persistently from original sequence 
			startPos = orgSequence.GetCurrentPosition();
			if (StepType::aspirate == stepType)
			{
				variable trackLabIdsLoc[];								// place to hold labware ids of positions to be tracked as erroneous
				variable trackPosIdsLoc[];								// place to hold position ids of positions to be tracked as erroneous
				variable volumes[];

				ExcludeSequencePositions(orgSequence, 
												 0, volumes, volumes, 
												 startPos, 0,
												 aspirateLabIds, aspiratePosIds, 
												 volumes, volumes, 
												 aspirateExcludePos, aspirateCurrentInc,
												 trackLabIdsLoc, trackPosIdsLoc);
			}
			if (StepType::dispense == stepType)
			{
				variable trackLabIdsLoc[];								// place to hold labware ids of positions to be tracked as erroneous
				variable trackPosIdsLoc[];								// place to hold position ids of positions to be tracked as erroneous
				variable volumes[];

				ExcludeSequencePositions(orgSequence, 
												 0, volumes, volumes, 
												 startPos, 0,
												 dispenseLabIds, dispensePosIds, 
												 volumes, volumes, 
												 dispenseExcludePos, dispenseCurrentInc,
												 trackLabIdsLoc, trackPosIdsLoc);
			}

			// restore current position of original sequence
			orgSequence.SetCurrentPosition(orgCurrent);

			// exclude error positions persistently from actual sequence 
			startPos = actSequence.GetCurrentPosition();
			if (StepType::aspirate == stepType)
			{
				aspirateExcludePos.SetSize(0);
				aspirateCurrentInc.SetSize(0);
				ExcludeSequencePositions(actSequence, 
												 excludeIndividualVolumes, individualVolumes_1, individualVolumes_2,
												 startPos, AspirateSequenceCurrentAlignPos,
												 aspirateLabIds, aspiratePosIds, 
												 aspirateVolumes_1, aspirateVolumes_2, 
												 aspirateExcludePos, aspirateCurrentInc,
												 trackLabIds, trackPosIds);
			}
			if (StepType::dispense == stepType)
			{
				dispenseExcludePos.SetSize(0);
				dispenseCurrentInc.SetSize(0);
				ExcludeSequencePositions(actSequence, 
												 excludeIndividualVolumes, individualVolumes_1, individualVolumes_2,
												 startPos, DispenseSequenceCurrentAlignPos,
												 dispenseLabIds, dispensePosIds, 
												 dispenseVolumes_1, dispenseVolumes_2, 
												 dispenseExcludePos, dispenseCurrentInc,
												 trackLabIds, trackPosIds);
			}

			// propagate the correction of the used positions of a sequence 
			// if an error occured and copy pattern has been enabled
			if (StepType::aspirate == stepType && setUsed)
			{
				string channelPattern; 

				// set the channel pattern
				channelPattern = GetPrevChannelPattern();
				if (channelPattern.GetLength() == 0)
					// we are not recovering from an error
					channelPattern = AspirateChannelVariable;

				xorPattern = XorChannelPattern(channelPattern);
				SetUsedPos(StepType::aspirate, GetUsedPos(StepType::aspirate) - NumberOfActiveChannels(xorPattern));
			}
			if (StepType::dispense == stepType && setUsed)
			{
				string channelPattern; 

				// set the channel pattern
				channelPattern = GetPrevChannelPattern();
				if (channelPattern.GetLength() == 0)
					// we are not recovering from an error
					channelPattern = DispenseChannelVariable;

				xorPattern = XorChannelPattern(channelPattern);
				SetUsedPos(StepType::dispense, GetUsedPos(StepType::dispense) - NumberOfActiveChannels(xorPattern));
			}
		}

		static function AlignExcludedPositions(
			sequence& aspirateSequence,
			sequence& dispenseSequence,
			variable aspirateMultiplicity,
			variable dispenseMultiplicity,
			variable drivingMode)
		{
			variable aspirateCurrentBak;				// backup of current of actual aspirate sequence
			variable aspirateCountBak;					// backup of count of actual aspirate sequence
			variable dispenseCurrentBak;				// backup of current of actual dispense sequence
			variable dispenseCountBak;					// backup of count of actual dispense sequence
			sequence AspirateSequenceBak;				// backup of original aspirate sequence
			sequence DispenseSequenceBak;				// backup of original dispense sequence

			// backup current and count of actual aspirate and dispense sequences
			aspirateCountBak = aspirateSequence.GetCount();
			dispenseCountBak = dispenseSequence.GetCount();
			aspirateCurrentBak = aspirateSequence.GetCurrentPosition();
			dispenseCurrentBak = dispenseSequence.GetCurrentPosition();

			// set current and count of actual aspirate and dispense sequences 
			aspirateSequence.SetCurrentPosition(AspirateSequence.GetCurrentPosition());
			dispenseSequence.SetCurrentPosition(DispenseSequence.GetCurrentPosition());
			if (aspirateSequence.GetCount() < AspirateSequence.GetCount())
				// the aspirate sequence has been reduced, 
				// restore the original count
				aspirateSequence.SetCount(AspirateSequence.GetCount());
			if (dispenseSequence.GetCount() < DispenseSequence.GetCount())
				// the dispense sequence has been reduced,
				// restore the original count
				dispenseSequence.SetCount(DispenseSequence.GetCount());

			// backup original aspirate and dispense sequences
			AspirateSequenceBak = AspirateSequence;
			DispenseSequenceBak = DispenseSequence;

			// fake new original aspirate and dispense sequences
			AspirateSequence = aspirateSequence;
			DispenseSequence = dispenseSequence;

			// align pipetting sequence counts
			PCB::AlignSequenceCounts(aspirateSequence, dispenseSequence, 
									 aspirateMultiplicity, dispenseMultiplicity, drivingMode, hslTrue);

			// restore original aspirate and dispense sequences
			AspirateSequence = AspirateSequenceBak;
			DispenseSequence = DispenseSequenceBak;

			// restore current of actual aspirate and dispense sequences
			aspirateSequence.SetCurrentPosition(aspirateCurrentBak);
			dispenseSequence.SetCurrentPosition(dispenseCurrentBak);
		}

		static function HandleError(
			device& ML_STAR,
			sequence& tipPickupSequence,
			variable isWashSequence,
			variable stepType,
			variable propagate)
		{
			variable rc[];										// step return array 

			if (StepType::aspirate == stepType || StepType::dispense == stepType)
			{
				string xorPattern("");						// failed channels (xor combination of channelPattern and StepReturn::copyPattern)
				variable copyCount(0);						// number of positions to copy
				variable usedPositions(0);					// number of used positions 
				sequence reverseTipPickupSequence;		// place to hold reverses order of positions of the tip pickup sequence
				string channelPattern("");					// channel pattern that was used to execute the step that failed
				variable canceledByTheUser(hslFalse);	// indicates whether an error recovery has been canceled by the user

				// propagate the correction of the used positions of a sequence 
				// if an error occured and copy pattern has been enabled
				xorPattern = XorChannelPattern(AspirateChannelVariable);
				if (CopyPatternEnabled && !ExcludeErrorPositionsEnabled)
				{
					if (propagate)
						SetUsedPos(StepType::dispense, NumberOfActiveChannels(xorPattern));
				}

				// set the channel pattern
				channelPattern = GetPrevChannelPattern();
				if (channelPattern.GetLength() == 0)
				{
					// we are not recovering from an error
					if (StepType::aspirate == stepType)
						channelPattern = AspirateChannelVariable;
					else
						channelPattern = DispenseChannelVariable;
				}
				xorPattern = XorChannelPattern(channelPattern);

				if (!isWashSequence)
				{
					// debug
					#ifdef _DEBUG
					FormatTrace("DEBUG", "ML_STAR.TipEject", TraceStatus::progress,
									"name = ", TipEjectWasteDestination.GetName(), 
									", current = ", TipEjectWasteDestination.GetCurrentPosition(), 
									", count = ", TipEjectWasteDestination.GetCount(),
									", maxPos = ", TipEjectWasteDestination.GetMax());
					#endif

					// eject tip from channels which are active in xorPattern
					Empty(rc);
					onerror goto TipEjectErrorHandler;
					rc = MlStarSteps::StepTipEject_cer(ML_STAR,
														TipEjectUseDefaultWaste,
														TipEjectWasteDestination,
														TipEjectSequenceCounting,
														xorPattern,
														TipEjectChannelUse,
														//ErrorHandling,
                                          ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, TipEjectCustomStepID),
                                          TipEjectCustomStepID,
														UserResponseTime);
					onerror goto 0;
					if (!Evaluate(ML_STAR, rc, ErrorHandling))
						Error::RaiseLast();
					Empty(rc);

					// pickup tip on channels which are active in xorPattern

					// Remark:
					// To keep the shape of the tip pickup sequence optimal if tips have been used 
					// to calibrate carriers or are used in the error handling, the tip pickup sequence 
					// is fully reversed. TipPickupReverseSequenceCount + 1 positions are copied 
					// in reverse order from the end of the original tip pickup sequence.

					// reverse tip pickup sequence
					ReverseSequence(tipPickupSequence, reverseTipPickupSequence, 
										 tipPickupSequence.GetCurrentPosition(), copyCount, TipPickupReverseSequenceCount + 1);

					// debug
					#ifdef _DEBUG
					FormatTrace("DEBUG", "ML_STAR.TipPickUp", TraceStatus::progress,
									"name = ", tipPickupSequence.GetName(), 
									", current = ", tipPickupSequence.GetCurrentPosition(), 
									", count = ", tipPickupSequence.GetCount(),
									", maxPos = ", tipPickupSequence.GetMax()); 
					#endif
					
					// pickup new tips (from reverseTipPickupSequence)
					//>> 20060519
					if (ErrorHandling == ErrorHandling::continue)
					{
						ExcludeRecoveryOptionEnabled = hslFalse;
					}
					//<< 20060519
					onerror goto TipPickupErrorHandler;
					rc = MlStarSteps::StepTipPickup_cer(ML_STAR,
														reverseTipPickupSequence,
														TipPickupSequenceCounting,
														xorPattern,
														TipPickupChannelUse,
														//>> 20060519
														//ErrorHandling,
														PCB::MapErrorHandlingContinue(ErrorHandling, TipPickupCustomStepID),
														//<< 20060519
                                          TipPickupCustomStepID,
														UserResponseTime);
					onerror goto 0;
					//>> 20060519
					if (ErrorHandling == ErrorHandling::continue)
					{
						ExcludeRecoveryOptionEnabled = hslTrue;
					}
					//<< 20060519
					if (!Evaluate(ML_STAR, rc, ErrorHandling))
						canceledByTheUser = hslTrue;
					Empty(rc);

					// increment tip pickup sequence 
					if (SequenceCounting::manually == TipPickupSequenceCounting)
						// manual sequence counting
						tipPickupSequence.Increment(copyCount);

					// get number of used positions and update the count of the tip pickup sequence
					usedPositions = reverseTipPickupSequence.GetUsedPositions();
					if (copyCount < usedPositions)
						tipPickupSequence.SetCount(tipPickupSequence.GetCount() - usedPositions + copyCount);

					// if tip counting is enabled, write indexes of tipPickupSequence to file
					if (TipCountingEnabled)
						TipCount::Write2(tipPickupSequence, TipCountingIdentifier, ML_STAR);

					// check if an error recovery has been canceled by the user
					if (canceledByTheUser)
						// re-throw error
						Error::RaiseLast();
				}
				else
				{
					// set the washing state to eject needles
					// (the ErrorHandling and UserResponseTime has already been set)
					SetWashingState(ML_STAR, tipPickupSequence, "NeedleEjectChannelVariable", xorPattern, 1);
					onerror goto NeedleEjectErrorHandler;
					rc = WCB::NeedleEject(ML_STAR, tipPickupSequence, hslTrue);
					onerror goto 0;
					//ba 2004-01-26 begin
					if (!Evaluate(ML_STAR, rc, ErrorHandling))
						Error::RaiseLast();
					//end

					// decrement the positions, that the previous needle eject step has incrmented,
					// so that we pickup the same needles
					tipPickupSequence.SetCurrentPosition(tipPickupSequence.GetCurrentPosition() - tipPickupSequence.GetUsedPositions());

					// set the washing state to pickup needles
					// (the ErrorHandling and UserResponseTime has already be set)
					SetWashingState(ML_STAR, tipPickupSequence, "NeedlePickupChannelVariable", xorPattern, 1);
					onerror goto NeedlePickupErrorHandler;
					rc = WCB::NeedlePickup(ML_STAR, tipPickupSequence, hslFalse);
					onerror goto 0;
					//ba 2004-01-26 begin
					if (!Evaluate(ML_STAR, rc, ErrorHandling))
						Error::RaiseLast();
					//end
				}
			}
			return(rc);

			TipEjectErrorHandler:
			{
				// bind error data
				StepReturn::Bind(rc);
				resume next;
			}

			TipPickupErrorHandler:
			{
				// bind error data
				StepReturn::Bind(rc);
				resume next;
			}

			NeedleEjectErrorHandler:
			{
				// bind error data
				StepReturn::Bind(rc);
				resume next;
			}

			NeedlePickupErrorHandler:
			{
				// bind error data
				StepReturn::Bind(rc);
				resume next;
			}
		}

		static function DumpData()
		{
			#ifdef _DEBUG
			variable index(0);
			variable source;
			variable action;

			source = "DEBUG";
			action = GetFunctionName();

			FormatTrace(source, action, TraceStatus::progress, "aspirate");
			for (index = 0; index < aspirateExcludePos.GetSize(); index++)
				FormatTrace(source, action, TraceStatus::progress, aspirateLabIds.GetAt(index), ", ", aspiratePosIds.GetAt(index), ", ", aspirateExcludePos.GetAt(index), ", ", aspirateCurrentInc.GetAt(index));
			FormatTrace(source, action, TraceStatus::progress, "dispense");
			for (index = 0; index < dispenseExcludePos.GetSize(); index++)
				FormatTrace(source, action, TraceStatus::progress, dispenseLabIds.GetAt(index), ", ", dispensePosIds.GetAt(index), ", ", dispenseExcludePos.GetAt(index), ", ", dispenseCurrentInc.GetAt(index));
			FormatTrace(source, action, TraceStatus::progress, "tracker data");
			for (index = 0; index < trackLabIds.GetSize(); index++)
				FormatTrace(source, action, TraceStatus::progress, trackLabIds.GetAt(index), ", ", trackPosIds.GetAt(index));
			FormatTrace(source, action, TraceStatus::progress, "error data");
			for (index = 0; index < errorLabIds.GetSize(); index++)
				FormatTrace(source, action, TraceStatus::progress, errorLabIds.GetAt(index), ", ", errorPosIds.GetAt(index));
			FormatTrace(source, action, TraceStatus::progress, "copyPattern = ", copyPattern);
			FormatTrace(source, action, TraceStatus::progress, "prevCopyPattern = ", prevCopyPattern);
			#endif
		}
	}

	static function ErrorHandling::AsString(variable errorHandling)
	{
		// switch over ErrorHandling entries
		if (errorHandling == ErrorHandling::abort_)
			return("abort");
		if (errorHandling == ErrorHandling::cancel)
			return("cancel");
		if (errorHandling == ErrorHandling::continue)
			return("continue");
		if (errorHandling == ErrorHandling::custom)
			return("custom");

		// unknown error handling
		Error::Raise(IDE::invalidErrorHandling, GetFileName(), GetFunctionName(), GetLineNumber());

		return("");
	}


   static function ErrorHandling::MapCustomStepErrorHandling(variable errorHandling, variable customStepID)
   {
      variable mappedErrorHandling(errorHandling);

      if(ErrorHandling::custom == errorHandling)
      {  
         // custom error handling defined, switch over pre-defined ErrorHandling options
         if(CustomStepID::stepErrorHandlingAbort == customStepID)
            mappedErrorHandling = ErrorHandling::abort_;
         if(CustomStepID::stepErrorHandlingAbortCancel == customStepID)
            mappedErrorHandling = ErrorHandling::cancel;
         if(CustomStepID::stepErrorHandlingDefault == customStepID)
            mappedErrorHandling = ErrorHandling::continue;
      }

		#ifdef _DEBUG
		FormatTrace("DEBUG", "ErrorHandling::MapCustomStepErrorHandling", TraceStatus::progress,
						"errorHandling = ", ErrorHandling::AsString(errorHandling), 
						", customStepID = ", customStepID,
                  ", mappedErrorHandling = ", ErrorHandling::AsString(mappedErrorHandling));
		#endif

      return (mappedErrorHandling);
   }


	static function DrivingMode::AsString(variable drivingMode)
	{
		// switch over DrivingMode entries
		if (drivingMode == DrivingMode::aspirateDriven)
			return("aspirateDriven");
		if (drivingMode == DrivingMode::dispenseDriven)
			return("dispenseDriven");
		if (drivingMode == DrivingMode::undefined)
			return("undefined");

		// unknown driving mode
		Error::Raise(IDE::invalidDrivingMode, GetFileName(), GetFunctionName(), GetLineNumber());

		return("");
	}

	static function RestVolumeDestination::AsString(variable restVolumeDestination)
	{
		// switch over RestVolumeDestination entries
		if (restVolumeDestination == RestVolumeDestination::aspirate)
			return("aspirate");
		if (restVolumeDestination == RestVolumeDestination::waste)
			return("waste");

		// unknown driving mode
		Error::Raise(IDE::invalidRestVolumeDestination, GetFileName(), GetFunctionName(), GetLineNumber());

		return("");
	}

	static function SequenceCounting::AsString(variable sequenceCounting)
	{
		// switch over SequenceCounting entries
		if (sequenceCounting == SequenceCounting::manually)
			return("manually");
		if (sequenceCounting == SequenceCounting::automatic)
			return("automatic");

		// unknown driving mode
		Error::Raise(IDE::invalidSequenceCounting, GetFileName(), GetFunctionName(), GetLineNumber());

		return("");
	}

	static function ChannelUse::AsString(variable channelUse)
	{
		// switch over ChannelUse entries
		if (channelUse == ChannelUse::allSequencePositions)
			return("allSequencePositions");
		if (channelUse == ChannelUse::channelPattern)
			return("channelPattern");

		// unknown driving mode
		Error::Raise(IDE::invalidChannelUse, GetFileName(), GetFunctionName(), GetLineNumber());

		return("");
	}

	static function AspirateMode::AsString(variable aspirateMode)
	{
		// switch over AspirateMode entries
		if (aspirateMode == AspirateMode::aspiration)
			return("aspiration");
		if (aspirateMode == AspirateMode::consecutiveAspiration)
			return("consecutiveAspiration");
		if (aspirateMode == AspirateMode::emptyCupAspiration)
			return("emptyCupAspiration");

		// unknown driving mode
		Error::Raise(IDE::invalidAspirateMode, GetFileName(), GetFunctionName(), GetLineNumber());

		return("");
	}

	static function DispenseMode::AsString(variable dispenseMode)
	{
		// switch over DispenseMode entries
		if (dispenseMode == DispenseMode::jet || dispenseMode == DispenseMode::jet_)
			return("Jet");
		if (dispenseMode == DispenseMode::surface || dispenseMode == DispenseMode::surface_)
			return("Surface");

		// unknown driving mode
		Error::Raise(IDE::invalidDispenseMode, GetFileName(), GetFunctionName(), GetLineNumber());

		return("");
	}

	static function StarDispenseMode::AsString(variable starDispenseMode)
	{
		// switch over StarDispenseMode entries
		if (starDispenseMode == StarDispenseMode::jetPartVolume)
			return("jetModePartVolume");
		if (starDispenseMode == StarDispenseMode::jetEmptyTip)
			return("jetModeEmptyTip");
		if (starDispenseMode == StarDispenseMode::surfacePartVolume)
			return("surfaceDispensePartVolume");
		if (starDispenseMode == StarDispenseMode::surfaceEmptyTip)
			return("surfaceDispenseEmptyTip");
		if (starDispenseMode == StarDispenseMode::blowoutTip)
			return("blowoutTip");

		// unknown driving mode
		Error::Raise(IDE::invalidDispenseMode, GetFileName(), GetFunctionName(), GetLineNumber());

		return("");
	}

	static function LLDSensitivity::AsString(variable lldSensitivity)
	{
		// switch over LLDSensitivity entries
		if (lldSensitivity == LLDSensitivity::off)
			return("off");
		if (lldSensitivity == LLDSensitivity::veryHigh)
			return("veryHigh");
		if (lldSensitivity == LLDSensitivity::high)
			return("high");
		if (lldSensitivity == LLDSensitivity::middle)
			return("middle");
		if (lldSensitivity == LLDSensitivity::low)
			return("low");
		if (lldSensitivity == LLDSensitivity::fromLabwareDefinition)
			return("fromLabwareDefinition");

		// unknown driving mode
		Error::Raise(IDE::invalidLLDSensitivity, GetFileName(), GetFunctionName(), GetLineNumber());

		return("");
	}

	static function SequenceInitialization::AsString(variable initialization)
	{
		// switch over SequenceInitialization entries
		if (initialization == SequenceInitialization::none)
			return("none");
		if (initialization == SequenceInitialization::reset)
			return("reset");
		if (0 <= initialization)
			return(IStr(initialization));

		// unknown sequence initialization
		Error::Raise(IDE::invalidInitialization, GetFileName(), GetFunctionName(), GetLineNumber());

		return("");
	}

	static function SequenceFinalization::AsString(variable finalization)
	{
		// switch over SequenceFinalization entries
		if (finalization == SequenceFinalization::none)
			return("none");
		if (finalization == SequenceFinalization::reset)
			return("reset");
		if (finalization == SequenceFinalization::initial)
			return("initial");
		if (finalization == SequenceFinalization::final)
			return("final");
		if (0 <= finalization)
			return(IStr(finalization));

		// unknown sequence finalization
		Error::Raise(IDE::invalidFinalization, GetFileName(), GetFunctionName(), GetLineNumber());

		return("");
	}

	static function SequenceFinalization::CurrentToNone(
		sequence& pipSequence,
		variable orgCurrent,
		variable actCurrent,
		variable orgCount,
		variable actCount)
	{
		variable module(0);
		variable interval(0);

		// map current of actual sequence to original sequence
		if (0 < orgCurrent)
		{
			module = orgCount - orgCurrent + 1;
			if (0 < actCurrent)
				interval = actCurrent - orgCurrent;
			else
				interval = actCount - orgCurrent + 1;
		}
		if (0 < interval && 0 < module)
		{
			if (0 < (interval % module))
				pipSequence.SetCurrentPosition(orgCurrent + (interval % module));
			else
				pipSequence.SetCurrentPosition(0);
		}

		#ifdef _DEBUG
		{
		variable source;
		variable action;
		source = "DEBUG";
		action = GetFunctionName();
		FormatTrace(source, action, TraceStatus::progress, "pipSequence.name = ", pipSequence.GetName());
		FormatTrace(source, action, TraceStatus::progress, "orgCurrent = ", orgCurrent);
		FormatTrace(source, action, TraceStatus::progress, "actCurrent = ", actCurrent);
		FormatTrace(source, action, TraceStatus::progress, "orgCount = ", orgCount);
		FormatTrace(source, action, TraceStatus::progress, "actCount = ", actCount);
		FormatTrace(source, action, TraceStatus::progress, "module = ", module);
		FormatTrace(source, action, TraceStatus::progress, "interval = ", interval);
		FormatTrace(source, action, TraceStatus::progress, "pipSequence.current = ", pipSequence.GetCurrentPosition());
		}
		#endif
	}

	static function SequenceFinalization::CurrentToFinal(
		sequence& pipSequence,
		variable orgCurrent,
		variable actCurrent,
		variable orgCount,
		variable actCount)
	{
		variable module(0);
		variable interval(0);

		// map count of actual sequence to original sequence
		if (0 < orgCurrent)
		{
			module = orgCount - orgCurrent + 1;
			if (0 < actCurrent)
				interval = actCurrent - orgCurrent;
			else
				interval = actCount - orgCurrent + 1;
		}
		if (0 < interval && 0 < module)
		{
			if (0 < (interval % module))
				pipSequence.SetCurrentPosition(orgCurrent + (interval % module));
			else
				pipSequence.SetCurrentPosition(0);
		}

		#ifdef _DEBUG
		{
		variable source;
		variable action;
		source = "DEBUG";
		action = GetFunctionName();
		FormatTrace(source, action, TraceStatus::progress, "pipSequence.name = ", pipSequence.GetName());
		FormatTrace(source, action, TraceStatus::progress, "orgCurrent = ", orgCurrent);
		FormatTrace(source, action, TraceStatus::progress, "actCurrent = ", actCurrent);
		FormatTrace(source, action, TraceStatus::progress, "orgCount = ", orgCount);
		FormatTrace(source, action, TraceStatus::progress, "actCount = ", actCount);
		FormatTrace(source, action, TraceStatus::progress, "module = ", module);
		FormatTrace(source, action, TraceStatus::progress, "interval = ", interval);
		FormatTrace(source, action, TraceStatus::progress, "pipSequence.current = ", pipSequence.GetCurrentPosition());
		}
		#endif
	}


	static function SequenceFinalization::CountToFinal(
		sequence& pipSequence,
		variable orgCurrent,
		variable actCurrent,
		variable orgCount,
		variable actCount)
	{
		variable module(0);
		variable interval(0);

		if ( actCount <= orgCount )
		{	
			// 2009-05-27/cj: Added if no reuse has been done.
			// no inserting/reuse of positions has been done
			// keep the actual count
			pipSequence.SetCount(actCount);
		}
		else
		{
			if  ( 0 < actCurrent && actCurrent <= orgCount )
			{
				// 2009-05-27/cj: sequence has been enlarged but this positions has not been used (e.g. t1057a)
				pipSequence.SetCount(actCurrent-1);
			}
			else
			{
				// map count of actual sequence to original sequence
				if (0 < orgCurrent)
					module = orgCount - orgCurrent + 1;
				interval = actCount - orgCount;
				if (0 < interval && 0 < module)
					if (0 < (interval % module))
						pipSequence.SetCount(orgCurrent + (interval % module) - 1);
			}
		}

		#ifdef _DEBUG
		{
		variable source;
		variable action;
		source = "DEBUG";
		action = GetFunctionName();
		FormatTrace(source, action, TraceStatus::progress, "pipSequence.name = ", pipSequence.GetName());
		FormatTrace(source, action, TraceStatus::progress, "orgCurrent = ", orgCurrent);
		FormatTrace(source, action, TraceStatus::progress, "actCurrent = ", actCurrent);
		FormatTrace(source, action, TraceStatus::progress, "orgCount = ", orgCount);
		FormatTrace(source, action, TraceStatus::progress, "actCount = ", actCount);
		FormatTrace(source, action, TraceStatus::progress, "module = ", module);
		FormatTrace(source, action, TraceStatus::progress, "interval = ", interval);
		FormatTrace(source, action, TraceStatus::progress, "pipSequence.count = ", pipSequence.GetCount());
		}
		#endif
	}

	static function InitPipettingLibrary()
	{
		// initialize the pipetting library once only
		if (!initializedLib)
		{
			//>> 20060913 (workaround for an old nasty string table file 'HSLPTLStringTableEnu.hs_' that 
			// occasionally gets imported from a mehtod package into the Methods directory)
			variable myDirectory("");
			myDirectory = GetFileName();
			myDirectory = StrLeft(myDirectory, StrReverseFind(myDirectory, "\\") + 1);
			StringTable::Init(myDirectory + "HSLPTLStringTable");
			//StringTable::Init("HSLPTLStringTable");
			//<< 20060913
			#ifdef _DEBUG
			//StringTable::Dump();
			#endif
			PCB::Inner::Init("");
			LCB::Init();
			UCB::Init();
			//WCB::Init(ML_STAR, washSequence); // unfortunately ML_STAR and washSequence are unknown
			TCB::Init();
			if (0 == ptlCs)
				ptlCs = SynInitializeCriticalSection();

			if (ptlScriptControl.IsNull())
			{
				ptlScriptControl.CreateObject("MSScriptControl.ScriptControl");
				ptlScriptControl.Language = "VBScript";
			}

			// Create and initialize some object-members
			{
				object objTemp;

				// Init TipVolume::objHxStarLiquid to IHxCoreLiquidClass
				if ( 0 == objTemp.CreateObject("Hamilton.HxCoreLiquidClass") )
				{
					variable errorDesc;
					errorDesc = StringTable::Load(IDE::createObjectFailed);
					StrReplace(errorDesc, "%s", "Hamilton.HxCoreLiquidClass");
					Error::RaiseEx(IDE::createObjectFailed, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				}
				if ( 0 == objTemp.GetObject("IHxCoreLiquidClass", TipVolume::objHxStarLiquid) )
				{
					variable errorDesc;
					errorDesc = StringTable::Load(IDE::queryInterfaceFailed);
					StrReplace(errorDesc, "%s", "IHxCoreLiquidClass");
					Error::RaiseEx(IDE::queryInterfaceFailed, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				}
				objTemp.ReleaseObject();
				// Init with the static instrument class - is valid for all Ml Star's
				TipVolume::objHxStarLiquid.InitCoreLiquidClass(StringConstants::mlStarInstrumentKey);

				// Init TipType::objHxStarTipTypes to IHxStarTipTypes
				if ( 0 == objTemp.CreateObject("Hamilton.HxCoreTipTypes") )
				{
					variable errorDesc;
					errorDesc = StringTable::Load(IDE::createObjectFailed);
					StrReplace(errorDesc, "%s", "Hamilton.HxCoreTipTypes");
					Error::RaiseEx(IDE::createObjectFailed, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				}
				// QI to "IHxCoreTipTypes"
				if ( 0 == objTemp.GetObject2("{88032E6A-09E6-49D6-B947-14AC5785BC8D}", TipType::objHxStarTipTypes) )
				{
					variable errorDesc;
					errorDesc = StringTable::Load(IDE::queryInterfaceFailed);
					StrReplace(errorDesc, "%s", "IHxCoreTipTypes");
					Error::RaiseEx(IDE::queryInterfaceFailed, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				}
				objTemp.ReleaseObject();
				// Init with the static instrument class - is valid for all Ml Star's
				TipType::objHxStarTipTypes.SetInstrumentClass(StringConstants::mlStarInstrumentKey);

				// Init PTL_Util::objHxServicesGeneralSettings2 to IHxServicesGeneralSettings2
				if ( 0 == objTemp.CreateObject("Hamilton.HxServicesGeneralSettings") )
				{
					variable errorDesc;
					errorDesc = StringTable::Load(IDE::createObjectFailed);
					StrReplace(errorDesc, "%s", "Hamilton.HxServicesGeneralSettings");
					Error::RaiseEx(IDE::createObjectFailed, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				}
				// QI to "IHxServicesGeneralSettings2"
				if ( 0 == objTemp.GetObject2("{F02C0FA4-ABC8-457B-88D1-31CD24C1C399}", PTL_Util::objHxServicesGeneralSettings2) )
				{
					variable errorDesc;
					errorDesc = StringTable::Load(IDE::queryInterfaceFailed);
					StrReplace(errorDesc, "%s", "IHxServicesGeneralSettings2");
					Error::RaiseEx(IDE::queryInterfaceFailed, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				}
				objTemp.ReleaseObject();
			}

			initializedLib = hslTrue;
		}
		return(initializedLib);
	}

	static function InitPipettingDevice(
		device& ML_STAR,
		variable errorHandling,
      variable initCustomStepID)
	{
		variable rc[];																		// step return 
		
		// initialize the pipetting device once only
		if (InitializeEnabled && TipPickupEnabled)
		{
			variable instrumentName;													// instrument name 
			variable arrIndex;															// an array index

			// activate error handler
			onerror goto Unexpected;

			// get access to global data
			SynEnterCriticalSection(ptlCs);

         errorHandling = ErrorHandling::MapCustomStepErrorHandling(errorHandling, initCustomStepID);

			// check if the instrument has already been initialized
			instrumentName = ML_STAR.GetInstrumentName();
			if (!PTL_Util::Lookup(ptlInitializedPipettingDevices, instrumentName, arrIndex))
			{
				// the instrument hasn't already been initialized,

				// release access to global data
				SynLeaveCriticalSection(ptlCs);

				// deactivate error handler
				onerror goto 0;

				// query the initialization state of the instrument to 
				// decide if the instrument has to be initialized
				if (!ML_STAR.GetCfgValueWithKey(MlStarCfgKey::instrumentIsInitialized))
				{

					// initialize
					onerror goto InitializeErrorHandler;
					rc = MlStarSteps::StepInitialize_cer(	ML_STAR,
															InitializeAlways,
															errorHandling,
                                             initCustomStepID,
															UserResponseTime);
					onerror goto 0;
					if (!StepReturn::Evaluate(ML_STAR, rc, errorHandling))
						Error::RaiseLast();
				}

				// disable initialization
				InitializeEnabled = hslFalse;

				// activate error handler
				onerror goto Unexpected;

				// get access to global data
				SynEnterCriticalSection(ptlCs);

				// add the instrument to the collection holding the initialized devices,
				ptlInitializedPipettingDevices.AddAsLast(instrumentName);

				// release access to global data
				SynLeaveCriticalSection(ptlCs);

				// deactivate error handler
				onerror goto 0;
			}

			// release access to global data
			SynLeaveCriticalSection(ptlCs);

			// deactivate error handler
			onerror goto 0;
		}
		return(rc);

		InitializeErrorHandler:
		{

			// bind error data
			StepReturn::Bind(rc);
			resume next;
		}

		Unexpected:
		{
			// release access to global data
			SynLeaveCriticalSection(ptlCs);
			Error::RaiseLast();
		}
	}

	static function PickupPipettingTips(
		device& ML_STAR,
		sequence& tipPickupSequence,
		variable& sequenceCycle,
		variable& multiplicityCycle,
		variable& volumeCycle,
		variable tipRenewalCycleSeq,
		variable tipRenewalCycleMul,
		variable tipRenewalCycleVol,
		variable isWashSequence)
	{
		variable rc[];																				// step return 

		// activate error handler
		onerror goto Unexpected;

		// if tip pickup is enabled and the sequence cycle exceeds the sequence tip renewal cycle, or 
		// the multiplicity cycle exceeds the multiplicity tip renewal cycle, or
		// the volume cycle exceeds the volume tip renewal cycle,
		// we pickup new tips
		if (PCB::NeedsTipPickup(sequenceCycle, multiplicityCycle, volumeCycle, 
										tipRenewalCycleSeq, tipRenewalCycleMul, tipRenewalCycleVol))
		{
			variable channelPattern("");				// tip pickup channel pattern

			// set the tip pickup channel pattern
			if (StepReturn::IsRecovering2())
				// we are recovering from an error
				channelPattern = StepReturn::GetChannelPattern();
			else
				// we are not recovering from an error
				channelPattern = TipPickupChannelVariable;

			if (!isWashSequence)
			{
				// Remark:
				// To keep the shape of the tip pickup sequence optimal if tips are used in 
				// the error handling, the tip pickup sequence is partially reversed. The 
				// first copyCount positions are copied from the begin of the original tip 
				// pickup sequence and the remaining TipPickupReverseSequenceCount are copied 
				// in reverse order from the end of the original tip pickup sequence.

				variable copyCount(0);						// number of positions to copy
				variable currentPos(0);						// current position
				variable numberOfActiveChannels(0);		// number of active channels
				variable availablePositions(0);			// number of available positions 
				variable maxPositionsPerStep(0);			// max number of positions per step
				variable usedPositions(0);					// number of used positions 
				sequence reverseTipPickupSequence;		// place to hold reverses order of positions of the tip pickup sequence
				variable canceledByTheUser(hslFalse);	// indicates whether an error recovery has been canceled by the user

				#ifdef _DEBUG_TIPHANDLING
				{
				variable source;
				variable action;
				source = "DEBUG";
				action = GetFunctionName();
				FormatTrace(source, action, TraceStatus::progress, "sequenceCycle = ", sequenceCycle);
				FormatTrace(source, action, TraceStatus::progress, "multiplicityCycle = ", multiplicityCycle);
				FormatTrace(source, action, TraceStatus::progress, "volumeCycle = ", volumeCycle);
				FormatTrace(source, action, TraceStatus::progress, "tipRenewalCycleSeq = ", tipRenewalCycleSeq);
				FormatTrace(source, action, TraceStatus::progress, "tipRenewalCycleMul = ", tipRenewalCycleMul);
				FormatTrace(source, action, TraceStatus::progress, "tipRenewalCycleVol = ", tipRenewalCycleVol);
				}
				#endif

				// determine tip pickup constraints 
				numberOfActiveChannels = NumberOfActiveChannels(channelPattern);
				maxPositionsPerStep = tipPickupSequence.GetMax();
				currentPos = tipPickupSequence.GetCurrentPosition();
				if (0 < currentPos)
					availablePositions = tipPickupSequence.GetCount() - currentPos + 1;
				copyCount = PTL_Util::Min(numberOfActiveChannels, PTL_Util::Min(maxPositionsPerStep, availablePositions));

				// reverse tip pickup sequence
				ReverseSequence(tipPickupSequence, reverseTipPickupSequence, 
									 tipPickupSequence.GetCurrentPosition(), copyCount, TipPickupReverseSequenceCount);

				// debug
				#ifdef _DEBUG
				FormatTrace("DEBUG", "ML_STAR.TipPickUp", TraceStatus::progress,
								"name = ", tipPickupSequence.GetName(), 
								", current = ", tipPickupSequence.GetCurrentPosition(), 
								", count = ", tipPickupSequence.GetCount(),
								", maxPos = ", tipPickupSequence.GetMax());
				#endif

				// pickup new tips (from reverseTipPickupSequence)
				onerror goto TipPickUpErrorHandler;
				rc = MlStarSteps::StepTipPickup_cer(ML_STAR,
													reverseTipPickupSequence,
													TipPickupSequenceCounting,
													channelPattern,
													TipPickupChannelUse,
													//>> 20060519
													//ErrorHandling,
													PCB::MapErrorHandlingContinue(ErrorHandling, TipPickupCustomStepID),
													//<< 20060519
                                       TipPickupCustomStepID,
													UserResponseTime);
				onerror goto Unexpected;
				if (!StepReturn::Evaluate(ML_STAR, rc, PCB::MapErrorHandlingContinue(ErrorHandling, TipPickupCustomStepID)))
					canceledByTheUser = hslTrue;

				// update tip presence
				PCB::SetTipPresence(channelPattern, 
										  reverseTipPickupSequence.GetUsedPositions(), hslTrue);

				// increment tip pickup sequence 
				if (SequenceCounting::manually == TipPickupSequenceCounting)
					// manual sequence counting
					tipPickupSequence.Increment(copyCount);

				// get number of used positions and update the count of the tip pickup sequence
				usedPositions = reverseTipPickupSequence.GetUsedPositions();
				if (copyCount < usedPositions)
					tipPickupSequence.SetCount(tipPickupSequence.GetCount() - usedPositions + copyCount);

				// if tip counting is enabled, write indexes of tipPickupSequence to file
				if (TipCountingEnabled)
					TipCount::Write2(tipPickupSequence, TipCountingIdentifier, ML_STAR);

				// reset sequence cycle
				sequenceCycle = 0;

				// check if an error recovery has been canceled by the user
				if (canceledByTheUser)
					// re-throw error
					Error::RaiseLast();
			}
			else
			{
				//ba 2004-01-26 begin
				variable canceledByTheUser(hslFalse);	// indicates whether an error recovery has been canceled by the user
				//end

				// set the washing state to pickup needles
				// (the ErrorHandling and UserResponseTime has already been set)
				SetWashingState(ML_STAR, tipPickupSequence, "NeedlePickupChannelVariable", channelPattern, 1);
				onerror goto NeedlePickUpErrorHandler;
				rc = WCB::NeedlePickup(ML_STAR, tipPickupSequence, hslFalse);
				onerror goto Unexpected;
				//ba 2004-01-26 begin
				if (!StepReturn::Evaluate(ML_STAR, rc, PCB::MapErrorHandlingContinue(ErrorHandling, TipPickupCustomStepID)))
					canceledByTheUser = hslTrue;
				//end

				// update tip presence
				PCB::SetTipPresence(channelPattern, 
										  tipPickupSequence.GetUsedPositions(), hslTrue);

				// tip counting not supported

				// reset sequence cycle
				sequenceCycle = 0;

				//ba 2004-01-26 begin
				// check if an error recovery has been canceled by the user
				if (canceledByTheUser)
					// re-throw error
					Error::RaiseLast();
				//end
			}
		}
		return(rc);

		TipPickUpErrorHandler:
		{
			// if tip counting is enabled, write indexes of tipPickupSequence to file
			if (TipCountingEnabled)
				TipCount::Write2(tipPickupSequence, TipCountingIdentifier, ML_STAR);

			// bind error data
			StepReturn::Bind(rc);
			resume next;
		}

		NeedlePickUpErrorHandler:
		{
			// tip counting not supported

			// bind error data
			StepReturn::Bind(rc);
			resume next;
		}

		Unexpected:
		{
			// if tip counting is enabled, write indexes of tipPickupSequence to file
			if (TipCountingEnabled)
				TipCount::Write2(tipPickupSequence, TipCountingIdentifier, ML_STAR);

			// re-throw error
			Error::RaiseLast();
		}
	}

	static function NumberOfActiveChannels(
		string& channelPattern)
	{
		variable index;
		variable length;
		variable numberOfActiveChannels(0);

		length = channelPattern.GetLength();
		for (index = 0; index < length; index++)
		{
			if ("1" == channelPattern.Mid(index, 1))
				numberOfActiveChannels++;
		}
		return(numberOfActiveChannels);
	}

	static function RightmostActiveChannel(
		string& channelPattern,
		string& rightmostActiveChannelPattern)
	{
		variable index;
		variable length;
		variable rightmostActiveChannel(0);

		length = channelPattern.GetLength();
		for (index = 0; index < length; index++)
		{
			if ("1" == channelPattern.Mid(index, 1))
				rightmostActiveChannel = index + 1;
		}
		rightmostActiveChannelPattern = "";
		for (index = 0; index < length; index++)
		{
			if (index + 1 == rightmostActiveChannel)
				rightmostActiveChannelPattern = rightmostActiveChannelPattern + "1";
			else
				rightmostActiveChannelPattern = rightmostActiveChannelPattern + "0";
		}

		return(rightmostActiveChannel);
	}

	static function SelectChannelPattern(
		string& channelPattern,
		string& selectedChannelPattern,
		variable channel)
	{
		variable index;
		variable length;

		selectedChannelPattern = "";
		length = channelPattern.GetLength();
		for (index = 0; index < length; index++)
		{
			if ((index + 1) == channel)
				selectedChannelPattern = selectedChannelPattern + "1";
			else
				selectedChannelPattern = selectedChannelPattern + "0";
		}
	}

	static function ReverseSequence(
		sequence& originalSequence,
		sequence& reverseSequence,
		variable start,
		variable copyCount,
		variable reverseCount)
	{
		variable index;
		variable count;
		variable currentPos;
		variable currentPosBak;

		// backup current position
		currentPosBak = originalSequence.GetCurrentPosition();

		// copy original sequence
		for (index = originalSequence.SetCurrentPosition(start); 
			  0 < index && index < start + copyCount; 
			  index = originalSequence.Increment(1))
			reverseSequence.Add(originalSequence.GetLabwareId(), originalSequence.GetPositionId());

		// reverse copy original sequence
		count = originalSequence.GetCount();
		currentPos = originalSequence.GetCurrentPosition();
		reverseCount = PTL_Util::Max(currentPos - 1, count - reverseCount);
		if (0 < reverseCount)
		{
			originalSequence.SetCurrentPosition(count);
			for (index = count; 
				  reverseCount < index; 
				  index = originalSequence.Increment(-1))
				reverseSequence.Add(originalSequence.GetLabwareId(), originalSequence.GetPositionId());
		}

		// restore current position
		originalSequence.SetCurrentPosition(currentPosBak);
		
		// set indexes of reverse sequence
		reverseSequence.SetCount(reverseSequence.GetTotal());
		reverseSequence.SetCurrentPosition(1);
		reverseSequence.SetMax(originalSequence.GetMax());

		return(hslTrue);
	}

	static function ExcludeSequencePositions(
		sequence& fromSequence,
		//>> 20060503
		variable excludeIndividualVolumes,
		variable& individualVolumes_1[],
		variable& individualVolumes_2[],
		//<< 20060503
		variable  startPos,
		variable  updatePos,
		variable& labIds[],
		variable& posIds[],
		//>> 20060503
		variable& volumes_1[],
		variable& volumes_2[],
		//<< 20060503
		variable& excludePos[],
		variable& currentInc[],
		variable& trackLabIds[],
		variable& trackPosIds[])
	{
		variable labId;							// labware id
		variable posId;							// position id
		//>> 20060503
		variable volume_1(0);
		variable volume_2(0);
		//<< 20060503
		variable size;								// size of input arrays (labIds, posIds)
		variable size0;							// size of output arrays at function entry (excludePos, currentInc)
		variable index;							// loop index
		variable currentPos;						// current position
		variable currentPosBak;					// backup of current position

		// backup current position
		currentPosBak = fromSequence.GetCurrentPosition();

		// verify input
		#ifdef _DEBUG
		Assert(labIds.GetSize() == posIds.GetSize(), GetFunctionName());
		Assert(0 <= startPos && startPos <= fromSequence.GetCount(), GetFunctionName());
		#endif

		// iterate over positions to exclude
		size = labIds.GetSize();
		size0 = excludePos.GetSize();
		excludePos.SetSize(size);
		currentInc.SetSize(size);
		//>> 20060503
		if (1 == excludeIndividualVolumes)
		{
			volumes_1.SetSize(size);
			volumes_2.SetSize(size);
		}
		//<< 20060503
		for (index = size0; index < size; index++)
		{
			variable numberOfRefs(0);				// number of references to the same position

			labId = labIds.GetAt(index);
			posId = posIds.GetAt(index);

			// invalidate index of positions to exclude
			excludePos.SetAt(index, 0);
			currentInc.SetAt(index, 0);

			// iterate over sequence
			for (currentPos = fromSequence.SetCurrentPosition(fromSequence.LookupPosition(labId, posId, startPos, hslTrue)); 
				  0 < currentPos; 
				  currentPos = fromSequence.SetCurrentPosition(fromSequence.LookupPosition(labId, posId, currentPos + 1, hslTrue)))
			{
				{
					variable labIndex;							// array index
					variable posIndex;							// array index
					variable trackSize;							// array size
					variable trackIndex;							// loop counter
					variable trackFound;							// indicates whether the position is already contained in the tracker data
					variable count(0);

					count = fromSequence.GetCount();

					// found a position to exclude
					fromSequence.RemoveAt(currentPos);

					//>> 20060503
					if (1 == excludeIndividualVolumes)
					{
						if (0 <= (currentPos - 1) && (currentPos - 1) < individualVolumes_1.GetSize())
						{
							volume_1 = individualVolumes_1.ElementAt(currentPos - 1);
							individualVolumes_1.RemoveElementAt(currentPos - 1);
						}
						if (0 <= (currentPos - 1) && (currentPos - 1) < individualVolumes_2.GetSize())
						{
							volume_2 = individualVolumes_2.ElementAt(currentPos - 1);
							individualVolumes_2.RemoveElementAt(currentPos - 1);
						}
					}
					//<< 20060503

					trackFound = hslFalse;
					trackSize = trackLabIds.GetSize();
					for (trackIndex = 0; trackIndex < trackSize; trackIndex++)
					{
						if ((trackLabIds.ElementAt(trackIndex) == labId) && (trackPosIds.ElementAt(trackIndex) == posId))
						{
							trackFound = hslTrue;
							break;
						}
					}
					if (!trackFound)
					{
						trackLabIds.AddAsLast(labId);
						trackPosIds.AddAsLast(posId);
					}

					// store the index of the excluded position 
					if (0 == numberOfRefs)
					{
						// it's the first hit,
						// set the index of the excluded position 
						excludePos.SetAt(index, currentPos);
					}
					else
					{
						// update loop index and array size
						index++;
						size++;

						if (index < excludePos.GetSize())
						{
							// there are multiple references to the same position,
							// insert the index of the excluded position 
							excludePos.InsertElementAt(index, currentPos);

							// align labIds, posIds and currentInc to 
							// the same size as the excludePos array
							labIds.InsertElementAt(index, labId);
							posIds.InsertElementAt(index, posId);
							currentInc.InsertElementAt(index, 0);
							//>> 20060503
							if (1 == excludeIndividualVolumes)
							{
								volumes_1.InsertElementAt(index, volume_1);
								volumes_2.InsertElementAt(index, volume_2);
							}
							//<< 20060503
						}
						else
						{
							// there are multiple references to the same position,
							// insert index
							excludePos.AddAsLast(currentPos);

							// align labware and position ids to the 
							// same size as the excludePos array
							labIds.AddAsLast(labId);
							posIds.AddAsLast(posId);
							currentInc.AddAsLast(0);
							//>> 20060503
							if (1 == excludeIndividualVolumes)
							{
								volumes_1.AddAsLast(volume_1);
								volumes_2.AddAsLast(volume_2);
							}
							//<< 20060503
						}
					}

					// adjust currentPosBak if removing a position before currentPosBak 
					// and store increment of current positions during exclusion
					if (currentPos < currentPosBak)
					{
						currentPosBak--;

						// we are removing a position before currentPosBak,
						// store -1 as the current increment
						currentInc.SetAt(index, -1);
					}
					else 
					{
						if (currentPosBak == count)
							// we are removing a position at currentPosBak AND currentPosBak 
							// points to count -> currentPosBak falls to 0,
							// store -count as the current increment
							currentInc.SetAt(index, - fromSequence.GetCount());
					}

					// adjust currentPos if not removing the last position 
					if (currentPos < count)
						currentPos--;

					// adjust the count if not removing the last position 
					if (fromSequence.GetCount() < fromSequence.GetTotal())
						fromSequence.SetCount(fromSequence.GetCount() - 1);

					// update updatePos if removing a position before currentPosBak 
					// and store increment of current positions during exclusion
					if (currentPos < updatePos)
						updatePos--;

					// increment number of references to the same position
					numberOfRefs++;
				}
			}
		}

		// restore current position
		fromSequence.SetCurrentPosition(currentPosBak);

		// verify output
		#ifdef _DEBUG
		Assert(labIds.GetSize() == posIds.GetSize(), GetFunctionName());
		Assert(labIds.GetSize() == excludePos.GetSize(), GetFunctionName());
		Assert(labIds.GetSize() == currentInc.GetSize(), GetFunctionName());
		#endif

		return(hslTrue);
	}

	static function IncludeSequencePositions(
		sequence& toSequence,
		//>> 20060503
		variable includeIndividualVolumes,
		variable& toVolumes_1[],
		variable& toVolumes_2[],
		//<< 20060503
		variable& labIds[],
		variable& posIds[],
		//>> 20060503
		variable& volumes_1[],
		variable& volumes_2[],
		//<< 20060503
		variable& includePos[],
		variable& currentInc[])
	{
		variable size;								// size of input arrays
		variable index;							// loop index
		variable position;						// sequence position index
		variable currentPos;						// current position

		// verify input
		#ifdef _DEBUG
		Assert(labIds.GetSize() == posIds.GetSize(), GetFunctionName());
		Assert(labIds.GetSize() == includePos.GetSize(), GetFunctionName());
		Assert(labIds.GetSize() == currentInc.GetSize(), GetFunctionName());
		#endif

//tb 20120213 SCR.1567
      // ================================================================================================
      // Analyse:
      // In case of an error handling on 'post aliquote back' step (line 6917), the function EvaluateEx() 
      // is called with propegate == hslFalse. This will exclude only the positions of aspirate sequence.
      // After tipEject RestorData2() IncludeSequencePositions() will fail (array out of bound) on
      // include dispense positions.
      // ================================================================================================
      // check for correct array dimensions
      if(labIds.GetSize() != posIds.GetSize() ||
         labIds.GetSize() != includePos.GetSize() ||
         labIds.GetSize() != currentInc.GetSize())
         return(hslTrue);
//tb end inserted 20120213

		// iterate over positions to include
		size = labIds.GetSize();
		for (index = size - 1; 0 <= index; index--)
		{
			position = includePos.GetAt(index);

			if (0 < position)
			{
				if (		       0 == toSequence.GetCount()
						|| position == toSequence.GetCount()+1 )		// 2009-12-16/cjoerg: If the last element of the sequence
																					// has been removed we have to Add because InsertAt fails
																					// if position = count+1
				{
					toSequence.Add(labIds.GetAt(index), posIds.GetAt(index));
				}
				else
				{
					// found the index where to insert the position BEFORE
					toSequence.InsertAt(position, labIds.GetAt(index), posIds.GetAt(index));
				}

				// adjust the count if not inserting at the last position 
				if (toSequence.GetCount() < toSequence.GetTotal())
					toSequence.SetCount(toSequence.GetCount() + 1);

				// adjust the current position   
				if (0 == toSequence.GetCurrentPosition())
					currentPos = 1;
				else
					currentPos = toSequence.GetCurrentPosition();
				toSequence.SetCurrentPosition(currentPos - currentInc.GetAt(index));

				//>> 20060503
				if (1 == includeIndividualVolumes)
				{
					if (0 == toVolumes_1.GetSize())
					{
						if (index < volumes_1.GetSize())
							toVolumes_1.AddAsLast(volumes_1.GetAt(index));
					}
					else
					{
						// found the index where to insert the position BEFORE
						if (index < volumes_1.GetSize())
							toVolumes_1.InsertElementAt(position - 1, volumes_1.GetAt(index));
					}
					if (0 == toVolumes_2.GetSize())
					{
						if (index < volumes_2.GetSize())
							toVolumes_2.AddAsLast(volumes_2.GetAt(index));
					}
					else
					{
						// found the index where to insert the position BEFORE
						if (index < volumes_2.GetSize())
							toVolumes_2.InsertElementAt(position - 1, volumes_2.GetAt(index));
					}
				}
				//<< 20060503
			}
		}

		return(hslTrue);
	}

	static function ExcludePositions(
		string& fromPositions,
		variable& excludePositions[])
	{

		variable positionsArr[];
		variable length;							// string length
		variable index(0);						// loop index
		variable unusedIndex(0);				// unused array index
		variable size;								// array size
		variable pos;								// a barcode read position

		// parse comma separated list of positons
		index = fromPositions.Find(StringConstants::csvDelimiter);
		length = fromPositions.GetLength();
		while (0 <= index)
		{
			positionsArr.AddAsLast(fromPositions.Left(index)); 
			fromPositions = fromPositions.Mid(index + 1, length);
			index = fromPositions.Find(StringConstants::csvDelimiter);
			length = fromPositions.GetLength();
		}
		if (0 < length)
			positionsArr.AddAsLast(fromPositions);

		fromPositions = "";
		size = positionsArr.GetSize();
		for (index = 0; index < size; index++)
		{
			pos = positionsArr.ElementAt(index);
			if (!PTL_Util::Lookup(excludePositions, pos, unusedIndex))
			{
				if (0 < fromPositions.GetLength())
					fromPositions = fromPositions + StringConstants::csvDelimiter;
				fromPositions = fromPositions + pos;
			}
		}
	}

	static function TransferLiquid(
		device& ML_STAR,
		sequence& tipPickupSequence,
		sequence& aspirateSequence,
		sequence& dispenseSequence,
		variable aspirateMultiplicity,
		variable dispenseMultiplicity,
		variable currentMultiplicity,
		//>> 20060503
		variable transferIndividualVolumes,
		variable& totalVolumes[],
		variable& currentVolumes[],
		//<< 20060503
		variable currentVolume,
		variable drivingMode,
		variable isWashSequence,
		variable errorHandlingEnabled)
	{
		variable volume(0);					// aspirate / dispense volume
		//>> 20060503
		variable volumes[];					// individual aspirate / dispense volumes
		//<< 20060503
		variable preVolume(0);				// volume of pre-aliquot (if any)
		variable mixCycles(0);				// aspirate mix cycles
		variable mixPosition(0);			// aspirate mix position
		variable mixVolume(0);				// aspirate mix volume
		variable numberOfAliquots(1);		// number of aliquots (if any)
		variable channelPattern("");		// aspirate / dispense channel pattern
		variable currentAliquot(0);		// current aliquot in dispense aliquot loop 
		variable rc[];							// step return array 
		string xorPattern("");				// failed channels (xor combination of channelPattern and StepReturn::copyPattern)
		//>> 20060503
		variable i(0);							// array index
		variable numberOfVolumes(0);		// number of individual volumes, indicates whether we have to transfer individual volumes or not
		//<< 20060503

		// set the aspirate channel pattern
		if (StepReturn::IsRecovering2())
			// we are recovering from an error
			channelPattern = StepReturn::GetChannelPattern();
		else
			// we are not recovering from an error
			channelPattern = AspirateChannelVariable;

		// synthesize number of aliquots (if any)
		if (AliquotEnabled)
		{
			//>>2009-06-09/CJ
			//numberOfAliquots = Ceiling(1.0 * AspirateVolume / DispenseVolume);
			numberOfAliquots = MthRound(1.0 * AspirateVolume / DispenseVolume, 0);
			//<<2009-06-09/CJ
		}
		else
		{
			// abstract simple pipette as degenerated aliquot
			numberOfAliquots = 1;
		}

		//>> 20060503
		// check if we have to transfer individual volumes
		volumes.SetSize(0);
		numberOfVolumes = AspirateVolumes.GetSize();
		if (0 < numberOfVolumes)
		{
			// we have to transfer individual volumes
			numberOfVolumes = AspirateVolumes.GetSize();
			for (i = 0; i < numberOfVolumes; i++)
			{
				if(0 < AspirateVolumes.ElementAt(i))
				{
					volumes.AddAsLast(AspirateVolumes.ElementAt(i) + AspirateRestVolume);
				}
				else
				{
					volumes.AddAsLast(AspirateVolumes.ElementAt(i));
				}
			}
		}
		else
		//<< 20060503
		{
			// we dont't have to transfer individual volumes

			// calculate aspirate volume as sum of 
			// aspirate volume plus rest volume plus volume of pre-aliquot (if any)
			volume = AspirateVolume + AspirateRestVolume + AliquotPreAspirateVolume;
		}

		// set default aspirate mix settings
		if (AliquotEnabled && AliquotAspirateDefaultMixingEnabled)
		{
			mixCycles = AliquotPreAspiratePrerinsingMixCycles;
			mixPosition = AliquotPreAspiratePrerinsingMixPosition;
			mixVolume = AliquotPreAspiratePrerinsingMixVolumeMultiplier * volume;
		}
		else
		{
			mixCycles = AspiratePrerinsingMixCycles;
			mixPosition = AspiratePrerinsingMixPosition;
			mixVolume = AspiratePrerinsingMixVolume;
		}

		// aspirate volume plus rest volume plus volume of pre-aliquot (if any)
		#ifdef _DEBUG
		FormatTrace("DEBUG", "ML_STAR.Aspirate", TraceStatus::progress,
						"name = ", aspirateSequence.GetName(), 
						", current = ", aspirateSequence.GetCurrentPosition(), 
						", count = ", aspirateSequence.GetCount(),
						", maxPos = ", aspirateSequence.GetMax(), 
						", volume = ", volume);
		//MessageBox("DebugBreak", "Asspirate");
		#endif
		onerror goto AspirateErrorHandler;

		//>> 20060503
		// check if we have to transfer individual volumes
		if (0 < numberOfVolumes)
		{
			// we have to transfer individual volumes
			rc = MlStarSteps::StepAspirateEx_cer(	ML_STAR,
												aspirateSequence,
												AspirateSequenceCounting,
												volumes,
												AspirateMode,
												AspirateCLLDSensitivity,
												AspiratePLLDSensitivity,
												AspirateSubmergeDepth,
												AspirateFluidHeight,
												AspirateMaxHeightDiff,
												channelPattern,
												AspirateChannelUse,
												AspirateLiquidFollowing,
												mixCycles,
												mixPosition,
												mixVolume,
												AspirateUserDefinedLiquidClass,
												//ErrorHandling,
                                    ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, AspirateCustomStepID),
                                    AspirateCustomStepID,
												UserResponseTime);
		}
		else
		//<< 20060503
		{
			// we dont't have to transfer individual volumes
			rc = MlStarSteps::StepAspirate_cer(	ML_STAR,
												aspirateSequence,
												AspirateSequenceCounting,
												volume,
												AspirateMode,
												AspirateCLLDSensitivity,
												AspiratePLLDSensitivity,
												AspirateSubmergeDepth,
												AspirateFluidHeight,
												AspirateMaxHeightDiff,
												channelPattern,
												AspirateChannelUse,
												AspirateLiquidFollowing,
												mixCycles,
												mixPosition,
												mixVolume,
												AspirateUserDefinedLiquidClass,
												//ErrorHandling,
                                    ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, AspirateCustomStepID),
                                    AspirateCustomStepID,
												UserResponseTime);
		}

		onerror goto 0;

		// propagate the correction of the used positions of a sequence 
		// if an error occured and copy pattern has been enabled
		if (CopyPatternEnabled && !ExcludeErrorPositionsEnabled)
		{
			xorPattern = StepReturn::XorChannelPattern(AspirateChannelVariable);
			StepReturn::SetUsedPos(StepReturn::StepType::aspirate, 
										  NumberOfActiveChannels(xorPattern));
		}
		else if (ExcludeErrorPositionsEnabled)
		{
			StepReturn::SetUsedPos(StepReturn::StepType::aspirate, 0);
		}

		// evaluate step return
		if (!StepReturn::EvaluateEx(ML_STAR, rc, ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, AspirateCustomStepID), aspirateSequence, dispenseSequence, 
											 aspirateMultiplicity, dispenseMultiplicity, drivingMode, 
											 transferIndividualVolumes, totalVolumes, currentVolumes, currentVolume,
											 StepReturn::StepType::unspecified, hslTrue))
		{
			if (errorHandlingEnabled)
				StepReturn::HandleError(ML_STAR, tipPickupSequence, isWashSequence, StepReturn::StepType::aspirate, hslTrue);
		}
		StepReturn::Empty(rc);

		// dispense pre-aliquot (if any)
		if (AliquotEnabled && 0 < AliquotPreAspirateVolume)
		{
			// set the dispense channel pattern
			if (StepReturn::IsRecovering2())
				// we are recovering from an error
				channelPattern = StepReturn::GetChannelPattern();
			else
				// we are not recovering from an error
				channelPattern = DispenseChannelVariable;

			// dispense volume of pre-aliquot back to aspirate sequence
			// Dispense mode: Jet mode part volume
			// Fixed height from bottom: DispenseRestVolumeFluidHeight
			// Liquid following: On
			volume = AliquotPreAspirateVolume;
			#ifdef _DEBUG
			FormatTrace("DEBUG", "ML_STAR.Dispense", TraceStatus::progress, 
							"name = ", aspirateSequence.GetName(), 
							", current = ", aspirateSequence.GetCurrentPosition(), 
							", count = ", aspirateSequence.GetCount(),
							", maxPos = ", aspirateSequence.GetMax(), 
							", volume = ", volume);
			//MessageBox("DebugBreak", "Dispense pre-aliquot");
			#endif

			if ( 0 <= StrFind(channelPattern, "1") )		// 2009-12-16/cjoerg: Added to prevent error if aspirateSequence is gone
																		// empty because of AspirateErrors and enabled copyPattern/excludeErrorPostions
																		// Only if a channel is active we must try to re-dispense
			{
				onerror goto DispenseErrorHandler;
				rc = MlStarSteps::StepDispense_cer(	ML_STAR,
													aspirateSequence,
													SequenceCounting::manually,
													volume,
													StarDispenseMode::jetPartVolume,
													LLDSensitivity::off,
													0,
													DispenseRestVolumeFluidHeight,
													channelPattern,
													ChannelUse::allSequencePositions,
													hslTrue,
													0,
													0,
													0,
													DispenseUserDefinedLiquidClass,
													//ErrorHandling,
                                       ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, PreDispenseCustomStepID),
                                       PreDispenseCustomStepID,
                                       DispenseType::preDispense,
													UserResponseTime);
				onerror goto 0;

				// propagate the correction of the used positions of a sequence 
				// if an error occured and copy pattern has been enabled
				if (CopyPatternEnabled && !ExcludeErrorPositionsEnabled)
				{
					xorPattern = StepReturn::XorChannelPattern(DispenseChannelVariable);
					StepReturn::SetUsedPos(StepReturn::StepType::aspirate, 
												  NumberOfActiveChannels(xorPattern));
				}
				else if (ExcludeErrorPositionsEnabled)
				{
					StepReturn::SetUsedPos(StepReturn::StepType::aspirate, 0);
				}

				// evaluate step return
				if (!StepReturn::EvaluateEx(ML_STAR, rc, ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, PreDispenseCustomStepID), aspirateSequence, dispenseSequence,
													 aspirateMultiplicity, dispenseMultiplicity, drivingMode, 
													 transferIndividualVolumes, totalVolumes, currentVolumes, currentVolume,
													 StepReturn::StepType::aspirate, hslTrue))
				{
					if (errorHandlingEnabled)
						StepReturn::HandleError(ML_STAR, tipPickupSequence, isWashSequence, StepReturn::StepType::dispense, hslTrue);
				}
				StepReturn::Empty(rc);
			}
		}

		// dispense volume 
		//>> 20060503
		// check if we have to transfer individual volumes
		volumes.SetSize(0);
		numberOfVolumes = DispenseVolumes.GetSize();
		if (0 < numberOfVolumes)
		{
			// we have to transfer individual volumes
			numberOfVolumes = DispenseVolumes.GetSize();
			for (i = 0; i < numberOfVolumes; i++)
			{
				volumes.AddAsLast(DispenseVolumes.ElementAt(i));
			}
		}
		else
		//<< 20060503
		{
			// we dont't have to transfer individual volumes
			volume = DispenseVolume;
		}
		for (currentAliquot = 0; currentAliquot < numberOfAliquots; currentAliquot++)
		{
			variable starDispenseMode(-1);

			// get the dispense mode for current step
			starDispenseMode = PCB::GetDispenseMode(currentAliquot + 1, numberOfAliquots);

			// set the dispense channel pattern
			if (StepReturn::IsRecovering2())
				// we are recovering from an error
				channelPattern = StepReturn::GetChannelPattern();
			else
				// we are not recovering from an error
				channelPattern = DispenseChannelVariable;

			// increment dispense sequence except before the first 
			// and after the last pass through the aliquot loop
			if (0 < currentAliquot)
			{
				variable usedDispensePositions(0);	// used dispense positions

				// restore the temporarily excluded sequence positions contained in the internal data of the StepReturn 
				StepReturn::RestoreData2(dispenseSequence, transferIndividualVolumes, totalVolumes, currentVolumes, dispenseMultiplicity, currentMultiplicity);
				dispenseSequence++;

				// get the correction of the used positions of the dispense sequence 
				// if an error occured and copy pattern has been enabled
				usedDispensePositions = StepReturn::GetUsedPos(StepReturn::StepType::dispense);
				dispenseSequence.Increment(usedDispensePositions);

				// reset internal dispense  data of StepReturn, except the used dispense positions
				StepReturn::ResetData(hslFalse, hslTrue);
				StepReturn::SetUsedPos(StepReturn::StepType::dispense, usedDispensePositions);

				// propagate excluded positions of dispense sequence if an error occured and copy pattern has been enabled
				StepReturn::PropagateExcludedPositions(dispenseSequence, DispenseChannelVariable, StepReturn::StepType::dispense);

				// re-align the max number of positions of the dispense and aspirate sequence
				// ba 2002-09-11 begin (SCR#210)
				//AlignSequences(hslTrue, dispenseSequence, 1);
				//>>20071019 (SCR#1193 : Strange behaviour in Aliquot procedure)
				//if (!isWashSequence)
				//	AlignSequences(hslTrue, tipPickupSequence, 1, aspirateSequence, 1, dispenseSequence, 1, TipEjectWasteDestination, 1);
				//else
					AlignSequences(hslTrue, aspirateSequence, 1, dispenseSequence, 1, TipEjectWasteDestination, 1);
				//<<20071019
				// end
			}

			#ifdef _DEBUG
			FormatTrace("DEBUG", "ML_STAR.Dispense", TraceStatus::progress, 
							"name = ", dispenseSequence.GetName(), 
							", current = ", dispenseSequence.GetCurrentPosition(), 
							", count = ", dispenseSequence.GetCount(),
							", maxPos = ", dispenseSequence.GetMax(), 
							", volume = ", volume);
			//MessageBox("DebugBreak", "Dispense volume");
			#endif
			onerror goto DispenseErrorHandler;

			//>> 20060503
			// check if we have to transfer individual volumes
			if (0 < numberOfVolumes)
			{
				// we have to transfer individual volumes
				rc = MlStarSteps::StepDispenseEx_cer(	ML_STAR,
													dispenseSequence,
													DispenseSequenceCounting,
													volumes,
													starDispenseMode,				// 2005-06-21/cjoerg: pass the evaluated StarDispenseMode
													DispenseCLLDSensitivity,
													DispenseSubmergeDepth,
													DispenseFluidHeight,
													channelPattern,
													DispenseChannelUse,
													DispenseLiquidFollowing,
													DispensePrerinsingMixCycles,
													DispensePrerinsingMixPosition,
													DispensePrerinsingMixVolume,
													DispenseUserDefinedLiquidClass,
													//ErrorHandling,
                                       ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, DispenseCustomStepID),
                                       DispenseCustomStepID,
                                       DispenseType::regularDispense,
													UserResponseTime);
			}
			else
			//<< 20060503
			{
				// we dont't have to transfer individual volumes
				rc = MlStarSteps::StepDispense_cer(	ML_STAR,
													dispenseSequence,
													DispenseSequenceCounting,
													volume,
													starDispenseMode,				// 2005-06-21/cjoerg: pass the evaluated StarDispenseMode
													DispenseCLLDSensitivity,
													DispenseSubmergeDepth,
													DispenseFluidHeight,
													channelPattern,
													DispenseChannelUse,
													DispenseLiquidFollowing,
													DispensePrerinsingMixCycles,
													DispensePrerinsingMixPosition,
													DispensePrerinsingMixVolume,
													DispenseUserDefinedLiquidClass,
													//ErrorHandling,
                                       ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, DispenseCustomStepID),
                                       DispenseCustomStepID,
                                       DispenseType::regularDispense,
													UserResponseTime);
			}

			onerror goto 0;

			// track the sample tracker data of the StepReturn 
			StepReturn::TrackData(ML_STAR);
			StepReturn::ResetTrackerData(hslTrue);

			// propagate the correction of the used positions of a sequence 
			// if an error occured and copy pattern has been enabled
			if (CopyPatternEnabled && !ExcludeErrorPositionsEnabled)
			{
				xorPattern = StepReturn::XorChannelPattern(DispenseChannelVariable);
				StepReturn::SetUsedPos(StepReturn::StepType::dispense, 
											  NumberOfActiveChannels(xorPattern));
			}
			else if (ExcludeErrorPositionsEnabled)
			{
				StepReturn::SetUsedPos(StepReturn::StepType::dispense, 0);
			}

			// evaluate step return
			if (!StepReturn::EvaluateEx(ML_STAR, rc, ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, DispenseCustomStepID), aspirateSequence, dispenseSequence,
												 aspirateMultiplicity, dispenseMultiplicity, drivingMode,
												 transferIndividualVolumes, totalVolumes, currentVolumes, currentVolume,
												 StepReturn::StepType::unspecified, hslTrue))
			{
				if (errorHandlingEnabled)
					StepReturn::HandleError(ML_STAR, tipPickupSequence, isWashSequence, StepReturn::StepType::dispense, hslFalse);
			}
			StepReturn::Empty(rc);

		}

		// dispense rest volume or post-aliquot respectively (if any)
		if (0 < DispenseRestVolume)
		{
			// set the dispense channel pattern
			if (StepReturn::IsRecovering2())
				// we are recovering from an error
				channelPattern = StepReturn::GetChannelPattern();
			else
				// we are not recovering from an error
				channelPattern = DispenseChannelVariable;

			if ( 0 <= StrFind(channelPattern, "1") )		// 2009-12-16/cjoerg: Added to prevent error if aspirateSequence is gone
																		// empty because of AspirateErrors and enabled copyPattern/excludeErrorPostions
																		// Only if a channel is active we must try to re-dispense
			{
				volume = DispenseRestVolume;
				if (RestVolumeDestination::aspirate == DispenseRestVolumeDestination)
				{
					// dispense rest volume or post-aliquot back to the aspirate sequence
					#ifdef _DEBUG
					FormatTrace("DEBUG", "ML_STAR.Dispense", TraceStatus::progress, 
									"name = ", aspirateSequence.GetName(), 
									", current = ", aspirateSequence.GetCurrentPosition(), 
									", count = ", aspirateSequence.GetCount(), 
									", maxPos = ", aspirateSequence.GetMax(), 
									", volume = ", volume);
					//MessageBox("DebugBreak", "Dispense rest volume or post-aliquot respectively");
					#endif
					onerror goto DispenseErrorHandler;
					// ba 20050511 begin (SCR#736)
					if (!DispenseRestVolumeToAspirateSequenceSurface)
					{
						// dispense rest volume or post-aliquot back to the aspirate sequence at fixed height from bottom
					// ba 20050511 end (SCR#736)
						rc = MlStarSteps::StepDispense_cer(	ML_STAR,
															aspirateSequence,
															SequenceCounting::manually,
															volume,
															// DispenseMode::jetModeEmptyTip,		// changed: 2005-04-21/cjoerg
															StarDispenseMode::blowoutTip,				// blowoutTip must be used (because of changed design of liquid-classes)
															LLDSensitivity::off,
															0,													// dispenseSubmergeDepth
															DispenseRestVolumeFluidHeight,
															channelPattern,
															ChannelUse::allSequencePositions,
															hslTrue,											// dispenseLiquidFollowing
															0,													// dispensePrerinsingMixCycles
															0,													// dispensePrerinsingMixPosition
															0,													// dispensePrerinsingMixVolume
															DispenseUserDefinedLiquidClass,
															//ErrorHandling,
                                             ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, PostDispenseCustomStepID),
                                             PostDispenseCustomStepID,
                                             DispenseType::postDispense,
															UserResponseTime);
					// ba 20050511 begin (SCR#736)
					}
					else
					{
						// dispense rest volume or post-aliquot back to the aspirate sequence at surface
						if (LLDSensitivity::off != AspirateCLLDSensitivity)
						{
							rc = MlStarSteps::StepDispense_cer(	ML_STAR,
																aspirateSequence,
																SequenceCounting::manually,
																volume,
																// DispenseMode::jetModeEmptyTip,		// changed: 2005-04-21/cjoerg
																StarDispenseMode::blowoutTip,				// blowoutTip must be used (because of changed design of liquid-classes)
																AspirateCLLDSensitivity,
																AspirateSubmergeDepth,
																0,													// dispenseFluidHeight
																channelPattern,
																ChannelUse::allSequencePositions,
																hslTrue,											// dispenseLiquidFollowing
																0,													// dispensePrerinsingMixCycles
																0,													// dispensePrerinsingMixPosition
																0,													// dispensePrerinsingMixVolume
																DispenseUserDefinedLiquidClass,
																//ErrorHandling,
                                                ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, PostDispenseCustomStepID),
                                                PostDispenseCustomStepID,
                                                DispenseType::postDispense,
																UserResponseTime);
						}
						else
						{
							if (LLDSensitivity::off == AspirateCLLDSensitivity &&
								 LLDSensitivity::off == AspiratePLLDSensitivity)
							{
								rc = MlStarSteps::StepDispense_cer(	ML_STAR,
																	aspirateSequence,
																	SequenceCounting::manually,
																	volume,
																	// DispenseMode::jetModeEmptyTip,		// changed: 2005-04-21/cjoerg
																	StarDispenseMode::blowoutTip,				// blowoutTip must be used (because of changed design of liquid-classes)
																	LLDSensitivity::off,
																	0,													// dispenseSubmergeDepth
																	AspirateFluidHeight,							// dispenseFluidHeight
																	channelPattern,
																	ChannelUse::allSequencePositions,
																	hslTrue,											// dispenseLiquidFollowing
																	0,													// dispensePrerinsingMixCycles
																	0,													// dispensePrerinsingMixPosition
																	0,													// dispensePrerinsingMixVolume
																	DispenseUserDefinedLiquidClass,
																	//ErrorHandling,
                                                   ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, PostDispenseCustomStepID),
                                                   PostDispenseCustomStepID,
                                                   DispenseType::postDispense,
																	UserResponseTime);
							}
							else
							{
								Error::Raise(IDE::failedToDispenseRestVolume, GetFileName(), GetFunctionName(), GetLineNumber());
							}
						}
					}
					// ba 20050511 end (SCR#736)
					onerror goto 0;

					// track the sample tracker data of the StepReturn 
					StepReturn::TrackData(ML_STAR);
					StepReturn::ResetTrackerData(hslTrue);

					// propagate the correction of the used positions of a sequence 
					// if an error occured and copy pattern has been enabled
					if (CopyPatternEnabled && !ExcludeErrorPositionsEnabled)
					{
						xorPattern = StepReturn::XorChannelPattern(DispenseChannelVariable);
						StepReturn::SetUsedPos(StepReturn::StepType::aspirate, 
													  NumberOfActiveChannels(xorPattern));
					}
					else if (ExcludeErrorPositionsEnabled)
					{
						StepReturn::SetUsedPos(StepReturn::StepType::aspirate, 0);
					}

					// evaluate step return
					if (!StepReturn::EvaluateEx(ML_STAR, rc, ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, PostDispenseCustomStepID), aspirateSequence, dispenseSequence,
														 aspirateMultiplicity, dispenseMultiplicity, drivingMode, 
														 transferIndividualVolumes, totalVolumes, currentVolumes, currentVolume,
														 StepReturn::StepType::aspirate, hslFalse))
					{
						if (errorHandlingEnabled)
							StepReturn::HandleError(ML_STAR, tipPickupSequence, isWashSequence, StepReturn::StepType::dispense, hslFalse);
					}
					StepReturn::Empty(rc);
				}
				if (RestVolumeDestination::waste == DispenseRestVolumeDestination)
				{
					// to the waste sequence
					// Dispense mode: Jet mode empty tip
					// Fixed height from bottom: DispenseRestVolumeConstFluidHeight
					// Liquid following: On
					#ifdef _DEBUG
					FormatTrace("DEBUG", "ML_STAR.Dispense", TraceStatus::progress, 
									"name = ", TipEjectWasteDestination.GetName(), 
									", current = ", TipEjectWasteDestination.GetCurrentPosition(), 
									", count = ", TipEjectWasteDestination.GetCount(), 
									", maxPos = ", TipEjectWasteDestination.GetMax(), 
									", volume = ", volume);
					//MessageBox("DebugBreak", "Dispense rest volume or post-aliquot respectively");
					#endif
					onerror goto DispenseErrorHandler;
					rc = MlStarSteps::StepDispense_cer(	ML_STAR,
														TipEjectWasteDestination,
														SequenceCounting::manually,
														volume,
														// DispenseMode::jetModeEmptyTip,		// changed: 2005-04-21/cjoerg
														StarDispenseMode::blowoutTip,				// blowoutTip must be used (because of changed design of liquid-classes)LLDSensitivity::off,
														LLDSensitivity::off,
														0,
														DispenseRestVolumeConstFluidHeight,
														channelPattern,
														ChannelUse::allSequencePositions,
														hslTrue,
														0,
														0,
														0,
														DispenseUserDefinedLiquidClass,
														//ErrorHandling,
                                          ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, PostDispenseCustomStepID),
                                          PostDispenseCustomStepID,
                                          DispenseType::postDispense,
														UserResponseTime);
					onerror goto 0;
					if (!StepReturn::Evaluate(ML_STAR, rc, ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, PostDispenseCustomStepID)))
						Error::RaiseLast();
					StepReturn::Empty(rc);
				}
			}
		}

		//MessageBox("DebugBreak", "DebugBreak");

		return(rc);

		AspirateErrorHandler:
		{
			// bind error data
			StepReturn::Bind(rc);
			resume next;
		}

		DispenseErrorHandler:
		{
			// bind error data
			StepReturn::Bind(rc);
			resume next;
		}
	}

	static function EjectPipettingTips(
		device& ML_STAR,
		variable& sequenceCycle,
		variable& multiplicityCycle,
		variable& volumeCycle,
		variable tipRenewalCycleSeq,
		variable tipRenewalCycleMul,
		variable tipRenewalCycleVol,
		sequence& tipPickupSequence,
		variable isWashSequence)
	{
		variable rc[];																// step return 

		// if tip pickup is enabled and the sequence cycle exceeds the sequence tip renewal cycle, or 
		// the multiplicity cycle exceeds the multiplicity tip renewal cycle, or
		// the volume cycle exceeds the volume tip renewal cycle,
		// we eject the tips
		if (TipPickupEnabled &&
			(tipRenewalCycleSeq <= sequenceCycle		||
			 tipRenewalCycleMul <= multiplicityCycle	||
			 tipRenewalCycleVol <= volumeCycle))
		{
			if (!isWashSequence)
			{
				// debug
				#ifdef _DEBUG_TIPHANDLING
				{
				variable source;
				variable action;
				source = "DEBUG";
				action = GetFunctionName();
				FormatTrace(source, action, TraceStatus::progress, "sequenceCycle = ", sequenceCycle);
				FormatTrace(source, action, TraceStatus::progress, "multiplicityCycle = ", multiplicityCycle);
				FormatTrace(source, action, TraceStatus::progress, "volumeCycle = ", volumeCycle);
				FormatTrace(source, action, TraceStatus::progress, "tipRenewalCycleSeq = ", tipRenewalCycleSeq);
				FormatTrace(source, action, TraceStatus::progress, "tipRenewalCycleMul = ", tipRenewalCycleMul);
				FormatTrace(source, action, TraceStatus::progress, "tipRenewalCycleVol = ", tipRenewalCycleVol);
				}
				#endif

				// The max number of positions of the tip eject waste destination has been 
				// aligned with the tip pickup the aspirate and the dispense sequence to 
				// prevent errors when redespesing the rest volume into the waste. So we have 
				// to re-align the max number of positions of the tip eject waste destination.
				AlignSequences(hslTrue, TipEjectWasteDestination, 1);

				#ifdef _DEBUG
				FormatTrace("DEBUG", "ML_STAR.TipEject", TraceStatus::progress,
								"name = ", TipEjectWasteDestination.GetName(), 
								", current = ", TipEjectWasteDestination.GetCurrentPosition(), 
								", count = ", TipEjectWasteDestination.GetCount(),
								", maxPos = ", TipEjectWasteDestination.GetMax());
				#endif

				// Remark: unlike to the TipPickUp, Aspirate and Dispense steps we use 
				// always TipEjectChannelVariable as the tip eject channel pattern

				// whenever the sequence cycle exceeds the sequence tip renewal cycle, or 
				// the multiplicity cycle exceeds the multiplicity tip renewal cycle, or 
				// the volume cycle exceeds the volume tip renewal cycle, 
				// we eject the old tips
				onerror goto TipEjectErrorHandler;
				rc = MlStarSteps::StepTipEject_cer(	ML_STAR,
													TipEjectUseDefaultWaste,
													TipEjectWasteDestination,
													TipEjectSequenceCounting,
													TipEjectChannelVariable,
													TipEjectChannelUse,
													//ErrorHandling,
                                       ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, TipEjectCustomStepID),
                                       TipEjectCustomStepID,
													UserResponseTime);
				onerror goto 0;
				if (!StepReturn::Evaluate(ML_STAR, rc, ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, TipEjectCustomStepID)))
					Error::RaiseLast();
			}
			else
			{

				// Remark: Because the wash sequence is incremented after the needles have been ejected, 
				// we cannot always use TipEjectChannelVariable as the needle eject channel pattern. 
				// Otherwise when we are recovering from an error we could pick up 6 needles with the 
				// pattern "00111111" and eject 8 needles with the pattern "11111111", what cleary crashes.
				// the best we can do is to take the tip presence pattern as the needle eject channel pattern.

				// set the washing state to eject needles
				// (the ErrorHandling and UserResponseTime has already been set)
				SetWashingState(ML_STAR, tipPickupSequence, "NeedleEjectChannelVariable", PCB::GetTipPresence(), 1);
				onerror goto NeedleEjectErrorHandler;
				rc = WCB::NeedleEject(ML_STAR, tipPickupSequence, hslTrue);
				onerror goto 0;
			}

			// update tip presence
			PCB::SetTipPresence(TipEjectChannelVariable, 
									  StrGetLength(TipEjectChannelVariable), hslFalse);

			// reset TipPickupEnabled control setting
			TipPickupEnabled = hslTrue;

			// reset the sequence cycle
			if (tipRenewalCycleSeq <= sequenceCycle)
				sequenceCycle = multiplicityCycle = volumeCycle = 0;

			// reset multiplicity
			if (tipRenewalCycleMul <= multiplicityCycle)
				multiplicityCycle = volumeCycle = 0;

			// reset the volume cycle
			if (tipRenewalCycleVol <= volumeCycle)
				volumeCycle = 0;
		}

		return(rc);

		TipEjectErrorHandler:
		{
			// bind error data
			StepReturn::Bind(rc);
			resume next;
		}

		NeedleEjectErrorHandler:
		{
			// bind error data
			StepReturn::Bind(rc);
			resume next;
		}
	}

	static function DumpParams(
		device& ML_STAR,
		sequence& tipPickupSequence,
		sequence& aspirateSequence,
		sequence& dispenseSequence,
		variable aspirateMultiplicity,
		variable dispenseMultiplicity,
		variable pipettingVolume,
		variable restVolume,
		variable drivingMode,
		variable tipRenewalCycleSeq,
		variable tipRenewalCycleMul,
		variable tipRenewalCycleVol)

	{
		#ifdef _DEBUG
		variable source;
		variable action;
		variable renewalCycleSeq;
		variable renewalCycleMul;
		variable renewalCycleVol;

		source = "DEBUG";
		action = GetFunctionName();

		renewalCycleSeq = tipRenewalCycleSeq;
		if (hslInfinite == tipRenewalCycleSeq)
			renewalCycleSeq = "infinite";
		renewalCycleMul = tipRenewalCycleMul;
		if (hslInfinite == tipRenewalCycleMul)
			renewalCycleMul = "infinite";
		renewalCycleVol = tipRenewalCycleVol;
		if (hslInfinite == tipRenewalCycleVol)
			renewalCycleVol = "infinite";
		
		FormatTrace(source, action, TraceStatus::progress, "ML_STAR = ", ML_STAR);
		FormatTrace(source, action, TraceStatus::progress, "tipPickupSequence.name = ", tipPickupSequence.GetName());
		FormatTrace(source, action, TraceStatus::progress, "tipPickupSequence.current = ", tipPickupSequence.GetCurrentPosition());
		FormatTrace(source, action, TraceStatus::progress, "tipPickupSequence.count = ", tipPickupSequence.GetCount());
		FormatTrace(source, action, TraceStatus::progress, "tipPickupSequence.total = ", tipPickupSequence.GetTotal());
		FormatTrace(source, action, TraceStatus::progress, "tipPickupSequence.maxPos = ", tipPickupSequence.GetMax());
		FormatTrace(source, action, TraceStatus::progress, "aspirateSequence.name = ", aspirateSequence.GetName());
		FormatTrace(source, action, TraceStatus::progress, "aspirateSequence.current = ", aspirateSequence.GetCurrentPosition());
		FormatTrace(source, action, TraceStatus::progress, "aspirateSequence.count = ", aspirateSequence.GetCount());
		FormatTrace(source, action, TraceStatus::progress, "aspirateSequence.total = ", aspirateSequence.GetTotal());
		FormatTrace(source, action, TraceStatus::progress, "aspirateSequence.maxPos = ", aspirateSequence.GetMax());
		FormatTrace(source, action, TraceStatus::progress, "dispenseSequence.name = ", dispenseSequence.GetName());
		FormatTrace(source, action, TraceStatus::progress, "dispenseSequence.current = ", dispenseSequence.GetCurrentPosition());
		FormatTrace(source, action, TraceStatus::progress, "dispenseSequence.count = ", dispenseSequence.GetCount());
		FormatTrace(source, action, TraceStatus::progress, "dispenseSequence.total = ", dispenseSequence.GetTotal());
		FormatTrace(source, action, TraceStatus::progress, "dispenseSequence.maxPos = ", dispenseSequence.GetMax());
		FormatTrace(source, action, TraceStatus::progress, "aspirateMultiplicity = ", aspirateMultiplicity);
		FormatTrace(source, action, TraceStatus::progress, "dispenseMultiplicity = ", dispenseMultiplicity);
		FormatTrace(source, action, TraceStatus::progress, "pipettingVolume = ", pipettingVolume);
		FormatTrace(source, action, TraceStatus::progress, "restVolume = ", restVolume);
		FormatTrace(source, action, TraceStatus::progress, "drivingMode = ", DrivingMode::AsString(drivingMode));
		FormatTrace(source, action, TraceStatus::progress, "tipRenewalCycleSeq = ", renewalCycleSeq);
		FormatTrace(source, action, TraceStatus::progress, "tipRenewalCycleMul = ", renewalCycleMul);
		FormatTrace(source, action, TraceStatus::progress, "tipRenewalCycleVol = ", renewalCycleVol);
		#endif
	}

	namespace PCB
	{

		static function Dump()
		{
			#ifdef _DEBUG
			variable source;
			variable action;
			variable userResponseTime;

			source = "DEBUG";
			action = GetFunctionName();

			userResponseTime = UserResponseTime;
			if (Limits::maxTimeInterval == UserResponseTime)
				userResponseTime = "infinite";

			// general settings 
			FormatTrace(source, action, TraceStatus::progress, "UserResponseTime = ", userResponseTime);
			FormatTrace(source, action, TraceStatus::progress, "ErrorHandling = ", ErrorHandling::AsString(ErrorHandling));
			FormatTrace(source, action, TraceStatus::progress, "TipCountingEnabled = ", TipCountingEnabled);
			FormatTrace(source, action, TraceStatus::progress, "TipCountingIdentifier = ", TipCountingIdentifier);
			FormatTrace(source, action, TraceStatus::progress, "CopyPatternEnabled = ", CopyPatternEnabled);
			FormatTrace(source, action, TraceStatus::progress, "ExcludeErrorPositionsEnabled = ", ExcludeErrorPositionsEnabled);

			// aliquot settings 
			FormatTrace(source, action, TraceStatus::progress, "AliquotEnabled = ", AliquotEnabled);
			FormatTrace(source, action, TraceStatus::progress, "AliquotPreAspirateVolume = ", AliquotPreAspirateVolume);
			FormatTrace(source, action, TraceStatus::progress, "AliquotAspirateDefaultMixingEnabled = ", AliquotAspirateDefaultMixingEnabled);
			FormatTrace(source, action, TraceStatus::progress, "AliquotPreAspiratePrerinsingMixCycles = ", AliquotPreAspiratePrerinsingMixCycles);
			FormatTrace(source, action, TraceStatus::progress, "AliquotPreAspiratePrerinsingMixPosition = ", AliquotPreAspiratePrerinsingMixPosition);
			FormatTrace(source, action, TraceStatus::progress, "AliquotPreAspiratePrerinsingMixVolumeMultiplier = ", AliquotPreAspiratePrerinsingMixVolumeMultiplier);

			// initialize settings 
			FormatTrace(source, action, TraceStatus::progress, "InitializeUseDefaultWaste = ", InitializeUseDefaultWaste);
			FormatTrace(source, action, TraceStatus::progress, "InitializeWasteDestination.name = ", InitializeWasteDestination.GetName());
			FormatTrace(source, action, TraceStatus::progress, "InitializeWasteDestination.current = ", InitializeWasteDestination.GetCurrentPosition());
			FormatTrace(source, action, TraceStatus::progress, "InitializeWasteDestination.count = ", InitializeWasteDestination.GetCount());
			FormatTrace(source, action, TraceStatus::progress, "InitializeWasteDestination.total = ", InitializeWasteDestination.GetTotal());
			FormatTrace(source, action, TraceStatus::progress, "InitializeWasteDestination.maxPos = ", InitializeWasteDestination.GetMax());
			FormatTrace(source, action, TraceStatus::progress, "InitializeChannelVariable = ", InitializeChannelVariable);
			FormatTrace(source, action, TraceStatus::progress, "InitializeSequenceCounting = ", SequenceCounting::AsString(InitializeSequenceCounting));
			FormatTrace(source, action, TraceStatus::progress, "InitializeChannelUse = ", ChannelUse::AsString(InitializeChannelUse));
			FormatTrace(source, action, TraceStatus::progress, "InitializeAlways = ", InitializeAlways);
			FormatTrace(source, action, TraceStatus::progress, "InitializeEnabled = ", InitializeEnabled);
			FormatTrace(source, action, TraceStatus::progress, "InitializeWasteDestinationReloadable = ", InitializeWasteDestinationReloadable);
			FormatTrace(source, action, TraceStatus::progress, "InitializeWasteDestinationReducible = ", InitializeWasteDestinationReducible);
			FormatTrace(source, action, TraceStatus::progress, "InitializeCustomStepID = ", InitializeCustomStepID);

			// load carrier settings 
			FormatTrace(source, action, TraceStatus::progress, "LoadCarrierBarcodeFileName = ", LoadCarrierBarcodeFileName);
			FormatTrace(source, action, TraceStatus::progress, "LoadCarrierCustomStepID = ", LoadCarrierCustomStepID);

			// unload carrier settings 
			FormatTrace(source, action, TraceStatus::progress, "UnloadCarrierCustomStepID = ", UnloadCarrierCustomStepID);

			// calibrate carrier settings 
			FormatTrace(source, action, TraceStatus::progress, "CalibrateCarrierChannel = ", CalibrateCarrierChannel);
			FormatTrace(source, action, TraceStatus::progress, "CalibrateCarrierCustomStepID = ", CalibrateCarrierCustomStepID);

			// tip pickup settings 
			FormatTrace(source, action, TraceStatus::progress, "TipPickupSequence.name = ", TipPickupSequence.GetName());
			FormatTrace(source, action, TraceStatus::progress, "TipPickupSequence.current = ", TipPickupSequence.GetCurrentPosition());
			FormatTrace(source, action, TraceStatus::progress, "TipPickupSequence.count = ", TipPickupSequence.GetCount());
			FormatTrace(source, action, TraceStatus::progress, "TipPickupSequence.total = ", TipPickupSequence.GetTotal());
			FormatTrace(source, action, TraceStatus::progress, "TipPickupSequence.maxPos = ", TipPickupSequence.GetMax());
			FormatTrace(source, action, TraceStatus::progress, "TipPickupChannelVariable = ", TipPickupChannelVariable);
			FormatTrace(source, action, TraceStatus::progress, "TipPickupSequenceCounting = ", SequenceCounting::AsString(TipPickupSequenceCounting));
			FormatTrace(source, action, TraceStatus::progress, "TipPickupChannelUse = ", ChannelUse::AsString(TipPickupChannelUse));
			FormatTrace(source, action, TraceStatus::progress, "TipPickupEnabled = ", TipPickupEnabled);
			FormatTrace(source, action, TraceStatus::progress, "TipPickupSequenceReloadable = ", TipPickupSequenceReloadable);
			FormatTrace(source, action, TraceStatus::progress, "TipPickupSequenceReducible = ", TipPickupSequenceReducible);
			FormatTrace(source, action, TraceStatus::progress, "TipPickupSequenceCurrentInitialization = ", SequenceInitialization::AsString(TipPickupSequenceCurrentInitialization));
			FormatTrace(source, action, TraceStatus::progress, "TipPickupSequenceCurrentFinalization = ", SequenceFinalization::AsString(TipPickupSequenceCurrentFinalization));
			FormatTrace(source, action, TraceStatus::progress, "TipPickupSequenceCountInitialization = ", SequenceInitialization::AsString(TipPickupSequenceCountInitialization));
			FormatTrace(source, action, TraceStatus::progress, "TipPickupSequenceCountFinalization = ", SequenceFinalization::AsString(TipPickupSequenceCountFinalization));
			FormatTrace(source, action, TraceStatus::progress, "TipPickupReverseSequenceCount = ", TipPickupReverseSequenceCount);
			FormatTrace(source, action, TraceStatus::progress, "TipPickupCustomStepID = ", TipPickupCustomStepID);

			// tip eject settings 
			FormatTrace(source, action, TraceStatus::progress, "TipEjectUseDefaultWaste = ", TipEjectUseDefaultWaste);
			FormatTrace(source, action, TraceStatus::progress, "TipEjectWasteDestination.name = ", TipEjectWasteDestination.GetName());
			FormatTrace(source, action, TraceStatus::progress, "TipEjectWasteDestination.current = ", TipEjectWasteDestination.GetCurrentPosition());
			FormatTrace(source, action, TraceStatus::progress, "TipEjectWasteDestination.count = ", TipEjectWasteDestination.GetCount());
			FormatTrace(source, action, TraceStatus::progress, "TipEjectWasteDestination.total = ", TipEjectWasteDestination.GetTotal());
			FormatTrace(source, action, TraceStatus::progress, "TipEjectWasteDestination.maxPos = ", TipEjectWasteDestination.GetMax());
			FormatTrace(source, action, TraceStatus::progress, "TipEjectChannelVariable = ", TipEjectChannelVariable);
			FormatTrace(source, action, TraceStatus::progress, "TipEjectChannelUse = ", ChannelUse::AsString(TipEjectChannelUse));
			FormatTrace(source, action, TraceStatus::progress, "TipEjectSequenceCounting = ", SequenceCounting::AsString(TipEjectSequenceCounting));
			FormatTrace(source, action, TraceStatus::progress, "TipEjectWasteDestinationReloadable = ", TipEjectWasteDestinationReloadable);
			FormatTrace(source, action, TraceStatus::progress, "TipEjectWasteDestinationReducible = ", TipEjectWasteDestinationReducible);
         FormatTrace(source, action, TraceStatus::progress, "TipEjectCustomStepID = ", TipEjectCustomStepID);

			// aspirate settings 
			FormatTrace(source, action, TraceStatus::progress, "AspirateSequence.name = ", AspirateSequence.GetName());
			FormatTrace(source, action, TraceStatus::progress, "AspirateSequence.current = ", AspirateSequence.GetCurrentPosition());
			FormatTrace(source, action, TraceStatus::progress, "AspirateSequence.count = ", AspirateSequence.GetCount());
			FormatTrace(source, action, TraceStatus::progress, "AspirateSequence.total = ", AspirateSequence.GetTotal());
			FormatTrace(source, action, TraceStatus::progress, "AspirateSequence.maxPos = ", AspirateSequence.GetMax());
			FormatTrace(source, action, TraceStatus::progress, "AspirateSequenceOriginal.name = ", AspirateSequenceOriginal.GetName());
			FormatTrace(source, action, TraceStatus::progress, "AspirateSequenceOriginal.current = ", AspirateSequenceOriginal.GetCurrentPosition());
			FormatTrace(source, action, TraceStatus::progress, "AspirateSequenceOriginal.count = ", AspirateSequenceOriginal.GetCount());
			FormatTrace(source, action, TraceStatus::progress, "AspirateSequenceOriginal.total = ", AspirateSequenceOriginal.GetTotal());
			FormatTrace(source, action, TraceStatus::progress, "AspirateSequenceOriginal.maxPos = ", AspirateSequenceOriginal.GetMax());
			FormatTrace(source, action, TraceStatus::progress, "AspirateSequenceCounting = ", SequenceCounting::AsString(AspirateSequenceCounting));
			FormatTrace(source, action, TraceStatus::progress, "AspirateChannelUse = ", ChannelUse::AsString(AspirateChannelUse));
			FormatTrace(source, action, TraceStatus::progress, "AspirateMode = ", AspirateMode::AsString(AspirateMode));
			FormatTrace(source, action, TraceStatus::progress, "AspirateCLLDSensitivity = ", LLDSensitivity::AsString(AspirateCLLDSensitivity));
			FormatTrace(source, action, TraceStatus::progress, "AspirateFluidHeight = ", AspirateFluidHeight);
			FormatTrace(source, action, TraceStatus::progress, "AspirateSubmergeDepth = ", AspirateSubmergeDepth);
			FormatTrace(source, action, TraceStatus::progress, "AspirateVolume = ", AspirateVolume);
			FormatTrace(source, action, TraceStatus::progress, "AspirateRestVolume = ", AspirateRestVolume);
			FormatTrace(source, action, TraceStatus::progress, "AspirateChannelVariable = ", AspirateChannelVariable);
			FormatTrace(source, action, TraceStatus::progress, "AspirateMaxHeightDiff = ", AspirateMaxHeightDiff);
			FormatTrace(source, action, TraceStatus::progress, "AspiratePLLDSensitivity = ", LLDSensitivity::AsString(AspiratePLLDSensitivity));
			FormatTrace(source, action, TraceStatus::progress, "AspirateLiquidFollowing = ", AspirateLiquidFollowing);
			FormatTrace(source, action, TraceStatus::progress, "AspiratePrerinsingMixCycles = ", AspiratePrerinsingMixCycles);
			FormatTrace(source, action, TraceStatus::progress, "AspiratePrerinsingMixPosition = ", AspiratePrerinsingMixPosition);
			FormatTrace(source, action, TraceStatus::progress, "AspiratePrerinsingMixVolume = ", AspiratePrerinsingMixVolume);
			FormatTrace(source, action, TraceStatus::progress, "AspirateUserDefinedLiquidClass = ", AspirateUserDefinedLiquidClass);
			FormatTrace(source, action, TraceStatus::progress, "AspirateSequenceReloadable = ", AspirateSequenceReloadable);
			FormatTrace(source, action, TraceStatus::progress, "AspirateSequenceReducible = ", AspirateSequenceReducible);
			FormatTrace(source, action, TraceStatus::progress, "AspirateSequenceCurrentInitialization = ", SequenceInitialization::AsString(AspirateSequenceCurrentInitialization));
			FormatTrace(source, action, TraceStatus::progress, "AspirateSequenceCurrentFinalization = ", SequenceFinalization::AsString(AspirateSequenceCurrentFinalization));
			FormatTrace(source, action, TraceStatus::progress, "AspirateSequenceCountInitialization = ", SequenceInitialization::AsString(AspirateSequenceCountInitialization));
			FormatTrace(source, action, TraceStatus::progress, "AspirateSequenceCountFinalization = ", SequenceFinalization::AsString(AspirateSequenceCountFinalization));
			FormatTrace(source, action, TraceStatus::progress, "AspirateSequenceCalibration = ", AspirateSequenceCalibration);
         FormatTrace(source, action, TraceStatus::progress, "AspirateCustomStepID = ", AspirateCustomStepID);

			// dispense settings 
			FormatTrace(source, action, TraceStatus::progress, "DispenseSequence.name = ", DispenseSequence.GetName());
			FormatTrace(source, action, TraceStatus::progress, "DispenseSequence.current = ", DispenseSequence.GetCurrentPosition());
			FormatTrace(source, action, TraceStatus::progress, "DispenseSequence.count = ", DispenseSequence.GetCount());
			FormatTrace(source, action, TraceStatus::progress, "DispenseSequence.total = ", DispenseSequence.GetTotal());
			FormatTrace(source, action, TraceStatus::progress, "DispenseSequence.maxPos = ", DispenseSequence.GetMax());
			FormatTrace(source, action, TraceStatus::progress, "DispenseSequenceOriginal.name = ", DispenseSequenceOriginal.GetName());
			FormatTrace(source, action, TraceStatus::progress, "DispenseSequenceOriginal.current = ", DispenseSequenceOriginal.GetCurrentPosition());
			FormatTrace(source, action, TraceStatus::progress, "DispenseSequenceOriginal.count = ", DispenseSequenceOriginal.GetCount());
			FormatTrace(source, action, TraceStatus::progress, "DispenseSequenceOriginal.total = ", DispenseSequenceOriginal.GetTotal());
			FormatTrace(source, action, TraceStatus::progress, "DispenseSequenceOriginal.maxPos = ", DispenseSequenceOriginal.GetMax());
			FormatTrace(source, action, TraceStatus::progress, "DispenseSubmergeDepth = ", DispenseSubmergeDepth);
			FormatTrace(source, action, TraceStatus::progress, "DispenseChannelVariable = ", DispenseChannelVariable);
			FormatTrace(source, action, TraceStatus::progress, "DispenseVolume = ", DispenseVolume);
			FormatTrace(source, action, TraceStatus::progress, "DispenseRestVolume = ", DispenseRestVolume);
			FormatTrace(source, action, TraceStatus::progress, "DispenseRestVolumeDestination = ", RestVolumeDestination::AsString(DispenseRestVolumeDestination));
			FormatTrace(source, action, TraceStatus::progress, "DispenseRestVolumeFluidHeight = ", DispenseRestVolumeFluidHeight);
			FormatTrace(source, action, TraceStatus::progress, "DispenseRestVolumeConstFluidHeight = ", DispenseRestVolumeConstFluidHeight);
			// ba 20050511 begin (SCR#736)
			FormatTrace(source, action, TraceStatus::progress, "DispenseRestVolumeToAspirateSequenceSurface = ", DispenseRestVolumeToAspirateSequenceSurface);
			// ba 20050511 end (SCR#736)
			FormatTrace(source, action, TraceStatus::progress, "DispenseChannelUse = ", ChannelUse::AsString(DispenseChannelUse));
			FormatTrace(source, action, TraceStatus::progress, "DispenseCLLDSensitivity = ", LLDSensitivity::AsString(DispenseCLLDSensitivity));
			FormatTrace(source, action, TraceStatus::progress, "DispenseSequenceCounting = ", SequenceCounting::AsString(DispenseSequenceCounting));
			FormatTrace(source, action, TraceStatus::progress, "DispenseFluidHeight = ", DispenseFluidHeight);
			FormatTrace(source, action, TraceStatus::progress, "DispenseMode = ", DispenseMode::AsString(DispenseMode));
			FormatTrace(source, action, TraceStatus::progress, "DispenseLiquidFollowing = ", DispenseLiquidFollowing);
			FormatTrace(source, action, TraceStatus::progress, "DispensePrerinsingMixCycles = ", DispensePrerinsingMixCycles);
			FormatTrace(source, action, TraceStatus::progress, "DispensePrerinsingMixPosition = ", DispensePrerinsingMixPosition);
			FormatTrace(source, action, TraceStatus::progress, "DispensePrerinsingMixVolume = ", DispensePrerinsingMixVolume);
			FormatTrace(source, action, TraceStatus::progress, "DispenseUserDefinedLiquidClass = ", DispenseUserDefinedLiquidClass);
			FormatTrace(source, action, TraceStatus::progress, "DispenseSequenceReloadable = ", DispenseSequenceReloadable);
			FormatTrace(source, action, TraceStatus::progress, "DispenseSequenceReducible = ", DispenseSequenceReducible);
			FormatTrace(source, action, TraceStatus::progress, "DispenseSequenceCurrentInitialization = ", SequenceInitialization::AsString(DispenseSequenceCurrentInitialization));
			FormatTrace(source, action, TraceStatus::progress, "DispenseSequenceCurrentFinalization = ", SequenceFinalization::AsString(DispenseSequenceCurrentFinalization));
			FormatTrace(source, action, TraceStatus::progress, "DispenseSequenceCountInitialization = ", SequenceInitialization::AsString(DispenseSequenceCountInitialization));
			FormatTrace(source, action, TraceStatus::progress, "DispenseSequenceCountFinalization = ", SequenceFinalization::AsString(DispenseSequenceCountFinalization));
			FormatTrace(source, action, TraceStatus::progress, "DispenseSequenceCalibration = ", DispenseSequenceCalibration);
         FormatTrace(source, action, TraceStatus::progress, "DispenseCustomStepID = ", DispenseCustomStepID);
         FormatTrace(source, action, TraceStatus::progress, "PreDispenseCustomStepID = ", PreDispenseCustomStepID);
         FormatTrace(source, action, TraceStatus::progress, "PostDispenseCustomStepID = ", PostDispenseCustomStepID);

			// wait needle wash settings 
			FormatTrace(source, action, TraceStatus::progress, "WaitNeedleWashCustomStepID = ", WaitNeedleWashCustomStepID);

			// start needle wash settings 
			FormatTrace(source, action, TraceStatus::progress, "StartNeedleWashCustomStepID = ", StartNeedleWashCustomStepID);

			#endif
		}

		static function DumpSequences()

		{
			#ifdef _DEBUG
			// dump sequences
			DumpSequence(TipPickupSequence, hslTrue);
			DumpSequence(AspirateSequence, hslTrue);
			DumpSequence(DispenseSequence, hslTrue);
			#endif
		}

		static function DumpSequence(sequence& sequenceObj, variable indexesOnly)

		{
			#ifdef _DEBUG
			variable currentPos(0);										// current position
			variable currentPosBak(0);									// backup of inital current position
			variable countPosBak(0);									// backup of inital count position
			variable source;
			variable action;
			source = StringTable::Load(IDS::traceSource);
			action = StringTable::Load(IDS::smartStepPipette);

			// dump indexes
			FormatTrace(source, action, TraceStatus::progress, "name = ", sequenceObj.GetName());
			FormatTrace(source, action, TraceStatus::progress, "current = ", sequenceObj.GetCurrentPosition());
			FormatTrace(source, action, TraceStatus::progress, "count = ", sequenceObj.GetCount());
			FormatTrace(source, action, TraceStatus::progress, "total = ", sequenceObj.GetTotal());
			FormatTrace(source, action, TraceStatus::progress, "maxPos = ", sequenceObj.GetMax());
			FormatTrace(source, action, TraceStatus::progress, "usedPos = ", sequenceObj.GetUsedPositions());

			// dump positions
			if (!indexesOnly)
			{

				// backup current position
				currentPosBak = sequenceObj.GetCurrentPosition();

				// backup count position
				countPosBak = sequenceObj.GetCount();

				sequenceObj.SetCount(sequenceObj.GetTotal());
				for (currentPos = sequenceObj.SetCurrentPosition(1); currentPos != 0; currentPos = sequenceObj.Increment(1))
					 FormatTrace(source, action, TraceStatus::progress, 
									"labwareId = ", sequenceObj.GetLabwareId(), ", positionId = ", sequenceObj.GetPositionId());

				// restore count position
				sequenceObj.SetCount(countPosBak);

				// restore current position
				sequenceObj.SetCurrentPosition(currentPosBak);
			}

			#endif
		}

		static function Validate()
		{
			// check aspirate mode
			PCB::CheckAspirateMode();

			return(hslTrue);
		}

		static function GetState(
			variable& pcbKey,
			variable& pcbValue)
		{
			// initialize output
			pcbValue = 0;
			
			// get value for pipetting control key,
			// switch over PCB entries

			// general settings
			if (pcbKey == "UserResponseTime")
			{
				pcbValue = UserResponseTime;
				return(hslTrue);
			}
			if (pcbKey == "ErrorHandling")
			{
				pcbValue = ErrorHandling;
				return(hslTrue);
			}
			if (pcbKey == "TipCountingEnabled")
			{
				pcbValue = TipCountingEnabled;
				return(hslTrue);
			}
			if (pcbKey == "TipCountingIdentifier")
			{
				pcbValue = TipCountingIdentifier;
				return(hslTrue);
			}
			if (pcbKey == "CopyPatternEnabled")
			{
				pcbValue = CopyPatternEnabled;
				return(hslTrue);
			}
			if (pcbKey == "ExcludeErrorPositionsEnabled")
			{
				pcbValue = ExcludeErrorPositionsEnabled;
				return(hslTrue);
			}

			// aliquot settings 
			if (pcbKey == "AliquotEnabled")
			{
				pcbValue = AliquotEnabled;
				return(hslTrue);
			}
			if (pcbKey == "AliquotPreAspirateVolume")
			{
				pcbValue = AliquotPreAspirateVolume;
				return(hslTrue);
			}
			if (pcbKey == "AliquotAspirateDefaultMixingEnabled")
			{
				pcbValue = AliquotAspirateDefaultMixingEnabled;
				return(hslTrue);
			}

			// initialize settings 
			if (pcbKey == "InitializeUseDefaultWaste")
			{
				pcbValue = InitializeUseDefaultWaste;
				return(hslTrue);
			}
			if (pcbKey == "InitializeChannelVariable")
			{
				pcbValue = InitializeChannelVariable;
				return(hslTrue);
			}
			if (pcbKey == "InitializeSequenceCounting")
			{
				pcbValue = InitializeSequenceCounting;
				return(hslTrue);
			}
			if (pcbKey == "InitializeChannelUse")
			{
				pcbValue = InitializeChannelUse;
				return(hslTrue);
			}
			if (pcbKey == "InitializeAlways")
			{
				pcbValue = InitializeAlways;
				return(hslTrue);
			}
			if (pcbKey == "InitializeEnabled")
			{
				pcbValue = InitializeEnabled;
				return(hslTrue);
			}
			if (pcbKey == "InitializeWasteDestinationReloadable")
			{
				pcbValue = InitializeWasteDestinationReloadable;
				return(hslTrue);
			}
			if (pcbKey == "InitializeWasteDestinationReducible")
			{
				pcbValue = InitializeWasteDestinationReducible;
				return(hslTrue);
			}
         if (pcbKey == "InitializeCustomStepID")
			{
				pcbValue = InitializeCustomStepID;
				return(hslTrue);
			}

			// load carrier settings 
			if (pcbKey == "LoadCarrierBarcodeFileName")
			{
				pcbValue = LoadCarrierBarcodeFileName;
				return(hslTrue);
			}
         if (pcbKey == "LoadCarrierCustomStepID")
			{
				pcbValue = LoadCarrierCustomStepID;
				return(hslTrue);
			}

			// unload carrier settings 
         if (pcbKey == "UnloadCarrierCustomStepID")
			{
				pcbValue = UnloadCarrierCustomStepID;
				return(hslTrue);
			}

			// calibrate carrier settings 
			if (pcbKey == "CalibrateCarrierChannel")
			{
				pcbValue = CalibrateCarrierChannel;
				return(hslTrue);
			}
         if (pcbKey == "CalibrateCarrierCustomStepID")
			{
				pcbValue = CalibrateCarrierCustomStepID;
				return(hslTrue);
			}

			// tip pickup settings 
			if (pcbKey == "TipPickupChannelVariable")
			{
				pcbValue = TipPickupChannelVariable;
				return(hslTrue);
			}
			if (pcbKey == "TipPickupSequenceCounting")
			{
				pcbValue = TipPickupSequenceCounting;
				return(hslTrue);
			}
			if (pcbKey == "TipPickupChannelUse")
			{
				pcbValue = TipPickupChannelUse;
				return(hslTrue);
			}
			if (pcbKey == "TipPickupEnabled")
			{
				pcbValue = TipPickupEnabled;
				return(hslTrue);
			}
			if (pcbKey == "TipPickupSequenceReloadable")
			{
				pcbValue = TipPickupSequenceReloadable;
				return(hslTrue);
			}
			if (pcbKey == "TipPickupSequenceReducible")
			{
				pcbValue = TipPickupSequenceReducible;
				return(hslTrue);
			}
			if (pcbKey == "TipPickupSequenceCurrentInitialization")
			{
				pcbValue = TipPickupSequenceCurrentInitialization;
				return(hslTrue);
			}
			if (pcbKey == "TipPickupSequenceCurrentFinalization")
			{
				pcbValue = TipPickupSequenceCurrentFinalization;
				return(hslTrue);
			}
			if (pcbKey == "TipPickupSequenceCountInitialization")
			{
				pcbValue = TipPickupSequenceCountInitialization;
				return(hslTrue);
			}
			if (pcbKey == "TipPickupSequenceCountFinalization")
			{
				pcbValue = TipPickupSequenceCountFinalization;
				return(hslTrue);
			}
			if (pcbKey == "TipPickupReverseSequenceCount")
			{
				pcbValue = TipPickupReverseSequenceCount;
				return(hslTrue);
			}
         if (pcbKey == "TipPickupCustomStepID")
			{
				pcbValue = TipPickupCustomStepID;
				return(hslTrue);
			}

			// tip eject settings 
			if (pcbKey == "TipEjectUseDefaultWaste")
			{
				pcbValue = TipEjectUseDefaultWaste;
				return(hslTrue);
			}
			if (pcbKey == "TipEjectChannelVariable")
			{
				pcbValue = TipEjectChannelVariable;
				return(hslTrue);
			}
			if (pcbKey == "TipEjectChannelUse")
			{
				pcbValue = TipEjectChannelUse;
				return(hslTrue);
			}
			if (pcbKey == "TipEjectSequenceCounting")
			{
				pcbValue = TipEjectSequenceCounting;
				return(hslTrue);
			}
			if (pcbKey == "TipEjectWasteDestinationReloadable")
			{
				pcbValue = TipEjectWasteDestinationReloadable;
				return(hslTrue);
			}
			if (pcbKey == "TipEjectWasteDestinationReducible")
			{
				pcbValue = TipEjectWasteDestinationReducible;
				return(hslTrue);
			}
         if (pcbKey == "TipEjectCustomStepID")
			{
				pcbValue = TipEjectCustomStepID;
				return(hslTrue);
			}

			// aspirate settings 
			if (pcbKey == "AspirateSequenceCounting")
			{
				pcbValue = AspirateSequenceCounting;
				return(hslTrue);
			}
			if (pcbKey == "AspirateChannelUse")
			{
				pcbValue = AspirateChannelUse;
				return(hslTrue);
			}
			if (pcbKey == "AspirateMode")
			{
				pcbValue = AspirateMode;
				return(hslTrue);
			}
			if (pcbKey == "AspirateCLLDSensitivity")
			{
				pcbValue = AspirateCLLDSensitivity;
				return(hslTrue);
			}
			if (pcbKey == "AspirateFluidHeight")
			{
				pcbValue = AspirateFluidHeight;
				return(hslTrue);
			}
			if (pcbKey == "AspirateSubmergeDepth")
			{
				pcbValue = AspirateSubmergeDepth;
				return(hslTrue);
			}
			if (pcbKey == "AspirateVolume")
			{
				pcbValue = AspirateVolume;
				return(hslTrue);
			}
			if (pcbKey == "AspirateRestVolume")
			{
				pcbValue = AspirateRestVolume;
				return(hslTrue);
			}
			if (pcbKey == "AspirateChannelVariable")
			{
				pcbValue = AspirateChannelVariable;
				return(hslTrue);
			}
			if (pcbKey == "AspirateMaxHeightDiff")
			{
				pcbValue = AspirateMaxHeightDiff;
				return(hslTrue);
			}
			if (pcbKey == "AspiratePLLDSensitivity")
			{
				pcbValue = AspiratePLLDSensitivity;
				return(hslTrue);
			}
			if (pcbKey == "AspirateLiquidFollowing")
			{
				pcbValue = AspirateLiquidFollowing;
				return(hslTrue);
			}
			if (pcbKey == "AspiratePrerinsingMixCycles")
			{
				pcbValue = AspiratePrerinsingMixCycles;
				return(hslTrue);
			}
			if (pcbKey == "AspiratePrerinsingMixPosition")
			{
				pcbValue = AspiratePrerinsingMixPosition;
				return(hslTrue);
			}
			if (pcbKey == "AspiratePrerinsingMixVolume")
			{
				pcbValue = AspiratePrerinsingMixVolume;
				return(hslTrue);
			}
			if (pcbKey == "AspirateUserDefinedLiquidClass")
			{
				pcbValue = AspirateUserDefinedLiquidClass;
				return(hslTrue);
			}
			if (pcbKey == "AspirateSequenceReloadable")
			{
				pcbValue = AspirateSequenceReloadable;
				return(hslTrue);
			}
			if (pcbKey == "AspirateSequenceReducible")
			{
				pcbValue = AspirateSequenceReducible;
				return(hslTrue);
			}
			if (pcbKey == "AspirateSequenceCurrentInitialization")
			{
				pcbValue = AspirateSequenceCurrentInitialization;
				return(hslTrue);
			}
			if (pcbKey == "AspirateSequenceCurrentFinalization")
			{
				pcbValue = AspirateSequenceCurrentFinalization;
				return(hslTrue);
			}
			if (pcbKey == "AspirateSequenceCountInitialization")
			{
				pcbValue = AspirateSequenceCountInitialization;
				return(hslTrue);
			}
			if (pcbKey == "AspirateSequenceCountFinalization")
			{
				pcbValue = AspirateSequenceCountFinalization;
				return(hslTrue);
			}
			if (pcbKey == "AspirateSequenceCalibration")
			{
				pcbValue = AspirateSequenceCalibration;
				return(hslTrue);
			}
         if (pcbKey == "AspirateCustomStepID")
			{
				pcbValue = AspirateCustomStepID;
				return(hslTrue);
			}

			// dispense settings 
			if (pcbKey == "DispenseSubmergeDepth")
			{
				pcbValue = DispenseSubmergeDepth;
				return(hslTrue);
			}
			if (pcbKey == "DispenseChannelVariable")
			{
				pcbValue = DispenseChannelVariable;
				return(hslTrue);
			}
			if (pcbKey == "DispenseVolume")
			{
				pcbValue = DispenseVolume;
				return(hslTrue);
			}
			if (pcbKey == "DispenseRestVolume")
			{
				pcbValue = DispenseRestVolume;
				return(hslTrue);
			}
			if (pcbKey == "DispenseRestVolumeDestination")
			{
				pcbValue = DispenseRestVolumeDestination;
				return(hslTrue);
			}
			if (pcbKey == "DispenseRestVolumeFluidHeight")
			{
				pcbValue = DispenseRestVolumeFluidHeight;
				return(hslTrue);
			}
			// ba 20050511 begin (SCR#736)
			if (pcbKey == "DispenseRestVolumeToAspirateSequenceSurface")
			{
				pcbValue = DispenseRestVolumeToAspirateSequenceSurface;
				return(hslTrue);
			}
			// ba 20050511 end (SCR#736)
			if (pcbKey == "DispenseChannelUse")
			{
				pcbValue = DispenseChannelUse;
				return(hslTrue);
			}
			if (pcbKey == "DispenseCLLDSensitivity")
			{
				pcbValue = DispenseCLLDSensitivity;
				return(hslTrue);
			}
			if (pcbKey == "DispenseSequenceCounting")
			{
				pcbValue = DispenseSequenceCounting;
				return(hslTrue);
			}
			if (pcbKey == "DispenseFluidHeight")
			{
				pcbValue = DispenseFluidHeight;
				return(hslTrue);
			}
			if (pcbKey == "DispenseMode")
			{
				pcbValue = DispenseMode;
				return(hslTrue);
			}
			if (pcbKey == "DispenseLiquidFollowing")
			{
				pcbValue = DispenseLiquidFollowing;
				return(hslTrue);
			}
			if (pcbKey == "DispensePrerinsingMixCycles")
			{
				pcbValue = DispensePrerinsingMixCycles;
				return(hslTrue);
			}
			if (pcbKey == "DispensePrerinsingMixPosition")
			{
				pcbValue = DispensePrerinsingMixPosition;
				return(hslTrue);
			}
			if (pcbKey == "DispensePrerinsingMixVolume")
			{
				pcbValue = DispensePrerinsingMixVolume;
				return(hslTrue);
			}
			if (pcbKey == "DispenseUserDefinedLiquidClass")
			{
				pcbValue = DispenseUserDefinedLiquidClass;
				return(hslTrue);
			}
			if (pcbKey == "DispenseSequenceReloadable")
			{
				pcbValue = DispenseSequenceReloadable;
				return(hslTrue);
			}
			if (pcbKey == "DispenseSequenceReducible")
			{
				pcbValue = DispenseSequenceReducible;
				return(hslTrue);
			}
			if (pcbKey == "DispenseSequenceCurrentInitialization")
			{
				pcbValue = DispenseSequenceCurrentInitialization;
				return(hslTrue);
			}
			if (pcbKey == "DispenseSequenceCurrentFinalization")
			{
				pcbValue = DispenseSequenceCurrentFinalization;
				return(hslTrue);
			}
			if (pcbKey == "DispenseSequenceCountInitialization")
			{
				pcbValue = DispenseSequenceCountInitialization;
				return(hslTrue);
			}
			if (pcbKey == "DispenseSequenceCountFinalization")
			{
				pcbValue = DispenseSequenceCountFinalization;
				return(hslTrue);
			}
			if (pcbKey == "DispenseSequenceCalibration")
			{
				pcbValue = DispenseSequenceCalibration;
				return(hslTrue);
			}
         if (pcbKey == "DispenseCustomStepID")
			{
				pcbValue = DispenseCustomStepID;
				return(hslTrue);
			}
         if (pcbKey == "PreDispenseCustomStepID")
			{
				pcbValue = PreDispenseCustomStepID;
				return(hslTrue);
			}
         if (pcbKey == "PostDispenseCustomStepID")
			{
				pcbValue = PostDispenseCustomStepID;
				return(hslTrue);
			}
         if (pcbKey == "StartNeedleWashCustomStepID")
			{
				pcbValue = WaitNeedleWashCustomStepID;
				return(hslTrue);
			}
         if (pcbKey == "StartNeedleWashCustomStepID")
			{
				pcbValue = WaitNeedleWashCustomStepID;
				return(hslTrue);
			}

			// unknown pcbKey
			Error::Raise(IDE::invalidPCBKey, GetFileName(), GetFunctionName(), GetLineNumber());

			return(hslFalse);
		}

		static function GetPipSequence(
			variable& pcbKey,
			sequence& pcbValue)
		{
			sequence null;												// null sequence

			// initialize output
			pcbValue.CopySequence(null);
			
			// set value for pipetting control key,
			// switch over PCB entries

			// initialize sequence
			if (pcbKey == "InitializeWasteDestination")
			{
				pcbValue.CopySequence(InitializeWasteDestination);
				return(hslTrue);
			}

			// tip pickup sequence 
			if (pcbKey == "TipPickupSequence")
			{
				pcbValue.CopySequence(TipPickupSequence);
				return(hslTrue);
			}

			// tip eject sequence 
			if (pcbKey == "TipEjectWasteDestination")
			{
				pcbValue.CopySequence(TipEjectWasteDestination);
				return(hslTrue);
			}

			// aspirate sequence
			if (pcbKey == "AspirateSequence")
			{
				pcbValue.CopySequence(AspirateSequence);
				return(hslTrue);
			}

			// dispense sequence 
			if (pcbKey == "DispenseSequence")
			{
				pcbValue.CopySequence(DispenseSequence);
				return(hslTrue);
			}

			// unknown pcbKey
			Error::Raise(IDE::invalidPCBKey, GetFileName(), GetFunctionName(), GetLineNumber());

			return(hslFalse);
		}

		static function SetState(
			variable& pcbKey,
			variable& pcbValue)
		{
			// set value for pipetting control key,
			// switch over PCB entries

			// general settings 
			if (pcbKey == "UserResponseTime")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				if (Limits::maxTimeInterval < pcbValue)
					UserResponseTime = Limits::maxTimeInterval;
				else
					UserResponseTime = pcbValue;
				if (!PTL_Util::IsInteger(UserResponseTime))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				return(hslTrue);
			}
			if (pcbKey == "ErrorHandling")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidErrorHandling, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidErrorHandling, GetFileName(), GetFunctionName(), GetLineNumber());
				if (pcbValue < ErrorHandling::first || ErrorHandling::last < pcbValue)
					Error::Raise(IDE::invalidErrorHandling, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				ErrorHandling = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "TipCountingEnabled")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsFloat(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				TipCountingEnabled = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "TipCountingIdentifier")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsString(pcbValue))
					Error::Raise(IDE::invalidTipCountingIdentifier, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				TipCountingIdentifier = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "CopyPatternEnabled")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsFloat(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				CopyPatternEnabled = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "ExcludeErrorPositionsEnabled")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsFloat(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				ExcludeErrorPositionsEnabled = pcbValue;
				return(hslTrue);
			}

			// aliquot settings 
			if (pcbKey == "AliquotEnabled")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsFloat(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				AliquotEnabled = pcbValue;
				AliquotEnabledBak = AliquotEnabled;
				return(hslTrue);
			}
			if (pcbKey == "AliquotPreAspirateVolume")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidVolume, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(pcbValue))
					Error::Raise(IDE::invalidVolume, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				AliquotPreAspirateVolume = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "AliquotAspirateDefaultMixingEnabled")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsFloat(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				AliquotAspirateDefaultMixingEnabled = pcbValue;
				return(hslTrue);
			}

			// initialize settings 
			if (pcbKey == "InitializeUseDefaultWaste")
			{
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (pcbValue < 0 || 1 < pcbValue)
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				InitializeUseDefaultWaste = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "InitializeChannelVariable")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsString(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				InitializeChannelVariable = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "InitializeSequenceCounting")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidSequenceCounting, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidSequenceCounting, GetFileName(), GetFunctionName(), GetLineNumber());
				if (pcbValue < SequenceCounting::first || SequenceCounting::last < pcbValue)
					Error::Raise(IDE::invalidSequenceCounting, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				InitializeSequenceCounting = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "InitializeChannelUse")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidChannelUse, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidChannelUse, GetFileName(), GetFunctionName(), GetLineNumber());
				if (pcbValue < ChannelUse::first || ChannelUse::last < pcbValue)
					Error::Raise(IDE::invalidChannelUse, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				InitializeChannelUse = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "InitializeAlways")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsFloat(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (pcbValue < 0 || 1 < pcbValue)
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				InitializeAlways = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "InitializeEnabled")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsFloat(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				InitializeEnabled = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "InitializeWasteDestinationReloadable")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsFloat(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				InitializeWasteDestinationReloadable = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "InitializeWasteDestinationReducible")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsFloat(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				InitializeWasteDestinationReducible = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "InitializeCustomStepID")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				InitializeCustomStepID = pcbValue;
				return(hslTrue);
			}

			// load carrier settings 
			if (pcbKey == "LoadCarrierBarcodeFileName")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsString(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				LoadCarrierBarcodeFileName = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "LoadCarrierCustomStepID")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				LoadCarrierCustomStepID = pcbValue;
				return(hslTrue);
			}

         // unload carrier settings
			if (pcbKey == "UnloadCarrierCustomStepID")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				UnloadCarrierCustomStepID = pcbValue;
				return(hslTrue);
			}

			// calibrate carrier settings 
			if (pcbKey == "CalibrateCarrierChannel")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				CalibrateCarrierChannel = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "CalibrateCarrierCustomStepID")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				CalibrateCarrierCustomStepID = pcbValue;
				return(hslTrue);
			}

			// tip pickup settings 
			if (pcbKey == "TipPickupChannelVariable")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsString(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				TipPickupChannelVariable = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "TipPickupSequenceCounting")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidSequenceCounting, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidSequenceCounting, GetFileName(), GetFunctionName(), GetLineNumber());
				if (pcbValue < SequenceCounting::first || SequenceCounting::last < pcbValue)
					Error::Raise(IDE::invalidSequenceCounting, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				TipPickupSequenceCounting = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "TipPickupChannelUse")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidChannelUse, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidChannelUse, GetFileName(), GetFunctionName(), GetLineNumber());
				if (pcbValue < ChannelUse::first || ChannelUse::last < pcbValue)
					Error::Raise(IDE::invalidChannelUse, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				TipPickupChannelUse = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "TipPickupEnabled")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsFloat(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				TipPickupEnabled = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "TipPickupSequenceReloadable")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsFloat(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				TipPickupSequenceReloadable = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "TipPickupSequenceReducible")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsFloat(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				TipPickupSequenceReducible = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "TipPickupSequenceCurrentInitialization")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidInitialization, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(pcbValue) && (pcbValue < SequenceInitialization::first || SequenceInitialization::last < pcbValue))
					Error::Raise(IDE::invalidInitialization, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				TipPickupSequenceCurrentInitialization = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "TipPickupSequenceCurrentFinalization")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidFinalization, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(pcbValue) && (pcbValue < SequenceFinalization::first || SequenceFinalization::last < pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				TipPickupSequenceCurrentFinalization = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "TipPickupSequenceCountInitialization")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidInitialization, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(pcbValue) && (pcbValue < SequenceInitialization::first || SequenceInitialization::last < pcbValue))
					Error::Raise(IDE::invalidInitialization, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				TipPickupSequenceCountInitialization = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "TipPickupSequenceCountFinalization")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidFinalization, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(pcbValue) && (pcbValue < SequenceFinalization::first || SequenceFinalization::last < pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				TipPickupSequenceCountFinalization = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "TipPickupReverseSequenceCount")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				TipPickupReverseSequenceCount = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "TipPickupCustomStepID")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				TipPickupCustomStepID = pcbValue;
				return(hslTrue);
			}

			// tip eject settings 
			if (pcbKey == "TipEjectUseDefaultWaste")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (pcbValue < 0 || 1 < pcbValue)
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				TipEjectUseDefaultWaste = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "TipEjectChannelVariable")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsString(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				TipEjectChannelVariable = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "TipEjectChannelUse")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidChannelUse, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidChannelUse, GetFileName(), GetFunctionName(), GetLineNumber());
				if (pcbValue < ChannelUse::first || ChannelUse::last < pcbValue)
					Error::Raise(IDE::invalidChannelUse, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				TipEjectChannelUse = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "TipEjectSequenceCounting")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidSequenceCounting, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidSequenceCounting, GetFileName(), GetFunctionName(), GetLineNumber());
				if (pcbValue < SequenceCounting::first || SequenceCounting::last < pcbValue)
					Error::Raise(IDE::invalidSequenceCounting, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				TipEjectSequenceCounting = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "TipEjectWasteDestinationReloadable")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsFloat(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				TipEjectWasteDestinationReloadable = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "TipEjectWasteDestinationReducible")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsFloat(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				TipEjectWasteDestinationReducible = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "TipEjectCustomStepID")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				TipEjectCustomStepID = pcbValue;
				return(hslTrue);
			}

			// aspirate settings 
			if (pcbKey == "AspirateSequenceCounting")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidSequenceCounting, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidSequenceCounting, GetFileName(), GetFunctionName(), GetLineNumber());
				if (pcbValue < SequenceCounting::first || SequenceCounting::last < pcbValue)
					Error::Raise(IDE::invalidSequenceCounting, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				AspirateSequenceCounting = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "AspirateChannelUse")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidChannelUse, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidChannelUse, GetFileName(), GetFunctionName(), GetLineNumber());
				if (pcbValue < ChannelUse::first || ChannelUse::last < pcbValue)
					Error::Raise(IDE::invalidChannelUse, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				AspirateChannelUse = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "AspirateMode")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidAspirateMode, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (pcbValue < AspirateMode::first || AspirateMode::last < pcbValue)
					Error::Raise(IDE::invalidAspirateMode, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				AspirateMode = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "AspirateCLLDSensitivity")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidLLDSensitivity, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (pcbValue < LLDSensitivity::first || LLDSensitivity::last < pcbValue)
					Error::Raise(IDE::invalidLLDSensitivity, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				AspirateCLLDSensitivity = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "AspirateFluidHeight")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				AspirateFluidHeight = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "AspirateSubmergeDepth")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				AspirateSubmergeDepth = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "AspirateVolume")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidVolume, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(pcbValue))
					Error::Raise(IDE::invalidVolume, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				AspirateVolume = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "AspirateRestVolume")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidRestVolume, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(pcbValue))
					Error::Raise(IDE::invalidRestVolume, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				AspirateRestVolume = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "AspirateChannelVariable")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsString(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				AspirateChannelVariable = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "AspirateMaxHeightDiff")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				AspirateMaxHeightDiff = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "AspiratePLLDSensitivity")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidLLDSensitivity, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (pcbValue < LLDSensitivity::first || LLDSensitivity::last < pcbValue)
					Error::Raise(IDE::invalidLLDSensitivity, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				AspiratePLLDSensitivity = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "AspirateLiquidFollowing")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsFloat(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (pcbValue < 0 || 1 < pcbValue)
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				AspirateLiquidFollowing = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "AspiratePrerinsingMixCycles")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				AspiratePrerinsingMixCycles = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "AspiratePrerinsingMixPosition")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				AspiratePrerinsingMixPosition = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "AspiratePrerinsingMixVolume")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidMixVolume, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(pcbValue))
					Error::Raise(IDE::invalidMixVolume, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				AspiratePrerinsingMixVolume = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "AspirateUserDefinedLiquidClass")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsString(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				AspirateUserDefinedLiquidClass = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "AspirateSequenceReloadable")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsFloat(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				AspirateSequenceReloadable = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "AspirateSequenceReducible")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsFloat(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				AspirateSequenceReducible = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "AspirateSequenceCurrentInitialization")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidInitialization, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(pcbValue) && (pcbValue < SequenceInitialization::first || SequenceInitialization::last < pcbValue))
					Error::Raise(IDE::invalidInitialization, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				AspirateSequenceCurrentInitialization = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "AspirateSequenceCurrentFinalization")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidFinalization, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(pcbValue) && (pcbValue < SequenceFinalization::first || SequenceFinalization::last < pcbValue))
					Error::Raise(IDE::invalidFinalization, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				AspirateSequenceCurrentFinalization = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "AspirateSequenceCountInitialization")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidInitialization, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(pcbValue) && (pcbValue < SequenceInitialization::first || SequenceInitialization::last < pcbValue))
					Error::Raise(IDE::invalidInitialization, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				AspirateSequenceCountInitialization = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "AspirateSequenceCountFinalization")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidFinalization, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(pcbValue) && (pcbValue < SequenceFinalization::first || SequenceFinalization::last < pcbValue))
					Error::Raise(IDE::invalidFinalization, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				AspirateSequenceCountFinalization = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "AspirateSequenceCalibration")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsFloat(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				AspirateSequenceCalibration = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "AspirateCustomStepID")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				AspirateCustomStepID = pcbValue;
				return(hslTrue);
			}

			// dispense settings 
			if (pcbKey == "DispenseSubmergeDepth")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				DispenseSubmergeDepth = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "DispenseChannelVariable")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsString(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				DispenseChannelVariable = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "DispenseVolume")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidVolume, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(pcbValue))
					Error::Raise(IDE::invalidVolume, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				DispenseVolume = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "DispenseRestVolume")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidRestVolume, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(pcbValue))
					Error::Raise(IDE::invalidRestVolume, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				DispenseRestVolume = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "DispenseRestVolumeDestination")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (pcbValue < RestVolumeDestination::first || RestVolumeDestination::last < pcbValue)
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				DispenseRestVolumeDestination = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "DispenseRestVolumeFluidHeight")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				DispenseRestVolumeFluidHeight = pcbValue;
				return(hslTrue);
			}
			// ba 20050511 begin (SCR#736)
			if (pcbKey == "DispenseRestVolumeToAspirateSequenceSurface")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				DispenseRestVolumeToAspirateSequenceSurface = pcbValue;
				return(hslTrue);
			}
			// ba 20050511 end (SCR#736)
			if (pcbKey == "DispenseChannelUse")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidChannelUse, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidChannelUse, GetFileName(), GetFunctionName(), GetLineNumber());
				if (pcbValue < ChannelUse::first || ChannelUse::last < pcbValue)
					Error::Raise(IDE::invalidChannelUse, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				DispenseChannelUse = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "DispenseCLLDSensitivity")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidLLDSensitivity, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (pcbValue < LLDSensitivity::first || LLDSensitivity::last < pcbValue)
					Error::Raise(IDE::invalidLLDSensitivity, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				DispenseCLLDSensitivity = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "DispenseSequenceCounting")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidSequenceCounting, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidSequenceCounting, GetFileName(), GetFunctionName(), GetLineNumber());
				if (pcbValue < SequenceCounting::first || SequenceCounting::last < pcbValue)
					Error::Raise(IDE::invalidSequenceCounting, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				DispenseSequenceCounting = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "DispenseFluidHeight")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				DispenseFluidHeight = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "DispenseMode")
			{
				// 2005-06-21/cjoerg
				// Changed interface that not longer the modes jetModePartVolume(0), jetModeEmptyTip(1),
				// jetModeEmptyTip(2) or jetModeEmptyTip(3) are published on the interface (SetPipettingState()).
				// Newly only jet / surface may be set from outside, the correct StarDispenseMode es evaluated
				// by the pipetting library internally.
				// But for compatibility we need to accept also the depricated values.

				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidDispenseMode, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (pcbValue < DispenseMode::first || DispenseMode::last < pcbValue)
					Error::Raise(IDE::invalidDispenseMode, GetFileName(), GetFunctionName(), GetLineNumber());

				// 2005-06-21/cjoerg: jet and jet_ are similar, map to jet
				if ( pcbValue == DispenseMode::jet_ )
					pcbValue = DispenseMode::jet;

				// 2005-06-21/cjoerg: surface_ is similar to surface, map to surface
				if ( pcbValue == DispenseMode::surface_ )
					pcbValue = DispenseMode::surface;

				// set pcbValue 
				DispenseMode = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "DispenseLiquidFollowing")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsFloat(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (pcbValue < 0 || 1 < pcbValue)
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				DispenseLiquidFollowing = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "DispensePrerinsingMixCycles")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				DispensePrerinsingMixCycles = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "DispensePrerinsingMixPosition")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				DispensePrerinsingMixPosition = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "DispensePrerinsingMixVolume")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidVolume, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(pcbValue))
					Error::Raise(IDE::invalidVolume, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				DispensePrerinsingMixVolume = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "DispenseUserDefinedLiquidClass")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsString(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				DispenseUserDefinedLiquidClass = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "DispenseSequenceReloadable")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsFloat(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				DispenseSequenceReloadable = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "DispenseSequenceReducible")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsFloat(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				DispenseSequenceReducible = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "DispenseSequenceCurrentInitialization")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidInitialization, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(pcbValue) && (pcbValue < SequenceInitialization::first || SequenceInitialization::last < pcbValue))
					Error::Raise(IDE::invalidInitialization, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				DispenseSequenceCurrentInitialization = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "DispenseSequenceCurrentFinalization")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidFinalization, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(pcbValue) && (pcbValue < SequenceFinalization::first || SequenceFinalization::last < pcbValue))
					Error::Raise(IDE::invalidFinalization, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				DispenseSequenceCurrentFinalization = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "DispenseSequenceCountInitialization")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidInitialization, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(pcbValue) && (pcbValue < SequenceInitialization::first || SequenceInitialization::last < pcbValue))
					Error::Raise(IDE::invalidInitialization, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				DispenseSequenceCountInitialization = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "DispenseSequenceCountFinalization")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidFinalization, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(pcbValue) && (pcbValue < SequenceFinalization::first || SequenceFinalization::last < pcbValue))
					Error::Raise(IDE::invalidFinalization, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				DispenseSequenceCountFinalization = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "DispenseSequenceCalibration")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsNumber(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsFloat(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				DispenseSequenceCalibration = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "DispenseCustomStepID")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				DispenseCustomStepID = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "PreDispenseCustomStepID")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				PreDispenseCustomStepID = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "PostDispenseCustomStepID")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				PostDispenseCustomStepID = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "StartNeedleWashCustomStepID")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				StartNeedleWashCustomStepID = pcbValue;
				return(hslTrue);
			}
			if (pcbKey == "WaitNeedleWashCustomStepID")
			{
				// check pcbValue to be valid
				if (!PTL_Util::IsInteger(pcbValue))
					Error::Raise(IDE::invalidPCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set pcbValue 
				WaitNeedleWashCustomStepID = pcbValue;
				return(hslTrue);
			}

			// unknown pcbKey
			Error::Raise(IDE::invalidPCBKey, GetFileName(), GetFunctionName(), GetLineNumber());

			return(hslFalse);
		}

		static function BindStates(
			device& ML_STAR)
		{
			variable index(0);
			variable index2(0);
			variable size(0);
			variable numberOfChannels(0);
			variable channelPattern("");

			// get number of channels
			numberOfChannels = ML_STAR.GetCfgValueWithKey(MlStarCfgKey::numberOfChannels);

			// bind value to pipetting control settings which have not yet been set to a reasonable value

			// general settings 

			// aliquot settings 

			// initialize settings 
			if ("" == InitializeChannelVariable)
			{
				if ("" == channelPattern)
				{
					for (index = 0; index < numberOfChannels; index++)
						channelPattern = channelPattern + "1";
				}
				InitializeChannelVariable = channelPattern;
			}

			// load carrier settings 

			// calibrate carrier settings 
			if (-1 == CalibrateCarrierChannel)
			{
				CalibrateCarrierChannel = numberOfChannels;
			}
			if (-1 == LCB::CalibrateCarrierChannel)
			{
				LCB::CalibrateCarrierChannel = numberOfChannels;
			}

			// get access to global data
			SynEnterCriticalSection(ptlCs);

			// tip pickup settings 
			if ("" == TipPickupChannelVariable)
			{
				if ("" == channelPattern)
				{
					for (index = 0; index < numberOfChannels; index++)
						channelPattern = channelPattern + "1";
				}
				TipPickupChannelVariable = channelPattern;
			}
			if ("" == TCB::TipPickupChannelVariable)
			{
				if ("" == channelPattern)
				{
					for (index = 0; index < numberOfChannels; index++)
						channelPattern = channelPattern + "1";
				}
				TCB::TipPickupChannelVariable = channelPattern;
			}
			size = ptlWcbNeedlePickupChannelVariableArr.GetSize();
			for (index2 = 0; index2 < size; index2++)
			{
				if ("" == ptlWcbNeedlePickupChannelVariableArr.ElementAt(index2))
				{
					if ("" == channelPattern)
					{
						for (index = 0; index < numberOfChannels; index++)
							channelPattern = channelPattern + "1";
					}
					ptlWcbNeedlePickupChannelVariableArr.SetAt(index2, channelPattern);
				}
			}

			// tip eject settings 
			if ("" == TipEjectChannelVariable)
			{
				if ("" == channelPattern)
				{
					for (index = 0; index < numberOfChannels; index++)
						channelPattern = channelPattern + "1";
				}
				TipEjectChannelVariable = channelPattern;
			}
			if ("" == TCB::TipEjectChannelVariable)
			{
				if ("" == channelPattern)
				{
					for (index = 0; index < numberOfChannels; index++)
						channelPattern = channelPattern + "1";
				}
				TCB::TipEjectChannelVariable = channelPattern;
			}

			size = ptlWcbNeedleEjectChannelVariableArr.GetSize();
			for (index2 = 0; index2 < size; index2++)
			{
				if ("" == ptlWcbNeedleEjectChannelVariableArr.ElementAt(index2))
				{
					if ("" == channelPattern)
					{
						for (index = 0; index < numberOfChannels; index++)
							channelPattern = channelPattern + "1";
					}
					ptlWcbNeedleEjectChannelVariableArr.SetAt(index2, channelPattern);
				}
			}

			// release access to global data
			SynLeaveCriticalSection(ptlCs);

			// aspirate settings 
			if ("" == AspirateChannelVariable)
			{
				if ("" == channelPattern)
				{
					for (index = 0; index < numberOfChannels; index++)
						channelPattern = channelPattern + "1";
				}
				AspirateChannelVariable = channelPattern;
			}

			// dispense settings 
			if ("" == DispenseChannelVariable)
			{
				if ("" == channelPattern)
				{
					for (index = 0; index < numberOfChannels; index++)
						channelPattern = channelPattern + "1";
				}
				DispenseChannelVariable = channelPattern;
			}
			return(hslTrue);
		}

		static function SetPipSequence(
			variable& pcbKey,
			sequence& pcbValue)
		{
			// set value for pipetting control key,
			// switch over PCB entries

			// initialize sequence
			if (pcbKey == "InitializeWasteDestination")
			{
				InitializeWasteDestination = pcbValue;
				return(hslTrue);
			}

			// tip pickup sequence 
			if (pcbKey == "TipPickupSequence")
			{
				TipPickupSequence = pcbValue;
				return(hslTrue);
			}

			// tip eject sequence
			if (pcbKey == "TipEjectWasteDestination")
			{
				TipEjectWasteDestination = pcbValue;
				return(hslTrue);
			}

			// aspirate sequence 
			if (pcbKey == "AspirateSequence")
			{
				AspirateSequence = pcbValue;
				return(hslTrue);
			}

			// dispense sequence 
			if (pcbKey == "DispenseSequence")
			{
				DispenseSequence = pcbValue;
				return(hslTrue);
			}

			// unknown pcbKey
			Error::Raise(IDE::invalidPCBKey, GetFileName(), GetFunctionName(), GetLineNumber());

			return(hslFalse);
		}
	
		static function IsWashSequence(
			device& ML_STAR,
			sequence& sequenceToTest) variable
		{
			variable isWashSequence(hslFalse);		// indicates whether tipPickupSequence is a wash sequence or not
			
			variable index;
			variable currentPosBak;						// backup of current position

			// backup current sequenceToTest
			currentPosBak = sequenceToTest.GetCurrentPosition();

			// iterate over labware contained in sequenceToTest
			for (index = sequenceToTest.SetCurrentPosition(1); 
				  0 < index; 
				  index = sequenceToTest.Increment(sequenceToTest.GetPositionCountForCurrLabware()))
			{
				if (WCB::IsWashStation(ML_STAR, sequenceToTest.GetLabwareId()))
				{
					// the labware is a need wash rack
					// needle wash racks are not reloadable
					TipPickupSequenceReloadable = hslFalse;

					isWashSequence = hslTrue;
					break;
				}
			}

			// restore current position
			sequenceToTest.SetCurrentPosition(currentPosBak);

			return(isWashSequence);
		}


		static function CheckAspirateMode()
		{

			// trace a warning if mixing will be ignored
			if ((0 < AspiratePrerinsingMixCycles) && 
				 (AspirateMode == AspirateMode::emptyCupAspiration || AspirateMode == AspirateMode::consecutiveAspiration))
			{
				// the mixing parameters are ignored (see 'Liquid Handling ML STAR', chapter 3.1)
				variable action;
				variable warnText;
				action = StringTable::Load(IDS::smartStepPipette);
				warnText = StringTable::Load(IDS::mixingOnAspirateIgnored);
				PTL_Util::TraceWarningIfNotValidated(action, warnText);
			}
		}

		static function CheckDispenseMode(variable starDispenseMode) void
		{

			// trace a warning if mixing will be ignored
			if ((0 < DispensePrerinsingMixCycles) && 
				 (    starDispenseMode == StarDispenseMode::jetPartVolume || starDispenseMode == StarDispenseMode::jetEmptyTip || starDispenseMode == StarDispenseMode::surfacePartVolume))
			{
				// the mixing parameters are ignored (see 'Liquid Handling ML STAR', chapter 3.2)
				variable action;
				variable warnText;
				action = StringTable::Load(IDS::smartStepPipette);
				warnText = StringTable::Load(IDS::mixingOnDispenseIgnored);
				PTL_Util::TraceWarningIfNotValidated(action, warnText);
			}
		}

		static function GetDispenseMode(
			variable currentAliquot,
			variable numberOfAliquots) variable
		{
			variable starDispenseMode(-1);

			// if the current aliquot is less than the number of aliquots, 
			// the dispense mode must be one of the part volume modes
			// START 2005-04-21 / cjoerg, added comment only
			//   the liquid class must be defined for 'jet empty tip' or 'surface empty tip'
			//   otherwise we get a dispense-error (except: no error if old (V3.2) liquid class is used)
			// END 2005-04-21 / cjoerg
			if (currentAliquot < numberOfAliquots)
			{
				// START 2005-06-21 / cjoerg
				//
				if ( DispenseMode == DispenseMode::jet || DispenseMode == DispenseMode::jet_ )
				{
					starDispenseMode = StarDispenseMode::jetPartVolume;
				}
				else if ( DispenseMode == DispenseMode::surface || DispenseMode == DispenseMode::surface_ )
				{
					starDispenseMode = StarDispenseMode::surfacePartVolume;
				}
				else
				{
					#ifdef _DEBUG
					Assert(hslFalse, GetFunctionName());
					#endif
					starDispenseMode = StarDispenseMode::jetPartVolume;	// default to jetPartVolume
				}

				//if (DispenseMode::surfaceDispensePartVolume != DispenseMode &&
				//	 DispenseMode::jetModePartVolume != DispenseMode)
				//{
				//	if (DispenseMode::jetModeEmptyTip == DispenseMode)
				//	{
				//		 DispenseMode = DispenseMode::jetModePartVolume;
				//	}
				//	if (DispenseMode::surfaceDispenseEmptyTip == DispenseMode)
				//	{
				//		 DispenseMode = DispenseMode::surfaceDispensePartVolume;
				//	}
				//}
				//
				// END 2005-06-21 / cjoerg
			}

			// if the current aliquot is eaqual to the number of aliquots, 
			// the dispense mode must be one of the empty tip modes, except we have rest volumes
			if (currentAliquot == numberOfAliquots)
			{
				// START 2005-06-21 / cjoerg
				//
				if ( DispenseMode == DispenseMode::jet || DispenseMode == DispenseMode::jet_ )
				{
					starDispenseMode = StarDispenseMode::jetEmptyTip;
				}
				else if ( DispenseMode == DispenseMode::surface || DispenseMode == DispenseMode::surface_ )
				{
					starDispenseMode = StarDispenseMode::surfaceEmptyTip;
				}
				else
				{
					#ifdef _DEBUG
					Assert(hslFalse, GetFunctionName());
					#endif
					starDispenseMode = StarDispenseMode::jetEmptyTip;	// default to jetEmptyTip
				}

				//if (DispenseMode::surfaceDispenseEmptyTip != DispenseMode &&
				//	 DispenseMode::jetModeEmptyTip != DispenseMode)
				//{
				//	if (DispenseMode::jetModePartVolume == DispenseMode)
				//	{
				//		 DispenseMode = DispenseMode::jetModeEmptyTip;
				//	}
				//	if (DispenseMode::surfaceDispensePartVolume == DispenseMode)
				//	{
				//		 DispenseMode = DispenseMode::surfaceDispenseEmptyTip;
				//	}
				//}
				//
				// END 2005-06-21 / cjoerg


				// if the current aliquot is eaqual to the number of aliquots, and
				// if the rest volume is greater than 0, the dispense mode 
				// must be one of the part volume modes
				if (0 < DispenseRestVolume)
				{
					// we have a rest volume, a liquid class for 'jet part volume' or 'surface part volume' must be passed
					// and also the liquid class must be a '..part volume'
					// the dispense must be processed with 'part volume'

					// START 2005-06-21 / cjoerg
					//
					if ( DispenseMode == DispenseMode::jet || DispenseMode == DispenseMode::jet_ )
					{
						starDispenseMode = StarDispenseMode::jetPartVolume;
					}
					else if ( DispenseMode == DispenseMode::surface || DispenseMode == DispenseMode::surface_ )
					{
						starDispenseMode = StarDispenseMode::surfacePartVolume;
					}
					else
					{
						#ifdef _DEBUG
						Assert(hslFalse, GetFunctionName());
						#endif
						starDispenseMode = StarDispenseMode::jetPartVolume;	// default to jetPartVolume
					}

					//if (DispenseMode::surfaceDispensePartVolume != DispenseMode &&
					//	 DispenseMode::jetModePartVolume != DispenseMode)
					//{
					//	if (DispenseMode::jetModeEmptyTip == DispenseMode)
					//	{
					//		 DispenseMode = DispenseMode::jetModePartVolume;
					//	}
					//	if (DispenseMode::surfaceDispenseEmptyTip == DispenseMode)
					//	{
					//		 DispenseMode = DispenseMode::surfaceDispensePartVolume;
					//	}
					//}
					//
					// END 2005-06-21 / cjoerg
				}

				// START 2005-04-21 / cjoerg
				//
				if ( AliquotEnabled )
				{
					// For an Aliquot a liquid class for 'jet part volume' (or 'surface part volume') must be passed.
					// If we have no rest-volume we musst proceed the last dispense with mode 'blow out tip',
					// alos if the aliquot is degenerated to a 1-1 pipette (numberOfAliquots==1).
					// Part volume may work to, but the plunger may not positioned to zero.
					// Empty tip does not work, because of liquid class for 'part volume'
					if ( 0 >= DispenseRestVolume)
					{
						// No rest volume follows -> blowout.
						starDispenseMode = StarDispenseMode::blowoutTip;
						//DispenseMode = DispenseMode::blowoutTip;
					}
				}
				//
				// END 2005-04-21 / cjoerg
			}

			
			#ifdef _DEBUG
			{
			variable source;
			variable action;
			source = "DEBUG";
			action = GetFunctionName();
			FormatTrace(source, action, TraceStatus::progress, "DispenseMode '", DispenseMode::AsString(DispenseMode),
								"' mapped to StarDispenseMode: ", StarDispenseMode::AsString(starDispenseMode));
			}
			#endif

			// check dispense mode
			CheckDispenseMode(starDispenseMode);

			return (starDispenseMode);
		}

		static function GetTipVolumeFromLiquidClass(
			variable& liquidClassName) variable
		{
			variable tipVolume(0);
			object resultPars;

			if ( 0 == resultPars.CreateObject("HXPARAMSLib.HxPars") )
			{
				// 20050629 cjoerg: Added this error handling
				variable errorDesc;
				errorDesc = StringTable::Load(IDE::createObjectFailed);
				StrReplace(errorDesc, "%s", "HXPARAMSLib.HxPars");
				Error::RaiseEx(IDE::createObjectFailed, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
			}
			TipVolume::objHxStarLiquid.GetLiquidClass(liquidClassName, resultPars, hslFalse);
			tipVolume = Floor(resultPars.Item1(TipVolume::objHxStarLiquid.liqMaxAspirateVolume));
			return (tipVolume);
		}

		static function SetVolume(
			sequence& dispenseSequence,
			variable totalVolume,
			variable currentVolume,
			variable& preVolume,
			variable& restVolume)
		{
			variable volume(0);						// volume restricted appropriate to the tip type
			variable residualTipVolume(0);		// residual tip volume 
			variable numberOfAliquots(1);			// number of aliquots (if any)
			variable tipVolumeFromLiquidClass(0);

			// initialize volume
			volume = currentVolume;

			tipVolumeFromLiquidClass = GetTipVolumeFromLiquidClass(AspirateUserDefinedLiquidClass);
			residualTipVolume = tipVolumeFromLiquidClass - preVolume - restVolume;

			// restrict volume appropriate to the tip type
			if (residualTipVolume < currentVolume)
			{
				variable numberOfVolumeCycles(1);

				// disable aliquot option 
				if (AliquotEnabled && (numberOfAliquots < Limits::minNumberOfAliquots))
				{
					variable source;
					variable action;
					source = StringTable::Load(IDS::traceSource);
					action = StringTable::Load(IDS::smartStepPipette);
					FormatTrace(source, action, TraceStatus::progress, StringTable::Load(IDS::aliquotDisabled));
					AliquotEnabled = hslFalse;
					residualTipVolume = residualTipVolume + preVolume + restVolume;
					preVolume = 0;
					restVolume = 0;
				}

				if (0 < residualTipVolume)
				{
					numberOfVolumeCycles = Ceiling(1.0 * totalVolume / residualTipVolume);
					if (0 < numberOfVolumeCycles)
						volume = Floor(1.0 * totalVolume / numberOfVolumeCycles);
				}
			}
			else
			{
				// check if aliquot has been enabled 
				if (AliquotEnabled)
				{
					// aliquot option is enabled
					variable channelPattern;						// channel pattern
					variable numberOfAliquotPipette(0);			// number of aliquot pipette steps
					variable numberOfActiveChannels(0);			// number of active channels
					variable numberOfActivePositions(0);		// number of active dispense positions

					// calculate the max number of aliquots per cycle
					if (0 < volume)
						numberOfAliquots = Floor(residualTipVolume / volume);

					// determine the number of active channels
					if (StepReturn::IsRecovering2())
						// we are recovering from an error
						channelPattern = StepReturn::GetChannelPattern();
					else
						// we are not recovering from an error
						channelPattern = DispenseChannelVariable;
					numberOfActiveChannels = NumberOfActiveChannels(channelPattern);

					// number of active dispense positions
					if (0 < dispenseSequence.GetCurrentPosition())
						numberOfActivePositions = dispenseSequence.GetCount() - dispenseSequence.GetCurrentPosition() + 1;

					// calculate the number of aliquot pipette steps
					if (0 < numberOfActiveChannels * numberOfAliquots)
						numberOfAliquotPipette = Ceiling((1.0 * numberOfActivePositions) / (numberOfActiveChannels * numberOfAliquots));

					// recalculate the number of aliquots of next cycle
					if (numberOfActivePositions < (numberOfActiveChannels * numberOfAliquots))
					{
						numberOfActiveChannels = PTL_Util::Min(numberOfActiveChannels, numberOfActivePositions);
						numberOfAliquots = Floor((1.0 * numberOfActivePositions) / (numberOfActiveChannels));
					}

					// optimize liquid transfer
					// we simply count the number of steps used with and without aliquots
					// Asp + 3 * Dsp >  1 * (Asp + Dsp)
					// Asp + 4 * Dsp >  2 * (Asp + Dsp)
					// Asp + 5 * Dsp == 3 * (Asp + Dsp)	--> minNumberOfAliquots = 3
					if (numberOfAliquots < Limits::minNumberOfAliquots)
					{
						variable source;
						variable action;
						source = StringTable::Load(IDS::traceSource);
						action = StringTable::Load(IDS::smartStepPipette);
						FormatTrace(source, action, TraceStatus::progress, StringTable::Load(IDS::aliquotDisabled));

						// disable aliquot option 
						AliquotEnabled = hslFalse;
						numberOfAliquots = 1;
						preVolume = 0;
						restVolume = 0;
					}
				}
			}

			// set volume
			AspirateVolume = volume * numberOfAliquots;
			DispenseVolume = volume;
			AspirateRestVolume = restVolume;
			DispenseRestVolume = restVolume;
			AliquotPreAspirateVolume = preVolume;

			// return residual volume
			return(currentVolume - volume);
		}

		//>> 20060503
		static function SetVolumes(
			sequence& aspirateSequence,
			sequence& dispenseSequence,
			variable drivingMode,
			variable& totalVolumes[],
			variable& currentVolumes[],
			variable& restVolume)
		{
			variable i(0);												// array index
			variable j(0);												// array index
			variable length(0);										// string length
			variable numberOfVolumes(0);							// number of volumes
			variable residualTipVolume(0);						// residual tip volume 
			variable residualVolume(0);							// residual volume 
			variable volumes[];										// volumes restricted appropriate to the tip type
			variable tipVolumeFromLiquidClass(0);

			variable currentPos(0);									// current position
			variable numberOfActiveChannels(0);					// number of active channels
			variable availablePositions(0);						// number of available positions 
			variable maxPositionsPerStep(0);						// max number of positions per step

			variable channelPattern("");							// channel pattern

			if (DrivingMode::aspirateDriven == drivingMode)
			{
				// determine the number of active channels
				if (StepReturn::IsRecovering2())
					// we are recovering from an error
					channelPattern = StepReturn::GetChannelPattern();
				else
					// we are not recovering from an error
					channelPattern = AspirateChannelVariable;
				numberOfActiveChannels = NumberOfActiveChannels(channelPattern);
				maxPositionsPerStep = aspirateSequence.GetMax();
				currentPos = aspirateSequence.GetCurrentPosition();
				if (0 < currentPos)
					availablePositions = aspirateSequence.GetCount() - currentPos + 1;
				maxPositionsPerStep = PTL_Util::Min(numberOfActiveChannels, PTL_Util::Min(maxPositionsPerStep, availablePositions));
			}
			else
			{
				// determine the number of active channels
				if (StepReturn::IsRecovering2())
					// we are recovering from an error
					channelPattern = StepReturn::GetChannelPattern();
				else
					// we are not recovering from an error
					channelPattern = DispenseChannelVariable;
				numberOfActiveChannels = NumberOfActiveChannels(channelPattern);
				maxPositionsPerStep = dispenseSequence.GetMax();
				currentPos = dispenseSequence.GetCurrentPosition();
				if (0 < currentPos)
					availablePositions = dispenseSequence.GetCount() - currentPos + 1;
				maxPositionsPerStep = PTL_Util::Min(numberOfActiveChannels, PTL_Util::Min(maxPositionsPerStep, availablePositions));
			}
			numberOfVolumes = maxPositionsPerStep;

			// initialize volume
			for (i = 0; i < numberOfVolumes; i++)
			{
				volumes.AddAsLast(currentVolumes.ElementAt(currentPos - 1 + i));
			}

			tipVolumeFromLiquidClass = GetTipVolumeFromLiquidClass(AspirateUserDefinedLiquidClass);
			residualTipVolume = tipVolumeFromLiquidClass - restVolume;

			// iterate over volumes
			for (i = 0; i < numberOfVolumes; i++)
			{
				// restrict volumes appropriate to the tip type
				if (residualTipVolume < currentVolumes.ElementAt(currentPos - 1 + i))
				{
					variable numberOfVolumeCycles(1);

					if (0 < residualTipVolume)
					{
						numberOfVolumeCycles = Ceiling(1.0 * totalVolumes.ElementAt(currentPos - 1 + i) / residualTipVolume);
						if (0 < numberOfVolumeCycles)
						{
							volumes.SetAt(i, Floor(1.0 * totalVolumes.ElementAt(currentPos - 1 + i) / numberOfVolumeCycles));
						}
					}
				}
			}

			// set volumes
			// we have to map the volumes to the channels, because we supply volumes per channel to the Aspirate/Dispense step
			length = StrGetLength(channelPattern);
			AspirateVolumes.SetSize(0);
			DispenseVolumes.SetSize(0);
			for (i = j = 0; i < length && j < numberOfVolumes; i++)
			{
				if ("1" == StrMid(channelPattern, i, 1))
				{
					AspirateVolumes.AddAsLast(volumes.ElementAt(j));
					DispenseVolumes.AddAsLast(volumes.ElementAt(j));
					j++;
				}
				else
				{
					AspirateVolumes.AddAsLast(0);
					DispenseVolumes.AddAsLast(0);
				}
			}
			AspirateRestVolume = restVolume;
			DispenseRestVolume = restVolume;

			// return residual volume
			for (i = 0; i < numberOfVolumes; i++)
			{
				currentVolumes.SetAt(currentPos - 1 + i, currentVolumes.ElementAt(currentPos - 1 + i) - volumes.ElementAt(i));
				residualVolume = PTL_Util::Max(residualVolume, currentVolumes.ElementAt(currentPos - 1 + i));
			}
			return(residualVolume);
		}
		//<< 20060503

		//>> 20060519
//		static function MapErrorHandlingContinue(variable errorHandling) variable
//		{
//			if (ErrorHandling::continue == errorHandling && !ExcludeRecoveryOptionEnabled)
//			{
//				return(ErrorHandling::continue_2);
//			}
//			return(errorHandling);
//		}
		//<< 20060519

		static function MapErrorHandlingContinue(variable errorHandling, variable customStepID) variable
		{
         errorHandling = ErrorHandling::MapCustomStepErrorHandling(errorHandling, customStepID);

			if (ErrorHandling::continue == errorHandling && !ExcludeRecoveryOptionEnabled)
			{
				return(ErrorHandling::continue_2);
			}
			return(errorHandling);
		}

		static function GetPreVolume()
		{
			if (AliquotEnabled)
				// aliquot option is enabled 
				return(AliquotPreAspirateVolume);
			else
				// aliquot option isn't enabled 
				return(0);
		}

		static function SelectLiquidClass()
		{
			// ba 2003-02-04 begin (disable automatic selection of liquid class)
			/*
			//---------------------
			// tips without filter
			//---------------------

			// dispense mode jet 
			if ("" == AspirateUserDefinedLiquidClass &&							// if not explicitly set AND
				TipType::lowVolumeTip == TipPickupTipType &&						// low volume tip type AND
				(DispenseMode::jetModeEmptyTip == DispenseMode ||				// dispense mode jet mode empty tip OR
				 DispenseMode::jetModePartVolume == DispenseMode))				// dispense mode jet mode part volume
			{
				if (AliquotEnabled)
					AspirateUserDefinedLiquidClass = "";
				else
					AspirateUserDefinedLiquidClass = "";
			}
			if ("" == DispenseUserDefinedLiquidClass &&							// if not explicitly set AND
				TipType::lowVolumeTip == TipPickupTipType &&						// low volume tip type AND
				(DispenseMode::jetModeEmptyTip == DispenseMode ||				// dispense mode jet mode empty tip OR
				 DispenseMode::jetModePartVolume == DispenseMode))				// dispense mode jet mode part volume
			{
				if (AliquotEnabled)
					DispenseUserDefinedLiquidClass = "";
				else
					DispenseUserDefinedLiquidClass = "";
			}
			if ("" == AspirateUserDefinedLiquidClass &&							// if not explicitly set AND
				TipType::standardVolumeTip == TipPickupTipType &&				// standard volume tip type AND
				(DispenseMode::jetModeEmptyTip == DispenseMode ||				// dispense mode jet mode empty tip OR
				 DispenseMode::jetModePartVolume == DispenseMode))				// dispense mode jet mode part volume
			{
				if (AliquotEnabled)
					AspirateUserDefinedLiquidClass = "StandardVolume_Water_AliquotJet";
				else
					AspirateUserDefinedLiquidClass = "StandardVolume_Water_DispenseJet";
			}
			if ("" == DispenseUserDefinedLiquidClass &&							// if not explicitly set AND
				TipType::standardVolumeTip == TipPickupTipType &&				// standard volume tip type AND
				(DispenseMode::jetModeEmptyTip == DispenseMode ||				// dispense mode jet mode empty tip OR
				 DispenseMode::jetModePartVolume == DispenseMode))				// dispense mode jet mode part volume
			{
				if (AliquotEnabled)
					DispenseUserDefinedLiquidClass = "StandardVolume_Water_AliquotJet";
				else
					DispenseUserDefinedLiquidClass = "StandardVolume_Water_DispenseJet";
			}
			if ("" == AspirateUserDefinedLiquidClass &&							// if not explicitly set AND
				TipType::highVolumeTip == TipPickupTipType &&					// high volume tip type AND
				(DispenseMode::jetModeEmptyTip == DispenseMode ||				// dispense mode jet mode empty tip OR
				 DispenseMode::jetModePartVolume == DispenseMode))				// dispense mode jet mode part volume
			{
				if (AliquotEnabled)
					AspirateUserDefinedLiquidClass = "HighVolume_Water_AliquotJet";
				else
					AspirateUserDefinedLiquidClass = "HighVolume_Water_DispenseJet";
			}
			if ("" == DispenseUserDefinedLiquidClass &&							// if not explicitly set AND
				TipType::highVolumeTip == TipPickupTipType &&					// high volume tip type AND
				(DispenseMode::jetModeEmptyTip == DispenseMode ||				// dispense mode jet mode empty tip OR
				 DispenseMode::jetModePartVolume == DispenseMode))				// dispense mode jet mode part volume
			{
				if (AliquotEnabled)
					DispenseUserDefinedLiquidClass = "HighVolume_Water_AliquotJet";
				else
					DispenseUserDefinedLiquidClass = "HighVolume_Water_DispenseJet";
			}

			// dispense mode surface 
			if ("" == AspirateUserDefinedLiquidClass &&							// if not explicitly set AND
				TipType::lowVolumeTip == TipPickupTipType &&						// low volume tip type AND
				(DispenseMode::surfaceDispenseEmptyTip == DispenseMode ||	// dispense mode surface dispense empty tip OR
				 DispenseMode::surfaceDispensePartVolume == DispenseMode))	// dispense mode surface dispense part volume
			{
				if (AliquotEnabled)
					AspirateUserDefinedLiquidClass = "";
				else
					AspirateUserDefinedLiquidClass = "LowVolume_Water_DispenseSurface";
			}
			if ("" == DispenseUserDefinedLiquidClass &&							// if not explicitly set AND
				TipType::lowVolumeTip == TipPickupTipType &&						// low volume tip type AND
				(DispenseMode::surfaceDispenseEmptyTip == DispenseMode ||	// dispense mode surface dispense empty tip OR
				 DispenseMode::surfaceDispensePartVolume == DispenseMode))	// dispense mode surface dispense part volume
			{
				if (AliquotEnabled)
					DispenseUserDefinedLiquidClass = "";
				else
					DispenseUserDefinedLiquidClass = "LowVolume_Water_DispenseSurface";
			}
			if ("" == AspirateUserDefinedLiquidClass &&							// if not explicitly set AND
				TipType::standardVolumeTip == TipPickupTipType &&				// standard volume tip type AND
				(DispenseMode::surfaceDispenseEmptyTip == DispenseMode ||	// dispense mode surface dispense empty tip OR
				 DispenseMode::surfaceDispensePartVolume == DispenseMode))	// dispense mode surface dispense part volume
			{
				if (AliquotEnabled)
					AspirateUserDefinedLiquidClass = "";
				else
					AspirateUserDefinedLiquidClass = "StandardVolume_Water_DispenseSurface";
			}
			if ("" == DispenseUserDefinedLiquidClass &&							// if not explicitly set
				TipType::standardVolumeTip == TipPickupTipType &&				// standard volume tip type
				(DispenseMode::surfaceDispenseEmptyTip == DispenseMode ||	// dispense mode surface dispense empty tip OR
				 DispenseMode::surfaceDispensePartVolume == DispenseMode))	// dispense mode surface dispense part volume
			{
				if (AliquotEnabled)
					DispenseUserDefinedLiquidClass = "";
				else
					DispenseUserDefinedLiquidClass = "StandardVolume_Water_DispenseSurface";
			}
			if ("" == AspirateUserDefinedLiquidClass &&							// if not explicitly set AND
				TipType::highVolumeTip == TipPickupTipType &&					// high volume tip type AND
				(DispenseMode::surfaceDispenseEmptyTip == DispenseMode ||	// dispense mode surface dispense empty tip OR
				 DispenseMode::surfaceDispensePartVolume == DispenseMode))	// dispense mode surface dispense part volume
			{
				if (AliquotEnabled)
					AspirateUserDefinedLiquidClass = "";
				else
					AspirateUserDefinedLiquidClass = "HighVolume_Water_DispenseSurface";
			}
			if ("" == DispenseUserDefinedLiquidClass &&							// if not explicitly set
				TipType::highVolumeTip == TipPickupTipType &&					// high volume tip type
				(DispenseMode::surfaceDispenseEmptyTip == DispenseMode ||	// dispense mode surface dispense empty tip OR
				 DispenseMode::surfaceDispensePartVolume == DispenseMode))	// dispense mode surface dispense part volume
			{
				if (AliquotEnabled)
					DispenseUserDefinedLiquidClass = "";
				else
					DispenseUserDefinedLiquidClass = "HighVolume_Water_DispenseSurface";
			}

			//------------------
			// tips with filter
			//------------------

			// dispense mode jet 
			if ("" == AspirateUserDefinedLiquidClass &&							// if not explicitly set AND
				TipType::lowVolumeTipWithFilter == TipPickupTipType &&		// low volume tip type with filter AND
				(DispenseMode::jetModeEmptyTip == DispenseMode ||				// dispense mode jet mode empty tip OR
				 DispenseMode::jetModePartVolume == DispenseMode))				// dispense mode jet mode part volume
			{
				if (AliquotEnabled)
					AspirateUserDefinedLiquidClass = "";
				else
					AspirateUserDefinedLiquidClass = "";
			}
			if ("" == DispenseUserDefinedLiquidClass &&							// if not explicitly set AND
				TipType::lowVolumeTipWithFilter == TipPickupTipType &&		// low volume tip type with filter AND
				(DispenseMode::jetModeEmptyTip == DispenseMode ||				// dispense mode jet mode empty tip OR
				 DispenseMode::jetModePartVolume == DispenseMode))				// dispense mode jet mode part volume
			{
				if (AliquotEnabled)
					DispenseUserDefinedLiquidClass = "";
				else
					DispenseUserDefinedLiquidClass = "";
			}
			if ("" == AspirateUserDefinedLiquidClass &&							// if not explicitly set AND
				TipType::standardVolumeTipWithFilter == TipPickupTipType &&	// standard volume tip type with filter AND
				(DispenseMode::jetModeEmptyTip == DispenseMode ||				// dispense mode jet mode empty tip OR
				 DispenseMode::jetModePartVolume == DispenseMode))				// dispense mode jet mode part volume
			{
				if (AliquotEnabled)
					AspirateUserDefinedLiquidClass = "StandardVolumeFilter_Water_AliquotJet";
				else
					AspirateUserDefinedLiquidClass = "StandardVolumeFilter_Water_DispenseJet";
			}
			if ("" == DispenseUserDefinedLiquidClass &&							// if not explicitly set AND
				TipType::standardVolumeTipWithFilter == TipPickupTipType &&	// standard volume tip type with filter AND
				(DispenseMode::jetModeEmptyTip == DispenseMode ||				// dispense mode jet mode empty tip OR
				 DispenseMode::jetModePartVolume == DispenseMode))				// dispense mode jet mode part volume
			{
				if (AliquotEnabled)
					DispenseUserDefinedLiquidClass = "StandardVolumeFilter_Water_AliquotJet";
				else
					DispenseUserDefinedLiquidClass = "StandardVolumeFilter_Water_DispenseJet";
			}
			if ("" == AspirateUserDefinedLiquidClass &&							// if not explicitly set AND
				TipType::highVolumeTipWithFilter == TipPickupTipType &&		// high volume tip type with filter AND
				(DispenseMode::jetModeEmptyTip == DispenseMode ||				// dispense mode jet mode empty tip OR
				 DispenseMode::jetModePartVolume == DispenseMode))				// dispense mode jet mode part volume
			{
				if (AliquotEnabled)
					AspirateUserDefinedLiquidClass = "HighVolumeFilter_Water_AliquotJet";
				else
					AspirateUserDefinedLiquidClass = "HighVolumeFilter_Water_DispenseJet";
			}
			if ("" == DispenseUserDefinedLiquidClass &&							// if not explicitly set AND
				TipType::highVolumeTipWithFilter == TipPickupTipType &&		// high volume tip type with filter AND
				(DispenseMode::jetModeEmptyTip == DispenseMode ||				// dispense mode jet mode empty tip OR
				 DispenseMode::jetModePartVolume == DispenseMode))				// dispense mode jet mode part volume
			{
				if (AliquotEnabled)
					DispenseUserDefinedLiquidClass = "HighVolumeFilter_Water_AliquotJet";
				else
					DispenseUserDefinedLiquidClass = "HighVolumeFilter_Water_DispenseJet";
			}

			// dispense mode surface 
			if ("" == AspirateUserDefinedLiquidClass &&							// if not explicitly set AND
				TipType::lowVolumeTipWithFilter == TipPickupTipType &&		// low volume tip type with filter AND
				(DispenseMode::surfaceDispenseEmptyTip == DispenseMode ||	// dispense mode surface dispense empty tip OR
				 DispenseMode::surfaceDispensePartVolume == DispenseMode))	// dispense mode surface dispense part volume
			{
				if (AliquotEnabled)
					AspirateUserDefinedLiquidClass = "";
				else
					AspirateUserDefinedLiquidClass = "LowVolumeFilter_Water_DispenseSurface";
			}
			if ("" == DispenseUserDefinedLiquidClass &&							// if not explicitly set AND
				TipType::lowVolumeTipWithFilter == TipPickupTipType &&		// low volume tip type with filter AND
				(DispenseMode::surfaceDispenseEmptyTip == DispenseMode ||	// dispense mode surface dispense empty tip OR
				 DispenseMode::surfaceDispensePartVolume == DispenseMode))	// dispense mode surface dispense part volume
			{
				if (AliquotEnabled)
					DispenseUserDefinedLiquidClass = "";
				else
					DispenseUserDefinedLiquidClass = "LowVolumeFilter_Water_DispenseSurface";
			}
			if ("" == AspirateUserDefinedLiquidClass &&							// if not explicitly set AND
				TipType::standardVolumeTipWithFilter == TipPickupTipType &&	// standard volume tip type with filter AND
				(DispenseMode::surfaceDispenseEmptyTip == DispenseMode ||	// dispense mode surface dispense empty tip OR
				 DispenseMode::surfaceDispensePartVolume == DispenseMode))	// dispense mode surface dispense part volume
			{
				if (AliquotEnabled)
					AspirateUserDefinedLiquidClass = "";
				else
					AspirateUserDefinedLiquidClass = "StandardVolumeFilter_Water_DispenseSurface";
			}
			if ("" == DispenseUserDefinedLiquidClass &&							// if not explicitly set
				TipType::standardVolumeTipWithFilter == TipPickupTipType &&	// standard volume tip type with filter AND
				(DispenseMode::surfaceDispenseEmptyTip == DispenseMode ||	// dispense mode surface dispense empty tip OR
				 DispenseMode::surfaceDispensePartVolume == DispenseMode))	// dispense mode surface dispense part volume
			{
				if (AliquotEnabled)
					DispenseUserDefinedLiquidClass = "";
				else
					DispenseUserDefinedLiquidClass = "StandardVolumeFilter_Water_DispenseSurface";
			}
			if ("" == AspirateUserDefinedLiquidClass &&							// if not explicitly set AND
				TipType::highVolumeTipWithFilter == TipPickupTipType &&		// high volume tip type with filter AND
				(DispenseMode::surfaceDispenseEmptyTip == DispenseMode ||	// dispense mode surface dispense empty tip OR
				 DispenseMode::surfaceDispensePartVolume == DispenseMode))	// dispense mode surface dispense part volume
			{
				if (AliquotEnabled)
					AspirateUserDefinedLiquidClass = "";
				else
					AspirateUserDefinedLiquidClass = "HighVolumeFilter_Water_DispenseSurface";
			}
			if ("" == DispenseUserDefinedLiquidClass &&							// if not explicitly set
				TipType::highVolumeTipWithFilter == TipPickupTipType &&		// high volume tip type with filter AND
				(DispenseMode::surfaceDispenseEmptyTip == DispenseMode ||	// dispense mode surface dispense empty tip OR
				 DispenseMode::surfaceDispensePartVolume == DispenseMode))	// dispense mode surface dispense part volume
			{
				if (AliquotEnabled)
					DispenseUserDefinedLiquidClass = "";
				else
					DispenseUserDefinedLiquidClass = "HighVolumeFilter_Water_DispenseSurface";
			}

			//------------------
			// needles 
			//------------------

			// dispense mode jet 
			if ("" == AspirateUserDefinedLiquidClass &&							// if not explicitly set AND
				TipType::lowVolumeNeedle == TipPickupTipType &&					// low volume needle type AND
				(DispenseMode::jetModeEmptyTip == DispenseMode ||				// dispense mode jet mode empty tip OR
				 DispenseMode::jetModePartVolume == DispenseMode))				// dispense mode jet mode part volume
			{
				if (AliquotEnabled)
					AspirateUserDefinedLiquidClass = "";
				else
					AspirateUserDefinedLiquidClass = "LowNeedle_Water_DispenseJet";
			}
			if ("" == DispenseUserDefinedLiquidClass &&							// if not explicitly set AND
				TipType::lowVolumeNeedle == TipPickupTipType &&					// low volume needle type AND
				(DispenseMode::jetModeEmptyTip == DispenseMode ||				// dispense mode jet mode empty tip OR
				 DispenseMode::jetModePartVolume == DispenseMode))				// dispense mode jet mode part volume
			{
				if (AliquotEnabled)
					DispenseUserDefinedLiquidClass = "";
				else
					DispenseUserDefinedLiquidClass = "LowNeedle_Water_DispenseJet";
			}
			if ("" == AspirateUserDefinedLiquidClass &&							// if not explicitly set AND
				TipType::standardVolumeNeedle == TipPickupTipType &&			// standard volume needle type AND
				(DispenseMode::jetModeEmptyTip == DispenseMode ||				// dispense mode jet mode empty tip OR
				 DispenseMode::jetModePartVolume == DispenseMode))				// dispense mode jet mode part volume
			{
				if (AliquotEnabled)
					AspirateUserDefinedLiquidClass = "";
				else
					AspirateUserDefinedLiquidClass = "StandardNeedle_Water_DispenseJet";
			}
			if ("" == DispenseUserDefinedLiquidClass &&							// if not explicitly set AND
				TipType::standardVolumeNeedle == TipPickupTipType &&			// standard volume needle type AND
				(DispenseMode::jetModeEmptyTip == DispenseMode ||				// dispense mode jet mode empty tip OR
				 DispenseMode::jetModePartVolume == DispenseMode))				// dispense mode jet mode part volume
			{
				if (AliquotEnabled)
					DispenseUserDefinedLiquidClass = "";
				else
					DispenseUserDefinedLiquidClass = "StandardNeedle_Water_DispenseJet";
			}
			if ("" == AspirateUserDefinedLiquidClass &&							// if not explicitly set AND
				TipType::highVolumeNeedle == TipPickupTipType &&				// high volume needle type AND
				(DispenseMode::jetModeEmptyTip == DispenseMode ||				// dispense mode jet mode empty tip OR
				 DispenseMode::jetModePartVolume == DispenseMode))				// dispense mode jet mode part volume
			{
				if (AliquotEnabled)
					AspirateUserDefinedLiquidClass = "";
				else
					AspirateUserDefinedLiquidClass = "HighNeedle_Water_DispenseJet";
			}
			if ("" == DispenseUserDefinedLiquidClass &&							// if not explicitly set AND
				TipType::highVolumeNeedle == TipPickupTipType &&				// high volume needle type AND
				(DispenseMode::jetModeEmptyTip == DispenseMode ||				// dispense mode jet mode empty tip OR
				 DispenseMode::jetModePartVolume == DispenseMode))				// dispense mode jet mode part volume
			{
				if (AliquotEnabled)
					DispenseUserDefinedLiquidClass = "";
				else
					DispenseUserDefinedLiquidClass = "HighNeedle_Water_DispenseJet";
			}

			// dispense mode surface 
			if ("" == AspirateUserDefinedLiquidClass &&							// if not explicitly set AND
				TipType::lowVolumeNeedle == TipPickupTipType &&					// low volume needle type AND
				(DispenseMode::surfaceDispenseEmptyTip == DispenseMode ||	// dispense mode surface dispense empty tip OR
				 DispenseMode::surfaceDispensePartVolume == DispenseMode))	// dispense mode surface dispense part volume
			{
				if (AliquotEnabled)
					AspirateUserDefinedLiquidClass = "";
				else
					AspirateUserDefinedLiquidClass = "LowNeedle_Water_DispenseSurface";
			}
			if ("" == DispenseUserDefinedLiquidClass &&							// if not explicitly set AND
				TipType::lowVolumeNeedle == TipPickupTipType &&					// low volume needle type AND
				(DispenseMode::surfaceDispenseEmptyTip == DispenseMode ||	// dispense mode surface dispense empty tip OR
				 DispenseMode::surfaceDispensePartVolume == DispenseMode))	// dispense mode surface dispense part volume
			{
				if (AliquotEnabled)
					DispenseUserDefinedLiquidClass = "";
				else
					DispenseUserDefinedLiquidClass = "LowNeedle_Water_DispenseSurface";
			}
			if ("" == AspirateUserDefinedLiquidClass &&							// if not explicitly set AND
				TipType::standardVolumeNeedle == TipPickupTipType &&			// standard volume needle type AND
				(DispenseMode::surfaceDispenseEmptyTip == DispenseMode ||	// dispense mode surface dispense empty tip OR
				 DispenseMode::surfaceDispensePartVolume == DispenseMode))	// dispense mode surface dispense part volume
			{
				if (AliquotEnabled)
					AspirateUserDefinedLiquidClass = "";
				else
					AspirateUserDefinedLiquidClass = "StandardNeedle_Water_DispenseSurface";
			}
			if ("" == DispenseUserDefinedLiquidClass &&							// if not explicitly set
				TipType::standardVolumeNeedle == TipPickupTipType &&			// standard volume needle type
				(DispenseMode::surfaceDispenseEmptyTip == DispenseMode ||	// dispense mode surface dispense empty tip OR
				 DispenseMode::surfaceDispensePartVolume == DispenseMode))	// dispense mode surface dispense part volume
			{
				if (AliquotEnabled)
					DispenseUserDefinedLiquidClass = "";
				else
					DispenseUserDefinedLiquidClass = "StandardNeedle_Water_DispenseSurface";
			}
			if ("" == AspirateUserDefinedLiquidClass &&							// if not explicitly set AND
				TipType::highVolumeNeedle == TipPickupTipType &&				// high volume needle type AND
				(DispenseMode::surfaceDispenseEmptyTip == DispenseMode ||	// dispense mode surface dispense empty tip OR
				 DispenseMode::surfaceDispensePartVolume == DispenseMode))	// dispense mode surface dispense part volume
			{
				if (AliquotEnabled)
					AspirateUserDefinedLiquidClass = "";
				else
					AspirateUserDefinedLiquidClass = "HighNeedle_Water_DispenseSurface";
			}
			if ("" == DispenseUserDefinedLiquidClass &&							// if not explicitly set
				TipType::highVolumeNeedle == TipPickupTipType &&				// high volume needle type
				(DispenseMode::surfaceDispenseEmptyTip == DispenseMode ||	// dispense mode surface dispense empty tip OR
				 DispenseMode::surfaceDispensePartVolume == DispenseMode))	// dispense mode surface dispense part volume
			{
				if (AliquotEnabled)
					DispenseUserDefinedLiquidClass = "";
				else
					DispenseUserDefinedLiquidClass = "HighNeedle_Water_DispenseSurface";
			}
			*/
			// end

			if ("" == AspirateUserDefinedLiquidClass || "" == DispenseUserDefinedLiquidClass)
				// unknown liquid class
				Error::Raise(IDE::invalidLiquidClass, GetFileName(), GetFunctionName(), GetLineNumber());

			return(hslTrue);
		}

		static function SelectDefaultWaste(
			device& ML_STAR,
			sequence& defaultWasteSequence)
		{
			variable defaultWasteSequenceName("");

			defaultWasteSequenceName = ML_STAR.GetCfgValueWithKey(MlStarCfgKey::defaultWaste);
			if (!ML_STAR.GetSequenceRef(defaultWasteSequenceName, defaultWasteSequence))
			{
				// desired deck sequence was not found
				variable errorDesc;
				errorDesc = StringTable::Load(IDE::defaultWasteNotFound);
				StrReplace(errorDesc, "%s", defaultWasteSequenceName);
				Error::RaiseEx(IDE::defaultWasteNotFound, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				return(hslFalse);
			}
			return(hslTrue);
		}

		static function SetTipPresence(
			string& channelPattern,
			variable numberOfChannels,
			variable presence)
		{
			variable index;
			variable length;
			variable channel;

			channel = 0;
			length = channelPattern.GetLength();
			for (index = 0; index < length && channel < numberOfChannels; index++)
			{
				if ("1" == channelPattern.Mid(index, 1))
				{
					// channel is active,
					// update tip presence
					TipPresence.SetAt(index, presence);
					channel++;
				}
			}
			#ifdef _DEBUG
			{
			variable dump("");
			variable source;
			variable action;
			source = "DEBUG";
			action = GetFunctionName();
			for (index = 0; index < length; index++)
				dump = dump + IStr(TipPresence.GetAt(index));
			FormatTrace(source, action, TraceStatus::progress, "TipPresence = ", dump);
			}
			#endif
			return(hslTrue);
		}

	//>> 20060529
		static function SetTipPresence2(
			variable& stepReturn) variable
		{
			variable i(0);
			variable numberOfPositions(0);	// number of positions in step return
			variable mainError(0);				// main error code
			variable recoveryButton(0);		// recovery button
			variable labwareId("");				// labware id

			StepReturn::prevTipPresence = "";
			numberOfPositions = StepReturn::GetNumberOfPositions(stepReturn);
			for (i = 0; i < numberOfPositions; i++)
			{
				labwareId = StepReturn::GetLabwareId(i + 1, stepReturn);
				if ("" != labwareId)
				{
					// channel is active
					mainError = StepReturn::GetMainError(i + 1, stepReturn);
					if (MainError::noError != mainError)
					{
						// channel has an error
						recoveryButton = StepReturn::GetRecoveryButton(i + 1, stepReturn);
						if (RecoveryButton::exclude == recoveryButton)
						{
							// channel has been excluded
							StepReturn::prevTipPresence = StepReturn::prevTipPresence + "0";
						}
						else
						{
							StepReturn::prevTipPresence = StepReturn::prevTipPresence + "1";
						}
					}
					else
					{
						StepReturn::prevTipPresence = StepReturn::prevTipPresence + "1";
					}
				}
				else
				{
					// channel is not active
					StepReturn::prevTipPresence = StepReturn::prevTipPresence + "0";
				}
			}

			return(hslTrue);
		}
		//<< 20060529

		static function GetTipPresence()
		{
			variable index;
			variable size;
			variable channelPattern("");

			size = TipPresence.GetSize();
			for (index = 0; index < size; index++)
					channelPattern = channelPattern + IStr(TipPresence.GetAt(index));
			#ifdef _DEBUG
			{
			variable source;
			variable action;
			source = "DEBUG";
			action = GetFunctionName();
			FormatTrace(source, action, TraceStatus::progress, "TipPresence = ", channelPattern);
			}
			#endif
			return(channelPattern);
		}

		static function BackupControlSettingsAndSequences()
		{
			pcbControlSettingsBak.SetSize(0);
			pcbControlSequencesBak.SetSize(0);

			// NOTE: Don't change the order of adding the elements to the array pcbControlSettingsBak.

			// general settings 

			pcbControlSettingsBak.AddAsLast(UserResponseTime);
			pcbControlSettingsBak.AddAsLast(ErrorHandling);
			pcbControlSettingsBak.AddAsLast(TipCountingEnabled);
			pcbControlSettingsBak.AddAsLast(TipCountingIdentifier);
			pcbControlSettingsBak.AddAsLast(CopyPatternEnabled);
			pcbControlSettingsBak.AddAsLast(ExcludeErrorPositionsEnabled);

			// aliquot settings 

			// public, read / write
			pcbControlSettingsBak.AddAsLast(AliquotEnabled);
			pcbControlSettingsBak.AddAsLast(AliquotEnabledBak);
			pcbControlSettingsBak.AddAsLast(AliquotPreAspirateVolume);
			pcbControlSettingsBak.AddAsLast(AliquotAspirateDefaultMixingEnabled);

			// initialize settings 

			// ba 2002-09-19 begin (this is a reference)
			//pcbControlSequencesBak.AddAsLast(InitializeWasteDestination);
			// edn
			pcbControlSettingsBak.AddAsLast(InitializeUseDefaultWaste);
			pcbControlSettingsBak.AddAsLast(InitializeChannelVariable);
			pcbControlSettingsBak.AddAsLast(InitializeSequenceCounting);
			pcbControlSettingsBak.AddAsLast(InitializeChannelUse);
			pcbControlSettingsBak.AddAsLast(InitializeAlways);
			pcbControlSettingsBak.AddAsLast(InitializeEnabled);
			pcbControlSettingsBak.AddAsLast(InitializeWasteDestinationReloadable);
			pcbControlSettingsBak.AddAsLast(InitializeWasteDestinationReducible);

			// load carrier settings

			pcbControlSettingsBak.AddAsLast(LoadCarrierBarcodeFileName);

			// calibrate carrier settings

			pcbControlSettingsBak.AddAsLast(CalibrateCarrierChannel);

			// tip pickup settings 

			pcbControlSequencesBak.AddAsLast(TipPickupSequence);
			pcbControlSettingsBak.AddAsLast(TipPickupChannelVariable);
			pcbControlSettingsBak.AddAsLast(TipPickupSequenceCounting);
			pcbControlSettingsBak.AddAsLast(TipPickupChannelUse);
			pcbControlSettingsBak.AddAsLast(TipPickupEnabled);
			pcbControlSettingsBak.AddAsLast(TipPickupSequenceReloadable);
			pcbControlSettingsBak.AddAsLast(TipPickupSequenceReducible);
			pcbControlSettingsBak.AddAsLast(TipPickupSequenceCurrentInitialization);
			pcbControlSettingsBak.AddAsLast(TipPickupSequenceCurrentFinalization);
			pcbControlSettingsBak.AddAsLast(TipPickupSequenceCountInitialization);
			pcbControlSettingsBak.AddAsLast(TipPickupSequenceCountFinalization);
			pcbControlSettingsBak.AddAsLast(TipPickupReverseSequenceCount);

			// tip eject settings 

			// ba 2002-09-19 begin (this is a reference)
			//pcbControlSequencesBak.AddAsLast(TipEjectWasteDestination);
			// end
			pcbControlSettingsBak.AddAsLast(TipEjectUseDefaultWaste);
			pcbControlSettingsBak.AddAsLast(TipEjectChannelVariable);
			pcbControlSettingsBak.AddAsLast(TipEjectChannelUse);
			pcbControlSettingsBak.AddAsLast(TipEjectSequenceCounting);
			pcbControlSettingsBak.AddAsLast(TipEjectWasteDestinationReloadable);
			pcbControlSettingsBak.AddAsLast(TipEjectWasteDestinationReducible);

			// aspirate settings 
			pcbControlSettingsBak.AddAsLast(AspirateSequenceReloadable);

			// dispense settings 
			pcbControlSettingsBak.AddAsLast(DispenseSequenceReloadable);

			// aspirate settings 

			pcbControlSequencesBak.AddAsLast(AspirateSequence);
			pcbControlSequencesBak.AddAsLast(AspirateSequenceOriginal);
			pcbControlSettingsBak.AddAsLast(AspirateSequenceCounting);
			pcbControlSettingsBak.AddAsLast(AspirateChannelUse);
			pcbControlSettingsBak.AddAsLast(AspirateMode);
			pcbControlSettingsBak.AddAsLast(AspirateCLLDSensitivity);
			pcbControlSettingsBak.AddAsLast(AspirateFluidHeight);
			pcbControlSettingsBak.AddAsLast(AspirateSubmergeDepth);
			pcbControlSettingsBak.AddAsLast(AspirateVolume);
			pcbControlSettingsBak.AddAsLast(AspirateRestVolume);
			pcbControlSettingsBak.AddAsLast(AspirateChannelVariable);
			pcbControlSettingsBak.AddAsLast(AspirateMaxHeightDiff);
			pcbControlSettingsBak.AddAsLast(AspiratePLLDSensitivity);
			pcbControlSettingsBak.AddAsLast(AspirateLiquidFollowing);
			pcbControlSettingsBak.AddAsLast(AspiratePrerinsingMixCycles);
			pcbControlSettingsBak.AddAsLast(AspiratePrerinsingMixPosition);
			pcbControlSettingsBak.AddAsLast(AspiratePrerinsingMixVolume);
			pcbControlSettingsBak.AddAsLast(AspirateUserDefinedLiquidClass);
			pcbControlSettingsBak.AddAsLast(AspirateSequenceReloadable);
			pcbControlSettingsBak.AddAsLast(AspirateSequenceReducible);
			pcbControlSettingsBak.AddAsLast(AspirateSequenceCurrentInitialization);
			pcbControlSettingsBak.AddAsLast(AspirateSequenceCurrentFinalization);
			pcbControlSettingsBak.AddAsLast(AspirateSequenceCountInitialization);
			pcbControlSettingsBak.AddAsLast(AspirateSequenceCountFinalization);
			pcbControlSettingsBak.AddAsLast(AspirateSequenceCalibration);
			// private, read / write
			pcbControlSettingsBak.AddAsLast(AspirateSequenceCurrentAlignPos);
			pcbControlSettingsBak.AddAsLast(AspirateSequenceReloaded);

			// dispense settings 

			pcbControlSequencesBak.AddAsLast(DispenseSequence);
			pcbControlSequencesBak.AddAsLast(DispenseSequenceOriginal);
			pcbControlSettingsBak.AddAsLast(DispenseSubmergeDepth);
			pcbControlSettingsBak.AddAsLast(DispenseChannelVariable);
			pcbControlSettingsBak.AddAsLast(DispenseVolume);
			pcbControlSettingsBak.AddAsLast(DispenseRestVolume);
			pcbControlSettingsBak.AddAsLast(DispenseRestVolumeDestination);
			pcbControlSettingsBak.AddAsLast(DispenseRestVolumeFluidHeight);
			// ba 20050511 begin (SCR#736)
			pcbControlSettingsBak.AddAsLast(DispenseRestVolumeToAspirateSequenceSurface);
			// ba 20050511 end (SCR#736)
			pcbControlSettingsBak.AddAsLast(DispenseChannelUse);
			pcbControlSettingsBak.AddAsLast(DispenseCLLDSensitivity);
			pcbControlSettingsBak.AddAsLast(DispenseSequenceCounting);
			pcbControlSettingsBak.AddAsLast(DispenseFluidHeight);
			pcbControlSettingsBak.AddAsLast(DispenseMode);
			pcbControlSettingsBak.AddAsLast(DispenseLiquidFollowing);
			pcbControlSettingsBak.AddAsLast(DispensePrerinsingMixCycles);
			pcbControlSettingsBak.AddAsLast(DispensePrerinsingMixPosition);
			pcbControlSettingsBak.AddAsLast(DispensePrerinsingMixVolume);
			pcbControlSettingsBak.AddAsLast(DispenseUserDefinedLiquidClass);
			pcbControlSettingsBak.AddAsLast(DispenseSequenceReloadable);
			pcbControlSettingsBak.AddAsLast(DispenseSequenceReducible);
			pcbControlSettingsBak.AddAsLast(DispenseSequenceCurrentInitialization);
			pcbControlSettingsBak.AddAsLast(DispenseSequenceCurrentFinalization);
			pcbControlSettingsBak.AddAsLast(DispenseSequenceCountInitialization);
			pcbControlSettingsBak.AddAsLast(DispenseSequenceCountFinalization);
			pcbControlSettingsBak.AddAsLast(DispenseSequenceCalibration);
			// private, read / write
			pcbControlSettingsBak.AddAsLast(DispenseSequenceCurrentAlignPos);
			pcbControlSettingsBak.AddAsLast(DispenseSequenceReloaded);

			return(hslTrue);
		}

		static function RestoreControlSettingsAndSequences()
		{
			variable settingIndex(0);
			variable sequenceIndex(0);

			if (pcbControlSettingsBak.GetSize() == 0)
				return;

			// NOTE: Don't change the order of adding the elements to the array pcbControlSettingsBak.

			// general settings 

			UserResponseTime = pcbControlSettingsBak.ElementAt(settingIndex++);
			ErrorHandling = pcbControlSettingsBak.ElementAt(settingIndex++);
			TipCountingEnabled = pcbControlSettingsBak.ElementAt(settingIndex++);
			TipCountingIdentifier = pcbControlSettingsBak.ElementAt(settingIndex++);
			CopyPatternEnabled = pcbControlSettingsBak.ElementAt(settingIndex++);
			ExcludeErrorPositionsEnabled = pcbControlSettingsBak.ElementAt(settingIndex++);

			// aliquot settings 

			// public, read / write
			AliquotEnabled = pcbControlSettingsBak.ElementAt(settingIndex++);
			AliquotEnabledBak = pcbControlSettingsBak.ElementAt(settingIndex++);
			AliquotPreAspirateVolume = pcbControlSettingsBak.ElementAt(settingIndex++);
			AliquotAspirateDefaultMixingEnabled = pcbControlSettingsBak.ElementAt(settingIndex++);

			// initialize settings 

			// ba 2002-09-19 begin (this is a reference)
			//InitializeWasteDestination.CopySequence(pcbControlSequencesBak.ElementAt(sequenceIndex++));
			// end
			InitializeUseDefaultWaste = pcbControlSettingsBak.ElementAt(settingIndex++);
			InitializeChannelVariable = pcbControlSettingsBak.ElementAt(settingIndex++);
			InitializeSequenceCounting = pcbControlSettingsBak.ElementAt(settingIndex++);
			InitializeChannelUse = pcbControlSettingsBak.ElementAt(settingIndex++);
			InitializeAlways = pcbControlSettingsBak.ElementAt(settingIndex++);
			InitializeEnabled = pcbControlSettingsBak.ElementAt(settingIndex++);
			InitializeWasteDestinationReloadable = pcbControlSettingsBak.ElementAt(settingIndex++);
			InitializeWasteDestinationReducible = pcbControlSettingsBak.ElementAt(settingIndex++);

			// load carrier settings

			LoadCarrierBarcodeFileName = pcbControlSettingsBak.ElementAt(settingIndex++);

			// calibrate carrier settings

			CalibrateCarrierChannel = pcbControlSettingsBak.ElementAt(settingIndex++);

			// tip pickup settings 

			TipPickupSequence.CopySequence(pcbControlSequencesBak.ElementAt(sequenceIndex++));
			TipPickupChannelVariable = pcbControlSettingsBak.ElementAt(settingIndex++);
			TipPickupSequenceCounting = pcbControlSettingsBak.ElementAt(settingIndex++);
			TipPickupChannelUse = pcbControlSettingsBak.ElementAt(settingIndex++);
			TipPickupEnabled = pcbControlSettingsBak.ElementAt(settingIndex++);
			TipPickupSequenceReloadable = pcbControlSettingsBak.ElementAt(settingIndex++);
			TipPickupSequenceReducible = pcbControlSettingsBak.ElementAt(settingIndex++);
			TipPickupSequenceCurrentInitialization = pcbControlSettingsBak.ElementAt(settingIndex++);
			TipPickupSequenceCurrentFinalization = pcbControlSettingsBak.ElementAt(settingIndex++);
			TipPickupSequenceCountInitialization = pcbControlSettingsBak.ElementAt(settingIndex++);
			TipPickupSequenceCountFinalization = pcbControlSettingsBak.ElementAt(settingIndex++);
			TipPickupReverseSequenceCount = pcbControlSettingsBak.ElementAt(settingIndex++);

			// tip eject settings 

			// ba 2002-09-19 begin (this is a reference)
			//TipEjectWasteDestination.CopySequence(pcbControlSequencesBak.ElementAt(sequenceIndex++));
			// end
			TipEjectUseDefaultWaste = pcbControlSettingsBak.ElementAt(settingIndex++);
			TipEjectChannelVariable = pcbControlSettingsBak.ElementAt(settingIndex++);
			TipEjectChannelUse = pcbControlSettingsBak.ElementAt(settingIndex++);
			TipEjectSequenceCounting = pcbControlSettingsBak.ElementAt(settingIndex++);
			TipEjectWasteDestinationReloadable = pcbControlSettingsBak.ElementAt(settingIndex++);
			TipEjectWasteDestinationReducible = pcbControlSettingsBak.ElementAt(settingIndex++);

			// aspirate settings 
			AspirateSequenceReloadable = pcbControlSettingsBak.ElementAt(settingIndex++);

			// dispense settings 
			DispenseSequenceReloadable = pcbControlSettingsBak.ElementAt(settingIndex++);

			// aspirate settings 

			AspirateSequence.CopySequence(pcbControlSequencesBak.ElementAt(sequenceIndex++));
			AspirateSequenceOriginal.CopySequence(pcbControlSequencesBak.ElementAt(sequenceIndex++));
			AspirateSequenceCounting              = pcbControlSettingsBak.ElementAt(settingIndex++);
			AspirateChannelUse                    = pcbControlSettingsBak.ElementAt(settingIndex++);
			AspirateMode                          = pcbControlSettingsBak.ElementAt(settingIndex++);
			AspirateCLLDSensitivity               = pcbControlSettingsBak.ElementAt(settingIndex++);
			AspirateFluidHeight                   = pcbControlSettingsBak.ElementAt(settingIndex++);
			AspirateSubmergeDepth                 = pcbControlSettingsBak.ElementAt(settingIndex++);
			AspirateVolume                        = pcbControlSettingsBak.ElementAt(settingIndex++);
			AspirateRestVolume                    = pcbControlSettingsBak.ElementAt(settingIndex++);
			AspirateChannelVariable               = pcbControlSettingsBak.ElementAt(settingIndex++);
			AspirateMaxHeightDiff                 = pcbControlSettingsBak.ElementAt(settingIndex++);
			AspiratePLLDSensitivity               = pcbControlSettingsBak.ElementAt(settingIndex++);
			AspirateLiquidFollowing               = pcbControlSettingsBak.ElementAt(settingIndex++);
			AspiratePrerinsingMixCycles           = pcbControlSettingsBak.ElementAt(settingIndex++);
			AspiratePrerinsingMixPosition         = pcbControlSettingsBak.ElementAt(settingIndex++);
			AspiratePrerinsingMixVolume           = pcbControlSettingsBak.ElementAt(settingIndex++);
			AspirateUserDefinedLiquidClass        = pcbControlSettingsBak.ElementAt(settingIndex++);
			AspirateSequenceReloadable            = pcbControlSettingsBak.ElementAt(settingIndex++);
			AspirateSequenceReducible             = pcbControlSettingsBak.ElementAt(settingIndex++);
			AspirateSequenceCurrentInitialization = pcbControlSettingsBak.ElementAt(settingIndex++);
			AspirateSequenceCurrentFinalization   = pcbControlSettingsBak.ElementAt(settingIndex++);
			AspirateSequenceCountInitialization   = pcbControlSettingsBak.ElementAt(settingIndex++);
			AspirateSequenceCountFinalization     = pcbControlSettingsBak.ElementAt(settingIndex++);
			AspirateSequenceCalibration           = pcbControlSettingsBak.ElementAt(settingIndex++);
			// private, read / write
			AspirateSequenceCurrentAlignPos       = pcbControlSettingsBak.ElementAt(settingIndex++);
			AspirateSequenceReloaded            = pcbControlSettingsBak.ElementAt(settingIndex++);

			// dispense settings 

			DispenseSequence.CopySequence(pcbControlSequencesBak.ElementAt(sequenceIndex++));
			DispenseSequenceOriginal.CopySequence(pcbControlSequencesBak.ElementAt(sequenceIndex++));
			DispenseSubmergeDepth                 = pcbControlSettingsBak.ElementAt(settingIndex++);
			DispenseChannelVariable               = pcbControlSettingsBak.ElementAt(settingIndex++);
			DispenseVolume                        = pcbControlSettingsBak.ElementAt(settingIndex++);
			DispenseRestVolume                    = pcbControlSettingsBak.ElementAt(settingIndex++);
			DispenseRestVolumeDestination         = pcbControlSettingsBak.ElementAt(settingIndex++);
			DispenseRestVolumeFluidHeight         = pcbControlSettingsBak.ElementAt(settingIndex++);
			// ba 20050511 begin (SCR#736)
			DispenseRestVolumeToAspirateSequenceSurface = pcbControlSettingsBak.ElementAt(settingIndex++);
			// ba 20050511 end (SCR#736)
			DispenseChannelUse                    = pcbControlSettingsBak.ElementAt(settingIndex++);
			DispenseCLLDSensitivity               = pcbControlSettingsBak.ElementAt(settingIndex++);
			DispenseSequenceCounting              = pcbControlSettingsBak.ElementAt(settingIndex++);
			DispenseFluidHeight                   = pcbControlSettingsBak.ElementAt(settingIndex++);
			DispenseMode                          = pcbControlSettingsBak.ElementAt(settingIndex++);
			DispenseLiquidFollowing               = pcbControlSettingsBak.ElementAt(settingIndex++);
			DispensePrerinsingMixCycles           = pcbControlSettingsBak.ElementAt(settingIndex++);
			DispensePrerinsingMixPosition         = pcbControlSettingsBak.ElementAt(settingIndex++);
			DispensePrerinsingMixVolume           = pcbControlSettingsBak.ElementAt(settingIndex++);
			DispenseUserDefinedLiquidClass        = pcbControlSettingsBak.ElementAt(settingIndex++);
			DispenseSequenceReloadable            = pcbControlSettingsBak.ElementAt(settingIndex++);
			DispenseSequenceReducible             = pcbControlSettingsBak.ElementAt(settingIndex++);
			DispenseSequenceCurrentInitialization = pcbControlSettingsBak.ElementAt(settingIndex++);
			DispenseSequenceCurrentFinalization   = pcbControlSettingsBak.ElementAt(settingIndex++);
			DispenseSequenceCountInitialization   = pcbControlSettingsBak.ElementAt(settingIndex++);
			DispenseSequenceCountFinalization     = pcbControlSettingsBak.ElementAt(settingIndex++);
			DispenseSequenceCalibration           = pcbControlSettingsBak.ElementAt(settingIndex++);
			// private, read / write
			DispenseSequenceCurrentAlignPos       = pcbControlSettingsBak.ElementAt(settingIndex++);
			DispenseSequenceReloaded            = pcbControlSettingsBak.ElementAt(settingIndex++);
		}

		static function BackupSequences(
			device& ML_STAR,
			sequence& tipPickupSequence,
			sequence& aspirateSequence,
			sequence& dispenseSequence,
			sequence& defaultWasteSequence,
			variable& controlBlock)
		{
			if ("TCB" == controlBlock)
				TCB::TipPickupSequence = tipPickupSequence;
			if ("PCB" == controlBlock)
				TipPickupSequence = tipPickupSequence;

			AspirateSequence = aspirateSequence;
			AspirateSequenceOriginal = aspirateSequence;
			DispenseSequence = dispenseSequence;
			DispenseSequenceOriginal = dispenseSequence;

			if ("TCB" == controlBlock)
			{
				if (0 == TCB::TipEjectWasteDestination.GetTotal())
					// tip eject waste destination has not been set
					ML_STAR.GetSequenceRef(defaultWasteSequence.GetName(), TCB::TipEjectWasteDestination);
			}
			if ("PCB" == controlBlock)
			{
				// set defaults for other sequences
				if (0 == InitializeWasteDestination.GetTotal())
					// initialize waste destination has not been set
					ML_STAR.GetSequenceRef(defaultWasteSequence.GetName(), InitializeWasteDestination);
				if (0 == TipEjectWasteDestination.GetTotal())
					// tip eject waste destination has not been set
					ML_STAR.GetSequenceRef(defaultWasteSequence.GetName(), TipEjectWasteDestination);
			}

			return(hslTrue);
		}

		static function RestoreSequences(
			sequence& tipPickupSequence,
			sequence& aspirateSequence,
			sequence& dispenseSequence,
			sequence& defaultWasteSequence)
		{
			tipPickupSequence.CopySequence(TipPickupSequence);
			aspirateSequence.CopySequence(AspirateSequence);
			dispenseSequence.CopySequence(DispenseSequence);

			if (0 < InitializeWasteDestination.GetTotal())
				// initialize waste destination has been set
				defaultWasteSequence.CopySequence(InitializeWasteDestination);
			if (0 < TipEjectWasteDestination.GetTotal())
				// tip eject waste destination has been set
				defaultWasteSequence.CopySequence(TipEjectWasteDestination);

			return(hslTrue);
		}

		static function InitializeSequences(
			sequence& tipPickupSequence,
			sequence& aspirateSequence,
			sequence& dispenseSequence)
		{
			// switch over SequenceInitialization entries and
			// initialize first the count and then the current
			if (SequenceInitialization::none == TipPickupSequenceCountInitialization)
			{
				// nothing to do
			}
			if (SequenceInitialization::reset == TipPickupSequenceCountInitialization)
			{
				// reset count 
				tipPickupSequence.SetCount(tipPickupSequence.GetTotal());
			}
			if (SequenceInitialization::none == AspirateSequenceCountInitialization)
			{
				// nothing to do
			}
			if (SequenceInitialization::reset == AspirateSequenceCountInitialization)
			{
				// reset count 
				aspirateSequence.SetCount(aspirateSequence.GetTotal());
			}
			if (SequenceInitialization::none == DispenseSequenceCountInitialization)
			{
				// nothing to do
			}
			if (SequenceInitialization::reset == DispenseSequenceCountInitialization)
			{
				// reset count 
				dispenseSequence.SetCount(dispenseSequence.GetTotal());
			}
			if (SequenceInitialization::none == TipPickupSequenceCurrentInitialization)
			{
				// nothing to do
			}
			if (SequenceInitialization::reset == TipPickupSequenceCurrentInitialization)
			{
				// reset current position
				tipPickupSequence.SetCurrentPosition(1);
			}
			if (SequenceInitialization::none == AspirateSequenceCurrentInitialization)
			{
				// nothing to do
			}
			if (SequenceInitialization::reset == AspirateSequenceCurrentInitialization)
			{
				// reset current position
				aspirateSequence.SetCurrentPosition(1);
			}
			if (SequenceInitialization::none == DispenseSequenceCurrentInitialization)
			{
				// nothing to do
			}
			if (SequenceInitialization::reset == DispenseSequenceCurrentInitialization)
			{
				// reset current position
				dispenseSequence.SetCurrentPosition(1);
			}

			return(hslTrue);
		}

		static function FinalizeSequences(
			device& ML_STAR,
			sequence& tipPickupSequence,
			sequence& aspirateSequence,
			sequence& dispenseSequence,
			variable drivingMode)
		{
			variable aspirateOrgCurrent;				// current of original aspirate sequence
			variable aspirateOrgCount;					// count of original aspirate sequence
			variable aspirateOrgMax;					// max positions of original aspirate sequence
			variable aspirateActCurrent;				// current of actual aspirate sequence
			variable aspirateActCount;					// count of actual aspirate sequence
			variable aspirateActTotal;					// total of actual aspirate sequence
			
			variable dispenseOrgCurrent;				// current of original dispense sequence
			variable dispenseOrgCount;					// count of original dispense sequence
			variable dispenseOrgMax;					// max positions of original dispense sequence
			variable dispenseActCurrent;				// current of actual dispense sequence
			variable dispenseActCount;					// count of actual dispense sequence
			variable dispenseActTotal;					// total of actual dispense sequence
			
			variable tipPickupOrgMax;					// max positions of original tip pickup sequence

			// backup current and count of actual and original aspirate and dispense sequences
			if (! AspirateSequenceReloaded )
			{
				aspirateOrgCurrent = AspirateSequence.GetCurrentPosition();
				aspirateOrgCount   = AspirateSequence.GetCount();
				aspirateOrgMax     = AspirateSequence.GetMax();
			}
			else
			{
				// 2009-05-27/cj: if reloaded changed to get the 'original' indexes from ...SequenceOriginal
				// 					because the 'CAPITAL letter named sequence' may be reseted if the target sequence is reloaded
				aspirateOrgCurrent = AspirateSequenceOriginal.GetCurrentPosition();
				aspirateOrgCount   = AspirateSequenceOriginal.GetCount();
				aspirateOrgMax     = AspirateSequenceOriginal.GetMax();
			}
			aspirateActCurrent = aspirateSequence.GetCurrentPosition();
			aspirateActCount   = aspirateSequence.GetCount();
			aspirateActTotal   = aspirateSequence.GetTotal();

			if (! DispenseSequenceReloaded )
			{
				dispenseOrgCurrent = DispenseSequence.GetCurrentPosition();
				dispenseOrgCount   = DispenseSequence.GetCount();
				dispenseOrgMax     = DispenseSequence.GetMax();
			}
			else
			{
				// 2009-05-27/cj: if reloaded changed to get the 'original' indexes from ...SequenceOriginal
				// 					because the 'CAPITAL letter named sequence' may be reseted if the target sequence is reloaded
				dispenseOrgCurrent = DispenseSequenceOriginal.GetCurrentPosition();
				dispenseOrgCount   = DispenseSequenceOriginal.GetCount();
				dispenseOrgMax     = DispenseSequenceOriginal.GetMax();
			}
			dispenseActCurrent = dispenseSequence.GetCurrentPosition();
			dispenseActCount   = dispenseSequence.GetCount();
			dispenseActTotal   = dispenseSequence.GetTotal();
			
			tipPickupOrgMax    = TipPickupSequence.GetMax();


			// always restore the non-driving sequence if the sequence isn't reloadable 
			UnalignSequences(aspirateSequence, dispenseSequence, drivingMode);


			// switch over SequenceFinalization entries and
			// finalize first the count and then the current

			// ------------ count finalizations ------------- 

			if (SequenceFinalization::none  == TipPickupSequenceCountFinalization ||
				 SequenceFinalization::final == TipPickupSequenceCountFinalization)
			{
				// set count position to identical / final position
			}
			else if (SequenceFinalization::reset == TipPickupSequenceCountFinalization)
			{
				// reset count 
				tipPickupSequence.SetCount(tipPickupSequence.GetTotal());
			}
			else if (SequenceFinalization::initial == TipPickupSequenceCountFinalization)
			{
				// set count position to initial position
				tipPickupSequence.SetCount(TipPickupSequence.GetCount());
			}


			if (SequenceFinalization::none  == AspirateSequenceCountFinalization ||
				 SequenceFinalization::reset == AspirateSequenceCountFinalization)
			{
				// reset count even if none to have a defined final state
				aspirateSequence.SetCount(aspirateActTotal);
			}
			else if (SequenceFinalization::initial == AspirateSequenceCountFinalization)
			{
				if ( ! AspirateSequenceReloaded )		// 2009-05-27/cj: added 
				{
					// set count position to initial position
					aspirateSequence.SetCount(aspirateOrgCount);
				}
				else
				{
					// 2009-05-27/cj: Sequence has changed (reloaded) and we must not apply the initial count because
					//                it has no relation to the changed sequence.
					if ( AspirateSequenceReducible )
					{
						// Reset the count to the total because during re-load all postions until total has been loaded/identified
						aspirateSequence.SetCount(aspirateActTotal);
					}
					else
					{
					 	// Keep the count where it is because during re-load only postions between
						// current and actual count has been loaded/identified (positions > actual count are not loaded
						aspirateSequence.SetCount(aspirateActCount);
					}
				}
			}
			else if (SequenceFinalization::final == AspirateSequenceCountFinalization)
			{
				if ( ! AspirateSequenceReloaded )		// 2009-05-27/cj: added
				{
					// set the count to the position where pipetting has stopped
					if ( AspirateSequenceReloadable )	// reloadable but has not reloaded		
					{
						if ( 0 < aspirateActCurrent )
						{
							aspirateSequence.SetCount(aspirateActCurrent - 1);				
						}
						else
						{
							// completely used 
							aspirateSequence.SetCount(aspirateActCount);				
						}
					}
					else
					{
						// Original count has been manipulated because of reuse option
						// and some positions may have been inserted due of sequence reusing
						// use the calculation as it was used available in previous version 
						SequenceFinalization::CountToFinal(aspirateSequence, 
																	  aspirateOrgCurrent, aspirateActCurrent, 
																	  aspirateOrgCount,   aspirateActCount);
					}
				}
				else
				{
					// 2009-05-27/cj: Sequence has changed (reloaded) and we move the count to
					//                last used position during last cycle on this sequence.
					if ( 0 < aspirateActCurrent )
					{
						aspirateSequence.SetCount(aspirateActCurrent - 1);				
					}
					else
					{
						// reloaded and completely used between 1 and count
						if ( AspirateSequenceReducible )
						{
							// Reset the count to the total because during re-load all postions until total has been loaded/identified
							aspirateSequence.SetCount(aspirateActTotal);
						}
						else
						{
						 	// Keep the count where it is because during re-load only postions between
							// current and actual count has been loaded/identified (positions > actual count are not loaded
							aspirateSequence.SetCount(aspirateActCount);
						}
					}
				}
			}


			if (SequenceFinalization::none  == DispenseSequenceCountFinalization ||
				 SequenceFinalization::reset == DispenseSequenceCountFinalization)
			{
				// reset count even if none to have a defined final state
				dispenseSequence.SetCount(dispenseActTotal);
			}
			else if (SequenceFinalization::initial == DispenseSequenceCountFinalization)
			{
				if ( ! DispenseSequenceReloaded )		// 2009-05-27/cj: added 
				{
					// set count position to initial position
					dispenseSequence.SetCount(dispenseOrgCount);
				}
				else
				{
					// 2009-05-27/cj: Sequence has changed (reloaded) and we must not apply the initial count because
					//                it has no relation to the changed sequence.
					if ( DispenseSequenceReducible )
					{
						// Reset the count to the total because during re-load all postions until total has been loaded/identified
						dispenseSequence.SetCount(dispenseActTotal);
					}
					else
					{
					 	// Keep the count where it is because during re-load only postions between
						// current and actual count has been loaded/identified (positions > actual count are not loaded
						dispenseSequence.SetCount(dispenseActCount);
					}
				}
			}
			else if (SequenceFinalization::final == DispenseSequenceCountFinalization)
			{
				if ( ! DispenseSequenceReloaded )		// 2009-05-27/cj: added
				{
					// set the count to the position where pipetting has stopped
					if ( DispenseSequenceReloadable )	// reloadable but has not reloaded		
					{
						if ( 0 < dispenseActCurrent )
						{
							dispenseSequence.SetCount(dispenseActCurrent - 1);				
						}
						else
						{
							// completely used 
							dispenseSequence.SetCount(dispenseActCount);				
						}
					}
					else
					{
						// Original count has been manipulated because of reuse option
						// and some positions may have been inserted due of sequence reusing
						// use the calculation as it was used available in previous version 
						SequenceFinalization::CountToFinal(dispenseSequence, 
																	  dispenseOrgCurrent, dispenseActCurrent, 
																	  dispenseOrgCount,   dispenseActCount);
					}
				}
				else
				{
					// 2009-05-27/cj: Sequence has changed (reloaded) and we move the count to
					//                last used position during last cycle on this sequence.
					if ( 0 < dispenseActCurrent )
					{
						dispenseSequence.SetCount(dispenseActCurrent - 1);				
					}
					else
					{
						// reloaded and completely used between 1 and count
						if ( DispenseSequenceReducible )
						{
							// Reset the count to the total because during re-load all postions until total has been loaded/identified
							dispenseSequence.SetCount(dispenseActTotal);
						}
						else
						{
						 	// Keep the count where it is because during re-load only postions between
							// current and actual count has been loaded/identified (positions > actual count are not loaded
							dispenseSequence.SetCount(dispenseActCount);
						}
					}
				}
			}


			// ------------ current finalizations ------------
			if (SequenceFinalization::none == TipPickupSequenceCurrentFinalization)
			{
				// set current position to identical position
			}
			else if (SequenceFinalization::reset == TipPickupSequenceCurrentFinalization)
			{
				// reset current position
				tipPickupSequence.SetCurrentPosition(1);
			}
			else if (SequenceFinalization::initial == TipPickupSequenceCurrentFinalization)
			{
				// set current position to initial position
				tipPickupSequence.SetCurrentPosition(TipPickupSequence.GetCurrentPosition());
			}
			else if (SequenceFinalization::final == TipPickupSequenceCurrentFinalization)
			{
				// set current position to final position
				tipPickupSequence.SetCurrentPosition(TipPickupSequence.GetCount() + 1);
			}


			if (SequenceFinalization::none  == AspirateSequenceCurrentFinalization ||
				 SequenceFinalization::reset == AspirateSequenceCurrentFinalization)
			{
				// reset current even if 'none' to have a defined final state
				aspirateSequence.SetCurrentPosition(1);
			}
			else if (SequenceFinalization::initial == AspirateSequenceCurrentFinalization)
			{
				if ( ! AspirateSequenceReloaded )		// 2009-05-27/cj: added 
				{
					// set current position to initial position
					aspirateSequence.SetCurrentPosition(aspirateOrgCurrent);
				}
				else
				{
					// 2009-05-27/cj: Sequence has changed (reloaded) and we must not apply the initial current because
					//                it has no relation to the changed sequence.
					//                --> Reset the current only.
					//                (We don't trace a warning because the sequence has been reloaded/changed and in this
					//                case the initial state of the sequence is lost which is expected)
					aspirateSequence.SetCurrentPosition(1);
				}
			}
			else if (SequenceFinalization::final == AspirateSequenceCurrentFinalization)
			{
				if ( ! AspirateSequenceReloaded )		// 2009-05-27/cj: added
				{
					// set the count to the position where pipetting has stopped
					if ( AspirateSequenceReloadable )	// reloadable but has not reloaded		
					{
						// keep the current where it is - even of zero because this corresponds to its final position
						aspirateSequence.SetCurrentPosition(aspirateActCurrent);
					}
					else
					{
						// Original count has been manipulated because of reuse option and the current
						// IS zero even if some positions are remaining
						// Use the calculation as it was used available in previous version 
						SequenceFinalization::CurrentToFinal(aspirateSequence, 
																		 aspirateOrgCurrent, aspirateActCurrent, 
																		 aspirateOrgCount,   aspirateActCount);
					}
				}
				else
				{
					// sequence has been reloaded and we keep the current where it is
					aspirateSequence.SetCurrentPosition(aspirateActCurrent);
				}
			}


			if (SequenceFinalization::none  == DispenseSequenceCurrentFinalization ||
				 SequenceFinalization::reset == DispenseSequenceCurrentFinalization)
			{
				// reset current even if 'none' to have a defined final state
				dispenseSequence.SetCurrentPosition(1);
			}
			else if (SequenceFinalization::initial == DispenseSequenceCurrentFinalization)
			{
				if ( ! DispenseSequenceReloaded )		// 2009-05-27/cj: added 
				{
					// set current position to initial position
					dispenseSequence.SetCurrentPosition(dispenseOrgCurrent);
				}
				else
				{
					// 2009-05-27/cj: Sequence has changed (reloaded) and we must not apply the initial current because
					//                it has no relation to the changed sequence.
					//                --> Reset the current only.
					//                (We don't trace a warning because the sequence has been reloaded/changed and in this
					//                case the initial state of the sequence is lost which is expected)
					dispenseSequence.SetCurrentPosition(1);
				}
			}
			else if (SequenceFinalization::final == DispenseSequenceCurrentFinalization)
			{
				if ( ! DispenseSequenceReloaded )		// 2009-05-27/cj: added
				{
					// set the count to the position where pipetting has stopped
					if ( DispenseSequenceReloadable )	// reloadable but has not reloaded		
					{
						// keep the current where it is - even of zero because this corresponds to its final position
						dispenseSequence.SetCurrentPosition(dispenseActCurrent);
					}
					else
					{
						// Original count has been manipulated because of reuse option and the current
						// IS zero even if some positions are remaining
						// Use the calculation as it was used available in previous version 
						SequenceFinalization::CurrentToFinal(dispenseSequence, 
																		 dispenseOrgCurrent, dispenseActCurrent, 
																		 dispenseOrgCount,   dispenseActCount);
					}
				}
				else
				{
					// sequence has been reloaded and we keep the current where it is
					dispenseSequence.SetCurrentPosition(dispenseActCurrent);
				}
			}


			// reset max positions
			tipPickupSequence.SetMax(tipPickupOrgMax);

			if ( ! AspirateSequenceReloaded ) 			// added 2009-05-27/cj
				aspirateSequence.SetMax(aspirateOrgMax);
			else
				aspirateSequence.SetMax(aspirateActTotal);

			if ( ! DispenseSequenceReloaded )
				dispenseSequence.SetMax(dispenseOrgMax);
			else
				dispenseSequence.SetMax(dispenseActTotal);

			// ba 2003-05-27 begin (SCR#406)
			// The max number of positions of the tip eject waste destination has been 
			// aligned with the tip pickup the aspirate and the dispense sequence to 
			// prevent errors when redespesing the rest volume into the waste. So we have 
			// to re-align the max number of positions of the tip eject waste destination.
			AlignSequences(hslTrue, TipEjectWasteDestination, 1);

			return(hslTrue);
		}

		static function InitializeSequenceFromDeckLayout(
			device& ML_STAR,
			sequence& deckSequence)
		{
			// read instance data from deck layout file
			if (0 != ML_STAR.ResetSequence(deckSequence.GetName()))
			{
				// found the sequence in the deck layout file
				deckSequence.CopySequence(ML_STAR.GetSequence(deckSequence.GetName()));
				return(hslTrue);
			}
			else
			{
				// didn't found the sequence in the deck layout file
				return(hslFalse);
			}
		}

		static function UpdateSequenceInDeckLayout(
			device& ML_STAR,
			sequence& deckSequence)
		{
			// get reference to deck sequence in the deck layout file
			sequence seq;
			if (0 != ML_STAR.GetSequenceRef(deckSequence.GetName(), seq))
			{
				// found the sequence in the deck layout file
				seq.CopySequence(deckSequence);
				return(hslTrue);
			}
			// didn't found the sequence in the deck layout file
			return(hslFalse);
		}

		static function AlignSequenceCounts(
			sequence& aspirateSequence,
			sequence& dispenseSequence,
			variable aspirateMultiplicity,
			variable dispenseMultiplicity,
			variable drivingMode,
			variable continueAlignment)
		{
			variable aspirateSequenceCount(0);								// count of aspirate sequence
			variable dispenseSequenceCount(0);								// count of dispense sequence
			variable aspirateSequenceCurrentPosBak(0);					// backup of inital current position of aspirate sequence
			variable dispenseSequenceCurrentPosBak(0);					// backup of inital current position of dispense sequence
			variable aspirateSequenceCurrentPosFallback(0);				// backup of current fallback position of aspirate sequence
			variable dispenseSequenceCurrentPosFallback(0);				// backup of current fallback position of dispense sequence
			variable aspirateSequenceCountPosBak(0);						// backup of inital count position of aspirate sequence
			variable dispenseSequenceCountPosBak(0);						// backup of inital count position of dispense sequence
			variable aspirateSequenceSetMax(hslTrue);						// set max flag of aspirate sequence
			variable dispenseSequenceSetMax(hslTrue);						// set max flag of dispense sequence
			variable newCount;													// new count of aspirate or dispense sequence respectively

			variable aspirateOrgCurrent;				// current of original aspirate sequence
			variable aspirateOrgCount;					// count of original aspirate sequence
			variable aspirateActCurrent;				// current of actual aspirate sequence
			variable aspirateActCount;					// count of actual aspirate sequence
			variable dispenseOrgCurrent;				// current of original dispense sequence
			variable dispenseOrgCount;					// count of original dispense sequence
			variable dispenseActCurrent;				// current of actual dispense sequence
			variable dispenseActCount;					// count of actual dispense sequence

			// backup current and count of actual and original aspirate and dispense sequences
			aspirateOrgCurrent = AspirateSequence.GetCurrentPosition();
			aspirateOrgCount = AspirateSequence.GetCount();
			aspirateActCurrent = aspirateSequence.GetCurrentPosition();
			aspirateActCount = aspirateSequence.GetCount();
			dispenseOrgCurrent = DispenseSequence.GetCurrentPosition();
			dispenseOrgCount = DispenseSequence.GetCount();
			dispenseActCurrent = dispenseSequence.GetCurrentPosition();
			dispenseActCount = dispenseSequence.GetCount();

			// unalign the sequences
			UnalignSequences(aspirateSequence, dispenseSequence, drivingMode);

			// set current position to final position
			SequenceFinalization::CurrentToFinal(aspirateSequence, 
															 aspirateOrgCurrent, aspirateActCurrent, 
															 aspirateOrgCount, aspirateActCount);
			SequenceFinalization::CurrentToFinal(dispenseSequence, 
															 dispenseOrgCurrent, dispenseActCurrent, 
															 dispenseOrgCount, dispenseActCount);
			if (0 == aspirateSequence.GetCurrentPosition() && 0 != AspirateSequence.GetCurrentPosition())
				aspirateSequence.SetCurrentPosition(AspirateSequence.GetCurrentPosition());
			if (0 == dispenseSequence.GetCurrentPosition() && 0 != DispenseSequence.GetCurrentPosition())
				dispenseSequence.SetCurrentPosition(DispenseSequence.GetCurrentPosition());

			// backup current position
			aspirateSequenceCurrentPosBak = aspirateSequence.GetCurrentPosition();
			dispenseSequenceCurrentPosBak = dispenseSequence.GetCurrentPosition();
			aspirateSequenceCurrentPosFallback = aspirateSequenceCurrentPosBak;
			dispenseSequenceCurrentPosFallback = dispenseSequenceCurrentPosBak;
			if (aspirateSequence.GetCurrentPosition() != AspirateSequence.GetCurrentPosition())
				aspirateSequenceCurrentPosFallback = AspirateSequence.GetCurrentPosition();
			if (dispenseSequence.GetCurrentPosition() != DispenseSequence.GetCurrentPosition())
				dispenseSequenceCurrentPosFallback = DispenseSequence.GetCurrentPosition();

			// backup count
			aspirateSequenceCountPosBak = aspirateSequence.GetCount();
			dispenseSequenceCountPosBak = dispenseSequence.GetCount();

			// get the count of the aspirate and dispense the sequences
			if (0 < aspirateSequence.GetCurrentPosition())
				aspirateSequenceCount = PTL_Util::Max(0, aspirateSequence.GetCount() - aspirateSequence.GetCurrentPosition() + 1);
			if (0 < dispenseSequence.GetCurrentPosition())
				dispenseSequenceCount = PTL_Util::Max(0, dispenseSequence.GetCount() - dispenseSequence.GetCurrentPosition() + 1);

			// set max flag of aspirate and dispense sequence
			aspirateSequenceSetMax = (aspirateSequenceCount == aspirateSequence.GetMax());
			dispenseSequenceSetMax = (dispenseSequenceCount == dispenseSequence.GetMax());

			// align the aspirate and dispense sequences
			if (dispenseMultiplicity * aspirateSequenceCount < aspirateMultiplicity * dispenseSequenceCount)
			{
				// the aspirate sequence effectively has less positions than the dispense sequence 
				if (DrivingMode::aspirateDriven == drivingMode)
				{
					// don't align the sequences if the non-driving sequence 
					// effectively has more positions and is reloadable
					if (!DispenseSequenceReloadable)
					{
						// if we are aspirate driven, we simply reduce the dispense 
						// sequence to the same effective size as the aspirate sequence
						AlignSequences(hslFalse, aspirateSequence, aspirateMultiplicity, dispenseSequence, dispenseMultiplicity);
					}
				}
				else
				{
					// don't align the sequences if the non-driving sequence 
					// effectively has less positions but is reloadable
					if (!AspirateSequenceReloadable)
					{
						// if we are dispense driven, we repeat the aspirate 
						// sequence to the same effective size as the dispense sequence
						variable index;							// loop index
						sequence tail;								// place to hold positions to the right of the index count 

						// Note, that we must insert positions after the index count

						// backup tail of aspirateSequence
						aspirateSequence.SetCount(aspirateSequence.GetTotal());
						for (index = aspirateSequence.SetCurrentPosition(aspirateSequenceCountPosBak + 1);
							  0 < index; 
							  index = aspirateSequence.Increment(1))
							tail.Add(aspirateSequence.GetLabwareId(), aspirateSequence.GetPositionId());

						// remove tail of aspirateSequence
						for (index = aspirateSequence.GetTotal(); 
							  aspirateSequenceCountPosBak < index; 
							  index--)
							aspirateSequence.RemoveAt(index);

						// calculate the number of positions to insert to the right of count 
						aspirateSequenceCount = Ceiling((aspirateMultiplicity * dispenseSequenceCount - 
																	dispenseMultiplicity * aspirateSequenceCount) / 
																  (1.0 * dispenseMultiplicity));

						// insert positions to the right of count 
						aspirateSequence.SetCount(aspirateSequenceCountPosBak);
						if (continueAlignment && 0 < AspirateSequenceCurrentAlignPos)
							aspirateSequence.SetCurrentPosition(AspirateSequenceCurrentAlignPos);
						else
							aspirateSequence.SetCurrentPosition(aspirateSequenceCurrentPosFallback);
						for (index = 0; index < aspirateSequenceCount; index++)
						{
							aspirateSequence.Add(aspirateSequence.GetLabwareId(), 
														aspirateSequence.GetPositionId());
							// Add adjusts count if count == total
							aspirateSequence.SetCount(aspirateSequenceCountPosBak);
							if (aspirateSequence.Increment(1) == 0)
								aspirateSequence.SetCurrentPosition(aspirateSequenceCurrentPosFallback);
						}
						AspirateSequenceCurrentAlignPos = aspirateSequence.GetCurrentPosition();

						// remeber the new count
						newCount = aspirateSequence.GetTotal();

						// restore tail of aspirateSequence
						for (index = tail.SetCurrentPosition(1); 
							  0 < index; 
							  index = tail.Increment(1))
							aspirateSequence.Add(tail.GetLabwareId(), tail.GetPositionId());

						// set the new count
						aspirateSequence.SetCount(newCount);
					}
				}
			}
			else if (dispenseMultiplicity * aspirateSequenceCount > aspirateMultiplicity * dispenseSequenceCount)
			{
				// the dispense sequence effectively has less positions than the aspirate sequence 
				if (DrivingMode::dispenseDriven == drivingMode)
				{
					// don't align the sequences if the non-driving sequence 
					// effectively has more positions and is reloadable
					if (!AspirateSequenceReloadable)
					{
						// if we are dispense driven, we simply reduce the aspirate
						// sequence to the same effective size as the dispense sequence
						AlignSequences(hslFalse, aspirateSequence, aspirateMultiplicity, dispenseSequence, dispenseMultiplicity);
					}
				}
				else
				{
					// don't align the sequences if the non-driving sequence 
					// effectively has less positions but is reloadable
					if (!DispenseSequenceReloadable)
					{
						// if we are aspirate driven, we repeat the dispense
						// sequence to the same effective size as the aspirate sequence
						variable index;							// loop index
						sequence tail;								// place to hold positions to the right of the index count 

						// Note, that we must insert positions after the index count

						// backup tail of dispenseSequence
						dispenseSequence.SetCount(dispenseSequence.GetTotal());
						for (index = dispenseSequence.SetCurrentPosition(dispenseSequenceCountPosBak + 1); 
							  0 < index; 
							  index = dispenseSequence.Increment(1))
							tail.Add(dispenseSequence.GetLabwareId(), dispenseSequence.GetPositionId());

						// remove tail of dispenseSequence
						for (index = dispenseSequence.GetTotal(); 
							  dispenseSequenceCountPosBak < index; 
							  index--)
							dispenseSequence.RemoveAt(index);

						// calculate the number of positions to insert to the right of count 
						dispenseSequenceCount = Ceiling((dispenseMultiplicity * aspirateSequenceCount - 
																	aspirateMultiplicity * dispenseSequenceCount) / 
																	(1.0 * aspirateMultiplicity));

						// insert positions to the right of count 
						dispenseSequence.SetCount(dispenseSequenceCountPosBak);
						if (continueAlignment && 0 < DispenseSequenceCurrentAlignPos)
							dispenseSequence.SetCurrentPosition(DispenseSequenceCurrentAlignPos);
						else
							dispenseSequence.SetCurrentPosition(dispenseSequenceCurrentPosFallback);
						for (index = 0; index < dispenseSequenceCount; index++)
						{
							dispenseSequence.Add(dispenseSequence.GetLabwareId(), 
														dispenseSequence.GetPositionId());
							// Add adjusts count if count == total
							dispenseSequence.SetCount(dispenseSequenceCountPosBak);
							if (dispenseSequence.Increment(1) == 0)
								dispenseSequence.SetCurrentPosition(dispenseSequenceCurrentPosFallback);
						}
						DispenseSequenceCurrentAlignPos = dispenseSequence.GetCurrentPosition();

						// remeber the new count
						newCount = dispenseSequence.GetTotal();

						// restore tail of dispenseSequence
						for (index = tail.SetCurrentPosition(1); 
							  0 < index; 
							  index = tail.Increment(1))
							dispenseSequence.Add(tail.GetLabwareId(), tail.GetPositionId());

						// set the new count
						dispenseSequence.SetCount(newCount);
					}
				}
			}

			// set the max position
			if (aspirateSequenceSetMax)
				aspirateSequence.SetMax(aspirateSequence.GetCount());
			if (dispenseSequenceSetMax)
				dispenseSequence.SetMax(dispenseSequence.GetCount());

			// restore current position
			aspirateSequence.SetCurrentPosition(aspirateSequenceCurrentPosBak);
			dispenseSequence.SetCurrentPosition(dispenseSequenceCurrentPosBak);

			return(hslTrue);
		}

		static function UnalignSequences(
			sequence& aspirateSequence,
			sequence& dispenseSequence,
			variable drivingMode)
		{
			// restore the sequence if the sequence isn't reloadable 
			if (!DispenseSequenceReloadable)
			{
				// restore dispense sequence
				dispenseSequence.CopySequence(DispenseSequence);
			}
			if (!AspirateSequenceReloadable)
			{
				// restore aspirate sequence
				aspirateSequence.CopySequence(AspirateSequence);
			}
		}

		static function IncrementSequences(
			sequence& aspirateSequence,
			sequence& dispenseSequence,
			//>> 20060503
			variable incrementIndividualVolumes,
			variable& volumes_1[],
			variable& volumes_2[],
			//<< 20060503
			variable aspirateMultiplicity,
			variable dispenseMultiplicity,
			variable currentMultiplicity,
			variable drivingMode)
		{
			// restore the temporarily excluded sequence positions contained in the internal data of the StepReturn 
			StepReturn::RestoreData(aspirateSequence, dispenseSequence,
											incrementIndividualVolumes, volumes_1, volumes_2,
											aspirateMultiplicity, dispenseMultiplicity, currentMultiplicity);

			if (SequenceCounting::manually == AspirateSequenceCounting)
			{
				if (1 < aspirateMultiplicity && 
					 0 < currentMultiplicity && currentMultiplicity < aspirateMultiplicity)
				{
					variable usedAspiratePositions(0);	// used aspirate positions

					// we are incrementing in the multiplicity loop
					aspirateSequence++;

					// get the correction of the used positions of the aspirate sequence 
					// if an error occured and copy pattern has been enabled
					usedAspiratePositions = StepReturn::GetUsedPos(StepReturn::StepType::aspirate);
					aspirateSequence.Increment(usedAspiratePositions);

					// reset internal aspirate  data of StepReturn, except the used aspirate positions
					StepReturn::ResetData(hslTrue, hslFalse);
					StepReturn::SetUsedPos(StepReturn::StepType::aspirate, usedAspiratePositions);

					// propagate excluded positions of aspirate sequence if an error occured and copy pattern has been enabled
					StepReturn::PropagateExcludedPositions(aspirateSequence, AspirateChannelVariable, StepReturn::StepType::aspirate);
				}
				else if (0 == currentMultiplicity)
				{
					// we are incrementing in the sequence loop
					aspirateSequence++;
					aspirateSequence.Increment(StepReturn::GetUsedPos(StepReturn::StepType::aspirate));

					// reset internal aspirate  data of StepReturn 
					StepReturn::ResetData(hslTrue, hslFalse);
				}
			}
			if (SequenceCounting::manually == DispenseSequenceCounting)
			{
				if (1 < dispenseMultiplicity && 
					 0 < currentMultiplicity && currentMultiplicity < dispenseMultiplicity)
				{
					variable usedDispensePositions(0);	// used dispense positions

					// we are incrementing in the multiplicity loop
					dispenseSequence++;

					// get the correction of the used positions of the dispense sequence 
					// if an error occured and copy pattern has been enabled
					usedDispensePositions = StepReturn::GetUsedPos(StepReturn::StepType::dispense);
					dispenseSequence.Increment(usedDispensePositions);

					// reset internal dispense  data of StepReturn, except the used dispense positions 
					StepReturn::ResetData(hslFalse, hslTrue);
					StepReturn::SetUsedPos(StepReturn::StepType::dispense, usedDispensePositions);

					// propagate excluded positions of dispense sequence if an error occured and copy pattern has been enabled
					StepReturn::PropagateExcludedPositions(dispenseSequence, DispenseChannelVariable, StepReturn::StepType::dispense);
				}
				else if (0 == currentMultiplicity)
				{
					// we are incrementing in the sequence loop
					dispenseSequence++;
					dispenseSequence.Increment(StepReturn::GetUsedPos(StepReturn::StepType::dispense));

					// reset internal dispense  data of StepReturn 
					StepReturn::ResetData(hslFalse, hslTrue);
				}
			}
			return(PCB::GetCurrentPos(aspirateSequence, dispenseSequence, drivingMode));
		}

		static function NeedsTipPickup(
			variable& sequenceCycle,
			variable& multiplicityCycle,
			variable& volumeCycle,
			variable tipRenewalCycleSeq,
			variable tipRenewalCycleMul,
			variable tipRenewalCycleVol)
		{
			return(TipPickupEnabled && 
					((0 == sequenceCycle && 0 == multiplicityCycle && 0 == volumeCycle)	|| 
					 (0 == multiplicityCycle && 0 == volumeCycle)								||
					 (0 == volumeCycle)																	|| 
					 tipRenewalCycleSeq <= sequenceCycle											|| 
					 tipRenewalCycleMul <= multiplicityCycle										|| 
					 tipRenewalCycleVol <= volumeCycle));
		}

		static function NeedsReload(
			sequence& tipPickupSequence,
			sequence& aspirateSequence,
			sequence& dispenseSequence,
			variable aspirateMultiplicity,
			variable dispenseMultiplicity,
			variable drivingMode,
			variable deferTipPickupSequence)
		{
			variable needsReload(hslFalse);	// indicates 'needs reload'

			// don't reload anything if the driving sequence isn't reloadable and 
			// the current position of the driving sequence is 0
			if ((DrivingMode::aspirateDriven == drivingMode && !AspirateSequenceReloadable && 0 == aspirateSequence.GetCurrentPosition()) || 
				 (DrivingMode::dispenseDriven == drivingMode && !DispenseSequenceReloadable && 0 == dispenseSequence.GetCurrentPosition()))
				return(hslFalse);

			if (1 < aspirateMultiplicity || 1 < dispenseMultiplicity)
			{
				variable currentPos(0);					// current position
				variable numberOfActiveChannels(0);	// number of active channels
				variable availableAspPositions(0);	// number of available aspirate positions 
				variable availableDspPositions(0);	// number of available dispense positions 
				variable maxAspPositionsPerStep(0);	// max number of aspirate positions per step
				variable maxDspPositionsPerStep(0);	// max number of dispense positions per step
				variable channelPattern("");			// channel pattern

				// set the tip pickup channel pattern
				if (StepReturn::IsRecovering2())
					// we are recovering from an error
					channelPattern = StepReturn::GetChannelPattern();
				else
					// we are not recovering from an error
					channelPattern = AspirateChannelVariable;

				numberOfActiveChannels = NumberOfActiveChannels(channelPattern);
				maxAspPositionsPerStep = aspirateSequence.GetMax();					// a constraint ?
				currentPos = aspirateSequence.GetCurrentPosition();
				if (0 < currentPos)
					availableAspPositions = aspirateSequence.GetCount() - currentPos + 1;
				maxAspPositionsPerStep = PTL_Util::Min(numberOfActiveChannels, PTL_Util::Min(maxAspPositionsPerStep, availableAspPositions));

				// set the tip pickup channel pattern
				if (StepReturn::IsRecovering2())
					// we are recovering from an error
					channelPattern = StepReturn::GetChannelPattern();
				else
					// we are not recovering from an error
					channelPattern = DispenseChannelVariable;
				numberOfActiveChannels = NumberOfActiveChannels(channelPattern);
				maxDspPositionsPerStep = dispenseSequence.GetMax();					// a constraint ?
				currentPos = dispenseSequence.GetCurrentPosition();
				if (0 < currentPos)
					availableDspPositions = dispenseSequence.GetCount() - currentPos + 1;
				maxDspPositionsPerStep = PTL_Util::Min(numberOfActiveChannels, PTL_Util::Min(maxDspPositionsPerStep, availableDspPositions));

				if (maxDspPositionsPerStep < maxAspPositionsPerStep)
				{
					if (DispenseSequenceReloadable)
						// force the reload
						dispenseSequence.SetCurrentPosition(0);
				}
				if (maxDspPositionsPerStep > maxAspPositionsPerStep)
				{
					if (AspirateSequenceReloadable)
						// force the reload 
						aspirateSequence.SetCurrentPosition(0);
				}
			}

			// evaluate reload condition
			// a sequence needs to be reloaded, if all of the following 
			// conditions evaluate to true:
			//		- the sequence is reloadable
			//		- the current position of the sequence is 0
			//		- the sequence is not empty
			if (!deferTipPickupSequence)
				needsReload = needsReload || (TipPickupSequenceReloadable && 0 == tipPickupSequence.GetCurrentPosition() && 0 < tipPickupSequence.GetCount());
			needsReload = needsReload || (AspirateSequenceReloadable && 0 == aspirateSequence.GetCurrentPosition() && 0 < aspirateSequence.GetCount());
			needsReload = needsReload || (DispenseSequenceReloadable && 0 == dispenseSequence.GetCurrentPosition() && 0 < dispenseSequence.GetCount());

			return(needsReload);
		}

		static function DrivingSequenceNeedsReload(
			sequence& aspirateSequence,
			sequence& dispenseSequence,
			variable drivingMode)
		{
			if (DrivingMode::aspirateDriven == drivingMode)
				return(AspirateSequenceReloadable && 0 == aspirateSequence.GetCurrentPosition() && 0 < aspirateSequence.GetCount());
			else
				return(DispenseSequenceReloadable && 0 == dispenseSequence.GetCurrentPosition() && 0 < dispenseSequence.GetCount());
		}

		static function TipPickupSequenceNeedsPreload(
			sequence& tipPickupSequence,
			sequence& aspirateSequence,
			sequence& dispenseSequence,
			variable drivingMode)
		{
			variable needsPreload(hslFalse);		// indicates 'needs preload'
			variable currentPos(0);					// current position
			variable numberOfActiveChannels(0);	// number of active channels
			variable availableTipPositions(0);	// number of available tip pickup positions 
			variable availableAspPositions(0);	// number of available aspirate positions 
			variable availableDspPositions(0);	// number of available dispense positions 
			variable maxTipPositionsPerStep(0);	// max number of tip pickup positions per step
			variable maxAspPositionsPerStep(0);	// max number of aspirate positions per step
			variable maxDspPositionsPerStep(0);	// max number of dispense positions per step
			variable channelPattern("");			// channel pattern

			// don't reload anything if the driving sequence isn't reloadable and 
			// the current position of the driving sequence is 0
			if ((DrivingMode::aspirateDriven == drivingMode && !AspirateSequenceReloadable && 0 == aspirateSequence.GetCurrentPosition()) || 
				 (DrivingMode::dispenseDriven == drivingMode && !DispenseSequenceReloadable && 0 == dispenseSequence.GetCurrentPosition()))
				return(hslFalse);

			// set the aspirate channel pattern
			if (StepReturn::IsRecovering2())
				// we are recovering from an error
				channelPattern = StepReturn::GetChannelPattern();
			else
				// we are not recovering from an error
				channelPattern = AspirateChannelVariable;
			numberOfActiveChannels = NumberOfActiveChannels(channelPattern);
			currentPos = aspirateSequence.GetCurrentPosition();
			if (0 < currentPos)
				availableAspPositions = aspirateSequence.GetCount() - currentPos + 1;
			maxAspPositionsPerStep = PTL_Util::Min(numberOfActiveChannels, availableAspPositions);

			// set the dispense channel pattern
			if (StepReturn::IsRecovering2())
				// we are recovering from an error
				channelPattern = StepReturn::GetChannelPattern();
			else
				// we are not recovering from an error
				channelPattern = DispenseChannelVariable;
			numberOfActiveChannels = NumberOfActiveChannels(channelPattern);
			currentPos = dispenseSequence.GetCurrentPosition();
			if (0 < currentPos)
				availableDspPositions = dispenseSequence.GetCount() - currentPos + 1;
			maxDspPositionsPerStep = PTL_Util::Min(numberOfActiveChannels, availableDspPositions);

			// set the tip pickup channel pattern
			if (StepReturn::IsRecovering2())
				// we are recovering from an error
				channelPattern = StepReturn::GetChannelPattern();
			else
				// we are not recovering from an error
				channelPattern = TipPickupChannelVariable;
			numberOfActiveChannels = NumberOfActiveChannels(channelPattern);
			currentPos = tipPickupSequence.GetCurrentPosition();
			if (0 < currentPos)
				availableTipPositions = tipPickupSequence.GetCount() - currentPos + 1;
			maxTipPositionsPerStep = PTL_Util::Min(numberOfActiveChannels, availableTipPositions);
			
			if (maxTipPositionsPerStep < numberOfActiveChannels &&
				 (maxTipPositionsPerStep < maxAspPositionsPerStep || 
				  maxTipPositionsPerStep < maxDspPositionsPerStep))
			{
				if (TipPickupSequenceReloadable)
					// force the reload 
					tipPickupSequence.SetCurrentPosition(0);
			}

			// evaluate reload condition
			// a sequence needs to be reloaded, if all of the following 
			// conditions evaluate to true:
			//		- the sequence is reloadable
			//		- the current position of the sequence is 0
			//		- the sequence is not empty
			needsPreload = (TipPickupSequenceReloadable && 0 == tipPickupSequence.GetCurrentPosition() && 0 < tipPickupSequence.GetCount());

			return(needsPreload);
		}

		static function AskUserForReload(
			sequence& aspirateSequence,
			sequence& dispenseSequence,
			variable drivingMode)
		{
			variable sequenceName("");
			variable retVal;
			
			// 20050629 cjoerg: show modeless dialog instead of modal MessageBox;
			dialog dlg;

			if (DrivingMode::aspirateDriven == drivingMode)
				sequenceName = aspirateSequence.GetName();
			else
				sequenceName = dispenseSequence.GetName();

			dlg.SetOutput(StringTable::Load(IDS::askUserForReloadText), " '", sequenceName, "' ", StringTable::Load(IDS::questionMark));

			if ( 0 != UserResponseTime )
				Sound::Play(PTL_Util::objHxServicesGeneralSettings2.HxServicesSoundEnum_soundQuestion);
			retVal = dlg.ShowOutput(StringTable::Load(IDS::askUserForReloadTitle),
											hslQuestion	| hslYesNo|hslDefButton1,
											UserResponseTime);
			Sound::Stop();

			return (retVal);

			//return(MessageBox(StringTable::Load(IDS::askUserForReloadText) + " '" + sequenceName + "' " + StringTable::Load(IDS::questionMark), 
			//						StringTable::Load(IDS::askUserForReloadTitle), 
			//						hslQuestion	|hslYesNo|hslDefButton1, 
			//						UserResponseTime));
		}

		static function ReloadWasCanceled(
			sequence& tipPickupSequence,
			sequence& aspirateSequence,
			sequence& dispenseSequence,
			variable drivingMode)
		{
			if (DrivingMode::aspirateDriven == drivingMode)
			{
				if (DispenseSequenceReloadable && 
					 0 == dispenseSequence.GetCurrentPosition() && 
					 0 == dispenseSequence.GetCount() && 
					 0 < aspirateSequence.GetCurrentPosition() && 
					 0 < aspirateSequence.GetCount())
				{
					return(hslTrue);
				}
				if (TipPickupSequenceReloadable && 
					 0 == tipPickupSequence.GetCurrentPosition() && 
					 0 == tipPickupSequence.GetCount() && 
					 0 < aspirateSequence.GetCurrentPosition() && 
					 0 < aspirateSequence.GetCount())
				{
					return(hslTrue);
				}
			}
			else
			{
				if (AspirateSequenceReloadable && 
					 0 == aspirateSequence.GetCurrentPosition() && 
					 0 == aspirateSequence.GetCount() && 
					 0 < dispenseSequence.GetCurrentPosition() && 
					 0 < dispenseSequence.GetCount())
				{
					return(hslTrue);
				}
				if (TipPickupSequenceReloadable && 
					 0 == tipPickupSequence.GetCurrentPosition() && 
					 0 == tipPickupSequence.GetCount() && 
					 0 < dispenseSequence.GetCurrentPosition() && 
					 0 < dispenseSequence.GetCount())
				{
					return(hslTrue);
				}
			}
			return(hslFalse);
		}

		// ba 20050511 begin (SCR#449)
		// Returns the short file (excluding path and extension) name from a given file name.
		static function GetShortFileName(string& fileName) variable
		{
			string shortFileName("");
			variable foundAt(-1);
			shortFileName = fileName;
			foundAt = StrReverseFind(shortFileName, ".");
			if (0 <= foundAt)
			{
				shortFileName = StrLeft(shortFileName, foundAt);
			}
			foundAt = StrReverseFind(shortFileName, "\\");
			if (0 <= foundAt)
			{
				shortFileName = StrRight(shortFileName, shortFileName.GetLength() - foundAt - 1);
			}
			return(shortFileName);
		}

		static function GetFileNameFromLabware(device& ML_STAR, variable& carrierName) variable
		{
			variable fileName("");							

			object deckLayout;
			object labware;
			object editLabware;

			deckLayout = ML_STAR.GetDeckLayoutObject();
			if (!deckLayout.IsNull())
			{
				labware = deckLayout.Labware(carrierName);
				if (!labware.IsNull())
				{
					labware.GetObject("IEditLabware5", editLabware);
					if (!editLabware.IsNull())
					{
						fileName = editLabware.FileName;
					}
				}
			}

			fileName = GetShortFileName(fileName);

			return(fileName);
		}

		static function GetCarrierType(device& ML_STAR, variable& carrierName) variable
		{
			variable carrierType("");							
			variable propertyKeys[];															// Place to hold property keys
			variable propertyValues[];															//	Place to hold property values

			propertyKeys.AddAsLast(StringConstants::carLabelName);
			ML_STAR.GetLabwareData(carrierName, propertyKeys, propertyValues);
			if (0 < propertyValues.GetSize() && "" != propertyValues.GetAt(0))
			{
				// Labware supports key MlStarCarLabelName
				carrierType = propertyValues.GetAt(0);
			}
			else
			{
				carrierType = GetFileNameFromLabware(ML_STAR, carrierName);
			}

			return(carrierType);
		}
		// ba 20050511 end (SCR#449)

		static function ReloadSequences(
			device& ML_STAR,
			sequence& tipPickupSequence,
			sequence& aspirateSequence,
			sequence& dispenseSequence,
			variable aspirateMultiplicity,
			variable dispenseMultiplicity,
			variable drivingMode,
			variable isWashSequence)
		{
			variable carrierNames[];									// place to hold names of carriers which should be unloaded/loaded
			variable carrierCalibrateFlags[];						// place to hold calibrate flag of carriers which should be unloaded/loaded
			variable carrierBarcodeReadPositions[];				// place to hold barcode read positions of carriers which should be loaded
			variable carrierBarcodeReadLabwareNames[];			// place to hold the carrier barcode read labware names
			variable carrierBarcodeReadPositionNames[];			// place to hold the carrier barcode read position names
			variable carrierRecoveryOptionContinue[];				// place to hold visibility of recovery option Continue (0 = invisible, 1 = visible)
			variable carrierRecoveryOptionExclude[];				// place to hold visibility of recovery option Exclude (0 = invisible, 1 = visible)
			variable carrierRecoveryOptionDefault[];				// place to hold default of recovery options Continue and Exclude (0 = Continue, 1 = Exclude) 
			variable carrierKitLotCheckEnabled[];					// place to hold kit lot check enabled flags
			variable prepareReloadMode;								// prepare reload mode (0 = prepare for unload, 1 = prepare for reduce, 2 = prepare for load)
			variable numberOfCarriers;									// number of carrier names in carrierNames array
			variable prompt("");											// user prompt
			variable index1(0);											// loop index
			variable index2(0);											// loop index
			variable index3(0);											// loop index
			variable carrier("");										// carrier name
			variable positions("");										// carrier barcode read positions
			variable labwareNames("");									// comma separated labware names
			variable positionNames("");								// comma separated position names
			variable qualifiedExcludePositions[];					// place to hold (qualified) positions of elements which should be excluded from the loading sequences
			variable unqualifiedExcludePositions[];				// place to hold (unqualified) positions of elements which should be excluded from the loading sequences
			variable excludeLabwareNames[];							// place to hold labware names of elements which should be excluded from the loading sequences
			variable excludePositionNames[];							// place to hold position names of elements which should be excluded from the loading sequences
			variable recoveryOptionContinue(hslTrue);				// visibility of recovery option Continue (0 = invisible, 1 = visible)
			variable recoveryOptionExclude(hslTrue);				// visibility of recovery option Continue (0 = invisible, 1 = visible)
			variable recoveryOptionDefault(0);						// default of recovery options Continue and Exclude (0 = Continue, 1 = Exclude) 
			variable kitLotCheckEnabled(hslFalse);					// kit lot check enabled flag
			variable expiredKitLots(hslTrue);						// expired kitlots flag
			variable expiredKitLotsStr("");							// list (csv) of expired kitlots, initial value must not be empty
			variable tipEjectChannelVariable("");					// channel pattern to eject tip used to calibrate carriers
			variable tipPickupChannelVariable("");					// channel pattern to pickup tip used to calibrate carriers
			variable pickupTip(hslFalse);								// indicates whether tip on channel used to calibrate carriers should be picked up
			variable rc[];													// step return 
			variable canceledByTheUser(hslFalse);					// indicates whether an error recovery has been canceled by the user
			variable size;													// array size

			// prepare for unload of sequences
			prepareReloadMode = 0;										// prepare for unload
			carrierNames.SetSize(0);
			carrierCalibrateFlags.SetSize(0);
			carrierBarcodeReadPositions.SetSize(0);
			carrierBarcodeReadLabwareNames.SetSize(0);
			carrierBarcodeReadPositionNames.SetSize(0);
			carrierRecoveryOptionContinue.SetSize(0);
			carrierRecoveryOptionExclude.SetSize(0);
			carrierRecoveryOptionDefault.SetSize(0);
			carrierKitLotCheckEnabled.SetSize(0);
			ML_STAR.RemoveSequences();
			prompt = StringTable::Load(IDS::unloadSequencePrompt) + StringConstants::crlf;
			PrepareReloadOfSequences(ML_STAR, 
									 		 tipPickupSequence, aspirateSequence, dispenseSequence, 
											 aspirateMultiplicity, dispenseMultiplicity, drivingMode, 
											 prepareReloadMode, ErrorHandling,
											 carrierNames, carrierCalibrateFlags, carrierBarcodeReadPositions, 
											 carrierBarcodeReadLabwareNames, carrierBarcodeReadPositionNames,
											 carrierRecoveryOptionContinue, carrierRecoveryOptionExclude, 
											 carrierRecoveryOptionDefault, carrierKitLotCheckEnabled,
											 prompt, hslFalse);		// 2005-07-11 cjoerg: Don't warn, we get data for unloading

			// show the user graphically the sequences that will be unloaded
			numberOfCarriers = carrierNames.GetSize();
			if (0 < numberOfCarriers)
			{
				ML_STAR.EditSequences(StringTable::Load(IDS::unloadSequenceTitle), prompt, UserResponseTime,
											 Sound::GetSoundFile(PTL_Util::objHxServicesGeneralSettings2.HxServicesSoundEnum_soundLoading));
			}

			// unload carriers
			for (index1 = 0; index1 < numberOfCarriers; index1++)
			{
				carrier = carrierNames.GetAt(index1);

				// debug
				#ifdef _DEBUG
				FormatTrace("DEBUG", "ML_STAR.UnloadCarrier", TraceStatus::progress, "carrier = ", carrier);
				#endif

				onerror goto UnloadCarrierErrorHandler;
				rc = MlStarSteps::StepUnloadCarrier_cer(	ML_STAR,
															carrier,
															//ErrorHandling,
                                             ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, UnloadCarrierCustomStepID),
                                             UnloadCarrierCustomStepID,
															UserResponseTime);
				onerror goto 0;
				if (!StepReturn::Evaluate(ML_STAR, rc, ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, UnloadCarrierCustomStepID)))
					Error::RaiseLast();
			}

			// prepare for reduce of sequences
			prepareReloadMode = 1;										// prepare for reduce
			carrierNames.SetSize(0);
			carrierCalibrateFlags.SetSize(0);
			carrierBarcodeReadPositions.SetSize(0);
			carrierBarcodeReadLabwareNames.SetSize(0);
			carrierBarcodeReadPositionNames.SetSize(0);
			carrierRecoveryOptionContinue.SetSize(0);
			carrierRecoveryOptionExclude.SetSize(0);
			carrierRecoveryOptionDefault.SetSize(0);
			carrierKitLotCheckEnabled.SetSize(0);
			ML_STAR.RemoveSequences();
			prompt = StringTable::Load(IDS::loadSequencePrompt) + StringConstants::crlf;
			PrepareReloadOfSequences(ML_STAR, 
											 tipPickupSequence, aspirateSequence, dispenseSequence, 
											 aspirateMultiplicity, dispenseMultiplicity, drivingMode, 
											 prepareReloadMode, ErrorHandling, 
											 carrierNames, carrierCalibrateFlags, carrierBarcodeReadPositions, 
											 carrierBarcodeReadLabwareNames, carrierBarcodeReadPositionNames,
											 carrierRecoveryOptionContinue, carrierRecoveryOptionExclude, 
											 carrierRecoveryOptionDefault, carrierKitLotCheckEnabled,
											 prompt, hslFalse);		// 2005-07-11 cjoerg: Don't warn, we get data for reduce

			// ask the user graphically to reduce the original sequence to the shape that should be loaded
			numberOfCarriers = carrierNames.GetSize();
			if (0 < numberOfCarriers)
			{
				ML_STAR.EditSequences(StringTable::Load(IDS::loadSequenceTitle), prompt, UserResponseTime,
											 Sound::GetSoundFile(PTL_Util::objHxServicesGeneralSettings2.HxServicesSoundEnum_soundLoading));
			}

			// prepare reload of sequences
			prepareReloadMode = 2;										// prepare for reload
			carrierNames.SetSize(0);
			carrierCalibrateFlags.SetSize(0);
			carrierBarcodeReadPositions.SetSize(0);
			carrierBarcodeReadLabwareNames.SetSize(0);
			carrierBarcodeReadPositionNames.SetSize(0);
			carrierRecoveryOptionContinue.SetSize(0);
			carrierRecoveryOptionExclude.SetSize(0);
			carrierRecoveryOptionDefault.SetSize(0);
			carrierKitLotCheckEnabled.SetSize(0);
			ML_STAR.RemoveSequences();
			prompt = StringTable::Load(IDS::loadSequencePrompt) + StringConstants::crlf;
			PrepareReloadOfSequences(ML_STAR, 
											 tipPickupSequence, aspirateSequence, dispenseSequence, 
											 aspirateMultiplicity, dispenseMultiplicity, drivingMode, 
											 prepareReloadMode, ErrorHandling, 
											 carrierNames, carrierCalibrateFlags, carrierBarcodeReadPositions, 
											 carrierBarcodeReadLabwareNames, carrierBarcodeReadPositionNames,
											 carrierRecoveryOptionContinue, carrierRecoveryOptionExclude, 
											 carrierRecoveryOptionDefault, carrierKitLotCheckEnabled,
											 prompt, hslTrue);		// 2005-07-11 cjoerg: Warn if load settings are not defined for current task

			// setup name of barcode file
			if ("" == LoadCarrierBarcodeFileName)
			{
				// barcode file name has not been set by the user,
				// setup default barcode file name
				variable methodName;
				methodName = GetMethodFileName();
				//>> 20060523
				if ("" == methodName)
				{
					methodName = GetWorkflowFileName();
				}
				//<< 20060523
				index1 = StrReverseFind(methodName, ".");
				if (0 <= index1)
					methodName = StrLeft(methodName, index1);
				index1 = StrReverseFind(methodName, "\\");
				if (0 <= index1)
					methodName = StrMid(methodName, index1 + 1, StrGetLength(methodName));
				LoadCarrierBarcodeFileName = GetLogFilesPath() + "\\" + methodName + StringConstants::barcodeFileExt;
			}

			// get numbers of carriers
			numberOfCarriers = carrierNames.GetSize();

			// load carriers
			for (index1 = 0; index1 < numberOfCarriers; index1++)
			{
				carrier = carrierNames.ElementAt(index1);
				positions = carrierBarcodeReadPositions.ElementAt(index1);
				labwareNames = carrierBarcodeReadLabwareNames.ElementAt(index1);
				positionNames = carrierBarcodeReadPositionNames.ElementAt(index1);
				if (ErrorHandling::continue == ErrorHandling  || ErrorHandling::custom == ErrorHandling)
				{
					recoveryOptionContinue = carrierRecoveryOptionContinue.ElementAt(index1);
					recoveryOptionExclude = carrierRecoveryOptionExclude.ElementAt(index1);
					recoveryOptionDefault = carrierRecoveryOptionDefault.ElementAt(index1);
					kitLotCheckEnabled = carrierKitLotCheckEnabled.ElementAt(index1);
				}
				else
				{
					recoveryOptionContinue = LCB::recoveryOptionContinueDefault;
					recoveryOptionExclude = LCB::recoveryOptionExcludeDefault;
					recoveryOptionDefault = LCB::recoveryOptionDefaultDefault;
					kitLotCheckEnabled = LCB::kitLotCheckEnabledDefault;
				}

				// if a kit lot expired, the carrier shall be unloaded and the user has to change the labware
				while (expiredKitLots)
				{

					// debug
					#ifdef _DEBUG
					FormatTrace("DEBUG", "ML_STAR.LoadCarrier", TraceStatus::progress, "carrier = ", carrier, ", positions = ", positions);
					FormatTrace("DEBUG", "ML_STAR.LoadCarrier", TraceStatus::progress, "labwareNames = ", labwareNames);
					FormatTrace("DEBUG", "ML_STAR.LoadCarrier", TraceStatus::progress, "positionNames = ", positionNames);
					FormatTrace("DEBUG", "ML_STAR.LoadCarrier", TraceStatus::progress, "recoveryOptionContinue = ", recoveryOptionContinue);
					FormatTrace("DEBUG", "ML_STAR.LoadCarrier", TraceStatus::progress, "recoveryOptionExclude = ", recoveryOptionExclude);
					if (0 == recoveryOptionDefault)
						FormatTrace("DEBUG", "ML_STAR.LoadCarrier", TraceStatus::progress, "recoveryOptionDefault = continue");
					else
						FormatTrace("DEBUG", "ML_STAR.LoadCarrier", TraceStatus::progress, "recoveryOptionDefault = exclude");
					FormatTrace("DEBUG", "ML_STAR.LoadCarrier", TraceStatus::progress, "kitLotCheckEnabled = ", kitLotCheckEnabled);
					#endif

					StepReturn::Empty(rc);
					qualifiedExcludePositions.SetSize(0);
					unqualifiedExcludePositions.SetSize(0);
					excludeLabwareNames.SetSize(0);
					excludePositionNames.SetSize(0);

					onerror goto LoadCarrierErrorHandler;
					rc = MlStarSteps::StepLoadCarrierEx_cer(	ML_STAR,
																carrier,
																LoadCarrierBarcodeFileName,
																//>> 20070702 (SCR#1121)
																PTL_Util::CsvToDelimited2(ML_STAR, positions),
																//<< 20070702
																recoveryOptionContinue,
																recoveryOptionExclude,
																recoveryOptionDefault,
																//ErrorHandling,
                                                ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, LoadCarrierCustomStepID),
                                                LoadCarrierCustomStepID,
																UserResponseTime);
					onerror goto 0;
					if (!StepReturn::Evaluate(ML_STAR, rc, ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, LoadCarrierCustomStepID)))
						Error::RaiseLast();
					if (!StepReturn::EvaluateExx(ML_STAR, rc, ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, LoadCarrierCustomStepID), 
														  positions, labwareNames, positionNames, 
														  qualifiedExcludePositions, excludeLabwareNames, excludePositionNames))
						Error::RaiseLast();

					// debug
					#ifdef _DEBUG
					{
					variable index2(0);
					variable size(0);
					variable source;
					variable action;
					source = "DEBUG";
					action = GetFunctionName();
					size = excludeLabwareNames.GetSize();
					for (index2 = 0; index2 < size; index2++)
					{
						FormatTrace(source, action, TraceStatus::progress, "qualifiedExcludePositions[", index2, "] = ", qualifiedExcludePositions.ElementAt(index2));
						FormatTrace(source, action, TraceStatus::progress, "excludeLabwareNames[", index2, "] = ", excludeLabwareNames.ElementAt(index2));
						FormatTrace(source, action, TraceStatus::progress, "excludePositionNames[", index2, "] = ", excludePositionNames.ElementAt(index2));
					}
					}
					#endif

					// exclude positions from the sequences
					#ifdef _DEBUG
					Assert(excludeLabwareNames.GetSize() == excludePositionNames.GetSize(), GetFunctionName());
					Assert(excludeLabwareNames.GetSize() == qualifiedExcludePositions.GetSize(), GetFunctionName());
					#endif
					if (0 < excludeLabwareNames.GetSize())
					{
							variable sequenceObjExcludePos[];						// place to hold indexes of excluded sequence positions 
							variable sequenceObjCurrentInc[];						// place to hold increments of current position during sequence exclusion
							variable sequenceObjTrackLabIds[];						// place to hold labware ids of positions which have been excluded
							variable sequenceObjTrackPosIds[];						// place to hold position ids of positions which have been excluded
							variable volumes[];

							// exclude positions from tip pickup sequence
							ExcludeSequencePositions(tipPickupSequence, 
															 0, volumes, volumes,
															 1, 0,
															 excludeLabwareNames, excludePositionNames, 
															 volumes, volumes,
															 sequenceObjExcludePos, sequenceObjCurrentInc,
															 sequenceObjTrackLabIds, sequenceObjTrackPosIds);
							sequenceObjTrackLabIds.SetSize(0);
							sequenceObjTrackPosIds.SetSize(0);

							// exclude positions from aspirate sequence
							sequenceObjExcludePos.SetSize(0);
							sequenceObjCurrentInc.SetSize(0);
							ExcludeSequencePositions(aspirateSequence, 
															 0, volumes, volumes,
															 1, 0,
															 excludeLabwareNames, excludePositionNames, 
															 volumes, volumes,
															 sequenceObjExcludePos, sequenceObjCurrentInc,
															 sequenceObjTrackLabIds, sequenceObjTrackPosIds);
							sequenceObjTrackLabIds.SetSize(0);
							sequenceObjTrackPosIds.SetSize(0);

							// exclude positions from dispenseSequence sequence
							sequenceObjExcludePos.SetSize(0);
							sequenceObjCurrentInc.SetSize(0);
							ExcludeSequencePositions(dispenseSequence, 
															 0, volumes, volumes, 
															 1, 0,
															 excludeLabwareNames, excludePositionNames, 
															 volumes, volumes,
															 sequenceObjExcludePos, sequenceObjCurrentInc,
															 sequenceObjTrackLabIds, sequenceObjTrackPosIds);
					}

					// process the string of (qualified) positions to be excluded 
					size = qualifiedExcludePositions.GetSize();
					for (index2 = 0; index2 < size; index2++)
					{
						string excludePosition("");	// position of element that should be excluded from the loading sequences
						excludePosition = qualifiedExcludePositions.ElementAt(index2);
						excludePosition = excludePosition.SpanExcluding(".");
						if (0 < excludePosition.GetLength())
						{
							// found a qualified position, e.g. 1.A1,
							// check if the corresponding labware id is still referenced in any of the loading sequences,
							// if not, the position can be removed from the string of positions 
							variable found(hslFalse);		// if 'true', the labware id is still referenced in this loading sequence
							variable excludeLabwareName;	// labware name of element that should be excluded from the loading sequences
							excludeLabwareName = excludeLabwareNames.ElementAt(index2);

							if (0 < tipPickupSequence.LookupPosition(excludeLabwareName, "", 1, hslTrue))
							{
								// the labware id is still referenced in this loading sequence
								found = hslTrue;
							}
							else
							{
								if (0 < aspirateSequence.LookupPosition(excludeLabwareName, "", 1, hslTrue))
								{
									// the labware id is still referenced in this loading sequence
									found = hslTrue;
								}
								else
								{
									if (0 < dispenseSequence.LookupPosition(excludeLabwareName, "", 1, hslTrue))
									{
										// the labware id is still referenced in this loading sequence
										found = hslTrue;
									}
								}
							}

							if (!found)
							{
								// the labware id is not referenced in any of the loading sequences,
								// check if the (unqualified) position is already contained in the collection unqualifiedExcludePositions
								variable arrIndex;
								if (!PTL_Util::Lookup(unqualifiedExcludePositions, excludePosition, arrIndex))
									unqualifiedExcludePositions.AddAsLast(excludePosition);
							}
						}
						else
						{
							// found an unqualified position, e.g. A1,
							// add the position to the collection unqualifiedExcludePositions
							unqualifiedExcludePositions.AddAsLast(qualifiedExcludePositions.ElementAt(index2));
						}
					}

					// update string of positions according to the collection unqualifiedExcludePositions
					if (0 < unqualifiedExcludePositions.GetSize())
						ExcludePositions(positions, unqualifiedExcludePositions);

					// check kitlot
					if (kitLotCheckEnabled)
					{
						// check kitlot
						expiredKitLotsStr = LCB::CheckKitLot(qualifiedExcludePositions, rc);

						// if a kit lot expired, the carrier shall be unloaded and the user has to change the labware
						if ("" != expiredKitLotsStr)
						{
							// ba 20050511 begin (SCR#449)
							variable carrierType("");
							carrierType = GetCarrierType(ML_STAR, carrier);
							// ba 20050511 end (SCR#449)

							// show the user graphically the carriers that will be unloaded
							prompt = StringTable::Load(IDS::expiredKitLotPrompt) + expiredKitLotsStr + StringConstants::crlf;
							// ba 20050511 begin (SCR#449)
							//prompt = prompt + StringTable::Load(IDS::unloadSequencePrompt) + carrier;
							prompt = prompt + StringTable::Load(IDS::unloadSequencePrompt) + carrierType;
							// ba 20050511 end (SCR#449)
							ML_STAR.EditSequences(StringTable::Load(IDS::unloadSequenceTitle), prompt, UserResponseTime,
											 			 Sound::GetSoundFile(PTL_Util::objHxServicesGeneralSettings2.HxServicesSoundEnum_soundLoading));

							// unload carrier
							#ifdef _DEBUG
							FormatTrace("DEBUG", "ML_STAR.UnloadCarrier", TraceStatus::progress, "carrier = ", carrier);
							#endif

							StepReturn::Empty(rc);
							onerror goto UnloadCarrierErrorHandler;
							rc = MlStarSteps::StepUnloadCarrier_cer(	ML_STAR,
																		carrier,
																		//ErrorHandling,
                                                      ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, UnloadCarrierCustomStepID),
                                                      UnloadCarrierCustomStepID,
																		UserResponseTime);
							onerror goto 0;
							if (!StepReturn::Evaluate(ML_STAR, rc, ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, UnloadCarrierCustomStepID)))
								Error::RaiseLast();

							// ... ask the user if he wants to reload the carrier with expired kitlots
							// ba 20050511 begin (SCR#449)
							//if (hslNo == LCB::AskUserForReload(expiredKitLotsStr, carrier, UserResponseTime))
							if (hslNo == LCB::AskUserForReload(expiredKitLotsStr, carrierType, UserResponseTime))
							// ba 20050511 end (SCR#449)
							{
								// user selected No button
								Error::Raise(IDE::loadingCanceled, GetFileName(), GetFunctionName(), GetLineNumber());
							}

							// show the user graphically the carriers that will be loaded
							prompt = StringTable::Load(IDS::expiredKitLotPrompt) + expiredKitLotsStr + StringConstants::crlf;
							// ba 20050511 begin (SCR#449)
							//prompt = prompt + StringTable::Load(IDS::loadSequencePrompt) + carrier;
							prompt = prompt + StringTable::Load(IDS::loadSequencePrompt) + carrierType;
							// ba 20050511 end (SCR#449)
							ML_STAR.EditSequences(StringTable::Load(IDS::loadSequenceTitle), prompt, UserResponseTime,
											 			 Sound::GetSoundFile(PTL_Util::objHxServicesGeneralSettings2.HxServicesSoundEnum_soundLoading));
						}
						else
						{
							expiredKitLots = hslFalse;
						}
					}
					else
					{
						expiredKitLots = hslFalse;
					}
				}
				expiredKitLots = hslTrue;
			}

			// select a channel for calibration
			if (0 == CalibrateCarrierChannel)
			{
				// channel for calibration has not been set by the user,
				// select the rightmost active channel as default channel for calibration
				if (0 < ML_STAR.GetCfgValueWithKey(MlStarCfgKey::numberOfChannels))
					CalibrateCarrierChannel = RightmostActiveChannel(TipPickupChannelVariable, tipEjectChannelVariable);
			}
			else
			{
				// channel for calibration has been set by the user,
				// select the this channel for calibration
				SelectChannelPattern(TipPickupChannelVariable, tipEjectChannelVariable, CalibrateCarrierChannel);
			}

			// calibrate carriers
			numberOfCarriers = carrierNames.GetSize();
			for (index1 = 0; index1 < numberOfCarriers; index1++)
			{
				if (carrierCalibrateFlags.GetAt(index1))
				{
					// carrier supports calibration and carrier should be calibrated
					if (0 < CalibrateCarrierChannel && TipPresence.GetAt(CalibrateCarrierChannel - 1))
					{
						if (!isWashSequence)
						{
							// debug
							#ifdef _DEBUG
							FormatTrace("DEBUG", "ML_STAR.TipEject", TraceStatus::progress,
											"name = ", TipEjectWasteDestination.GetName(), 
											", current = ", TipEjectWasteDestination.GetCurrentPosition(), 
											", count = ", TipEjectWasteDestination.GetCount(),
											", maxPos = ", TipEjectWasteDestination.GetMax());
							#endif

							// eject tip from channel used to calibrate the carriers
							onerror goto TipEjectErrorHandler;
							rc = MlStarSteps::StepTipEject_cer(	ML_STAR,
																TipEjectUseDefaultWaste,
																TipEjectWasteDestination,
																TipEjectSequenceCounting,
																tipEjectChannelVariable,
																TipEjectChannelUse,
																//ErrorHandling,
                                                ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, TipEjectCustomStepID),
                                                TipEjectCustomStepID,
																UserResponseTime);
							onerror goto 0;
							if (!StepReturn::Evaluate(ML_STAR, rc, ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, TipEjectCustomStepID)))
								Error::RaiseLast();
							pickupTip = hslTrue;
						}
						else
						{
							// set the washing state to eject needles
							// (the ErrorHandling and UserResponseTime has already been set)
							SetWashingState(ML_STAR, tipPickupSequence, "NeedleEjectChannelVariable", tipEjectChannelVariable, 1);
							onerror goto NeedleEjectErrorHandler;
							rc = WCB::NeedleEject(ML_STAR, tipPickupSequence, hslTrue);
							onerror goto 0;
							pickupTip = hslTrue;
						}
					}

					// calibrate carrier
					carrier = carrierNames.GetAt(index1);

					// debug
					#ifdef _DEBUG
					FormatTrace("DEBUG", "ML_STAR.Calibrate1536Plate", TraceStatus::progress, "carrier = ", carrier, ", channel = ", CalibrateCarrierChannel);
					#endif

					onerror goto Calibrate1536PlateErrorHandler;
					rc = MlStarSteps::StepCalibrate1536Plate_cer(ML_STAR,
																	carrier,
																	CalibrateCarrierChannel,
																	//ErrorHandling,
                                                   ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, CalibrateCarrierCustomStepID),
                                                   CalibrateCarrierCustomStepID,
																	UserResponseTime);
					onerror goto 0;
					if (!StepReturn::Evaluate(ML_STAR, rc, ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, CalibrateCarrierCustomStepID)))
						Error::RaiseLast();
				}
			}

			// pickup tip on channel used to calibrate the carriers
			if (pickupTip)
			{
				// tip has been ejected from channel used to calibrate the carriers,
				// pickup tip on channel used to calibrate the carriers

				if (!isWashSequence)
				{
					// Remark:
					// To keep the shape of the tip pickup sequence optimal if tips have been used 
					// to calibrate carriers or are used in the error handling, the tip pickup sequence 
					// is fully reversed. TipPickupReverseSequenceCount + 1 positions are copied 
					// in reverse order from the end of the original tip pickup sequence.

					variable copyCount(0);					// number of positions to copy
					variable usedPositions(0);				// number of used positions 
					sequence reverseTipPickupSequence;	// place to hold reverse order of positions of the tip pickup sequence

					// reverse tip pickup sequence
					ReverseSequence(tipPickupSequence, reverseTipPickupSequence, 
										 tipPickupSequence.GetCurrentPosition(), copyCount, TipPickupReverseSequenceCount + 1);

					// debug
					#ifdef _DEBUG
					FormatTrace("DEBUG", "ML_STAR.TipPickUp", TraceStatus::progress,
									"name = ", tipPickupSequence.GetName(), 
									", current = ", tipPickupSequence.GetCurrentPosition(), 
									", count = ", tipPickupSequence.GetCount(),
									", maxPos = ", tipPickupSequence.GetMax()); 
					#endif
					
					// pickup new tips (from reverseTipPickupSequence)
					tipPickupChannelVariable = tipEjectChannelVariable;
					onerror goto TipPickupErrorHandler;
					rc = MlStarSteps::StepTipPickup_cer(ML_STAR,
														reverseTipPickupSequence,
														TipPickupSequenceCounting,
														tipPickupChannelVariable,
														TipPickupChannelUse,
														//>> 20060519
														//ErrorHandling,
														PCB::MapErrorHandlingContinue(ErrorHandling, TipPickupCustomStepID),
														//<< 20060519
                                          TipPickupCustomStepID,
														UserResponseTime);
					onerror goto 0;
					if (!StepReturn::Evaluate(ML_STAR, rc, PCB::MapErrorHandlingContinue(ErrorHandling, TipPickupCustomStepID)))
						canceledByTheUser = hslTrue;

					// increment tip pickup sequence 
					if (SequenceCounting::manually == TipPickupSequenceCounting)
						// manual sequence counting
						tipPickupSequence.Increment(copyCount);

					// get number of used positions and update the count of the tip pickup sequence
					usedPositions = reverseTipPickupSequence.GetUsedPositions();
					if (copyCount < usedPositions)
						tipPickupSequence.SetCount(tipPickupSequence.GetCount() - usedPositions + copyCount);
				}
				else
				{

					// decrement the positions, that the previous needle eject step has incrmented,
					// so that we pickup the same needle
					tipPickupSequence.SetCurrentPosition(tipPickupSequence.GetCurrentPosition() - tipPickupSequence.GetUsedPositions());

					// set the washing state to pickup needles
					// (the ErrorHandling and UserResponseTime has already been set)
					tipPickupChannelVariable = tipEjectChannelVariable;
					SetWashingState(ML_STAR, tipPickupSequence, "NeedlePickupChannelVariable", tipPickupChannelVariable, 1);
					onerror goto NeedlePickUpErrorHandler;
					rc = WCB::NeedlePickup(ML_STAR, tipPickupSequence, hslFalse);
					onerror goto 0;
					//ba 2004-01-26 begin
					if (!StepReturn::Evaluate(ML_STAR, rc, PCB::MapErrorHandlingContinue(ErrorHandling, TipPickupCustomStepID)))
						Error::RaiseLast();
					//end
				}

			}

			// if tip counting is enabled, write indexes of tipPickupSequence to file
			if (TipCountingEnabled)
				TipCount::Write2(tipPickupSequence, TipCountingIdentifier, ML_STAR);

			// check if an error recovery has been canceled by the user
			if (canceledByTheUser)
				// re-throw error
				Error::RaiseLast();

			return(rc);

			LoadCarrierErrorHandler:
			{
				// bind error data
				StepReturn::Bind(rc);
				resume next;
			}

			UnloadCarrierErrorHandler:
			{
				// bind error data
				StepReturn::Bind(rc);
				resume next;
			}

			TipEjectErrorHandler:
			{
				// bind error data
				StepReturn::Bind(rc);
				resume next;
			}

			NeedleEjectErrorHandler:
			{
				// bind error data
				StepReturn::Bind(rc);
				resume next;
			}

			Calibrate1536PlateErrorHandler:
			{
				// bind error data
				StepReturn::Bind(rc);
				resume next;
			}

			TipPickupErrorHandler:
			{
				// bind error data
				StepReturn::Bind(rc);
				resume next;
			}

			NeedlePickUpErrorHandler:
			{
				// bind error data
				StepReturn::Bind(rc);
				resume next;
			}
		}

		static function PrepareReloadOfSequences(
			device& ML_STAR,
			sequence& tipPickupSequence,
			sequence& aspirateSequence,
			sequence& dispenseSequence,
			variable aspirateMultiplicity,
			variable dispenseMultiplicity,
			variable drivingMode,
			variable prepareReloadMode,
			variable errorHandling,
			variable& carrierNames[],
			variable& carrierCalibrateFlags[],
			variable& carrierBarcodeReadPositions[],
			variable& carrierBarcodeReadLabwareNames[],
			variable& carrierBarcodeReadPositionNames[],
			variable& carrierRecoveryOptionContinue[],
			variable& carrierRecoveryOptionExclude[],
			variable& carrierRecoveryOptionDefault[],
			variable& carrierKitLotCheckEnabled[],
			variable& prompt,
			variable bWarnLoadSettingsNotForTask)		// added 2005-07-11 cjoerg
		{
			variable index;												// loop counter
			variable size;													// size of carrierNames array
			variable editableByUser(hslFalse);						// specifies whether sequence editing by the user is enabled
			variable retainReloadCondition(hslFalse);				// specifies whether to retain reload condition of sequence
			variable restoreOriginalSequence(hslFalse);			// specifies whether to restore the original sequence 
			variable addCurrentSequence(hslFalse);					// specifies whether to add the current sequence to the collection holding the editable sequences of the device
			variable alignSequences(hslFalse);						// align sequences flag
			variable retainAspirateReloadCondition(hslFalse);	// specifies whether to retain reload condition of the aspirate sequence
			variable retainDispenseReloadCondition(hslFalse);	// specifies whether to retain reload condition of the dispense sequence
			// ba 20050511 begin (SCR#449)
			variable carrierTypes[];									// place to hold carrier types from carrier names
			variable carrierCounts[];									// place to hold carrier counts of carrier types 
			variable carrierType;										// a carrier type
			variable foundAt(-1);										// search index
			// ba 20050511 end (SCR#449)

			// prepare reload modes:
			// 0 = prepare for unload
			// 1 = prepare for reduce
			// 2 = prepare for load

			// restore the original sequence in prepare for reduce mode,
			if (1 == prepareReloadMode)
				// prepare for reduce mode
				restoreOriginalSequence = hslTrue;

			// enable sequence editing by the user in prepare for reduce mode
			if (1 == prepareReloadMode)
				// prepare for reduce mode
				editableByUser = hslTrue;

			// add the current sequence to the collection holding the 
			// editable sequences of the device in prepare for unload and reduce mode
			if (0 == prepareReloadMode || 1 == prepareReloadMode || 2 == prepareReloadMode)
				// prepare for unload or prepare for reduce mode 
				addCurrentSequence = hslTrue;

			// retain reload condition in prepare for unload and prepare for reduce mode 
			if (0 == prepareReloadMode || 1 == prepareReloadMode)
				// prepare for unload or prepare for reduce mode 
				retainReloadCondition = hslTrue;

			// initialize sequence
			if (InitializeWasteDestinationReloadable && 0 == InitializeWasteDestination.GetCurrentPosition())
			{
				// restore original sequence
				if (restoreOriginalSequence)
				{
					InitializeSequenceFromDeckLayout(ML_STAR, InitializeWasteDestination);
				}

				// add the sequence to the collection holding the editable sequences of the device
				if (addCurrentSequence)
					ML_STAR.AddSequence(InitializeWasteDestination, hslFalse, 1, InitializeWasteDestination.GetCount(), editableByUser && InitializeWasteDestinationReducible, "");

				// collect names of loadable carriers given a sequence
				GetCarrierNames(ML_STAR, InitializeWasteDestination, hslFalse, errorHandling,
									 carrierNames, carrierCalibrateFlags, carrierBarcodeReadPositions, 
									 carrierBarcodeReadLabwareNames, carrierBarcodeReadPositionNames,
									 carrierRecoveryOptionContinue, carrierRecoveryOptionExclude, 
									 carrierRecoveryOptionDefault, carrierKitLotCheckEnabled, bWarnLoadSettingsNotForTask);

				// retain reload condition 
				if (retainReloadCondition)
					InitializeWasteDestination.SetCurrentPosition(0);
				else
					InitializeWasteDestination.SetCurrentPosition(1);
			}

			// tip pickup sequence
			if (TipPickupSequenceReloadable && 0 == tipPickupSequence.GetCurrentPosition())
			{
				// restore original sequence
				if (restoreOriginalSequence)
				{
					InitializeSequenceFromDeckLayout(ML_STAR, TipPickupSequence);
					tipPickupSequence.CopySequence(TipPickupSequence);
				}

				// add the sequence to the collection holding the editable sequences of the device
				if (addCurrentSequence)
					ML_STAR.AddSequence(tipPickupSequence, hslFalse, 1, tipPickupSequence.GetCount(), editableByUser && TipPickupSequenceReducible, "");

				// collect names of loadable carriers given a sequence
				GetCarrierNames(ML_STAR, tipPickupSequence, hslFalse, errorHandling,
									 carrierNames, carrierCalibrateFlags, carrierBarcodeReadPositions, 
									 carrierBarcodeReadLabwareNames, carrierBarcodeReadPositionNames,
									 carrierRecoveryOptionContinue, carrierRecoveryOptionExclude, 
									 carrierRecoveryOptionDefault, carrierKitLotCheckEnabled, bWarnLoadSettingsNotForTask);

				// retain reload condition in prepare for unload and prepare for reduce mode 
				if (retainReloadCondition)
					tipPickupSequence.SetCurrentPosition(0);
				else
					tipPickupSequence.SetCurrentPosition(1);
			}

			// tip eject sequence
			if (TipEjectWasteDestinationReloadable && 0 == TipEjectWasteDestination.GetCurrentPosition())
			{
				// restore original sequence
				if (restoreOriginalSequence)
				{
					InitializeSequenceFromDeckLayout(ML_STAR, TipEjectWasteDestination);
				}

				// add the sequence to the collection holding the editable sequences of the device
				if (addCurrentSequence)
					ML_STAR.AddSequence(TipEjectWasteDestination, hslFalse, 1, TipEjectWasteDestination.GetCount(), editableByUser && TipEjectWasteDestinationReducible, "");

				// collect names of loadable carriers given a sequence
				GetCarrierNames(ML_STAR, TipEjectWasteDestination, hslFalse, errorHandling,
									 carrierNames, carrierCalibrateFlags, carrierBarcodeReadPositions, 
									 carrierBarcodeReadLabwareNames, carrierBarcodeReadPositionNames,
									 carrierRecoveryOptionContinue, carrierRecoveryOptionExclude, 
									 carrierRecoveryOptionDefault, carrierKitLotCheckEnabled, bWarnLoadSettingsNotForTask);

				// retain reload condition in prepare for unload and prepare for reduce mode 
				if (retainReloadCondition)
					TipEjectWasteDestination.SetCurrentPosition(0);
				else
					TipEjectWasteDestination.SetCurrentPosition(1);
			}

			// aspirate sequence
			if (AspirateSequenceReloadable && 0 == aspirateSequence.GetCurrentPosition())
			{

				// restore the original sequence in prepare for unload mode
				if (restoreOriginalSequence)
				{
					if (AspirateSequenceReducible)
					{
						InitializeSequenceFromDeckLayout(ML_STAR, AspirateSequence);
						aspirateSequence.CopySequence(AspirateSequence);
					}
					else
					{
						if (ExcludeErrorPositionsEnabled)
						{
							AspirateSequence.CopySequence(AspirateSequenceOriginal);
							aspirateSequence.CopySequence(AspirateSequenceOriginal);
						}
						else
							aspirateSequence.CopySequence(AspirateSequence);
					}
				}

				// add the sequence to the collection holding the editable sequences of the device
				if (addCurrentSequence)
					ML_STAR.AddSequence(aspirateSequence, hslFalse, 1, aspirateSequence.GetCount(), editableByUser && AspirateSequenceReducible, "");

				// collect names of loadable carriers given a sequence
				GetCarrierNames(ML_STAR, aspirateSequence, AspirateSequenceCalibration, errorHandling, 
									 carrierNames, carrierCalibrateFlags, carrierBarcodeReadPositions, 
									 carrierBarcodeReadLabwareNames, carrierBarcodeReadPositionNames,
									 carrierRecoveryOptionContinue, carrierRecoveryOptionExclude, 
									 carrierRecoveryOptionDefault, carrierKitLotCheckEnabled, bWarnLoadSettingsNotForTask);

				// retain reload condition in prepare for unload and prepare for reduce mode 
				if (retainReloadCondition)
				{
					// defer retaining the reload condition until the sequence has been aligned
					retainAspirateReloadCondition = hslTrue;
				}
				else
				{
					aspirateSequence.SetCurrentPosition(1);

					// state that the pipetting sequences have to be aligned
					alignSequences = alignSequences || (0 < aspirateSequence.GetCurrentPosition());
				}

				// 2009-05-27/cj: Added to know later (e.g. in FinalizeSequences) if the sequence has been reloaded or not.
				if (2 == prepareReloadMode)
				{
					// Asp sequence will be reloaded soon. Set the flag.
					AspirateSequenceReloaded = hslTrue;
				}
			}

			// dispense sequence
			if (DispenseSequenceReloadable && 0 == dispenseSequence.GetCurrentPosition())
			{
				// restore the original sequence 
				if (restoreOriginalSequence)
				{
					if (DispenseSequenceReducible)
					{
						InitializeSequenceFromDeckLayout(ML_STAR, DispenseSequence);
						dispenseSequence.CopySequence(DispenseSequence);
					}
					else
					{
						if (ExcludeErrorPositionsEnabled)
						{
							DispenseSequence.CopySequence(DispenseSequenceOriginal);
							dispenseSequence.CopySequence(DispenseSequenceOriginal);
						}
						else
							dispenseSequence.CopySequence(DispenseSequence);
					}
				}

				// add the sequence to the collection holding the editable sequences of the device
				if (addCurrentSequence)
					ML_STAR.AddSequence(dispenseSequence, hslFalse, 1, dispenseSequence.GetCount(), editableByUser && DispenseSequenceReducible, "");

				// collect names of loadable carriers given a sequence
				GetCarrierNames(ML_STAR, dispenseSequence, DispenseSequenceCalibration, errorHandling, 
									 carrierNames, carrierCalibrateFlags, carrierBarcodeReadPositions, 
									 carrierBarcodeReadLabwareNames, carrierBarcodeReadPositionNames,
									 carrierRecoveryOptionContinue, carrierRecoveryOptionExclude, 
									 carrierRecoveryOptionDefault, carrierKitLotCheckEnabled, bWarnLoadSettingsNotForTask);

				// retain reload condition in prepare for unload and prepare for reduce mode 
				if (retainReloadCondition)
				{
					// defer retaining the reload condition until the sequence has been aligned
					retainDispenseReloadCondition = hslTrue;
				}
				else
				{
					dispenseSequence.SetCurrentPosition(1);

					// state that the pipetting sequences have to be aligned
					alignSequences = alignSequences || (0 < dispenseSequence.GetCurrentPosition());
				}

				// 2009-05-27/cj: Added to know later (e.g. in FinalizeSequences) if the sequence has been reloaded or not.
				if (2 == prepareReloadMode)
				{
					// Disp sequence will be reloaded soon. Set the flag.
					DispenseSequenceReloaded = hslTrue;
				}
			}

			// align pipetting sequence counts
			if (alignSequences)
				PCB::AlignSequenceCounts(aspirateSequence, dispenseSequence, 
												 aspirateMultiplicity, dispenseMultiplicity, drivingMode, hslFalse);

			// retain deferred reload condition in prepare 
			// for unload and prepare for reduce mode 
			if (retainAspirateReloadCondition)
				aspirateSequence.SetCurrentPosition(0);
			if (retainDispenseReloadCondition)
				dispenseSequence.SetCurrentPosition(0);

			// ba 20050511 begin (SCR#449)
			size = carrierNames.GetSize();
			for (index = 0; index < size; index++)
			{
				carrierType = PCB::GetCarrierType(ML_STAR, carrierNames.GetAt(index));
				if (!PTL_Util::Lookup(carrierTypes, carrierType, foundAt))
				{
					// didn't found current carrier type in collection holding carrier types
					// --> add carrier type
					carrierTypes.AddAsLast(carrierType);
					carrierCounts.AddAsLast(1);
				}
				else
				{
					// found current carrier type in collection holding carrier types
					// --> increment carrier count
					carrierCounts.SetAt(foundAt, carrierCounts.GetAt(foundAt) + 1);
				}
			}
	
			// add carrier types which should be loaded to user prompt
			size = carrierTypes.GetSize();
			for (index = 0; index < size; index++)
			{
				prompt = prompt + IStr(carrierCounts.GetAt(index)) + " " + carrierTypes.GetAt(index);
				if (0 == ((index + 1) % 4))
					prompt = prompt + StringConstants::crlf;
				else
				{
					if (index + 1 < size)
						prompt = prompt + StringConstants::csvDelimiter2;
				}
			}

			// add carrier names which should be unloaded to user prompt
			//size = carrierNames.GetSize();
			//for (index = 0; index < size; index++)
			//{
			//	prompt = prompt + carrierNames.GetAt(index);
			//	if (0 == ((index + 1) % 4))
			//		prompt = prompt + StringConstants::crlf;
			//	else
			//	{
			//		if (index + 1 < size)
			//			prompt = prompt + StringConstants::csvDelimiter2;
			//	}
			//}
			// ba 20050511 end (SCR#449)

			return(hslTrue);
		}


		static function GetCarrierNames(
			device& ML_STAR,
			sequence& pipSequence,
			variable sequenceCalibrationFlag,
			variable errorHandling,
			variable& carrierNames[],
			variable& carrierCalibrateFlags[],
			variable& carrierBarcodeReadPositions[],
			variable& carrierBarcodeReadLabwareNames[],
			variable& carrierBarcodeReadPositionNames[],
			variable& carrierRecoveryOptionContinue[],
			variable& carrierRecoveryOptionExclude[],
			variable& carrierRecoveryOptionDefault[],
			variable& carrierKitLotCheckEnabled[],
			variable bWarnLoadSettingsNotForTask)			// added 2005-07-11 cjoerg
		{
			variable templateNames[];									// place to hold template names 
			variable labwareNames[];									// place to hold labware names 
			variable labwareIds[];										// place to hold unique labware ids of the sequence 
			variable labId("");											// labware id
			variable arrIndex;											// array index
			variable arrIndex2;											// array index
			variable index;												// loop counter
			variable index2;												// loop counter
			variable index3;												// loop counter
			variable size;													// array size
			variable size2;												// array size
			variable length;												// string length
			variable propertyKeys[];									// place to hold property keys
			variable propertyValues[];									//	place to hold property values
			variable barcodeReadPos;									// a barcode read position
			string	csBarcodeReadPositions;							// comma separated load carrier barcode read positions
			string	csBarcodeReadLabwareNames;						// comma separated load carrier barcode read labware names
			string	csBarcodeReadPositionNames;					// comma separated load carrier barcode read position names
			variable barcodeReadPositions[];							// load carrier barcode read positions
			variable barcodeReadLabwareNames[];						// load carrier barcode read labware names
			variable barcodeReadPositionNames[];					// load carrier barcode read position names
			variable crBarcodeReadPositions[];						// current load carrier barcode read positions
			variable recoveryOptionContinue;							// visibility of recovery option Continue (0 = invisible, 1 = visible)
			variable recoveryOptionExclude;							// visibility of recovery option Exclude (0 = invisible, 1 = visible)
			variable recoveryOptionDefault;							// default of recovery options Continue and Exclude (0 = Continue, 1 = Exclude) 
			variable kitLotCheckEnabled;								// kit lot check enabled flag

			// get labware names with associated template name
			ML_STAR.GetTemplateLabwareNames(templateNames, labwareNames);

			// get unique labware ids of the sequence 
			pipSequence.GetLabwareIds(labwareIds);

			// get advanced load settings of the given sequence 
			if (ErrorHandling::continue == errorHandling  || ErrorHandling::custom == errorHandling)
			{
				if (!LCB::GetStateEx(ML_STAR, pipSequence, "RecoveryOptionContinue", recoveryOptionContinue, bWarnLoadSettingsNotForTask))		// warn if needed
					// advanced load settings not found for the given sequence 
					recoveryOptionContinue = LCB::recoveryOptionContinueDefault;
				if (!LCB::GetStateEx(ML_STAR, pipSequence, "RecoveryOptionExclude", recoveryOptionExclude, hslFalse))		// no warning, warn only once
					// advanced load settings not found for the given sequence 
					recoveryOptionExclude = LCB::recoveryOptionExcludeDefault;
				if (!LCB::GetStateEx(ML_STAR, pipSequence, "RecoveryOptionDefault", recoveryOptionDefault, hslFalse))		// no warning, warn only once
					// advanced load settings not found for the given sequence 
					recoveryOptionDefault = LCB::recoveryOptionDefaultDefault;
				if (!LCB::GetStateEx(ML_STAR, pipSequence, "KitLotCheckEnabled", kitLotCheckEnabled, hslFalse))				// no warning, warn only once
					// advanced load settings not found for the given sequence 
					kitLotCheckEnabled = LCB::kitLotCheckEnabledDefault;
			}

			// iterate over unique labware ids of pipetting sequence 
			// and collect associated template names (if any)
			propertyKeys.AddAsLast(StringConstants::carIsLoadableKey);
			propertyKeys.AddAsLast(StringConstants::carCalibrateXKey);
			size = labwareIds.GetSize();
			for (index = 0; index < size; index++)
			{
				variable propertyValue("0");			// value of MlStarCarIsLoadable or MlStarCarCalibrateX property respectively
				variable isLoadable(hslFalse);		// if 'true', the given labware is loadable
				variable isCalibratable(hslFalse);	// if 'true', the given labware is calibratable
				variable templateName("");
				variable isTemplate(hslTrue);			// if 'true', the given labware is a real template

				labId = labwareIds.GetAt(index);

				// lookup associated template name
				if (PTL_Util::Lookup(labwareNames, labId, arrIndex))
				{
					// found an associated template name
					templateName = templateNames.GetAt(arrIndex);
					if (StringConstants::templateDefaultName == templateName)
					{
						// not really a template
						templateName = labwareNames.GetAt(arrIndex);
						isTemplate = hslFalse;
					}

					// check if the labware is loadable
					ML_STAR.GetLabwareData(templateName, propertyKeys, propertyValues);
					if (0 < propertyValues.GetSize())
					{
						// found a labware supporting key MlStarCarIsLoadable
						propertyValue = propertyValues.GetAt(0);
						isLoadable = ("1" == propertyValue);
					}

					// check if the template name is already contained 
					// in the collection holding the carrier names
					if (!PTL_Util::Lookup(carrierNames, templateName, arrIndex))
					{
						// the template name isn't already contained 
						// in the collection holding the carrier names

						// check if the labware is calibratable
						if (1 < propertyValues.GetSize())
						{
							// found a labware supporting key MlStarCarCalibrateX
							propertyValue = propertyValues.GetAt(1);
							isCalibratable = ("" != propertyValue);
						}

						// found an associated template name
						if (isLoadable)
						{
							// the labware is loadable,
							// add template name to carrierNames
							carrierNames.AddAsLast(templateName);
							if (isCalibratable && sequenceCalibrationFlag)
								// the labware is calibratable,
								// add flag to carrierCalibrateFlags
								carrierCalibrateFlags.AddAsLast(hslTrue);
							else
								// the labware isn't calibratable,
								// add flag to carrierCalibrateFlags
								carrierCalibrateFlags.AddAsLast(hslFalse);

							// get barcode read positions
							barcodeReadPositions.SetSize(0);
							barcodeReadLabwareNames.SetSize(0);
							barcodeReadPositionNames.SetSize(0);
							ML_STAR.GetPositionsLabwareNames(pipSequence, templateName, barcodeReadPositions, 
																		barcodeReadLabwareNames, barcodeReadPositionNames);
							#ifdef _DEBUG_POSITIONSLABWARENAMES
							{
							variable index;
							variable size;
							variable source;
							variable action;
							source = "DEBUG";
							action = GetFunctionName();
							Assert(barcodeReadPositions.GetSize() == barcodeReadLabwareNames.GetSize(), GetFunctionName());
							Assert(barcodeReadPositions.GetSize() == barcodeReadPositionNames.GetSize(), GetFunctionName());
							size = barcodeReadPositions.GetSize();
							FormatTrace(source, action, TraceStatus::progress, "pipSequence = ", pipSequence.GetName());
							FormatTrace(source, action, TraceStatus::progress, "templateName = ", templateName);
							for (index = 0; index < size; index++)
							{
								FormatTrace(source, action, TraceStatus::progress, "barcodeReadPositions[", index, "] = ", barcodeReadPositions.ElementAt(index));
								FormatTrace(source, action, TraceStatus::progress, "barcodeReadLabwareNames[", index, "] = ", barcodeReadLabwareNames.ElementAt(index));
								FormatTrace(source, action, TraceStatus::progress, "barcodeReadPositionNames[", index, "] = ", barcodeReadPositionNames.ElementAt(index));
							}
							}
							#endif

							// build comma separated load carrier barcode read positions
							csBarcodeReadPositions = "";
							size2 = barcodeReadPositions.GetSize();
							for (index2 = 0; index2 < size2; index2++)
							{
								if (isTemplate)
									barcodeReadPos = barcodeReadPositions.ElementAt(index2);
								else
									barcodeReadPos = barcodeReadPositionNames.ElementAt(index2);
								if (0 < csBarcodeReadPositions.GetLength())
									csBarcodeReadPositions = csBarcodeReadPositions + StringConstants::csvDelimiter;
								csBarcodeReadPositions = csBarcodeReadPositions + barcodeReadPos;
							}

							// add barcode read positions to carrierBarcodeReadPositions
							carrierBarcodeReadPositions.AddAsLast(csBarcodeReadPositions);

							// build comma separated load carrier barcode read labware names
							csBarcodeReadLabwareNames = "";
							size2 = barcodeReadLabwareNames.GetSize();
							for (index2 = 0; index2 < size2; index2++)
							{
								if (0 < csBarcodeReadLabwareNames.GetLength())
									csBarcodeReadLabwareNames = csBarcodeReadLabwareNames + StringConstants::csvDelimiter;
								csBarcodeReadLabwareNames = csBarcodeReadLabwareNames + barcodeReadLabwareNames.GetAt(index2);
							}

							// add barcode read labware names to carrierBarcodeReadLabwareNames
							carrierBarcodeReadLabwareNames.AddAsLast(csBarcodeReadLabwareNames);

							// build comma separated load carrier barcode read position names
							csBarcodeReadPositionNames = "";
							size2 = barcodeReadPositionNames.GetSize();
							for (index2 = 0; index2 < size2; index2++)
							{
								if (0 < csBarcodeReadPositionNames.GetLength())
									csBarcodeReadPositionNames = csBarcodeReadPositionNames + StringConstants::csvDelimiter;
								csBarcodeReadPositionNames = csBarcodeReadPositionNames + barcodeReadPositionNames.GetAt(index2);
							}

							// add barcode read position names to carrierBarcodeReadPositionNames
							carrierBarcodeReadPositionNames.AddAsLast(csBarcodeReadPositionNames);

							// add advanced load settings of the given sequence 
							if (ErrorHandling::continue == errorHandling || ErrorHandling::custom == errorHandling)
							{
								carrierRecoveryOptionContinue.AddAsLast(recoveryOptionContinue);
								carrierRecoveryOptionExclude.AddAsLast(recoveryOptionExclude);
								carrierRecoveryOptionDefault.AddAsLast(recoveryOptionDefault);
								carrierKitLotCheckEnabled.AddAsLast(kitLotCheckEnabled);
							}
						}
					}
					else
					{
						// the template name is already contained 
						// in the collection holding the carrier names

						if (isLoadable)
						{
							// the labware is loadable,
							// get barcode read positions
							barcodeReadPositions.SetSize(0);
							barcodeReadLabwareNames.SetSize(0);
							barcodeReadPositionNames.SetSize(0);
							ML_STAR.GetPositionsLabwareNames(pipSequence, templateName, barcodeReadPositions, 
																		barcodeReadLabwareNames, barcodeReadPositionNames);
							#ifdef _DEBUG_POSITIONSLABWARENAMES
							{
							variable index;
							variable size;
							variable source;
							variable action;
							source = "DEBUG";
							action = GetFunctionName();
							Assert(barcodeReadPositions.GetSize() == barcodeReadLabwareNames.GetSize(), GetFunctionName());
							Assert(barcodeReadPositions.GetSize() == barcodeReadPositionNames.GetSize(), GetFunctionName());
							size = barcodeReadPositions.GetSize();
							FormatTrace(source, action, TraceStatus::progress, "pipSequence = ", pipSequence.GetName());
							FormatTrace(source, action, TraceStatus::progress, "templateName = ", templateName);
							for (index = 0; index < size; index++)
							{
								FormatTrace(source, action, TraceStatus::progress, "barcodeReadPositions[", index, "] = ", barcodeReadPositions.ElementAt(index));
								FormatTrace(source, action, TraceStatus::progress, "barcodeReadLabwareNames[", index, "] = ", barcodeReadLabwareNames.ElementAt(index));
								FormatTrace(source, action, TraceStatus::progress, "barcodeReadPositionNames[", index, "] = ", barcodeReadPositionNames.ElementAt(index));
							}
							}
							#endif

							// get current barcode read positions 
							csBarcodeReadPositions = carrierBarcodeReadPositions.ElementAt(arrIndex);

							// parse current barcode read positions into temporary array
							crBarcodeReadPositions.SetSize(0);
							index3 = csBarcodeReadPositions.Find(StringConstants::csvDelimiter);
							length = csBarcodeReadPositions.GetLength();
							while (0 <= index3)
							{
								crBarcodeReadPositions.AddAsLast(csBarcodeReadPositions.Left(index3)); 
								csBarcodeReadPositions = csBarcodeReadPositions.Mid(index3 + 1, length);
								index3 = csBarcodeReadPositions.Find(StringConstants::csvDelimiter);
								length = csBarcodeReadPositions.GetLength();
							}
							if (0 < length)
								crBarcodeReadPositions.AddAsLast(csBarcodeReadPositions);

							// (re)get current barcode read positions 
							csBarcodeReadPositions = carrierBarcodeReadPositions.ElementAt(arrIndex);

							// get current barcode read labware names
							csBarcodeReadLabwareNames = carrierBarcodeReadLabwareNames.ElementAt(arrIndex);

							// get current barcode read position names
							csBarcodeReadPositionNames = carrierBarcodeReadPositionNames.ElementAt(arrIndex);

							// iterate over barcode read positions and collect positions 
							// which are not already contained in the current barcode read positions 
							size2 = barcodeReadPositions.GetSize();
							for (index2 = 0; index2 < size2; index2++)
							{
								if (isTemplate)
									barcodeReadPos = barcodeReadPositions.ElementAt(index2);
								else
									barcodeReadPos = barcodeReadPositionNames.ElementAt(index2);
								if (!PTL_Util::Lookup(crBarcodeReadPositions, barcodeReadPos, arrIndex2)) 
								{
									// position not already contained in the current barcode read positions 
									if (0 < csBarcodeReadPositions.GetLength())
									{
										csBarcodeReadPositions = csBarcodeReadPositions + StringConstants::csvDelimiter;
										csBarcodeReadLabwareNames = csBarcodeReadLabwareNames + StringConstants::csvDelimiter;
										csBarcodeReadPositionNames = csBarcodeReadPositionNames + StringConstants::csvDelimiter;
									}
									csBarcodeReadPositions = csBarcodeReadPositions + barcodeReadPos;
									csBarcodeReadLabwareNames = csBarcodeReadLabwareNames + barcodeReadLabwareNames.ElementAt(index2);
									csBarcodeReadPositionNames = csBarcodeReadPositionNames + barcodeReadPositionNames.ElementAt(index2);
								}
							}

							// add barcode read positions to carrierBarcodeReadPositions
							carrierBarcodeReadPositions.SetAt(arrIndex, csBarcodeReadPositions);

							// add barcode read labware names to carrierBarcodeReadLabwareNames
							carrierBarcodeReadLabwareNames.SetAt(arrIndex, csBarcodeReadLabwareNames);

							// add barcode read position names to carrierBarcodeReadPositionNames
							carrierBarcodeReadPositionNames.SetAt(arrIndex, csBarcodeReadPositionNames);

							// check advanced load settings of the given sequence 
							if (ErrorHandling::continue == errorHandling || ErrorHandling::custom == errorHandling)
							{
								if (carrierRecoveryOptionContinue.ElementAt(arrIndex) != recoveryOptionContinue ||
									 carrierRecoveryOptionExclude.ElementAt(arrIndex) != recoveryOptionExclude ||
									 carrierRecoveryOptionDefault.ElementAt(arrIndex) != recoveryOptionDefault ||
									 carrierKitLotCheckEnabled.ElementAt(arrIndex) != kitLotCheckEnabled)
								{
									variable errorDesc;
									errorDesc = StringTable::Load(IDE::advancedLoadSettingsConflict);
									StrReplace(errorDesc, "%s", carrierNames.ElementAt(arrIndex));
									Error::RaiseEx(IDE::advancedLoadSettingsConflict, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
								}
							}
						}
					}
				}

			}
			return(hslTrue);
		}

		static function GetCurrentPos(
			sequence& aspirateSequence,
			sequence& dispenseSequence,
			variable drivingMode)
		{
			if (DrivingMode::aspirateDriven == drivingMode)
				return(aspirateSequence.GetCurrentPosition());
			else
				return(dispenseSequence.GetCurrentPosition());
		}

		namespace Inner
		{
			// We implement the function inside the namespace, so 
			// that at runtime the function gets executed in 
			// the namespace PTL::PCB::Inner and not in the namespae
			// PTL. The nested namespace Inner is to prevent 
			// redeclared identifiers we would get, if we parse 
			// the config file in the namespace PTL::PCB.
			static function Init(
				string& cfgFile)
			{
				sequence null;															// null sequence

				// general settings 

				UserResponseTime = Limits::maxTimeInterval;					// user response time [s]
				ErrorHandling = ErrorHandling::continue;						// error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
				TipCountingEnabled = hslFalse;									// tip counting enabled flag
				TipCountingIdentifier = StringConstants::tipCountingId;	// tip count identifier
				CopyPatternEnabled = hslFalse;									// copy pattern enabled flag
				ExcludeErrorPositionsEnabled = hslFalse;						// exclude error positions enabled flag
				//>> 20060519
				ExcludeRecoveryOptionEnabled = hslTrue;						// exclude recovery option enabled flag
				//<< 20060519
				TipPresence.SetSize(0);												// tip presence (hslFalse = not present, hslTrue = present)
				TipPresence.SetSize(Limits::channelUpperBound);				// tip presence (hslFalse = not present, hslTrue = present)

				// aliquot settings 

				AliquotEnabled = hslFalse;											// aliquot enabled flag
				AliquotEnabledBak = hslFalse;										// backup of aliquot enabled flag
				AliquotPreAspirateVolume = 0;										// aspirate pre-aliquot volume [ul]
				AliquotAspirateDefaultMixingEnabled = hslTrue;				// aspirate aliquot default mixing enabled flag

				// initialize settings 

				InitializeUseDefaultWaste = hslTrue;							// indicates whether to use the default waste (0 = off, 1 = on)
				InitializeWasteDestination = null;								// initialize waste destination
				InitializeChannelVariable = Limits::channelVariable16;	// channel variable (0 = unused, 1 = used)
				InitializeSequenceCounting = SequenceCounting::manually;	// sequence counting (0 = manually, 1 = automatic)
				InitializeChannelUse = ChannelUse::allSequencePositions;	// channel use (1 = all sequence positions, 2 = channel pattern)
				InitializeAlways = hslFalse;										// initialize always flag
				InitializeEnabled = hslTrue;										// initialize enabled flag (0 = disabled, 1 = enabled)
				InitializeWasteDestinationReloadable = hslFalse;			// waste destination reloadable flag 
				InitializeWasteDestinationReducible = hslFalse;				// waste destination reducible flag 

				// load carrier settings

				LoadCarrierBarcodeFileName = "";									// load carrier barcode file name, defaults to MethodPathName.txt

				// calibrate carrier settings

				CalibrateCarrierChannel = 0;										// calibrate carrier channel, defaults to rightmost active channel

				// tip pickup settings 

				TipPickupSequence = null;											// tip pickup sequence
				TipPickupChannelVariable = Limits::channelVariable16;		// channel variable (0 = unused, 1 = used)
				TipPickupSequenceCounting = SequenceCounting::manually;	// sequence counting (0 = manually, 1 = automatic)
				TipPickupChannelUse = ChannelUse::allSequencePositions;	// channel use (1 = all sequence positions, 2 = channel pattern)
				TipPickupEnabled = hslTrue;										// tip pickup enabled flag (0 = disabled, 1 = enabled)
				TipPickupSequenceReloadable = hslTrue;							// sequence reloadable flag 
				TipPickupSequenceReducible = hslTrue;							// sequence reducible flag 
				TipPickupSequenceCurrentInitialization = SequenceInitialization::none;// sequence initialization (-10 = none, -9 = reset, n = SetCurrentPosition(n)) 
				TipPickupSequenceCurrentFinalization = SequenceFinalization::none;// sequence finalization (-10 = none, -9 = reset, -8 = set to initial, -7 = set to final, n = SetCurrentPosition(n)) 
				TipPickupSequenceCountInitialization = SequenceInitialization::none;// sequence initialization (-10 = none, -9 = reset, n = SetCount(n)) 
				TipPickupSequenceCountFinalization = SequenceFinalization::none;// sequence finalization (-10 = none, -9 = reset, -8 = set to initial, -7 = set to final, n = SetCount(n)) 
				TipPickupReverseSequenceCount = Limits::reverseSequenceCount;// count of reverse tip pickup sequence

				// tip eject settings 

				TipEjectUseDefaultWaste = hslTrue;								// indicates whether to use the default waste (0 = off, 1 = on)
				TipEjectWasteDestination = null;									// tip eject sequence
				TipEjectChannelVariable = Limits::channelVariable16;		// channel variable (0 = unused, 1 = used)
				TipEjectChannelUse = ChannelUse::allSequencePositions;	// channel use (1 = all sequence positions, 2 = channel pattern)
				TipEjectSequenceCounting = SequenceCounting::manually;	// sequence counting (0 = manually, 1 = automatic)
				TipEjectWasteDestinationReloadable = hslFalse;				// waste destination reloadable flag 
				TipEjectWasteDestinationReducible = hslFalse;				// waste destination reducible flag 

				// aspirate settings 

				AspirateSequence = null;											// aspirate sequence
				AspirateSequenceOriginal = null;									// readonly original aspirate sequence (WITHOUT excluded positions)
				AspirateSequenceCounting = SequenceCounting::manually;	// sequence counting (0 = manually, 1 = automatic)
				AspirateChannelUse = ChannelUse::allSequencePositions;	// channel use (1 = all sequence positions, 2 = channel pattern)
				AspirateMode = AspirateMode::aspiration;						// aspirate mode (0 = aspiration, 1 = consecutive aspiration, 2 = empty cup aspiration)
				AspirateCLLDSensitivity = LLDSensitivity::off;				// capacitive liquid level detection (0 = off, 1 = very high, 2 = high, 3 = middle, 4 = low)
				AspirateFluidHeight = 0;											// liquid height from bottom if liquid level detection is disabled
				AspirateSubmergeDepth = 2;											// submerge depth after the liquid level detection [mm]
				AspirateVolume = 0;													// aspirate volume [ul]
				AspirateVolumes.SetSize(0);										// individual aspirate volumes [ul]
				AspirateRestVolume = 0;												// aspirate rest volume [ul]
				AspirateChannelVariable = Limits::channelVariable16;		// channel variable (0 = unused, 1 = used)
				AspirateMaxHeightDiff = 0;											// the maximum difference between the two liquid level detection measurements [mm]
				AspiratePLLDSensitivity = LLDSensitivity::off;				// pressure liquid level detection (0 = off, 1 = very high, 2 = high, 3 = middle, 4 = low)
				AspirateLiquidFollowing = hslTrue;								// liquid following during aspirate and mix (0 = disabled, 1 = enabled)
				AspiratePrerinsingMixCycles = 0;									// prerinsing / mix cycles 
				AspiratePrerinsingMixPosition = 2;								// prerinsing / mix position [mm]
				AspiratePrerinsingMixVolume = 0;									// prerinsing / mix volume [ul]
				AspirateUserDefinedLiquidClass = "";							// liquid class, will be automatically selected if not explicitly set
				AspirateSequenceReloadable = hslTrue;							// sequence reloadable flag 
				AspirateSequenceReducible = hslTrue;							// sequence reducible flag 
				AspirateSequenceCurrentInitialization = SequenceInitialization::reset;// sequence initialization (-10 = none, -9 = reset, n = SetCurrentPosition(n)) 
				AspirateSequenceCurrentFinalization = SequenceFinalization::initial;// sequence finalization (-10 = none, -9 = reset, -8 = set to initial, -7 = set to final, n = SetCurrentPosition(n)) 
				AspirateSequenceCountInitialization = SequenceInitialization::none;// sequence initialization (-10 = none, -9 = reset, n = SetCount(n)) 
				AspirateSequenceCountFinalization = SequenceFinalization::none;// sequence finalization (-10 = none, -9 = reset, -8 = set to initial, -7 = set to final, n = SetCount(n)) 
				AspirateSequenceCalibration = hslTrue;							// sequence calibration flag
				AspirateSequenceCurrentAlignPos = 0;							// last alignment position in aspirate sequence
				AspirateSequenceReloaded = 0;									// set if the aspirate sequence IS reloaded during processing

				// dispense settings 

				DispenseSequence = null;											// dispense sequence
				DispenseSequenceOriginal = null;									// readonly original dispense sequence (WITHOUT excluded positions)
				DispenseSubmergeDepth = 2;											// submerge depth after the liquid level detection [mm]
				DispenseChannelVariable = Limits::channelVariable16;		// channel variable (0 = unused, 1 = used)
				DispenseVolume = 0;													// dispense volume [ul]
				DispenseVolumes.SetSize(0);										// individual dispense volumes [ul]
				DispenseRestVolume = 0;												// dispense rest volume [ul]
				DispenseRestVolumeDestination = RestVolumeDestination::waste;// dispense rest volume destination (0 = waste, 1 = aspirate sequence)
				DispenseRestVolumeFluidHeight = 10;								// liquid height from bottom if liquid level detection is disabled
				// ba 20050511 begin (SCR#736)
				DispenseRestVolumeToAspirateSequenceSurface = hslFalse;	// indicates whether to dispense the rest volume to the surface of the rest volume
				// ba 20050511 end (SCR#736)
				DispenseChannelUse = ChannelUse::allSequencePositions;	// channel use (1 = all sequence positions, 2 = channel pattern)
				DispenseCLLDSensitivity = LLDSensitivity::off;				// capacitive liquid level detection (0 = off, 1 = very high, 2 = high, 3 = middle, 4 = low)
				DispenseSequenceCounting = SequenceCounting::manually;	// sequence counting (0 = manually, 1 = automatic)
				DispenseFluidHeight = 0;											// liquid height from bottom if liquid level detection is disabled
				DispenseMode = DispenseMode::jet;								// dispense mode (0/1 = jet, 2/3 = surface)
				DispenseLiquidFollowing = hslTrue;								// liquid following during dispense and mix (0 = disabled, 1 = enabled)
				DispensePrerinsingMixCycles = 0;									// prerinsing / mix cycles 
				DispensePrerinsingMixPosition = 2;								// prerinsing / mix position [mm]
				DispensePrerinsingMixVolume = 0;									// prerinsing / mix volume [ul]
				DispenseUserDefinedLiquidClass = "";							// liquid class, will be automatically selected if not explicitly set
				DispenseSequenceReloadable = hslTrue;							// sequence reloadable flag 
				DispenseSequenceReducible = hslTrue;							// sequence reducible flag 
				DispenseSequenceCurrentInitialization = SequenceInitialization::reset;// sequence initialization (-10 = none, -9 = reset, n = SetCurrentPosition(n)) 
				DispenseSequenceCurrentFinalization = SequenceFinalization::initial;// sequence finalization (-10 = none, -9 = reset, -8 = set to initial, -7 = set to final, n = SetCurrentPosition(n)) 
				DispenseSequenceCountInitialization = SequenceInitialization::none;// sequence initialization (-10 = none, -9 = reset, n = SetCount(n)) 
				DispenseSequenceCountFinalization = SequenceFinalization::none;// sequence finalization (-10 = none, -9 = reset, -8 = set to initial, -7 = set to final, n = SetCount(n)) 
				DispenseSequenceCalibration = hslTrue;							// sequence calibration flag
				DispenseSequenceCurrentAlignPos = 0;							// last alignment position in dispense sequence
				DispenseSequenceReloaded = 0;									// set if the dispense sequence IS reloaded during processing

				// if required parse configuration file
				if (0 < cfgFile.GetLength())
					InitFromConfig(cfgFile);

				return(hslTrue);
			}

			static function InitFromConfig(
				string& cfgFile)
			{
				// if required parse configuration file
				<< cfgFile;

				// general settings 

				SetState("UserResponseTime", UserResponseTime);
				SetState("ErrorHandling", ErrorHandling);
				SetState("TipCountingEnabled", TipCountingEnabled);
				SetState("TipCountingIdentifier", TipCountingIdentifier);
				SetState("CopyPatternEnabled", CopyPatternEnabled);
				SetState("ExcludeErrorPositionsEnabled", ExcludeErrorPositionsEnabled);

				// alliquote settings 

				SetState("AliquotEnabled", AliquotEnabled);
				SetState("AliquotPreAspirateVolume", AliquotPreAspirateVolume);
				SetState("AliquotAspirateDefaultMixingEnabled", AliquotAspirateDefaultMixingEnabled);

				// initialize settings 

				SetState("InitializeUseDefaultWaste", InitializeUseDefaultWaste);
				SetPipSequence("InitializeWasteDestination", InitializeWasteDestination);
				SetState("InitializeChannelVariable", InitializeChannelVariable);
				SetState("InitializeSequenceCounting", InitializeSequenceCounting);
				SetState("InitializeChannelUse", InitializeChannelUse);
				SetState("InitializeAlways", InitializeAlways);
				SetState("InitializeEnabled", InitializeEnabled);
				SetState("InitializeWasteDestinationReloadable", InitializeWasteDestinationReloadable);
				SetState("InitializeWasteDestinationReducible", InitializeWasteDestinationReducible);

				// load carrier settings 

				SetState("LoadCarrierBarcodeFileName", LoadCarrierBarcodeFileName);

				// tip pickup settings 

				SetPipSequence("TipPickupSequence", TipPickupSequence);
				SetState("TipPickupChannelVariable", TipPickupChannelVariable);
				SetState("TipPickupSequenceCounting", TipPickupSequenceCounting);
				SetState("TipPickupChannelUse", TipPickupChannelUse);
				SetState("TipPickupEnabled", TipPickupEnabled);
				SetState("TipPickupSequenceReloadable", TipPickupSequenceReloadable);
				SetState("TipPickupSequenceReducible", TipPickupSequenceReducible);
				SetState("TipPickupSequenceCurrentInitialization", TipPickupSequenceCurrentInitialization);
				SetState("TipPickupSequenceCurrentFinalization", TipPickupSequenceCurrentFinalization);
				SetState("TipPickupSequenceCountInitialization", TipPickupSequenceCountInitialization);
				SetState("TipPickupSequenceCountFinalization", TipPickupSequenceCountFinalization);
				SetState("TipPickupReverseSequenceCount", TipPickupReverseSequenceCount);

				// tip eject settings 

				SetState("TipEjectUseDefaultWaste", TipEjectUseDefaultWaste);
				SetPipSequence("TipEjectWasteDestination", TipEjectWasteDestination);
				SetState("TipEjectChannelVariable", TipEjectChannelVariable);
				SetState("TipEjectChannelUse", TipEjectChannelUse);
				SetState("TipEjectSequenceCounting", TipEjectSequenceCounting);
				SetState("TipEjectWasteDestinationReloadable", TipEjectWasteDestinationReloadable);
				SetState("TipEjectWasteDestinationReloadable", TipEjectWasteDestinationReloadable);
				SetState("TipEjectWasteDestinationReducible", TipEjectWasteDestinationReducible);

				// aspirate settings 

				SetPipSequence("AspirateSequence", AspirateSequence);
				SetState("AspirateSequenceCounting", AspirateSequenceCounting);
				SetState("AspirateChannelUse", AspirateChannelUse);
				SetState("AspirateMode", AspirateMode);
				SetState("AspirateCLLDSensitivity", AspirateCLLDSensitivity);
				SetState("AspirateFluidHeight", AspirateFluidHeight);
				SetState("AspirateSubmergeDepth", AspirateSubmergeDepth);
				SetState("AspirateVolume", AspirateVolume);
				SetState("AspirateRestVolume", AspirateRestVolume);
				SetState("AspirateChannelVariable", AspirateChannelVariable);
				SetState("AspirateMaxHeightDiff", AspirateMaxHeightDiff);
				SetState("AspiratePLLDSensitivity", AspiratePLLDSensitivity);
				SetState("AspirateLiquidFollowing", AspirateLiquidFollowing);
				SetState("AspiratePrerinsingMixCycles", AspiratePrerinsingMixCycles);
				SetState("AspiratePrerinsingMixPosition", AspiratePrerinsingMixPosition);
				SetState("AspiratePrerinsingMixVolume", AspiratePrerinsingMixVolume);
				SetState("AspirateUserDefinedLiquidClass", AspirateUserDefinedLiquidClass);
				SetState("AspirateSequenceReloadable", AspirateSequenceReloadable);
				SetState("AspirateSequenceReducible", AspirateSequenceReducible);
				SetState("AspirateSequenceCurrentInitialization", AspirateSequenceCurrentInitialization);
				SetState("AspirateSequenceCurrentFinalization", AspirateSequenceCurrentFinalization);
				SetState("AspirateSequenceCountInitialization", AspirateSequenceCountInitialization);
				SetState("AspirateSequenceCountFinalization", AspirateSequenceCountFinalization);
				SetState("AspirateSequenceCalibration", AspirateSequenceCalibration);

				// dispense settings 

				SetPipSequence("DispenseSequence", DispenseSequence);
				SetState("DispenseSubmergeDepth", DispenseSubmergeDepth);
				SetState("DispenseChannelVariable", DispenseChannelVariable);
				SetState("DispenseVolume", DispenseVolume);
				SetState("DispenseRestVolume", DispenseRestVolume);
				SetState("DispenseRestVolumeDestination", DispenseRestVolumeDestination);
				SetState("DispenseRestVolumeFluidHeight", DispenseRestVolumeFluidHeight);
				// ba 20050511 begin (SCR#736)
				SetState("DispenseRestVolumeToAspirateSequenceSurface", DispenseRestVolumeToAspirateSequenceSurface);
				// ba 20050511 end (SCR#736)
				SetState("DispenseChannelUse", DispenseChannelUse);
				SetState("DispenseCLLDSensitivity", DispenseCLLDSensitivity);
				SetState("DispenseSequenceCounting", DispenseSequenceCounting);
				SetState("DispenseFluidHeight", DispenseFluidHeight);
				SetState("DispenseMode", DispenseMode);
				SetState("DispenseLiquidFollowing", DispenseLiquidFollowing);
				SetState("DispensePrerinsingMixCycles", DispensePrerinsingMixCycles);
				SetState("DispensePrerinsingMixPosition", DispensePrerinsingMixPosition);
				SetState("DispensePrerinsingMixVolume", DispensePrerinsingMixVolume);
				SetState("DispenseUserDefinedLiquidClass", DispenseUserDefinedLiquidClass);
				SetState("DispenseSequenceReloadable", DispenseSequenceReloadable);
				SetState("DispenseSequenceReducible", DispenseSequenceReducible);
				SetState("DispenseSequenceCurrentInitialization", DispenseSequenceCurrentInitialization);
				SetState("DispenseSequenceCurrentFinalization", DispenseSequenceCurrentFinalization);
				SetState("DispenseSequenceCountInitialization", DispenseSequenceCountInitialization);
				SetState("DispenseSequenceCountFinalization", DispenseSequenceCountFinalization);
				SetState("DispenseSequenceCalibration", DispenseSequenceCalibration);

				return(hslTrue);
			}
		}
	}


	static function ValidateParams(
		device& ML_STAR,
		sequence& tipPickupSequence,
		sequence& aspirateSequence,
		sequence& dispenseSequence,
		variable aspirateMultiplicity,
		variable dispenseMultiplicity,
		variable pipettingVolume,
		variable restVolume,
		variable drivingMode,
		variable tipRenewalCycleSeq,
		variable tipRenewalCycleMul,
		variable tipRenewalCycleVol)
	{
		// 20050628 cjoerg begin
		//variable unknownTipType(hslTrue);
		// 20050628 cjoerg end

		// 20050628 cjoerg begin
		variable tipVolumeFromLiquidClass(0);
		// 20050628 cjoerg end

		// the multiplicity must be greater than or eaqual to 1
		if (aspirateMultiplicity < 1 || dispenseMultiplicity < 1)
			Error::Raise(IDE::invalidMultiplicity2, GetFileName(), GetFunctionName(), GetLineNumber());

		// either of the multiplicities must be 1
		if (aspirateMultiplicity != 1 && dispenseMultiplicity != 1)
			Error::Raise(IDE::invalidMultiplicity1, GetFileName(), GetFunctionName(), GetLineNumber());

		// the volume must be greater than or eaqual to 0
		if (pipettingVolume < 0)
			Error::Raise(IDE::invalidVolume, GetFileName(), GetFunctionName(), GetLineNumber());

		// the rest volume must be greater than or eaqual to 0
		if (restVolume < 0)
		{
			if (AliquotEnabled)
				Error::Raise(IDE::invalidPrePostVolume, GetFileName(), GetFunctionName(), GetLineNumber());
			else
				Error::Raise(IDE::invalidRestVolume, GetFileName(), GetFunctionName(), GetLineNumber());
		}

		// 20050628 cjoerg begin
		tipVolumeFromLiquidClass = PCB::GetTipVolumeFromLiquidClass(AspirateUserDefinedLiquidClass);
		// 20050628 cjoerg end

		if (AliquotEnabled)
		{
			// Aliquot procedure
			// the rest volume plus the volume of any pre-aliquot must be smaller than the tip volume
	
			// 20050628 cjoerg begin
			if (		(tipVolumeFromLiquidClass - AliquotPreAspirateVolume - restVolume <= 0 ) && ( pipettingVolume != 0 )
					|| (tipVolumeFromLiquidClass - AliquotPreAspirateVolume - restVolume < 0 ))
				Error::Raise(IDE::invalidPrePostVolume, GetFileName(), GetFunctionName(), GetLineNumber());
			// 20050628 cjoerg end
		}
		else
		{	
			// standard pipette
			// the rest volume must be smaller than the tip volume

			// 20050628 cjoerg begin
			if (		( tipVolumeFromLiquidClass - restVolume <= 0 ) && ( pipettingVolume != 0 )
					|| ( tipVolumeFromLiquidClass - restVolume < 0 ) )
				Error::Raise(IDE::invalidRestVolume, GetFileName(), GetFunctionName(), GetLineNumber());
			// 20050628 cjoerg end
		}

		// the tip renewal cycles must be greater than or eaqual to 1
		if (tipRenewalCycleSeq < 1 || tipRenewalCycleMul < 1 || tipRenewalCycleVol < 1)
			Error::Raise(IDE::invalidRenewalCycle, GetFileName(), GetFunctionName(), GetLineNumber());

		// the driving mode must be one of DrivingMode
		if (drivingMode < DrivingMode::first || DrivingMode::last < drivingMode)
			Error::Raise(IDE::invalidDrivingMode, GetFileName(), GetFunctionName(), GetLineNumber());

		if (TipCountingEnabled && 0 == StrGetLength(TipCountingIdentifier))
			Error::Raise(IDE::invalidTipCountingIdentifier, GetFileName(), GetFunctionName(), GetLineNumber());

		// if the aliquot option is enabled, ...
		if (AliquotEnabled)
		{
			// the driving mode must be dispenseDriven
			if (DrivingMode::dispenseDriven != drivingMode)
				Error::Raise(IDE::invalidDrivingMode, GetFileName(), GetFunctionName(), GetLineNumber());

			// the tip renewal cycle in the volume loop must be infinite
			if (tipRenewalCycleVol < hslInfinite)
				Error::Raise(IDE::invalidRenewalCycle, GetFileName(), GetFunctionName(), GetLineNumber());
		}
	}

	function GetPipettingState(
		variable& pcbKey,
		variable& pcbValue)
	{
		// initialize pipetting library
		InitPipettingLibrary();

		// validate input
		if (!PTL_Util::IsString(pcbKey))
			// pcbKey must be a string
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());

		// get pipetting control setting
		return(PCB::GetState(pcbKey, pcbValue));
	}

	function SetPipettingState(
		variable& pcbKey,
		variable& pcbValue)
	{
		// initialize pipetting library
		InitPipettingLibrary();

		// validate input
		if (!PTL_Util::IsString(pcbKey))
			// pcbKey must be a string
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());

		// set pipetting control setting
		return(PCB::SetState(pcbKey, pcbValue));
	}

	static function GetPipettingSequence(
		variable& pcbKey,
		sequence& pcbValue)
	{
		// initialize pipetting library
		InitPipettingLibrary();

		// validate input
		if (!PTL_Util::IsString(pcbKey))
			// pcbKey must be a string
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());

		return(PCB::GetPipSequence(pcbKey, pcbValue));
	}

	static function SetPipettingSequence(
		variable& pcbKey,
		sequence& pcbValue)
	{
		// initialize pipetting library
		InitPipettingLibrary();

		// validate input
		if (!PTL_Util::IsString(pcbKey))
			// pcbKey must be a string
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());

		return(PCB::SetPipSequence(pcbKey, pcbValue));
	}

	static function ResetPipettingStateAndSequences(
		variable pipettingCfgFile)
	{
		// initialize pipetting library
		InitPipettingLibrary();

		return(PCB::Inner::Init(pipettingCfgFile));
	}

   static function MergeSequencesDistinctively(sequence& sequences[], variable pipetteOrder)
   {
      sequence mergedSequenceDistinctively;

      file file1;
      variable fileName1;
      variable labId;
      variable posId;
      variable i;
      
      fileName1 = GetLogFilesPath() + "\\" + StringConstants::fileNameSeqMerged;

      HSLMapReport::DisableEnhancedLibraryTraces();
      HSLMapReport::DeleteFile(fileName1);

      file1.AddField("labId", labId, hslString);
      file1.AddField("posId", posId, hslString);

      file1.Open(fileName1 + " " + "sequenceData", hslWrite);

      // add labware position data of all sequences into file1
      i = 0;
      while(i < sequences.GetSize())
      {
         sequence s;
         s = sequences.ElementAt(i);

         // Initialization of aspiration sequences
         if(pipetteOrder == PipetteOrder::aspiration)
         {
            if (SequenceInitialization::reset == AspirateSequenceCountInitialization)
   		   {
   			   // reset count 
               s.SetCount(s.GetTotal());
   		   }

            if (SequenceInitialization::reset == AspirateSequenceCurrentInitialization)
   			{
   				// reset current position
               s.SetCurrentPosition(1);
   			}
         }
      
         // Initialization of dispensation sequences
         if(pipetteOrder == PipetteOrder::dispensation)
         {
            if (SequenceInitialization::reset == DispenseSequenceCountInitialization)
			   {
				   // reset count 
               s.SetCount(s.GetTotal());
			   }

            if (SequenceInitialization::reset == DispenseSequenceCurrentInitialization)
   			{
   				// reset current position
               s.SetCurrentPosition(1);
   			}
         }

         if(s.GetCount() > 0)
         {
            while(s.GetCurrentPosition() > 0)
            {
               if(s.GetMax() == 0)
                  break;
               else
               {
                  labId = s.GetLabwareId();
                  posId = s.GetPositionId();

                  file1.WriteRecord();

                  s.Increment(1);
               }
            }
         }

         i++;   
      }
      
      file1.Close();

      // open file1 distinctively
      file1.Open(fileName1 + " " + "sequenceData", hslRead, "SELECT DISTINCT labId, posId FROM sequenceData");     

      while(file1.Eof() == 0)
      {
         file1.ReadRecord();
         SeqAdd(mergedSequenceDistinctively, labId, posId);
      }

      file1.Close();

      #ifdef _DEBUG
         TrcTraceSequence(mergedSequenceDistinctively);
		#endif

      #ifndef _DEBUG
         HSLMapReport::DeleteFile(fileName1);
		#endif

      return(mergedSequenceDistinctively);
   }

   static function SortSequenceForProbeHead(device& ML_STAR, sequence& seq, sequence& seqSorted)
   {
      variable channelRaster(0);
      variable numberOfChannels(0);
	   object objProbePars;
      object objSequenceSorter;
      object objGruCompCmd;

      channelRaster = ML_STAR.GetCfgValueWithKey(MlStarCfgKey::yChannelDistance);
      numberOfChannels = ML_STAR.GetCfgValueWithKey(MlStarCfgKey::numberOfChannels);

   	objProbePars.CreateObject("HXPARAMSLib.HxPars");
   	objProbePars.Add(     numberOfChannels, ProbeHeadParsKeys::probeHeadRows);
   	objProbePars.Add(                    1, ProbeHeadParsKeys::probeHeadColumns);
   	objProbePars.Add(                  1.0, ProbeHeadParsKeys::probeTipDeltaColumn);
   	objProbePars.Add(        channelRaster, ProbeHeadParsKeys::probeTipDeltaRow);
   	objProbePars.Add(                    1, ProbeHeadParsKeys::probeTipRowStart);
   	objProbePars.Add(                    1, ProbeHeadParsKeys::probeTipColStart);
   	objProbePars.Add(                    0, ProbeHeadParsKeys::probeTipOrderByCol);
   	objProbePars.Add(                    0, ProbeHeadParsKeys::probeTipSerpentine);
      objProbePars.Add(                 -1.0, ProbeHeadParsKeys::probeTipDeltaXMin);
      objProbePars.Add(                  1.0, ProbeHeadParsKeys::probeTipDeltaXMax);
      objProbePars.Add((channelRaster - 0.1), ProbeHeadParsKeys::probeTipDeltaYMin);
      objProbePars.Add(                 99.9, ProbeHeadParsKeys::probeTipDeltaYMax);

	   objGruCompCmd.CreateObject("Hamilton.HxGRUCompCmd");

	   if( 0 != objGruCompCmd.GetObject("IHxGRUCompCmdSequenceSorter", objSequenceSorter) )
      {
         objSequenceSorter.SortSequence( ML_STAR.GetDeckLayoutObject(), objProbePars, seq.GetSequenceObject(), seqSorted.GetSequenceObject() );
      }

	   objProbePars.ReleaseObject();
      objGruCompCmd.ReleaseObject();
      objSequenceSorter.ReleaseObject();
   }

   static function MergeSequencesDistinctivelyAndSortForProbeHead(device& ML_STAR, sequence& sequences[], variable pipetteOrder)
   {
      sequence mergedSequence;
      sequence seqMergedAndSorted;

      if(sequences.GetSize() > 1)
      {
         mergedSequence = MergeSequencesDistinctively(sequences, pipetteOrder);

         SortSequenceForProbeHead(ML_STAR, mergedSequence, seqMergedAndSorted);
      }
      else
      { 
         // do not sort a single sequence (same behavior than in earlier software versions!)
         return (sequences.ElementAt(0));
      }

      return (seqMergedAndSorted);
   }

	function PipetteImpl(
		device& ML_STAR,
		sequence& tipPickupSequence,
		sequence& aspirateSequence,
		sequence& dispenseSequence,
		variable aspirateMultiplicity,
		variable dispenseMultiplicity,
		variable pipetteIndividualVolumes,						// i: indicates whether to pipette individual volumes (0 = single volume, 1 = pipette individual volumes)
		variable& pipettingVolumes[],								// i: individual volumes, ignored if pipetteIndividualVolumes == 0
		variable pipettingVolume,									// i: single volume, ignored if pipetteIndividualVolumes == 1
		variable restVolume,
		variable drivingMode,
		variable tipRenewalCycleSeq,
		variable tipRenewalCycleMul,
		variable tipRenewalCycleVol,
      sequence& seqMergedAspirate,
      sequence& seqMergedDispense)
	{
		variable rc[];													// step return 
		variable traceSource;										// source for formated trace
		variable traceAction;										// action for formated trace
		variable curPosition(0);									// current position, drives the outer loop
		variable curMultiplicity(0);								// current multiplicity, drives the first nested loop
		variable curVolume(0);										// current volume, drives the second nested loop
		//>> 20060503
		variable curVolumes[];										// current volumes, drives the second nested loop
		//<< 20060503
		variable preVolume(0);										// volume of pre-aliquot (if any)
		//>> 20060503
		variable i(0);													// array index
		variable numberOfVolumes(0);								// number of volumes in volume array
		//<< 20060503
		variable maxMultiplicity(0);								// maximal multiplicity
		variable sequenceCycle(0);									// current cycle in the sequence loop
		variable multiplicityCycle(0);							// current cycle in the multiplicity loop
		variable volumeCycle(0);									// current cycle in the volume loop
		//>> 20060519
		variable effVolumeCycle(0);								// effective cycle in the volume loop
		//<< 20060519
		variable infiniteTipRenewalCycles(hslFalse);			// infinite tip renewal cycles flag
		sequence defaultWasteSequence;							// default waste, Waste or Waste16
		variable ivdSystem(0);										// the IVD System installed flag from the System Registry
		variable releaseLock(hslFalse);							// indicates whether to release the lock
		variable isWashSequence(hslFalse);						// indicates whether tipPickupSequence is a wash sequence or not

		// activate error handler
		onerror goto Unexpected;

		// initialize pipetting library
		InitPipettingLibrary();

		// trace start of pipetting 
		traceSource = StringTable::Load(IDS::traceSource);
		traceAction = StringTable::Load(IDS::smartStepPipette);
		FormatTrace(traceSource, traceAction, TraceStatus::start);

		//>> 20060503
		// check if we have to pipette individual volumes
		if (pipetteIndividualVolumes)
		{
			// validate input parameters
			numberOfVolumes = pipettingVolumes.GetSize();
			for (i = 0; i < numberOfVolumes; i++)
			{

				// the volume must be greater than or eaqual to 0
				if (pipettingVolumes.GetAt(i) < 0)
					Error::Raise(IDE::invalidVolume, GetFileName(), GetFunctionName(), GetLineNumber());

				// determine max pipetting volume
				curVolume = PTL_Util::Max(curVolume, pipettingVolumes.GetAt(i));
			}
		}
		else
		{
			curVolume = pipettingVolume;
		}
		//<< 20060503

		// dump input parameters
		#ifdef _DEBUG
		DumpParams(ML_STAR, tipPickupSequence, aspirateSequence, dispenseSequence,
					  aspirateMultiplicity, dispenseMultiplicity,
					  curVolume, restVolume, drivingMode, tipRenewalCycleSeq, tipRenewalCycleMul, tipRenewalCycleVol);
		#endif

		// validate input parameters
		ValidateParams(ML_STAR, tipPickupSequence, aspirateSequence, dispenseSequence,
						   aspirateMultiplicity, dispenseMultiplicity,
							curVolume, restVolume, drivingMode, tipRenewalCycleSeq, tipRenewalCycleMul, tipRenewalCycleVol);

		//>> 20060503
		// check if we have to pipette individual volumes
		if (pipetteIndividualVolumes)
		{
			// both of the multiplicities must be equal to 1 (Pipette Simple only)
			if (aspirateMultiplicity != 1 || dispenseMultiplicity != 1)
				Error::Raise(IDE::invalidMultiplicity3, GetFileName(), GetFunctionName(), GetLineNumber());

			// aliquoting must be disabled
			if (AliquotEnabled)
				Error::Raise(IDE::aliquotingMustBeDisabled, GetFileName(), GetFunctionName(), GetLineNumber());

			// check the number of available volumes to be greater than or equal to the number of available pipetting positions
			if (DrivingMode::aspirateDriven == drivingMode)
			{
				if (0 < aspirateSequence.GetCurrentPosition())
				{
					if (numberOfVolumes < aspirateSequence.GetCount() - aspirateSequence.GetCurrentPosition() + 1)
						Error::Raise(IDE::tooFewVolumes, GetFileName(), GetFunctionName(), GetLineNumber());
				}
			}
			else if (DrivingMode::dispenseDriven == drivingMode)
			{
				if (0 < dispenseSequence.GetCurrentPosition())
				{
					if (numberOfVolumes < dispenseSequence.GetCount() - dispenseSequence.GetCurrentPosition() + 1)
						Error::Raise(IDE::tooFewVolumes, GetFileName(), GetFunctionName(), GetLineNumber());
				}
			}
		}
		//<< 20060503

		// retrieve the IVD System installed flag from the System Registry
		ivdSystem = GetIVDSystem();		

		// bind all pipetting control setting which have not yet been set to a reasonable value
		PCB::BindStates(ML_STAR);

		// select a default waste
		PCB::SelectDefaultWaste(ML_STAR, defaultWasteSequence);

		// initialize pipetting sequences
		PCB::InitializeSequences(tipPickupSequence, aspirateSequence, dispenseSequence);

		// backup pipetting sequences
		PCB::BackupSequences(ML_STAR, tipPickupSequence, aspirateSequence, dispenseSequence, defaultWasteSequence, "PCB");

		isWashSequence = PCB::IsWashSequence(ML_STAR, tipPickupSequence);

		// if the tip pickup sequence is a wash sequence,
		// set the washing state to pickup and eject needles
		// (the channel pattern has always to be set immediately before the step is executed)
		if (isWashSequence)
		{
			SetWashingState(ML_STAR, tipPickupSequence, "ErrorHandling", ErrorHandling, 1);
         SetWashingState(ML_STAR, tipPickupSequence, "InitializeCustomStepID", InitializeCustomStepID, 1);
         SetWashingState(ML_STAR, tipPickupSequence, "TipPickupCustomStepID", TipPickupCustomStepID, 1);
         SetWashingState(ML_STAR, tipPickupSequence, "TipEjectCustomStepID", TipEjectCustomStepID, 1);
         SetWashingState(ML_STAR, tipPickupSequence, "WaitNeedleWashCustomStepID", WaitNeedleWashCustomStepID, 1);
         SetWashingState(ML_STAR, tipPickupSequence, "StartNeedleWashCustomStepID", StartNeedleWashCustomStepID, 1);
			SetWashingState(ML_STAR, tipPickupSequence, "UserResponseTime", UserResponseTime, 1);
		}

		// get volume of pre-aliquot (if any)
		preVolume = PCB::GetPreVolume();

		// set pipetting volume
		// Remark: The function SetVolume() may disable the AliquotEnabled flag, 
		// and if so, it sets the volume of the pre- and post-aliquot to 0.
		//>> 20060503
		// check if we have to pipette individual volumes
		if (pipetteIndividualVolumes)
		{
			curVolumes = pipettingVolumes;
			AspirateRestVolume = restVolume;
			DispenseRestVolume = restVolume;
		}
		else
		//<< 20060503
		{
			curVolume = pipettingVolume;
			PCB::SetVolume(dispenseSequence, pipettingVolume, curVolume, preVolume, restVolume);
		}

		// set tip presence
		PCB::SetTipPresence(TipPickupChannelVariable, 
								  StrGetLength(TipPickupChannelVariable), !TipPickupEnabled);

		// select liquid class
		PCB::SelectLiquidClass();

		// initialize pipetting device
		rc = InitPipettingDevice(ML_STAR, ErrorHandling, InitializeCustomStepID);
		// ba 2002-09-11 begin (SCR#220)
		if (StepReturn::IsEmpty(rc))
			// The instrument has already been initialized.
			// The final tip eject at the end of this function looks whether the 
			// return code is empty to decide if tips have to be ejected.
			// To prevent an unnecessary tip eject if there is nothing to pipette 
			// we make the return code rc non-empty.
			rc.SetSize(1);
		// end

		// reload pipetting sequences
		if (PCB::NeedsReload(tipPickupSequence, aspirateSequence, dispenseSequence,
									aspirateMultiplicity, dispenseMultiplicity, drivingMode, hslFalse))
		{
			// if the driving sequence needs to be reloaded, ...
			if (PCB::DrivingSequenceNeedsReload(aspirateSequence, dispenseSequence, drivingMode))
			{
				// ... ask the user if he wants to reload the driving sequence or cancel the pipetting procedure
				if (hslNo == PCB::AskUserForReload(aspirateSequence, dispenseSequence, drivingMode))
				{
					// user selected No button, finalize the pipetting procedure

					// if tip pickup is enabled and all of the tip renewal cycles
					// have been set to infinite we force the tip ejection by 
					// setting all of the current tip renewal cycles to infinite
					// before we try to eject the tips once more
					if (infiniteTipRenewalCycles)
						 sequenceCycle = multiplicityCycle = volumeCycle = hslInfinite;

					// eject pipetting tips (if necessary)
					StepReturn::Empty(rc);
					if (TipPickupEnabled && 0 < NumberOfActiveChannels(PCB::GetTipPresence()))
						rc = EjectPipettingTips(ML_STAR, 
														sequenceCycle, multiplicityCycle, volumeCycle,
														tipRenewalCycleSeq, tipRenewalCycleMul, tipRenewalCycleVol, 
														tipPickupSequence, isWashSequence);

					// finalize pipetting sequences
					PCB::FinalizeSequences(ML_STAR, tipPickupSequence, aspirateSequence, dispenseSequence, drivingMode);

               // bind sequences to merged sequences out parameter (only on Pipette3 & Pipette4 interface)
               seqMergedAspirate.CopySequence(aspirateSequence);
               seqMergedDispense.CopySequence(dispenseSequence);

					// trace completion of pipetting and return
					FormatTrace(traceSource, traceAction, TraceStatus::complete);
					return(hslTrue);
				}

				// reset AliquotEnabled flag
				AliquotEnabled = AliquotEnabledBak;
			}
			
			PCB::ReloadSequences		(ML_STAR, tipPickupSequence, aspirateSequence, dispenseSequence, 
										aspirateMultiplicity, dispenseMultiplicity, drivingMode, isWashSequence);

			// check if reload of non-driving sequence was canceled by the user
			if (PCB::ReloadWasCanceled(tipPickupSequence, aspirateSequence, dispenseSequence, drivingMode))
			{
				// user canceled reload of non-driving sequence,
				Error::Raise(IDE::loadingCanceled, GetFileName(), GetFunctionName(), GetLineNumber());
			}
		}

		// align pipetting sequence counts
		PCB::AlignSequenceCounts(aspirateSequence, dispenseSequence,
										 aspirateMultiplicity, dispenseMultiplicity, drivingMode, hslFalse);

		// dump pipetting settings
		#ifdef _DEBUG
		PCB::Dump();
		#endif

		// dump current pipetting sequences
		#ifdef _DEBUG
		PCB::DumpSequence(tipPickupSequence, hslTrue);
		PCB::DumpSequence(aspirateSequence, hslTrue);
		PCB::DumpSequence(dispenseSequence, hslTrue);
		#endif

		// validate pipetting settings
		PCB::Validate();

		// calculate the infinite tip renewal cycles flag
		infiniteTipRenewalCycles = (hslInfinite == tipRenewalCycleSeq && 
											 hslInfinite == tipRenewalCycleMul && 
											 hslInfinite == tipRenewalCycleVol);

		// set the multiplicity
		maxMultiplicity = PTL_Util::Max(aspirateMultiplicity, dispenseMultiplicity);

		// iterate over driving sequence
		curPosition = PCB::GetCurrentPos(aspirateSequence, dispenseSequence, drivingMode);
		while (0 < curPosition && 0 < curVolume)
		{
			// reset any internal state of StepReturn 
			StepReturn::ResetData(hslTrue, hslTrue);

			// reset any sample tracker data of the StepReturn 
			StepReturn::ResetTrackerData(hslTrue);

			// iterate over multiplicity
			// Remark: Because positions of the driving sequence might have been excluded 
			// in the error handling we must check the curPosition to be valid before 
			// entering the multiplicity loop
			while (curMultiplicity < maxMultiplicity && 0 < curPosition)
			{
				// iterate over volume
				while (0 < curVolume)
				{
					// align the max number of positions of the pipetting sequences
					if (!isWashSequence
						//>>20071019 (SCR#1193 : Strange behaviour in Aliquot procedure)
						&& PCB::NeedsTipPickup(sequenceCycle, multiplicityCycle, volumeCycle, tipRenewalCycleSeq, tipRenewalCycleMul, tipRenewalCycleVol))
						//<<20071019
						AlignSequences(hslTrue, tipPickupSequence, 1, aspirateSequence, 1, dispenseSequence, 1, TipEjectWasteDestination, 1);
					else
						AlignSequences(hslTrue, aspirateSequence, 1, dispenseSequence, 1, TipEjectWasteDestination, 1);

					// set pipetting volume
					//>> 20060503
					// check if we have to pipette individual volumes
					if (pipetteIndividualVolumes)
					{
						curVolume = PCB::SetVolumes(aspirateSequence, dispenseSequence, drivingMode, pipettingVolumes, curVolumes, restVolume);
					}
					else
					//<< 20060503
					{
						// set pipetting volume
						curVolume = PCB::SetVolume(dispenseSequence, pipettingVolume, curVolume, preVolume, restVolume);
					}

					// preload tip pickup sequence (if necessary),
					// this is an optimization path to keep pattern matching in sync
					if (PCB::NeedsTipPickup(sequenceCycle, multiplicityCycle, volumeCycle, tipRenewalCycleSeq, tipRenewalCycleMul, tipRenewalCycleVol) &&
						 PCB::TipPickupSequenceNeedsPreload(tipPickupSequence, aspirateSequence, dispenseSequence, drivingMode))
					{
						PCB::ReloadSequences(ML_STAR, tipPickupSequence, aspirateSequence, dispenseSequence, 
													aspirateMultiplicity, dispenseMultiplicity, drivingMode, isWashSequence);

						// check if reload of non-driving sequence was canceled by the user
						if (PCB::ReloadWasCanceled(tipPickupSequence, aspirateSequence, dispenseSequence, drivingMode))
						{
							// user canceled reload of non-driving sequence,
							Error::Raise(IDE::loadingCanceled, GetFileName(), GetFunctionName(), GetLineNumber());
						}

						// requery current position of driving sequence
						#ifdef _DEBUG
						Assert(curPosition == PCB::GetCurrentPos(aspirateSequence, dispenseSequence, drivingMode), GetFunctionName());
						#endif

						// re-align the max number of positions of the pipetting sequences
						if (!isWashSequence)
							AlignSequences(hslTrue, tipPickupSequence, 1, aspirateSequence, 1, dispenseSequence, 1, TipEjectWasteDestination, 1);
						else
							AlignSequences(hslTrue, aspirateSequence, 1, dispenseSequence, 1, TipEjectWasteDestination, 1);

						// dump current pipetting sequences
						#ifdef _DEBUG
						PCB::DumpSequence(tipPickupSequence, hslTrue);
						PCB::DumpSequence(aspirateSequence, hslTrue);
						PCB::DumpSequence(dispenseSequence, hslTrue);
						#endif
					}

					//>> 20060519
					if ((0 < effVolumeCycle || 0 < curMultiplicity) && ErrorHandling == ErrorHandling::continue)
					{
						ExcludeRecoveryOptionEnabled = hslFalse;
					}
					//<< 20060519

					StepReturn::Empty(rc);
					// pickup pipetting tips or needles (if necessary)
					rc = PickupPipettingTips(ML_STAR, tipPickupSequence, 
													 sequenceCycle, multiplicityCycle, volumeCycle,
													 tipRenewalCycleSeq, tipRenewalCycleMul, tipRenewalCycleVol, isWashSequence);

					//>> 20060519
					if ((0 < effVolumeCycle || 0 < curMultiplicity) && ErrorHandling == ErrorHandling::continue)
					{
						ExcludeRecoveryOptionEnabled = hslTrue;
					}
					//<< 20060519

					// disable pause in an IVD System
					if (1 == ivdSystem)
					{
						lock;
						releaseLock = hslTrue;
					}

					// transfer liquid
					StepReturn::Empty(rc);
					rc = TransferLiquid(ML_STAR, tipPickupSequence, aspirateSequence, dispenseSequence,
											  aspirateMultiplicity, dispenseMultiplicity, curMultiplicity, 
											  pipetteIndividualVolumes, pipettingVolumes, curVolumes, curVolume, 
											  drivingMode, isWashSequence, infiniteTipRenewalCycles);

					//>> 20060503
					numberOfVolumes = curVolumes.GetSize();
					//<< 20060503

					// enable pause in an IVD System
					if (1 == ivdSystem)
					{
						unlock;
						releaseLock = hslFalse;
					}

					// increment the volume cycle
					//>> 20060519
					effVolumeCycle++;
					//<< 20060519
					volumeCycle++;

					StepReturn::Empty(rc);
					// eject pipetting tips or needles (if necessary)
					rc = EjectPipettingTips(ML_STAR, 
													sequenceCycle, multiplicityCycle, volumeCycle,
													tipRenewalCycleSeq, tipRenewalCycleMul, tipRenewalCycleVol, 
													tipPickupSequence, isWashSequence);

					// reload pipetting sequences,
					// defer reloading of tip pickup sequence if tips have not been ejected in the previous tip eject statement
					if (PCB::NeedsReload(tipPickupSequence, aspirateSequence, dispenseSequence, 
												aspirateMultiplicity, dispenseMultiplicity, drivingMode, 
												//ba 2004-03-01 begin (Unnecessary re-load of Carriers in Smart step 'Tip Pickup')
												//StepReturn::IsEmpty(rc)))
												hslTrue))
												//end
					{
						// if the driving sequence needs to be reloaded, ...
						if (PCB::DrivingSequenceNeedsReload(aspirateSequence, dispenseSequence, drivingMode))
						{
							// ... ask the user if he wants to reload the driving sequence or cancel the pipetting procedure
							if (hslNo == PCB::AskUserForReload(aspirateSequence, dispenseSequence, drivingMode))
							{
								// user selected No button, finalize the pipetting procedure

								// if tip pickup is enabled and all of the tip renewal cycles
								// have been set to infinite we force the tip ejection by 
								// setting the all of the current tip renewal cycles to infinite
								// before we try to eject the tips once more
								if (infiniteTipRenewalCycles)
									 sequenceCycle = multiplicityCycle = volumeCycle = hslInfinite;

								// eject pipetting tips (if necessary)
								StepReturn::Empty(rc);
								if (TipPickupEnabled && 0 < NumberOfActiveChannels(PCB::GetTipPresence()))
									rc = EjectPipettingTips(ML_STAR, 
																	sequenceCycle, multiplicityCycle, volumeCycle,
																	tipRenewalCycleSeq, tipRenewalCycleMul, tipRenewalCycleVol, 
																	tipPickupSequence, isWashSequence);

								// finalize pipetting sequences
								PCB::FinalizeSequences(ML_STAR, tipPickupSequence, aspirateSequence, dispenseSequence, drivingMode);

                        // bind sequences to merged sequences out parameter (only on Pipette3 & Pipette4 interface)
                        seqMergedAspirate.CopySequence(aspirateSequence);
                        seqMergedDispense.CopySequence(dispenseSequence);

								// trace completion of pipetting and return
								FormatTrace(traceSource, traceAction, TraceStatus::complete);
								return(hslTrue);
							}

							// reset AliquotEnabled flag
							AliquotEnabled = AliquotEnabledBak;
						}

						PCB::ReloadSequences(ML_STAR, tipPickupSequence, aspirateSequence, dispenseSequence, 
													aspirateMultiplicity, dispenseMultiplicity, drivingMode, isWashSequence);

						// check if reload of non-driving sequence was canceled by the user
						if (PCB::ReloadWasCanceled(tipPickupSequence, aspirateSequence, dispenseSequence, drivingMode))
						{
							// user canceled reload of non-driving sequence,
							Error::Raise(IDE::loadingCanceled, GetFileName(), GetFunctionName(), GetLineNumber());
						}

						// requery current position of driving sequence
						#ifdef _DEBUG
						Assert(curPosition == PCB::GetCurrentPos(aspirateSequence, dispenseSequence, drivingMode), GetFunctionName());
						#endif

						// dump current pipetting sequences
						#ifdef _DEBUG
						PCB::DumpSequence(tipPickupSequence, hslTrue);
						PCB::DumpSequence(aspirateSequence, hslTrue);
						PCB::DumpSequence(dispenseSequence, hslTrue);
						#endif
					}
				}

				//>> 20060519
				// reset effective volume cycle
				effVolumeCycle = 0;
				//<< 20060519

				// increment the multiplicity cycle
				curMultiplicity++;
				multiplicityCycle++;

				// eject pipetting tips (if necessary)
				if (StepReturn::IsEmpty(rc))
					rc = EjectPipettingTips(ML_STAR, 
													sequenceCycle, multiplicityCycle, volumeCycle,
													tipRenewalCycleSeq, tipRenewalCycleMul, tipRenewalCycleVol, 
													tipPickupSequence, isWashSequence);

				//>> 20060503
				// check if we have to pipette individual volumes
				if (pipetteIndividualVolumes)
				{
					// reset pipetting volume
					curVolume = 0;
					for (i = 0; i < numberOfVolumes; i++)
					{
						curVolume = PTL_Util::Max(curVolume, curVolumes.GetAt(i));
					}
				}
				else
				//<< 20060503
				{
					// reset pipetting volume
					curVolume = pipettingVolume;
				}

				// increment pipetting sequences
				curPosition = PCB::IncrementSequences(aspirateSequence, dispenseSequence,
																  pipetteIndividualVolumes, pipettingVolumes, curVolumes, 
																  aspirateMultiplicity, dispenseMultiplicity, 
																  curMultiplicity, drivingMode);

				// reload pipetting sequences
				// defer reloading of tip pickup sequence if tips have not been ejected in the previous tip eject statement
				if (PCB::NeedsReload(tipPickupSequence, aspirateSequence, dispenseSequence, 
											aspirateMultiplicity, dispenseMultiplicity, drivingMode, 
											//ba 2004-03-01 begin (Unnecessary re-load of Carriers in Smart step 'Tip Pickup')
											//StepReturn::IsEmpty(rc)))
											hslTrue))
											//end
				{
					// if the driving sequence needs to be reloaded, ...
					if (PCB::DrivingSequenceNeedsReload(aspirateSequence, dispenseSequence, drivingMode))
					{
						// ... ask the user if he wants to reload the driving sequence or cancel the pipetting procedure
						if (hslNo == PCB::AskUserForReload(aspirateSequence, dispenseSequence, drivingMode))
						{
							// user selected No button, finalize the pipetting procedure

							// if tip pickup is enabled and all of the tip renewal cycles
							// have been set to infinite we force the tip ejection by 
							// setting the all of the current tip renewal cycles to infinite
							// before we try to eject the tips once more
							if (infiniteTipRenewalCycles)
								 sequenceCycle = multiplicityCycle = volumeCycle = hslInfinite;

							// eject pipetting tips (if necessary)
							StepReturn::Empty(rc);
							if (TipPickupEnabled && 0 < NumberOfActiveChannels(PCB::GetTipPresence()))
								rc = EjectPipettingTips(ML_STAR, 
																sequenceCycle, multiplicityCycle, volumeCycle,
																tipRenewalCycleSeq, tipRenewalCycleMul, tipRenewalCycleVol, 
																tipPickupSequence, isWashSequence);

							// finalize pipetting sequences
							PCB::FinalizeSequences(ML_STAR, tipPickupSequence, aspirateSequence, dispenseSequence, drivingMode);

                     // bind sequences to merged sequences out parameter (only on Pipette3 & Pipette4 interface)
                     seqMergedAspirate.CopySequence(aspirateSequence);
                     seqMergedDispense.CopySequence(dispenseSequence);

							// trace completion of pipetting and return 
							FormatTrace(traceSource, traceAction, TraceStatus::complete);
							return(hslTrue);
						}

						// reset AliquotEnabled flag
						AliquotEnabled = AliquotEnabledBak;
					}

					PCB::ReloadSequences(ML_STAR, tipPickupSequence, aspirateSequence, dispenseSequence, 
												aspirateMultiplicity, dispenseMultiplicity, drivingMode, isWashSequence);

					// check if reload of non-driving sequence was canceled by the user
					if (PCB::ReloadWasCanceled(tipPickupSequence, aspirateSequence, dispenseSequence, drivingMode))
					{
						// user canceled reload of non-driving sequence,
						Error::Raise(IDE::loadingCanceled, GetFileName(), GetFunctionName(), GetLineNumber());
					}

					// requery current position of driving sequence
					curPosition = PCB::GetCurrentPos(aspirateSequence, dispenseSequence, drivingMode);

					// dump current pipetting sequences
					#ifdef _DEBUG
					PCB::DumpSequence(tipPickupSequence, hslTrue);
					PCB::DumpSequence(aspirateSequence, hslTrue);
					PCB::DumpSequence(dispenseSequence, hslTrue);
					#endif
				}
			}

			// reset multiplicity
			curMultiplicity = 0;

			// increment the sequence cycle
			sequenceCycle++;

			// eject pipetting tips (if necessary)
			if (StepReturn::IsEmpty(rc))
				rc = EjectPipettingTips(ML_STAR, 
												sequenceCycle, multiplicityCycle, volumeCycle,
												tipRenewalCycleSeq, tipRenewalCycleMul, tipRenewalCycleVol, 
												tipPickupSequence, isWashSequence);

			// increment pipetting sequences
			curPosition = PCB::IncrementSequences(aspirateSequence, dispenseSequence,
															  pipetteIndividualVolumes, pipettingVolumes, curVolumes, 
															  aspirateMultiplicity, dispenseMultiplicity, 
															  curMultiplicity, drivingMode);

			// reload pipetting sequences
			if (PCB::NeedsReload(tipPickupSequence, aspirateSequence, dispenseSequence, 
										aspirateMultiplicity, dispenseMultiplicity, drivingMode, 
										//ba 2004-03-01 begin (Unnecessary re-load of Carriers in Smart step 'Tip Pickup')
										//StepReturn::IsEmpty(rc)))
										hslTrue))
										//end
			{
				// if the driving sequence needs to be reloaded, ...
				if (PCB::DrivingSequenceNeedsReload(aspirateSequence, dispenseSequence, drivingMode))
				{
					// ... ask the user if he wants to reload the driving sequence or cancel the pipetting procedure
					if (hslNo == PCB::AskUserForReload(aspirateSequence, dispenseSequence, drivingMode))
					{
						// user selected No button, finalize the pipetting procedure

						// if tip pickup is enabled and all of the tip renewal cycles
						// have been set to infinite we force the tip ejection by 
						// setting the all of the current tip renewal cycles to infinite
						// before we try to eject the tips once more
						if (infiniteTipRenewalCycles)
							 sequenceCycle = multiplicityCycle = volumeCycle = hslInfinite;

						// eject pipetting tips (if necessary)
						StepReturn::Empty(rc);
						if (TipPickupEnabled && 0 < NumberOfActiveChannels(PCB::GetTipPresence()))
							rc = EjectPipettingTips(ML_STAR, 
															sequenceCycle, multiplicityCycle, volumeCycle,
															tipRenewalCycleSeq, tipRenewalCycleMul, tipRenewalCycleVol, 
															tipPickupSequence, isWashSequence);

						// finalize pipetting sequences
						PCB::FinalizeSequences(ML_STAR, tipPickupSequence, aspirateSequence, dispenseSequence, drivingMode);

                  // bind sequences to merged sequences out parameter (only on Pipette3 & Pipette4 interface)
                  seqMergedAspirate.CopySequence(aspirateSequence);
                  seqMergedDispense.CopySequence(dispenseSequence);

						// trace completion of pipetting and return 
						FormatTrace(traceSource, traceAction, TraceStatus::complete);
						return(hslTrue);
					}

					// reset AliquotEnabled flag
					AliquotEnabled = AliquotEnabledBak;
				}

				PCB::ReloadSequences(ML_STAR, tipPickupSequence, aspirateSequence, dispenseSequence, 
											aspirateMultiplicity, dispenseMultiplicity, drivingMode, isWashSequence);

				// check if reload of non-driving sequence was canceled by the user
				if (PCB::ReloadWasCanceled(tipPickupSequence, aspirateSequence, dispenseSequence, drivingMode))
				{
					// user canceled reload of non-driving sequence,
					Error::Raise(IDE::loadingCanceled, GetFileName(), GetFunctionName(), GetLineNumber());
				}

				// requery current position of driving sequence
				curPosition = PCB::GetCurrentPos(aspirateSequence, dispenseSequence, drivingMode);

				// dump current pipetting sequences
				#ifdef _DEBUG
				PCB::DumpSequence(tipPickupSequence, hslTrue);
				PCB::DumpSequence(aspirateSequence, hslTrue);
				PCB::DumpSequence(dispenseSequence, hslTrue);
				#endif
			}
		}

		// if tip pickup is enabled and all of the tip renewal cycles
		// have been set to infinite we force the tip ejection by 
		// setting the all of the current tip renewal cycles to infinite
		// before we try to eject the tips once more
		if (infiniteTipRenewalCycles)
			 sequenceCycle = multiplicityCycle = volumeCycle = hslInfinite;

		// eject pipetting tips
		if (StepReturn::IsEmpty(rc))
			rc = EjectPipettingTips(ML_STAR, 
											sequenceCycle, multiplicityCycle, volumeCycle,
											tipRenewalCycleSeq, tipRenewalCycleMul, tipRenewalCycleVol, 
											tipPickupSequence, isWashSequence);

		// finalize pipetting sequences
		PCB::FinalizeSequences(ML_STAR, tipPickupSequence, aspirateSequence, dispenseSequence, drivingMode);

      // bind sequences to merged sequences out parameter (only on Pipette3 & Pipette4 interface)
      seqMergedAspirate.CopySequence(aspirateSequence);
      seqMergedDispense.CopySequence(dispenseSequence);

		// trace completion of pipetting 
		FormatTrace(traceSource, traceAction, TraceStatus::complete);

		return(hslTrue);

		Unexpected:
		{
			// if tip pickup is enabled and all of the tip renewal cycles
			// have been set to infinite we force the tip ejection by 
			// setting the all of the current tip renewal cycles to infinite
			// before we try to eject the tips once more
			if (infiniteTipRenewalCycles)
				 sequenceCycle = multiplicityCycle = volumeCycle = hslInfinite;

			// eject pipetting tips (if necessary)
			StepReturn::Empty(rc);
			if (TipPickupEnabled && 0 < NumberOfActiveChannels(PCB::GetTipPresence()))
				rc = EjectPipettingTips(ML_STAR, 
												sequenceCycle, multiplicityCycle, volumeCycle,
												tipRenewalCycleSeq, tipRenewalCycleMul, tipRenewalCycleVol, 
												tipPickupSequence, isWashSequence);

			// finalize pipetting sequences
			PCB::FinalizeSequences(ML_STAR, tipPickupSequence, aspirateSequence, dispenseSequence, drivingMode);

         // bind sequences to merged sequences out parameter (only on Pipette3 & Pipette4 interface)
         seqMergedAspirate.CopySequence(aspirateSequence);
         seqMergedDispense.CopySequence(dispenseSequence);

			// if necessary release lock in an IVD System
			if (1 == ivdSystem && releaseLock)
				unlock;

			// trace completion with error of pipetting 
			FormatTrace(traceSource, traceAction, TraceStatus::completeWithError);

			// display the error in debug the version
			//#ifdef _DEBUG
			//if (hslYes == Error::Display())
			//	abort;
			//resume next;
			//#endif

			// check if we should abort the method
			// Remark: a request to abort the method is signaled 
			// by raising the 'methodAborted ' error id
			if (err.GetId() == IDE::methodAborted)
				abort;

			// re-throw the error in the release version
			//#ifndef _DEBUG
			Error::RaiseLast();
			//#endif
		}
	}

	function Pipette(
		device& ML_STAR,
		sequence& tipPickupSequence,
		sequence& aspirateSequence,
		sequence& dispenseSequence,
		variable aspirateMultiplicity,
		variable dispenseMultiplicity,
		variable pipettingVolume,
		variable restVolume,
		variable drivingMode,
		variable tipRenewalCycleSeq,
		variable tipRenewalCycleMul,
		variable tipRenewalCycleVol,
		variable& _tipType_unused)		// 20050629 cjoerg tip type is not longer used/interpreted.
												// is evaluated from tipPickupSequence in all cases.

	{
		variable pipettingVolumes[];
      sequence dummy;

		return(PipetteImpl(		ML_STAR,
										tipPickupSequence,
										aspirateSequence,
										dispenseSequence,
										aspirateMultiplicity,
										dispenseMultiplicity,
										0,										// i: indicates whether to pipette individual volumes (0 = single volume, 1 = pipette individual volumes)
										pipettingVolumes,					// i: individual volumes, ignored if pipetteIndividualVolumes == 0
										pipettingVolume,					// i: single volume, ignored if pipetteIndividualVolumes == 1
										restVolume,
										drivingMode,
										tipRenewalCycleSeq,
										tipRenewalCycleMul,
										tipRenewalCycleVol,
                              dummy,
                              dummy));
	}

	function Pipette2(
		device& ML_STAR,
		sequence& tipPickupSequence,
		sequence& aspirateSequence,
		sequence& dispenseSequence,
		variable aspirateMultiplicity,
		variable dispenseMultiplicity,
		variable& pipettingVolumes[],
		variable restVolume,
		variable drivingMode,
		variable tipRenewalCycleSeq,
		variable tipRenewalCycleMul,
		variable tipRenewalCycleVol,
		variable& _tipType_unused)
	{
		variable pipettingVolume(0);
      sequence dummy;

		return(PipetteImpl(		ML_STAR,
										tipPickupSequence,
										aspirateSequence,
										dispenseSequence,
										aspirateMultiplicity,
										dispenseMultiplicity,
										1,										// i: indicates whether to pipette individual volumes (0 = single volume, 1 = pipette individual volumes)
										pipettingVolumes,					// i: individual volumes, ignored if pipetteIndividualVolumes == 0
										pipettingVolume,					// i: single volume, ignored if pipetteIndividualVolumes == 1
										restVolume,
										drivingMode,
										tipRenewalCycleSeq,
										tipRenewalCycleMul,
										tipRenewalCycleVol,
                              dummy,
                              dummy));
	}

	function Pipette3(
		device& ML_STAR,
		sequence& tipPickupSequence,
		sequence& aspirateSequences[],
		sequence& dispenseSequences[],
		variable aspirateMultiplicity,
		variable dispenseMultiplicity,
		variable pipettingVolume,
		variable restVolume,
		variable drivingMode,
		variable tipRenewalCycleSeq,
		variable tipRenewalCycleMul,
		variable tipRenewalCycleVol,
		variable& tipType,
      sequence& seqMergedAspirate,
      sequence& seqMergedDispense)
	{
      variable pipettingVolumes[];

		return(PipetteImpl(		ML_STAR,
										tipPickupSequence,
										MergeSequencesDistinctivelyAndSortForProbeHead(ML_STAR, aspirateSequences, PipetteOrder::aspiration),
										MergeSequencesDistinctivelyAndSortForProbeHead(ML_STAR, dispenseSequences, PipetteOrder::dispensation),
										aspirateMultiplicity,
										dispenseMultiplicity,
										0,										// i: indicates whether to pipette individual volumes (0 = single volume, 1 = pipette individual volumes)
										pipettingVolumes,					// i: individual volumes, ignored if pipetteIndividualVolumes == 0
										pipettingVolume,					// i: single volume, ignored if pipetteIndividualVolumes == 1
										restVolume,
										drivingMode,
										tipRenewalCycleSeq,
										tipRenewalCycleMul,
										tipRenewalCycleVol,
                              seqMergedAspirate,
                              seqMergedDispense));
   }

	function Pipette4(
		device& ML_STAR,
		sequence& tipPickupSequence,
		sequence& aspirateSequences[],
		sequence& dispenseSequences[],
		variable aspirateMultiplicity,
		variable dispenseMultiplicity,
		variable& pipettingVolumes[],
		variable restVolume,
		variable drivingMode,
		variable tipRenewalCycleSeq,
		variable tipRenewalCycleMul,
		variable tipRenewalCycleVol,
		variable& tipType,
      sequence& seqMergedAspirate,
      sequence& seqMergedDispense)

	{
      variable pipettingVolume(0);

		return(PipetteImpl(		ML_STAR,
										tipPickupSequence,
										MergeSequencesDistinctivelyAndSortForProbeHead(ML_STAR, aspirateSequences, PipetteOrder::aspiration),
										MergeSequencesDistinctivelyAndSortForProbeHead(ML_STAR, dispenseSequences, PipetteOrder::dispensation),
										aspirateMultiplicity,
										dispenseMultiplicity,
										1,										// i: indicates whether to pipette individual volumes (0 = single volume, 1 = pipette individual volumes)
										pipettingVolumes,					// i: individual volumes, ignored if pipetteIndividualVolumes == 0
										pipettingVolume,					// i: single volume, ignored if pipetteIndividualVolumes == 1
										restVolume,
										drivingMode,
										tipRenewalCycleSeq,
										tipRenewalCycleMul,
                              tipRenewalCycleVol,
                              seqMergedAspirate,
                              seqMergedDispense));
   }

	// --------------------------------------------------------------------------------------
	// Loading
	// --------------------------------------------------------------------------------------

	function GetLoadingStateEx(
		device& ML_STAR,
		sequence& sequenceObj,
		variable& lcbKey,
		variable& lcbValue)
	{
		// initialize pipetting library
		InitPipettingLibrary();

		return(LCB::GetStateEx(ML_STAR, sequenceObj, lcbKey, lcbValue, hslTrue));	// warn if load settings not defined for current task
	}

	function SetLoadingStateEx(
		device& ML_STAR,
		sequence& sequenceObj,
		variable& lcbKey,
		variable& lcbValue,
		variable lcbStatus)
	{
		variable traceSource;										// source for formated trace
		variable traceAction;										// action for formated trace
		variable status;

		// activate error handler
		onerror goto Unexpected;

		// initialize pipetting library
		InitPipettingLibrary();

		// check params to be valid
		if (!PTL_Util::IsString(lcbKey))
			Error::Raise(IDE::invalidLCBKey, GetFileName(), GetFunctionName(), GetLineNumber());
		if (!PTL_Util::IsNumber(lcbStatus))
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());
		if (!PTL_Util::IsInteger(lcbStatus))
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());
		if (lcbStatus < 0 || 2 < lcbStatus)
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());

		// trace start of advanced load settings
		traceSource = StringTable::Load(IDS::traceSource);
		traceAction = StringTable::Load(IDS::smartStepAdvancedLoadSettings);
		if (0 == lcbStatus)
			FormatTrace(traceSource, traceAction, TraceStatus::start);

		status = LCB::SetStateEx(ML_STAR, sequenceObj, lcbKey, lcbValue);

		// trace completion of advanced load settings
		if (2 == lcbStatus)
		{
			// check load settings to be valid
			if (!LCB::ValidateStateEx())
				Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

			// trace completion of advanced load settings
			FormatTrace(traceSource, traceAction, TraceStatus::complete);
		}

		return(status);

		Unexpected:
		{
			// trace completion of advanced load settings
			FormatTrace(traceSource, traceAction, TraceStatus::completeWithError);

			Error::RaiseLast();
		}
	}

	function ResetLoadingStateEx(
	device& ML_STAR,
	sequence& sequenceObj)
	{
		// initialize pipetting library
		InitPipettingLibrary();
	
		return(LCB::InitEx(ML_STAR, sequenceObj));
	}

	function GetLoadingState(
		variable& lcbKey,
		variable& lcbValue)
	{
		// initialize pipetting library
		InitPipettingLibrary();

		return(LCB::GetState(lcbKey, lcbValue));
	}

	function SetLoadingState(
		variable& lcbKey,
		variable& lcbValue)
	{
		// initialize pipetting library
		InitPipettingLibrary();

		return(LCB::SetState(lcbKey, lcbValue));
	}

	function GetLoadingStateDefault(
		variable& lcbKey,
		variable& lcbValue)
	{
		// initialize pipetting library
		InitPipettingLibrary();

		return(LCB::GetStateDefault(lcbKey, lcbValue));
	}

	function SetLoadingStateDefault(
		variable& lcbKey,
		variable& lcbValue)
	{
		// initialize pipetting library
		InitPipettingLibrary();

		return(LCB::SetStateDefault(lcbKey, lcbValue));
	}

	function SetLoadingSize(
		variable newSize)
	{
		// initialize pipetting library
		InitPipettingLibrary();

		LCB::Setsize(newSize);
	}

	function GetLoadingSize()
	{
		// initialize pipetting library
		InitPipettingLibrary();

		return(LCB::Getsize());
	}

	function SetLoadingSequence(
		variable index,
		sequence& sequenceObj,
		variable first,
		variable last,
		variable editable,
		variable readTipCount,
		variable& tipCountIdentifier)
	{
		// initialize pipetting library
		InitPipettingLibrary();

		LCB::SetSequence(index, sequenceObj, first, last, editable, readTipCount, tipCountIdentifier);
	}

	function GetLoadingSequence(
		variable index,
		sequence& sequenceObj)
	{
		// initialize pipetting library
		InitPipettingLibrary();
	
		LCB::Getsequence(index, sequenceObj);
	}

	function ResetLoadingStateAndSequences()
	{
		// initialize pipetting library
		InitPipettingLibrary();
	
		return(LCB::Init());
	}

	function Load(
		device& ML_STAR,
		variable calibrateSequences)
	{
		variable rc[];													// step return 
		variable traceSource;										// source for formated trace
		variable traceAction;										// action for formated trace
		sequence null;													// null sequence
		sequence defaultWasteSequence;							// default waste, Waste or Waste16

		// activate error handler
		onerror goto Unexpected;

		// initialize pipetting library
		InitPipettingLibrary();

		// trace start of loading
		traceSource = StringTable::Load(IDS::traceSource);
		traceAction = StringTable::Load(IDS::smartStepLoad);
		FormatTrace(traceSource, traceAction, TraceStatus::start);

		// bind all pipetting control setting which have not yet been set to a reasonable value
		PCB::BindStates(ML_STAR);

      //>>20071126
		//// select a default waste
		//PCB::SelectDefaultWaste(ML_STAR, defaultWasteSequence);

		//// backup pipetting sequences
		//PCB::BackupSequences(ML_STAR, null, null, null, defaultWasteSequence, "PCB");
      //<<20071126

		// initialize pipetting device
		rc = InitPipettingDevice(ML_STAR, LCB::ErrorHandling, LCB::InitializeCustomStepID);

		// load pipetting sequences
		LCB::Load(ML_STAR, calibrateSequences, hslFalse, hslFalse, hslFalse);

		// dump loaded sequences
		#ifdef _DEBUG
		//LCB::DumpSequences();
		#endif

		// trace completion of loading
		FormatTrace(traceSource, traceAction, TraceStatus::complete);

		return(hslTrue);

		Unexpected:
		{
			// trace completion with error of loading
			FormatTrace(traceSource, traceAction, TraceStatus::completeWithError);

			// display the error in debug the version
			//#ifdef _DEBUG
			//if (hslYes == Error::Display())
			//	abort;
			//resume next;
			//#endif

			// re-throw the error in the release version
			//#ifndef _DEBUG
			Error::RaiseLast();
			//#endif
		}
	}

	function Load2(													// supports Smart Step 'Load and Match'
		device& ML_STAR,
		variable calibrateSequences,
		variable scanAutoloadTray,
		variable unloadUnusedSampleTubes) variable
	{
		variable rc[];													// step return 
		variable traceSource;										// source for formated trace
		variable traceAction;										// action for formated trace
		sequence null;													// null sequence
		sequence defaultWasteSequence;							// default waste, Waste or Waste16

		// activate error handler
		onerror goto Unexpected;

		// initialize pipetting library
		InitPipettingLibrary();

		// trace start of loading
		traceSource = StringTable::Load(IDS::traceSource);
		traceAction = StringTable::Load(IDS::smartStepLoadAndMatch);
		FormatTrace(traceSource, traceAction, TraceStatus::start);

		// bind all pipetting control setting which have not yet been set to a reasonable value
		PCB::BindStates(ML_STAR);

      //>>20071126
		//// select a default waste
		//PCB::SelectDefaultWaste(ML_STAR, defaultWasteSequence);

		//// backup pipetting sequences
		//PCB::BackupSequences(ML_STAR, null, null, null, defaultWasteSequence, "PCB");
      //<<20071126

		// initialize pipetting device
		rc = InitPipettingDevice(ML_STAR, LCB::ErrorHandling, LCB::InitializeCustomStepID);

		// load pipetting sequences
		LCB::Load(ML_STAR, calibrateSequences, scanAutoloadTray, hslTrue, unloadUnusedSampleTubes);

		// dump loaded sequences
		#ifdef _DEBUG
		//LCB::DumpSequences();
		#endif

		// trace completion of loading
		FormatTrace(traceSource, traceAction, TraceStatus::complete);

		return(hslTrue);

		Unexpected:
		{
			// trace completion with error of loading
			FormatTrace(traceSource, traceAction, TraceStatus::completeWithError);

			// display the error in debug the version
			//#ifdef _DEBUG
			//if (hslYes == Error::Display())
			//	abort;
			//resume next;
			//#endif

			// re-throw the error in the release version
			//#ifndef _DEBUG
			Error::RaiseLast();
			//#endif
		}
	}

	// --------------------------------------------------------------------------------------
	// Unloading
	// --------------------------------------------------------------------------------------

	function GetUnloadingState(
		variable& ucbKey,
		variable& ucbValue)
	{
		// initialize pipetting library
		InitPipettingLibrary();

		return(UCB::GetState(ucbKey, ucbValue));
	}

	function SetUnloadingState(
		variable& ucbKey,
		variable& ucbValue)
	{
		// initialize pipetting library
		InitPipettingLibrary();

		return(UCB::SetState(ucbKey, ucbValue));
	}

	function SetUnloadingSize(
		variable newSize)
	{
		// initialize pipetting library
		InitPipettingLibrary();

		LCB::Setsize(newSize);
	}

	function GetUnloadingSize()
	{
		// initialize pipetting library
		InitPipettingLibrary();

		return(LCB::Getsize());
	}

	function SetUnloadingSequence(
		variable index,
		sequence& sequenceObj,
		variable writeTipCount,
		variable& tipCountIdentifier)
	{
		// initialize pipetting library
		InitPipettingLibrary();

		LCB::SetSequence(index, sequenceObj, 1, sequenceObj.GetCount(), hslFalse, writeTipCount, tipCountIdentifier);
	}

	function GetUnloadingSequence(
		variable index,
		sequence& sequenceObj)
	{
		// initialize pipetting library
		InitPipettingLibrary();
	
		LCB::Getsequence(index, sequenceObj);
	}

	function ResetUnloadingStateAndSequences()
	{
		// initialize pipetting library
		InitPipettingLibrary();
	
		return(UCB::Init());
	}

	function Unload(
		device& ML_STAR)
	{
		variable rc[];													// step return 
		variable traceSource;										// source for formated trace
		variable traceAction;										// action for formated trace
		sequence null;													// null sequence
		sequence defaultWasteSequence;							// default waste, Waste or Waste16

		// activate error handler
		onerror goto Unexpected;

		// initialize pipetting library
		InitPipettingLibrary();

		// trace start of unloading
		traceSource = StringTable::Load(IDS::traceSource);
		traceAction = StringTable::Load(IDS::smartStepUnload);
		FormatTrace(traceSource, traceAction, TraceStatus::start);

		// bind all pipetting control setting which have not yet been set to a reasonable value
		PCB::BindStates(ML_STAR);

      //>>20071126
		//// select a default waste
		//PCB::SelectDefaultWaste(ML_STAR, defaultWasteSequence);

		//// backup pipetting sequences
		//PCB::BackupSequences(ML_STAR, null, null, null, defaultWasteSequence, "PCB");
      //<<20071126

		// initialize pipetting device
		rc = InitPipettingDevice(ML_STAR, UCB::ErrorHandling, UCB::InitializeCustomStepID);

		// unload pipetting sequences
		LCB::Unload(ML_STAR);

		// dump unloaded sequences
		#ifdef _DEBUG
		LCB::DumpSequences();
		#endif

		// trace completion of unloading
		FormatTrace(traceSource, traceAction, TraceStatus::complete);

		return(hslTrue);

		Unexpected:
		{
			// trace completion with error of unloading
			FormatTrace(traceSource, traceAction, TraceStatus::completeWithError);

			// display the error in debug the version
			//#ifdef _DEBUG
			//if (hslYes == Error::Display())
			//	abort;
			//resume next;
			//#endif

			// re-throw the error in the release version
			//#ifndef _DEBUG
			Error::RaiseLast();
			//#endif
		}
	}

	namespace LCB
	{
	
		function GetStateEx(
			device& ML_STAR,
			sequence& sequenceObj,
			variable& lcbKey,
			variable& lcbValue,
			variable bWarnLoadSettingsNotForTask)		// added: 2005-07-11 cjoerg
		{
			variable size;													// array size
			variable index;												// loop counter
			variable instrumentId("");									// instrument id
			variable sequenceId("");									// sequence id

			// initialize output param
			lcbValue = 0;

			// get instrument name 
			instrumentId = ML_STAR.GetInstrumentName();

			// get sequence name 
			sequenceId = sequenceObj.GetName();

			// activate error handler
			onerror goto Unexpected;

			// get access to global data
			SynEnterCriticalSection(ptlCs);

			// verify array sizes
			size = ptlLcbInstrumentIdArr.GetSize();
			#ifdef _DEBUG
			Assert(ptlLcbTaskIdArr.GetSize() == size, GetFunctionName());		// 20050704 cjoerg: added
			Assert(ptlLcbSequenceIdArr.GetSize() == size, GetFunctionName());
			Assert(ptlLcbRecoveryOptionContinueArr.GetSize() == size, GetFunctionName());
			Assert(ptlLcbRecoveryOptionExcludeArr.GetSize() == size, GetFunctionName());
			Assert(ptlLcbRecoveryOptionDefaultArr.GetSize() == size, GetFunctionName());
			Assert(ptlLcbKitLotCheckEnabledArr.GetSize() == size, GetFunctionName());
			#endif

			// iterate over instrument sequence pairs
			for (index = 0; index < size; index++)
			{
				if (ptlLcbInstrumentIdArr.ElementAt(index) == instrumentId && 
					ptlLcbSequenceIdArr.ElementAt(index) == sequenceId)
					// found a matching instrument sequence pair
					break;
			}

			if (index < size && 0 < size)
			{
				// 20050704 cjoerg
				// Added check that the load settings are set from the same task that try
				// to get it not.
				// This check forces that if scheduled the 'Advanced Load Settings' must be set from
				// exactly the task that needs to use them.
				// The safest way to ensure this is to programm the 'Advanced Load Settings' within
				// activity where the settings are used (e.g. Load or Pipette).
				// If not scheduled GetCurrentTaskId() returns zero, equals to the value which 
				// is used to initialze the ptlWcbTaskIdArr[].
				if (		( bWarnLoadSettingsNotForTask )
						&& (ptlLcbTaskIdArr.GetAt(index) != GetCurrentTaskId()) )
						
				{
					variable action;
					variable warnText;
					action   = StringTable::Load(IDS::actionLoad);
					warnText = StringTable::Load(IDS::loadSettingsNotForCurrentTaskId);
					StrReplace(warnText, "%s", sequenceId);
					PTL_Util::TraceWarningIfNotValidated(action, warnText);
				}

				// get the settings for the instrument sequence pair
				// switch over LCB entries
				if (lcbKey == "RecoveryOptionContinue")
				{
					lcbValue = ptlLcbRecoveryOptionContinueArr.ElementAt(index);

					// release access to global data
					SynLeaveCriticalSection(ptlCs);
					return(hslTrue);
				}
				if (lcbKey == "RecoveryOptionExclude")
				{
					lcbValue = ptlLcbRecoveryOptionExcludeArr.ElementAt(index);

					// release access to global data
					SynLeaveCriticalSection(ptlCs);
					return(hslTrue);
				}
				if (lcbKey == "RecoveryOptionDefault")
				{
					lcbValue = ptlLcbRecoveryOptionDefaultArr.ElementAt(index);

					// release access to global data
					SynLeaveCriticalSection(ptlCs);
					return(hslTrue);
				}
				if (lcbKey == "KitLotCheckEnabled")
				{
					lcbValue = ptlLcbKitLotCheckEnabledArr.ElementAt(index);

					// release access to global data
					SynLeaveCriticalSection(ptlCs);
					return(hslTrue);
				}

				// unknown lcbKey
				Error::Raise(IDE::invalidLCBKey, GetFileName(), GetFunctionName(), GetLineNumber());

			}
			else
			{
				// 20050704 cjoerg
				// Advanced load settings are not explicit set for current labware.
				// Defaults may be used but them must not be identical between different methods
				// (e.g. if methods are created with different installations / OEM's).
				// If we are scheduling (GetCurrentTaskId() returns value not equal to zero)
				// this is a programming failure.
				if (		(bWarnLoadSettingsNotForTask)
						&& (0 != GetCurrentTaskId()) )
				{
					variable action;
					variable warnText;
					action   = StringTable::Load(IDS::actionLoad);
					warnText = StringTable::Load(IDS::loadSettingsNotForCurrentTaskId);
					StrReplace(warnText, "%s", sequenceId);
					PTL_Util::TraceWarningIfNotValidated(action, warnText);
				}
			}

			// release access to global data
			SynLeaveCriticalSection(ptlCs);

			return(hslFalse);

			Unexpected:
			{
				// release access to global data
				SynLeaveCriticalSection(ptlCs);
				Error::RaiseLast();
			}
		}

		function SetStateEx(
			device& ML_STAR,
			sequence& sequenceObj,
			variable& lcbKey,
			variable& lcbValue)
		{
			variable index;												// loop counter
			variable size;													// array size
			variable instrumentId("");									// instrument id
			variable sequenceId("");									// sequence id

			// get instrument name 
			instrumentId = ML_STAR.GetInstrumentName();

			// get sequence name 
			sequenceId = sequenceObj.GetName();

			// activate error handler
			onerror goto Unexpected;

			// get access to global data
			SynEnterCriticalSection(ptlCs);

			// verify array sizes
			size = ptlLcbInstrumentIdArr.GetSize();
			#ifdef _DEBUG
			Assert(ptlLcbTaskIdArr.GetSize() == size, GetFunctionName());		// 20050704 cjoerg: added
			Assert(ptlLcbSequenceIdArr.GetSize() == size, GetFunctionName());
			Assert(ptlLcbRecoveryOptionContinueArr.GetSize() == size, GetFunctionName());
			Assert(ptlLcbRecoveryOptionExcludeArr.GetSize() == size, GetFunctionName());
			Assert(ptlLcbRecoveryOptionDefaultArr.GetSize() == size, GetFunctionName());
			Assert(ptlLcbKitLotCheckEnabledArr.GetSize() == size, GetFunctionName());
			#endif

			// iterate over instrument sequence pairs
			for (index = 0; index < size; index++)
			{
				if (ptlLcbInstrumentIdArr.GetAt(index) == instrumentId && 
					ptlLcbSequenceIdArr.GetAt(index) == sequenceId)
					// found a matching instrument sequence pair
					break;
			}

			if (size <= index)
			{
				// didn't found a matching instrument sequence pair,
				// register new instrument sequence pair
				ptlLcbInstrumentIdArr.AddAsLast(instrumentId);
				ptlLcbSequenceIdArr.AddAsLast(sequenceId);
				ptlLcbTaskIdArr.AddAsLast(0);		// 20050630 cjoerg: added, must be zero for the case that not used with scheduler
				ptlLcbRecoveryOptionContinueArr.AddAsLast(recoveryOptionContinueDefault);
				ptlLcbRecoveryOptionExcludeArr.AddAsLast(recoveryOptionExcludeDefault);
				ptlLcbRecoveryOptionDefaultArr.AddAsLast(recoveryOptionDefaultDefault);
				ptlLcbKitLotCheckEnabledArr.AddAsLast(kitLotCheckEnabledDefault);
			}

			// set the settings for the instrument sequence pair
			// switch over LCB entries

			// 20050630 cjoerg
			// Set also the CurrentTaskId into ptlLcbTaskIdArr because during acces to the data
			// we check that the Load Settings are defined from a step of same task.
			// By this way we force (if a method is scheduled) that the 'Advanced Load Settings' are set for
			// the current task as last and that them are not overridden from an other task.
			// GetCurrentTaskId() returns zero if not not scheduled.

			if (lcbKey == "RecoveryOptionContinue")
			{
				ptlLcbTaskIdArr.SetAt(index, GetCurrentTaskId());	// 20050704 cjoerg: added

				// check lcbValue to be valid
				if (!PTL_Util::IsNumber(lcbValue))
					Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(lcbValue))
					Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (0 != lcbValue && 1 != lcbValue)
					Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set lcbValue 
				ptlLcbRecoveryOptionContinueArr.SetAt(index, lcbValue);

				// release access to global data
				SynLeaveCriticalSection(ptlCs);
				return(hslTrue);
			}
			if (lcbKey == "RecoveryOptionExclude")
			{
				ptlLcbTaskIdArr.SetAt(index, GetCurrentTaskId());	// 20050704 cjoerg: added

				// check lcbValue to be valid
				if (!PTL_Util::IsNumber(lcbValue))
					Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(lcbValue))
					Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (0 != lcbValue && 1 != lcbValue)
					Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set lcbValue 
				ptlLcbRecoveryOptionExcludeArr.SetAt(index, lcbValue);

				// release access to global data
				SynLeaveCriticalSection(ptlCs);
				return(hslTrue);
			}
			if (lcbKey == "RecoveryOptionDefault")
			{
				ptlLcbTaskIdArr.SetAt(index, GetCurrentTaskId());	// 20050704 cjoerg: added

				// check lcbValue to be valid
				if (!PTL_Util::IsNumber(lcbValue))
					Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(lcbValue))
					Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (0 != lcbValue && 1 != lcbValue)
					Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set lcbValue 
				ptlLcbRecoveryOptionDefaultArr.SetAt(index, lcbValue);

				// release access to global data
				SynLeaveCriticalSection(ptlCs);
				return(hslTrue);
			}
			if (lcbKey == "KitLotCheckEnabled")
			{
				ptlLcbTaskIdArr.SetAt(index, GetCurrentTaskId());	// 20050704 cjoerg: added

				// check lcbValue to be valid
				if (!PTL_Util::IsNumber(lcbValue))
					Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(lcbValue))
					Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (0 != lcbValue && 1 != lcbValue)
					Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set lcbValue 
				ptlLcbKitLotCheckEnabledArr.SetAt(index, lcbValue);

				// release access to global data
				SynLeaveCriticalSection(ptlCs);
				return(hslTrue);
			}

			// unknown wcbKey
			Error::Raise(IDE::invalidLCBKey, GetFileName(), GetFunctionName(), GetLineNumber());

			// release access to global data
			SynLeaveCriticalSection(ptlCs);

			return(hslFalse);

			Unexpected:
			{
				// release access to global data
				SynLeaveCriticalSection(ptlCs);
				Error::RaiseLast();
			}
		}

		function ValidateStateEx()
		{
			variable index;												// loop counter
			variable size;													// array size
			variable status(hslTrue);									// validation status

			// activate error handler
			onerror goto Unexpected;

			// get access to global data
			SynEnterCriticalSection(ptlCs);

			// verify array sizes
			size = ptlLcbInstrumentIdArr.GetSize();
			#ifdef _DEBUG
			Assert(ptlLcbTaskIdArr.GetSize() == size, GetFunctionName());		// 20050704 cjoerg: added
			Assert(ptlLcbSequenceIdArr.GetSize() == size, GetFunctionName());
			Assert(ptlLcbRecoveryOptionContinueArr.GetSize() == size, GetFunctionName());
			Assert(ptlLcbRecoveryOptionExcludeArr.GetSize() == size, GetFunctionName());
			Assert(ptlLcbRecoveryOptionDefaultArr.GetSize() == size, GetFunctionName());
			Assert(ptlLcbKitLotCheckEnabledArr.GetSize() == size, GetFunctionName());
			#endif

			// iterate over instrument sequence pairs
			for (index = 0; index < size; index++)
			{
				variable recoveryOptionContinue;
				variable recoveryOptionExclude;
				variable recoveryOptionDefault;

				// validate the settings for the instrument sequence pair
				recoveryOptionContinue = ptlLcbRecoveryOptionContinueArr.ElementAt(index);
				recoveryOptionExclude = ptlLcbRecoveryOptionExcludeArr.ElementAt(index);
				recoveryOptionDefault = ptlLcbRecoveryOptionDefaultArr.ElementAt(index);
				if (!recoveryOptionContinue && !recoveryOptionExclude)
				{
					status = hslFalse;
					break;
				}
				if (0 == recoveryOptionDefault && !recoveryOptionContinue)
				{
					status = hslFalse;
					break;
				}
				if (1 == recoveryOptionDefault && !recoveryOptionExclude)
				{
					status = hslFalse;
					break;
				}
			}

			// release access to global data
			SynLeaveCriticalSection(ptlCs);

			return(status);

			Unexpected:
			{
				// release access to global data
				SynLeaveCriticalSection(ptlCs);
				Error::RaiseLast();
			}
		}

		static function GetState(
			variable& lcbKey,
			variable& lcbValue)
		{
			// initialize output
			lcbValue = 0;
			
			// get value for loading control key,
			// switch over LCB entries

			// general settings
			if (lcbKey == "UserResponseTime")
			{
				lcbValue = UserResponseTime;
				return(hslTrue);
			}
			if (lcbKey == "ErrorHandling")
			{
				lcbValue = ErrorHandling;
				return(hslTrue);
			}
			if (lcbKey == "InitializeCustomStepID")
			{
				lcbValue = InitializeCustomStepID;
				return(hslTrue);
			}
   		if (lcbKey == "LoadCarrierCustomStepID")
			{
				lcbValue = LoadCarrierCustomStepID;
				return(hslTrue);
			}
   		if (lcbKey == "CalibrateCarrierCustomStepID")
			{
				lcbValue = CalibrateCarrierCustomStepID;
				return(hslTrue);
			}

			// calibrate carrier settings 
			if (lcbKey == "CalibrateCarrierChannel")
			{
				lcbValue = CalibrateCarrierChannel;
				return(hslTrue);
			}

			// unknown lcbKey
			Error::Raise(IDE::invalidLCBKey, GetFileName(), GetFunctionName(), GetLineNumber());

			return(hslFalse);
		}

		static function SetState(
			variable& lcbKey,
			variable& lcbValue)
		{
			// set value for loading control key,
			// switch over LCB entries

			// general settings 
			if (lcbKey == "UserResponseTime")
			{
				// check lcbValue to be valid
				if (!PTL_Util::IsNumber(lcbValue))
					Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(lcbValue))
					Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set lcbValue 
				if (Limits::maxTimeInterval < lcbValue)
					LCB::UserResponseTime = Limits::maxTimeInterval;
				else
					LCB::UserResponseTime = lcbValue;
				if (!PTL_Util::IsInteger(LCB::UserResponseTime))
					Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				return(hslTrue);
			}
			if (lcbKey == "ErrorHandling")
			{
				// check lcbValue to be valid
				if (!PTL_Util::IsNumber(lcbValue))
					Error::Raise(IDE::invalidErrorHandling, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(lcbValue))
					Error::Raise(IDE::invalidErrorHandling, GetFileName(), GetFunctionName(), GetLineNumber());
				if (lcbValue < ErrorHandling::first || ErrorHandling::last < lcbValue)
					Error::Raise(IDE::invalidErrorHandling, GetFileName(), GetFunctionName(), GetLineNumber());

				// set lcbValue 
				LCB::ErrorHandling = lcbValue;
				return(hslTrue);
			}
			if (lcbKey == "InitializeCustomStepID")
			{
				// check lcbValue to be valid
				if (!PTL_Util::IsInteger(lcbValue))
					Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set lcbValue 
				LCB::InitializeCustomStepID = lcbValue;
				return(hslTrue);
			}
			if (lcbKey == "LoadCarrierCustomStepID")
			{
				// check lcbValue to be valid
				if (!PTL_Util::IsInteger(lcbValue))
					Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set lcbValue 
				LCB::LoadCarrierCustomStepID = lcbValue;
				return(hslTrue);
			}
			if (lcbKey == "CalibrateCarrierCustomStepID")
			{
				// check lcbValue to be valid
				if (!PTL_Util::IsInteger(lcbValue))
					Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set lcbValue 
				LCB::CalibrateCarrierCustomStepID = lcbValue;
				return(hslTrue);
			}

			// calibrate carrier settings 
			if (lcbKey == "CalibrateCarrierChannel")
			{
				// check lcbValue to be valid
				if (!PTL_Util::IsInteger(lcbValue))
					Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set lcbValue 
				LCB::CalibrateCarrierChannel = lcbValue;
				return(hslTrue);
			}

			// unknown lcbKey
			Error::Raise(IDE::invalidLCBKey, GetFileName(), GetFunctionName(), GetLineNumber());

			return(hslFalse);
		}

		static function GetStateDefault(
			variable& lcbKey,
			variable& lcbValue)
		{
			// initialize output param
			lcbValue = 0;

			// switch over LCB entries
			if (lcbKey == "RecoveryOptionContinue")
			{
				lcbValue = recoveryOptionContinueDefault;
				return(hslTrue);
			}
			if (lcbKey == "RecoveryOptionExclude")
			{
				lcbValue = recoveryOptionExcludeDefault;
				return(hslTrue);
			}
			if (lcbKey == "RecoveryOptionDefault")
			{
				lcbValue = recoveryOptionDefaultDefault;
				return(hslTrue);
			}
			if (lcbKey == "KitLotCheckEnabled")
			{
				lcbValue = kitLotCheckEnabledDefault;
				return(hslTrue);
			}

			// unknown lcbKey
			Error::Raise(IDE::invalidLCBKey, GetFileName(), GetFunctionName(), GetLineNumber());

			return(hslTrue);
		}

		static function SetStateDefault(
			variable& lcbKey,
			variable& lcbValue)
		{
			// switch over LCB entries
			if (lcbKey == "RecoveryOptionContinue")
			{
				// check lcbValue to be valid
				if (!PTL_Util::IsNumber(lcbValue))
					Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(lcbValue))
					Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (0 != lcbValue && 1 != lcbValue)
					Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set lcbDefaultValue 
				recoveryOptionContinueDefault = lcbValue;
				return(hslTrue);
			}
			if (lcbKey == "RecoveryOptionExclude")
			{
				// check lcbValue to be valid
				if (!PTL_Util::IsNumber(lcbValue))
					Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(lcbValue))
					Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (0 != lcbValue && 1 != lcbValue)
					Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set lcbDefaultValue 
				recoveryOptionExcludeDefault = lcbValue;
				return(hslTrue);
			}
			if (lcbKey == "RecoveryOptionDefault")
			{
				// check lcbValue to be valid
				if (!PTL_Util::IsNumber(lcbValue))
					Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(lcbValue))
					Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (0 != lcbValue && 1 != lcbValue)
					Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set lcbDefaultValue 
				recoveryOptionDefaultDefault = lcbValue;
				return(hslTrue);
			}
			if (lcbKey == "KitLotCheckEnabled")
			{
				// check lcbValue to be valid
				if (!PTL_Util::IsNumber(lcbValue))
					Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(lcbValue))
					Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (0 != lcbValue && 1 != lcbValue)
					Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set lcbDefaultValue 
				kitLotCheckEnabledDefault = lcbValue;
				return(hslTrue);
			}

			// unknown lcbKey
			Error::Raise(IDE::invalidLCBKey, GetFileName(), GetFunctionName(), GetLineNumber());

			return(hslTrue);
		}

		static function Setsize(
			variable newSize)
		{
			// check size to be valid
			if (!PTL_Util::IsNumber(newSize))
				Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
			if (!PTL_Util::IsInteger(newSize))
				Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
			if (PTL_Util::IsNegative(newSize))
				Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

			sequenceObjArr.SetSize(newSize);
			sequenceObjCopyArr.SetSize(newSize);
			resetSequenceFlagArr.SetSize(newSize);
			firstArr.SetSize(newSize);
			lastArr.SetSize(newSize);
			editableArr.SetSize(newSize);
			ioTipCountArr.SetSize(newSize);
			tipCountIdentifierArr.SetSize(newSize);
		}

		static function Getsize()
		{
			return(sequenceObjArr.GetSize());
		}

		static function SetSequence(
			variable index,
			sequence& sequenceObj,
			variable first,
			variable last,
			variable editable,
			variable readTipCount,
			variable& tipCountIdentifier)
		{
			#ifdef _DEBUG
			Assert(0 <= index && index < sequenceObjArr.GetSize(), GetFunctionName());
			#endif

			// check first to be valid
			if (!PTL_Util::IsNumber(first))
				Error::Raise(IDE::invalidFirst, GetFileName(), GetFunctionName(), GetLineNumber());
			if (!PTL_Util::IsInteger(first))
				Error::Raise(IDE::invalidFirst, GetFileName(), GetFunctionName(), GetLineNumber());
			if (first < 1)
				Error::Raise(IDE::invalidFirst, GetFileName(), GetFunctionName(), GetLineNumber());

			// check last to be valid
			if (!PTL_Util::IsNumber(last))
				Error::Raise(IDE::invalidLast, GetFileName(), GetFunctionName(), GetLineNumber());
			if (!PTL_Util::IsInteger(last))
				Error::Raise(IDE::invalidLast, GetFileName(), GetFunctionName(), GetLineNumber());
			if (PTL_Util::IsNegative(last) && (last < LoadingSequenceInitialization::first || LoadingSequenceInitialization::last < last))
				Error::Raise(IDE::invalidLast, GetFileName(), GetFunctionName(), GetLineNumber());

			// check editable to be valid
			if (!PTL_Util::IsNumber(editable))
				Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
			if (PTL_Util::IsFloat(editable))
				Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

			// check readTipCount to be valid
			if (!PTL_Util::IsNumber(readTipCount))
				Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
			if (PTL_Util::IsFloat(readTipCount))
				Error::Raise(IDE::invalidLCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

			// check tipCountIdentifier to be valid
			if (!PTL_Util::IsString(tipCountIdentifier))
				Error::Raise(IDE::invalidTipCountingIdentifier, GetFileName(), GetFunctionName(), GetLineNumber());
			if (readTipCount && 0 == StrGetLength(tipCountIdentifier))
				Error::Raise(IDE::invalidTipCountingIdentifier, GetFileName(), GetFunctionName(), GetLineNumber());
			
			// set sequence
			sequenceObjArr.SetAt(index, sequenceObj);
			if (readTipCount)
				sequenceObjCopyArr.SetAt(index, sequenceObj);
			resetSequenceFlagArr.SetAt(index, hslFalse);
			firstArr.SetAt(index, first);
			lastArr.SetAt(index, last);
			editableArr.SetAt(index, editable);
			ioTipCountArr.SetAt(index, readTipCount);
			tipCountIdentifierArr.SetAt(index, tipCountIdentifier);
		}

		static function Getsequence(
			variable index,
			sequence& sequenceObj)
		{
			#ifdef _DEBUG
			Assert(0 <= index && index < sequenceObjArr.GetSize(), GetFunctionName());
			#endif
			sequenceObj.CopySequence(sequenceObjArr.GetAt(index));
		}

		// Converts the integer number into the corresponding binary character string. 
		static function BinIStr(variable number) variable
		{
			variable base, remainder, quotient, unsignedNum(number);
			string digits, digit, result;

			base = 2;
			digits = "01";

			if (number < 0)
				unsignedNum = NumericConstants::longMax + number + 1;
			remainder = unsignedNum % base;
			for (quotient = unsignedNum / base; 
				quotient != 0; 
				quotient = quotient / base)
			{
				digit = digits.Mid(remainder, 1);
				result = digit + result;
				remainder = quotient % base;
			}
			digit = digits.Mid(remainder, 1);
			result = digit + result;
			return(result);
		}

		static function DetectPreloadedCarriers(
			device& ML_STAR,
			variable& preloadedCarriers[]) variable
		{
			variable numberOfPreloadedCarriers(0);			// Number of preloaded carriers
			variable commandString("");						// Command string
			variable rc[];											// Low level step return values

			// Initialize output params
			preloadedCarriers.SetSize(0);

			// Check for presence of carriers on loading tray
			commandString = "C0CS";
			MlStarSteps::StepFirmwareCommand(ML_STAR, commandString, "", rc);
			if (4 == rc.GetSize())
			{
				variable length(0);
				variable index(0);
				string stepReturn("");
				string hexBitPatternStr("");
				string binBitPatternStr("");
				variable bitPatternArr[];
				stepReturn = rc.ElementAt(3);
				//>> 20061122
				// Check error status
				if (0 <= stepReturn.Find("er00/00")) 
				{
					// no error
					//<< 20061122
					length = stepReturn.GetLength();
					hexBitPatternStr = stepReturn.Mid(stepReturn.Find("cd") + 2, length);
					length = hexBitPatternStr.GetLength();
					for (index = length - 1; 0 <= index ; index--)
					{
						binBitPatternStr = StrFillLeft(BinIStr(IVal("0x" + hexBitPatternStr.Mid(index, 1))), "0", 4) + binBitPatternStr;
					}
					length = binBitPatternStr.GetLength();
					for (index = length - 1; 0 <= index ; index--)
					{
						if ("1" == binBitPatternStr.Mid(index, 1))
						{
							numberOfPreloadedCarriers++;
							preloadedCarriers.AddAsLast(hslTrue);
						}
						else
						{
							preloadedCarriers.AddAsLast(hslFalse);
						}
					}
					//>> 20061122
				}
				//<< 20061122
			}
			return(numberOfPreloadedCarriers);
		}

		static function SelectPreloadedCarriers(
			device& ML_STAR,
			variable& preloadedCarriers[],
			variable& carrierNames[],
			variable& carrierCalibrateFlags[],
			variable& carrierBarcodeReadPositions[],
			variable& carrierBarcodeReadLabwareNames[],
			variable& carrierBarcodeReadPositionNames[],
			variable& carrierRecoveryOptionContinue[],
			variable& carrierRecoveryOptionExclude[],
			variable& carrierRecoveryOptionDefault[],
			variable& carrierKitLotCheckEnabled[]) void
		{
			variable i(0); 								// Loop index
			variable j(0); 								// Loop index
			variable k(0); 								// Loop index
			variable size(0); 							// Array size
			variable carrierName(""); 					// A carrier name
			variable deckID(0); 							// Deck ID (VectorDb)
			variable carrierNamesAtDeckSite[];		// Array to retrieve carrier names at a given deck site
			variable labwareNamesAtDeckSite[];		// Array to retrieve labware names at a given deck site
			variable templateSitesAtDeckSite[];		// Array to retrieve template sites at a given deck site
			object carrierNamesDict;					// Index for carrierNames, key = carrier name, value = array index in carrierNames
			object preloadedCarrierIndexes;			// Place to store the indexes of the preloaded carriers in the array carrierNames, key = indexes of the preloaded carriers in the array carrierNames, value = 0
			object preloadedLabwareNamesDict;		// Place to store the labware names of the preloaded carriers in the array carrierNames, key = labware name of the preloaded carriers in the array carrierNames, value = 0

			// Create an index for the array carrierNames: key = carrier name, value = array index in carrierNames
			preloadedLabwareNamesDict.CreateObject("Scripting.Dictionary");
			preloadedCarrierIndexes.CreateObject("Scripting.Dictionary");
			carrierNamesDict.CreateObject("Scripting.Dictionary");
			size = carrierNames.GetSize();
			for (i = 0; i < size; i++)
			{
				carrierNamesDict.Add(carrierNames.ElementAt(i), i);
			}

			// Init / update deck definitions 
			MlStarDeckDef::Init(ML_STAR);

			// Get deck ID
			deckID = VectorDb_Deck::GetDeckID(ML_STAR.GetInstrumentName());

			// Iterate deck sites and see if there is a preloaded carrier
			size = preloadedCarriers.GetSize();
			for (i = 0; i < size; i++)
			{
				if (preloadedCarriers.ElementAt(i))
				{
					// There is a preloaded carrier at this deck site.
					// Get carrier names at this deck site. 
					MlStarDeckDef::GetCarrierAtDeckSite(ML_STAR, i + 1, carrierNamesAtDeckSite);

					// Iterate over carrier names at this deck site. 
					for (j = 0; j < carrierNamesAtDeckSite.GetSize(); j++)
					{
						carrierName = carrierNamesAtDeckSite.ElementAt(j);

						// See whether current carrier exists in the list of carriers to load, that we got via parameter carrierNames
						if (carrierNamesDict.Exists(carrierName))
						{
							// Current carrier exists in the list of carriers to load, that we got via parameter carrierNames.
							// Check that there is no carrier still loaded at this deck site.
							if (0 == VectorDb_Labware::IsLabwareLoadedByLabwareId(deckID, carrierName))
							{
								variable labwareId("");				// A labware id
								variable carrierIndex(0);			// A carrier index

								// Get labware names at this deck site.
								MlStarDeckDef::GetLabwareAtDeckSite(ML_STAR, i + 1, carrierName, labwareNamesAtDeckSite, templateSitesAtDeckSite);

								// Iterate over labware names at this deck site. 
								for (k = 0; k < labwareNamesAtDeckSite.GetSize(); k++)
								{
									labwareId = labwareNamesAtDeckSite.ElementAt(k);
									if (!preloadedLabwareNamesDict.Exists(labwareId))
										preloadedLabwareNamesDict.Add(labwareId, 0);
								}
							
								// Store the index of the preloaded carriers in the array carrierNames.
								carrierIndex = carrierNamesDict.Item(carrierName);
								if (!preloadedCarrierIndexes.Exists(carrierIndex))
									preloadedCarrierIndexes.Add(carrierIndex, 0);
							}
						}
					}
				}
			}

			// Iterate over the list of carriers to load, that we got via parameter carrierNames
			size = carrierNames.GetSize();
			for (i = size - 1; 0 <= i ; i--)
			{
				// See whether this carrier exists in the collection containing the indexes of the preloaded carriers
				if (!preloadedCarrierIndexes.Exists(i))
				{
					// This carrier doesn't exist in the collection containing the indexes of the preloaded carriers 
					// -> remove it from the list
					carrierNames.RemoveElementAt(i);
					carrierCalibrateFlags.RemoveElementAt(i);
					carrierBarcodeReadPositions.RemoveElementAt(i);
					carrierBarcodeReadLabwareNames.RemoveElementAt(i);
					carrierBarcodeReadPositionNames.RemoveElementAt(i);
					if (ErrorHandling::continue == ErrorHandling || ErrorHandling::custom == ErrorHandling)
					{
						carrierRecoveryOptionContinue.RemoveElementAt(i);
						carrierRecoveryOptionExclude.RemoveElementAt(i);
						carrierRecoveryOptionDefault.RemoveElementAt(i);
						carrierKitLotCheckEnabled.RemoveElementAt(i);
					}
				}
			}

			// Iterate over the list of sequences to load
			size = sequenceObjArr.GetSize();
			for (i = 0; i < size ; i++)
			{
				variable labwareId("");				// A labware id
				variable labwareIds[];				// Array to retrieve distinct labware ids from sequence
				variable numberOfLabwareIds;		// Number of distinct labware ids of a sequence

				// Get list of distinct labware ids of this sequence
				sequenceObjArr[i].GetLabwareIds(labwareIds);

				// Iterate over list of distinct labware ids of this sequence
				numberOfLabwareIds = labwareIds.GetSize();
				for (j = 0; j < numberOfLabwareIds; j++)
				{
					// See whether this labware exists in the collection containing the labware names of the preloaded carriers
					labwareId = labwareIds.ElementAt(j);
					if (!preloadedLabwareNamesDict.Exists(labwareId))
					{
						sequenceObjArr[i].DeleteLabware(labwareId);
					}
				}
			}
		}

		private function GetSerialNumber(device& ML_STAR) variable
		{
			variable command("");								// Command string
			variable parameter("");								// Parameter string
			variable serialNumber("");							// Serial number
			variable rc[];											// Low level step return values

			// Get serial number
			command = "C0RI";				// Request Installation data
			parameter = "";

			MlStarSteps::StepFirmwareCommand(ML_STAR,command,parameter,rc);
			if (4 == rc.GetSize())
				serialNumber = StrMid(rc.ElementAt(3), StrFind(rc.ElementAt(3), "sn"), 6);
			return(StrMakeUpper(serialNumber));
		}

		private function WriteUnusedSampleTubesReport(
			device& ML_STAR,
			variable& carrierNames[], 
			variable& carrierBarcodes[], 
			variable& labwareNames[], 
			variable& labwarePositions[], 
			variable& labwareBarcodes[])
		{
			object fso;
			object registry;
			variable unusedSampleTubesReportFileName("");
			variable carrierName("");
			variable carrierBarcode("");
			variable labwareName("");
			variable labwarePosition("");
			variable labwareBarcode("");
			variable operator("");
			variable laboratory("");
			variable instrumentName("");
			variable instrumentSerialNumber("");
			variable date("");

			variable i(0);
			variable size(0);
			
			file unusedSampleTubesReport;

			registry.CreateObject("HXREGLib.HxRegistry");
			fso.CreateObject("Scripting.FileSystemObject");
			unusedSampleTubesReportFileName = GetLogFilesPath() + "\\" + fso.GetBaseName(GetMethodFileName()) + "_" + GetUniqueRunId() + "_" + StringConstants::unusedSampleTubesReportFileNameExtension;

			unusedSampleTubesReport.AddField(StringConstants::carrierNameColumnName, carrierName, hslString);
			unusedSampleTubesReport.AddField(StringConstants::carrierBarcodeColumnName, carrierBarcode, hslString);
			unusedSampleTubesReport.AddField(StringConstants::labwareNameColumnName, labwareName, hslString);
			unusedSampleTubesReport.AddField(StringConstants::labwarePositionColumnName, labwarePosition, hslString);
			unusedSampleTubesReport.AddField(StringConstants::labwareBarcodeColumnName, labwareBarcode, hslString);
			if (!unusedSampleTubesReport.Open(unusedSampleTubesReportFileName + " " + StringConstants::unusedSampleTubesReportTableName, hslWrite))
			{
				variable errorDesc;
				errorDesc = StringTable::Load(IDE::fileOpenFailed);
				errorDesc = errorDesc + "\n" + unusedSampleTubesReportFileName;
				Error::RaiseEx(IDE::fileOpenFailed, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
			}
			
			size = carrierBarcodes.GetSize();
			for (i = 0; i < size; i++)
			{
				carrierName = carrierNames.ElementAt(i);
				carrierBarcode = carrierBarcodes.ElementAt(i);
				labwareName = labwareNames.ElementAt(i);
				labwarePosition = labwarePositions.ElementAt(i);
				labwareBarcode = labwareBarcodes.ElementAt(i);
				unusedSampleTubesReport.WriteRecord();
			}
			unusedSampleTubesReport.Close();
			unusedSampleTubesReport.RemoveFields();

			unusedSampleTubesReport.AddField(StringConstants::operatorColumnName, operator, hslString);
			unusedSampleTubesReport.AddField(StringConstants::laboratoryColumnName, laboratory, hslString);
			unusedSampleTubesReport.AddField(StringConstants::instrumentNameColumnName, instrumentName, hslString);
			unusedSampleTubesReport.AddField(StringConstants::instrumentSerialNumberColumnName, instrumentSerialNumber, hslString);
			unusedSampleTubesReport.AddField(StringConstants::dateColumnName, date, hslString);
			if (!unusedSampleTubesReport.Open(unusedSampleTubesReportFileName + " " + StringConstants::unusedSampleTubesInfoTableName, hslWrite))
			{
				variable errorDesc;
				errorDesc = StringTable::Load(IDE::fileOpenFailed);
				errorDesc = errorDesc + "\n" + unusedSampleTubesReportFileName;
				Error::RaiseEx(IDE::fileOpenFailed, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
			}
			operator = GetUserName();
			laboratory = registry.Laboratory;
			instrumentName = ML_STAR.GetInstrumentName();
			instrumentSerialNumber = GetSerialNumber(ML_STAR);
			date = GetDate("%Y-%m-%d") + " " + GetTime("%H:%M:%S");
			unusedSampleTubesReport.WriteRecord();
		}

		static function ShowUnusedSampleTubesReport(
			variable& carrierNames[], 
			variable& carrierBarcodes[], 
			variable& labwarePositions[], 
			variable& labwareBarcodes[]) variable
		{
			dialog dlg;
			variable i(0);
			variable size(0);
			variable text("");
			//>> 20061026
			//variable buttonClicked(0);
			variable buttonClicked(hslOK);
			//<< 20061026

			text = text + 	StringTable::Load(IDS::unusedSampleTubesReportText) + "\n";
			text = text + "-------------------------------------------------------------------------------------------------------------\n";
			text = text + 	StrFillRight(StringTable::Load(IDS::carrierNameColumnName), " ", 60) + 
					 StrFillRight(StringTable::Load(IDS::carrierBarcodeColumnName), " ", 40) + 
					 StrFillRight(StringTable::Load(IDS::labwarePositionColumnName), " ", 20) + 
					 StrFillRight(StringTable::Load(IDS::labwareBarcodeColumnName), " ", 40) + "\n";
			text = text + "-----------------------------------------------------------------------------------------------------------------------------\n";
			size = carrierBarcodes.GetSize();
			for (i = 0; i < size; i++)
			{
				text = text + 	StrFillRight(carrierNames.ElementAt(i), " ", 40) + 
									StrFillRight(carrierBarcodes.ElementAt(i), " ", 40) + 
									StrFillRight(labwarePositions.ElementAt(i), " ", 20) + 
									StrFillRight(labwareBarcodes.ElementAt(i), " ", 40) + "\n";
			}
			text = text + "-----------------------------------------------------------------------------------------------------------------------------\n";
			
         dlg.SetOutput(text);
			if (0 < size)
			{
				buttonClicked = dlg.ShowOutput(StringTable::Load(IDS::unusedSampleTubesReportTitle), hslInformation);
			}
			return(buttonClicked);
		}

		static function ShowRequiredSampleTubesReport(
			variable& carrierNames[], 
			variable& carrierBarcodes[], 
			variable& labwarePositions[],
         variable& sourceBarcodes[]    // SCR 1299: array of barcodes not found on any carrier
         ) variable
		{
			dialog dlg;
			variable i(0);
			variable size1(0), size2(0);
			variable text("");
			//>> 20061026
			//variable buttonClicked(0);
			variable buttonClicked(hslOK);
			//<< 20061026

			text = text + 	StringTable::Load(IDS::requiredSampleTubesReportText) + "\n";
			text = text + "---------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
         text = text + 	StrFillRight(StringTable::Load(IDS::sourceBarcodeColumnName), " ", 50) + // SCR 1299
                        StrFillRight(StringTable::Load(IDS::carrierNameColumnName), " ", 60) + 
					         StrFillRight(StringTable::Load(IDS::carrierBarcodeColumnName), " ", 40) + 
					         StrFillRight(StringTable::Load(IDS::labwarePositionColumnName), " ", 20) + "\n";
			text = text + "---------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";

         size1 = sourceBarcodes.GetSize();
   		for (i = 0; i < size1; i++) // SCR 1299
			{
				text = text + 	StrFillRight(sourceBarcodes.ElementAt(i), " ", 50) + 
                           StrFillRight(StringTable::Load(IDS::requiredAtAnyFreePos), " ", 60) + 
									StrFillRight(" ", " ", 40) + 
									StrFillRight(" ", " ", 20) + "\n";
			}

         size2 = carrierBarcodes.GetSize();
   		for (i = 0; i < size2; i++)
   		{
				text = text + 	StrFillRight(" ", " ", 50) + 
                           StrFillRight(carrierNames.ElementAt(i), " ", 60) + 
									StrFillRight(carrierBarcodes.ElementAt(i), " ", 40) + 
									StrFillRight(labwarePositions.ElementAt(i), " ", 20) + "\n";
   		}
   		
         text = text + "---------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
			text = text + StringTable::Load(IDS::requiredSampleTubesReportText2);

         dlg.SetOutput(text);
			if ( (0 < size1) || (0 < size2))
			{
				buttonClicked = dlg.ShowOutput(StringTable::Load(IDS::requiredSampleTubesReportTitle), hslOKCancel + hslInformation);
			}
			return(buttonClicked);
		}

		static function GetLabwareIdAndPositionId(		// Returns the labware and the position id in the deck layout, given a labware ID in the Vector Database
			variable labwareID, 									// [in]:  Labware ID in Vector Database (integer)
			variable& labwareId,									// [out]: Labware id in deck layout (string)
			variable& positionId) variable					// [out]: Position id in deck layout (string)
		{
			// Init output params
			labwareId = "";
			positionId = "";

			// Query labware and position id in the deck layout, given a labware ID in the Vector Database
			if (0 < labwareID)
			{
				variable parentLabwareID(0);

				VectorDb_Labware::GetLabwareByElementID(	labwareID,
															0, // deckID,
															parentLabwareID,
															positionId,
															0, // labwareLevel,
															0, // barcode,
															0, // volume,
															0, // labwareState,
															0, // userLabwareState,
															0, // deckCoordinateX,
															0, // deckCoordinateY,
															0, // deckCoordinateZ,
															0); // userLabwareTypeID);

				VectorDb_Labware::GetLabwareByElementID(	parentLabwareID,
															0, // deckID,
															0, // parentLabwareID,
															labwareId,
															0, // labwareLevel,
															0, // barcode,
															0, // volume,
															0, // labwareState,
															0, // userLabwareState,
															0, // deckCoordinateX,
															0, // deckCoordinateY,
															0, // deckCoordinateZ,
															0); // userLabwareTypeID);
				return(hslTrue);
			}
			return(hslFalse);
		}

		// See VBScript 'Split' function.
		static function Split(variable& str, variable& delimiter, variable& substrings[]) void
		{
			substrings.SetSize(0);
			substrings = ptlScriptControl.Eval("Split(\"" + str + "\", \"" + delimiter + "\")");
		}

		// See HSLUtilLib 'PTL_Util::Lookup' function.
		// The FastLookup function does no type checking and assumes that the 
		// type of the array elements matches with the type of the value searched.
		function FastLookup(variable& varArr[], variable& value, variable& index) variable
		{
			variable size(0);

			// Do a sequential search
			size = varArr.GetSize();
			for (index = 0; index < size; index++)
				if (varArr.ElementAt(index) == value)
					return(hslTrue);
			index = -1;
			return(hslFalse);
		}

		static function UnloadUnusedSampleTubes(
			device& ML_STAR,
			sequence& fullSampleSequence,
			sequence& loadedSampleSequence) void
		{
			variable i(0);											// Loop counter
			variable currentPos(-1);							// A current position
			variable currentPosBck(-1);						// Backup of current position of input sequence
			variable prevLabwareId("");						// A previous labware id 
			variable labwareId("");								// A labware id 
			variable positionId("");							// A position id
			variable maxPositionIdWidth(0);					// Max string width of position id
			variable templateSite("");							// A template site
			variable carrierID(0);								// A carrier VectorDb-ID 
			variable carrierBarcode("");						// A carrier barcode 
			variable position("");								// Either a rack position (template site) or a well position
			variable deckID(0); 									// Deck ID (VectorDb)

			variable numberOfJobs(0);							// Number of jobs 
			variable jobStateFilter(0);						// Job state filter
			variable jobIDs[];									// Array to retrieve job data
			variable jobNames[];									// Array to retrieve job data
			variable jobPriorities[];							// Array to retrieve job data
			variable jobStates[];								// Array to retrieve job data
			variable jobUserStates[];							// Array to retrieve job data
			variable sourceLabwareIDs[];						// Array to retrieve job data
			variable sourceBarcodes[];							// Array to retrieve job data
			variable sourceLabwareIds[];						// Array to retrieve job data
			variable sourcePositionIds[];						// Array to retrieve job data
			variable sourceRequiredFlags[];					// Array to retrieve job data
			variable targetLabwareIDs[];						// Array to retrieve job data
			variable targetBarcodes[];							// Array to retrieve job data
			variable targetLabwareIds[];						// Array to retrieve job data
			variable targetPositionIds[];						// Array to retrieve job data
			variable targetVolumes[];							// Array to retrieve job data

			object sourceLabwareIdPositionIdDict;			// Index for arrays sourceLabwareId-sourcePositionId-pair: key = sourceLabwareId + "\\" + sourcePositionId, value = array index in sourceLabwareId
			variable sampleCarriersUsed[];					// Place to hold unique names of carriers containing used samples
			object sampleCarriersUsedDict;					// Index for sampleCarriersUsed
			variable sampleCarrierPositionsUsed[];			// Place to hold carrier positions/sites of carriers containing used samples
			variable sampleCarrierLabwareIdsUsed[];		// Place to hold labware ids of carriers containing used samples
			variable sampleCarriersUnused[];					// Place to hold unique names of carriers containing unused samples
			object sampleCarriersUnusedDict;					// Index for sampleCarriersUnused
			variable sampleCarrierPositionsUnused[];		// Place to hold carrier positions/sites of carriers containing unused samples
			variable positionsOfLoadedLabware[];			// Place to hold carrier positions/sites of labware loaded on carriers containing unused samples
			variable fieldDelimiter("");						// The field delimiter of the command associated to the device

			// The following lists will be built during the determination of the sample tubes that can be unloaded.
			// They grow in parallel and represent columns in the Unused Sample Tubes Report.
			variable carrierNames[];							// Place to hold values of column 'Carrier name' in Unused Sample Tubes Report
			variable carrierBarcodes[];						// Place to hold values of column 'Carrier barcode' in Unused Sample Tubes Report
			variable labwareNames[];							// Place to hold values of column 'Labware name' in Unused Sample Tubes Report
			variable labwarePositions[];						// Place to hold values of column 'Labware position' in Unused Sample Tubes Report
			variable sampleBarcodes[];							// Place to hold values of column 'Sample barcode' in Unused Sample Tubes Report

			variable foundAt(-1);								// Search index
			variable numberOfCarriers(0);						// Number of carriers
			variable carrierName("");							// A carrier name
			variable positions("");								// Positions string passed to the low-level-step Load
			variable labwareIds("");							// Labware ids associated to positions contained in positions string passed to the low-level-step Load
			variable buttonClicked(0);							// Id of button clicked by the user in the unloading unused samples dialog
			variable substrings1[];								// Place to hold substrings of a string
			variable substrings2[];								// Place to hold substrings of a string
			variable rc[];											// Place to hold step return values

			// Activate error handler
			onerror goto Unexpected;

			// Query all jobs, that have been assigned but not yet been processed
			numberOfJobs = -1;
			jobStateFilter = VectorDb_JobState::Assigned;
			jobIDs.SetSize(0);
			jobNames.SetSize(0);
			jobStates.SetSize(0);
			jobUserStates.SetSize(0);
			jobPriorities.SetSize(0);
			sourceBarcodes.SetSize(0);
			sourceLabwareIds.SetSize(0);
			sourcePositionIds.SetSize(0);
			sourceRequiredFlags.SetSize(0);
			targetBarcodes.SetSize(0);
			targetLabwareIds.SetSize(0);
			targetPositionIds.SetSize(0);
			targetVolumes.SetSize(0);
			numberOfJobs = VectorDb::GetJobs(jobStateFilter,
														jobIDs,jobNames,jobPriorities,jobStates,jobUserStates,
														sourceLabwareIDs,sourceBarcodes,sourceLabwareIds,sourcePositionIds,sourceRequiredFlags,
														targetLabwareIDs,targetBarcodes,targetLabwareIds,targetPositionIds,targetVolumes);

			// Create indexes for faster lookup
			sourceLabwareIdPositionIdDict.CreateObject("Scripting.Dictionary");
			sampleCarriersUsedDict.CreateObject("Scripting.Dictionary");
			sampleCarriersUnusedDict.CreateObject("Scripting.Dictionary");

			// Fill indexes for faster lookup
			for (i = 0; i < numberOfJobs; i++)
			{
				variable key(0);

				variable labwareId("");
				variable positionId("");

				GetLabwareIdAndPositionId(sourceLabwareIDs.ElementAt(i), labwareId, positionId);
				key = labwareId + "\\" + positionId;
				if (!sourceLabwareIdPositionIdDict.Exists(key))
					sourceLabwareIdPositionIdDict.Add(key, i);
			}

			// Get deck ID
			deckID = VectorDb_Deck::GetDeckID(ML_STAR.GetInstrumentName());

			// Get the field delimiter of the command associated to the device
			fieldDelimiter = StringConstants::barcodePosDelimiter; // SCR#1503: ML_STAR.GetCfgValueWithKey(MlStarCfgKey::wordSeparator);

			// Backup current position of full sample sequence
			currentPosBck = fullSampleSequence.GetCurrentPosition();

			// Iterate over full sample sequence from position 1 to end position and determine max string width of positionId
			for (currentPos = fullSampleSequence.SetCurrentPosition(1);
				  0 < currentPos;
				  currentPos = fullSampleSequence.Increment(1))
			{
				maxPositionIdWidth = PTL_Util::Max(maxPositionIdWidth, StrGetLength(fullSampleSequence.GetPositionId()));
			}
			// Iterate over full sample sequence from position 1 to end position and collect positions of unused samples 
			for (currentPos = fullSampleSequence.SetCurrentPosition(1);
				  0 < currentPos;
				  currentPos = fullSampleSequence.Increment(1))
			{
				// Get labware and position id of element at current position
				labwareId = fullSampleSequence.GetLabwareId();
				positionId = fullSampleSequence.GetPositionId();

				// Check for a labware change (optimization)
				if (prevLabwareId != labwareId)
				{
					// Get carrier name from labware
					MlStarDeckDef::GetCarrierForLabware(ML_STAR, 
																	labwareId, 
																	carrierName, 
																	0, // deckSite, 
																	templateSite);

					// Get carrier ID from VectorDb
					carrierID = VectorDb_Labware::IsLabwareLoadedByLabwareId(deckID, carrierName);

					// Get carrier barcode VectorDb
					if (0 < carrierID)
					{
						carrierBarcode = VectorDb_Labware::GetLabwareBarcodeByElementID(carrierID);
					}
					else
					{
						carrierBarcode = "";
					}

					// Remember current labware (optimization)
					prevLabwareId = labwareId;
				}

				// Determine labware position depending of labware level (template or rack)
				if ("" != templateSite)
				{
					// Carrier from labware is a template
					position = templateSite;
				}
				else
				{
					// Carrier from labware is not a templat, but a rack
					position = positionId;
				}

				// Lookup element at current position in list of jobs, that have been assigned but not yet been processed
				if (!sourceLabwareIdPositionIdDict.Exists(labwareId + "\\" + positionId))
				{
					// Didn't found element at current position in list of jobs, that have been assigned but not yet been processed

					// Check if element at current position has been loaded at all
					if (0 != loadedSampleSequence.LookupPosition(labwareId, positionId, 1, hslTrue))
					{
						// Element at current position has been loaded 

						variable sampleID(0);								// A sample VectorDb-ID 
						variable sampleBarcode("");						// A sample barcode 

						// Get sample barcode from VectorDb
						sampleID = VectorDb_Labware::GetElementIDByCurrentPositionOfSequence(deckID, fullSampleSequence);
						if (0 < sampleID)
						{
							sampleBarcode = VectorDb_Labware::GetLabwareBarcodeByElementID(sampleID);
						}

						// Make position id fixed width, e.g. A1 --> A01, 1 --> 01, 10 --> 10
						MlStarDeckDef::FormatPosition(positionId, maxPositionIdWidth - 1, maxPositionIdWidth);

						// Add position to lists that represent columns in the Unused Sample Tubes Report 
						carrierNames.AddAsLast(carrierName);	//carrierNames.AddAsLast(PCB::GetCarrierType(ML_STAR, carrierName));
						carrierBarcodes.AddAsLast(carrierBarcode);
						labwareNames.AddAsLast(labwareId);
						labwarePositions.AddAsLast(positionId);
						sampleBarcodes.AddAsLast(sampleBarcode);

						// Add carrier to array containing names of carriers containing unused samples
						if (!sampleCarriersUnusedDict.Exists(carrierName))
						{
							sampleCarriersUnused.AddAsLast(carrierName);
							sampleCarriersUnusedDict.Add(carrierName, sampleCarriersUnused.GetSize() - 1);
							sampleCarrierPositionsUnused.AddAsLast(position);
						}
						else
						{
							foundAt = sampleCarriersUnusedDict.Item(carrierName);
							positions = sampleCarrierPositionsUnused.ElementAt(foundAt);
							Split(positions, fieldDelimiter, substrings1);
							if (!FastLookup(substrings1, position, 0 /*index*/))
							{
								sampleCarrierPositionsUnused.SetAt(foundAt, sampleCarrierPositionsUnused.ElementAt(foundAt) + fieldDelimiter + position);
							}
						}
					}
				}
				else
				{
					// Add carrier to array containing names of carriers containing used samples
					if (!sampleCarriersUsedDict.Exists(carrierName))
					{
						sampleCarriersUsed.AddAsLast(carrierName);
						sampleCarriersUsedDict.Add(carrierName, sampleCarriersUsed.GetSize() - 1);
						sampleCarrierPositionsUsed.AddAsLast(position);
						sampleCarrierLabwareIdsUsed.AddAsLast(labwareId);
					}
					else
					{
						foundAt = sampleCarriersUsedDict.Item(carrierName);
						positions = sampleCarrierPositionsUsed.ElementAt(foundAt);
						Split(positions, fieldDelimiter, substrings1);
						if (!FastLookup(substrings1, position, 0 /*index*/))
						{
							sampleCarrierPositionsUsed.SetAt(foundAt, sampleCarrierPositionsUsed.ElementAt(foundAt) + fieldDelimiter + position);
							sampleCarrierLabwareIdsUsed.SetAt(foundAt, sampleCarrierLabwareIdsUsed.ElementAt(foundAt) + fieldDelimiter + labwareId);
						}
					}
				}
			}

			// Restore current position of full sample sequence
			fullSampleSequence.SetCurrentPosition(currentPosBck);

			// Check whether we found carriers containing unused samples
			if (0 < carrierBarcodes.GetSize())
			{
				// We found carriers containing unused samples
				
				//>> 20061026
				// Write Unused Sample Tubes Report 
				//WriteUnusedSampleTubesReport(ML_STAR, carrierNames, carrierBarcodes, labwareNames, labwarePositions, sampleBarcodes);
				//<< 20061026

				// Unload carriers containing unused samples
				numberOfCarriers = sampleCarriersUnused.GetSize();
				for (i = 0; i < numberOfCarriers; i++)
				{
					carrierName = sampleCarriersUnused.ElementAt(i);
					positions = sampleCarrierPositionsUnused.ElementAt(i);
					Split(positions, fieldDelimiter, substrings1);

					// Don't unload this carrier, if all of it's positions (template sites) are used
					if (sampleCarriersUsedDict.Exists(carrierName))
					{
						variable c(0);							// Loop counter
						variable s(0);							// Array size

						foundAt = sampleCarriersUsedDict.Item(carrierName);
						positions = sampleCarrierPositionsUsed.ElementAt(foundAt);
						Split(positions, fieldDelimiter, substrings2);
						s = substrings1.GetSize();
						for (c = 0; c < s; c++)
						{
							if (!FastLookup(substrings2, substrings1.ElementAt(c), foundAt))
								// Unload this carrier
								break;
						}
						if (s <= c)
						{
							// All of the carriers positions (template sites) are used
							// --> don't unload this carrier
							sampleCarriersUnused.SetAt(i, "");

							//>> 20061026
							s = carrierNames.GetSize();
							for (c = s - 1; 0 <= c; c--)
							{
								if (carrierNames.ElementAt(c) == carrierName)
								{
									carrierNames.RemoveElementAt(c);
									carrierBarcodes.RemoveElementAt(c);
									labwareNames.RemoveElementAt(c);
									labwarePositions.RemoveElementAt(c);
									sampleBarcodes.RemoveElementAt(c);
								}
							}
							//<< 20061026
						}
					}

					// Unload carrier
					carrierName = sampleCarriersUnused.ElementAt(i);
					positions = sampleCarrierPositionsUnused.ElementAt(i);
					if ("" != carrierName)
					{
						variable j(0);						// Loop counter
						variable s(0);						// Array size
						variable labwareNames[];		// Place to retrieve labware names
						variable positionNames[];		// Place to retrieve position names

						// Get positions of labware currently loaded without load error on this carrier and 
						// subtract unused from loaded positions (positions of stacks should be removed from 
						// loaded positions as well but how can we determine positions of stacks ?).
						Split(positions, fieldDelimiter, substrings1);
						//>> 20061018 (Function VectorDb_Labware::IsLabwareLoadedByLabwareIdPositionId() called from 
						//					MlStarDeckDef::GetLoadedLabwareForCarrier() does not work as expected in V4.1.
						//					Function MlStarDeckDef::GetLoadedLabwareForCarrier2() implements a workaround)
						//MlStarDeckDef::GetLoadedLabwareForCarrier(ML_STAR,carrierName,hslTrue,labwareNames,positionNames);
						MlStarDeckDef::GetLoadedLabwareForCarrier2(ML_STAR, carrierName, loadedSampleSequence, hslTrue, labwareNames, positionNames);
						//<< 20061018
						positions = "";
						// Iterate over loaded positions
						s = positionNames.GetSize();
						for (j = 0; j < s; j++)
						{
							// Subtract unused from loaded positions
							if (!FastLookup(substrings1, positionNames.ElementAt(j), foundAt))
							{
								if ("" != positions)
									positions = positions + fieldDelimiter;
								positions = positions + positionNames.ElementAt(j);
							}
						}
						positionsOfLoadedLabware.AddAsLast(positions);

						// Carrier should be unloaded
						#ifdef _DEBUG
						FormatTrace("DEBUG", "ML_STAR.UnloadCarrier", TraceStatus::progress, "carrier = ", carrierName);
						#endif
						StepReturn::Empty(rc);
						onerror goto UnloadCarrierErrorHandler;
						rc = MlStarSteps::StepUnloadCarrier_cer(ML_STAR,
																carrierName,
																//ErrorHandling,
                                                ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, UnloadCarrierCustomStepID),
                                                UnloadCarrierCustomStepID,
																UserResponseTime);
						onerror goto 0;
						if (!StepReturn::Evaluate(ML_STAR, rc, ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, UnloadCarrierCustomStepID)))
							Error::RaiseLast();
						StepReturn::Empty(rc);
					}
				}

				//>> 20061026
				// Write Unused Sample Tubes Report 
				WriteUnusedSampleTubesReport(ML_STAR, carrierNames, carrierBarcodes, labwareNames, labwarePositions, sampleBarcodes);
				//<< 20061026

				// Show Unused Sample Tubes Report 
				buttonClicked = ShowUnusedSampleTubesReport(carrierNames, carrierBarcodes, labwarePositions, sampleBarcodes);
				if (hslOK == buttonClicked)
				{
					// User confirmed unloading of unused samples

					// setup name of barcode file
					if ("" == LoadCarrierBarcodeFileName)
					{
						// barcode file name has not been set by the user,
						// setup default barcode file name
						variable methodName;
						methodName = GetMethodFileName();
						if ("" == methodName)
						{
							methodName = GetWorkflowFileName();
						}
						i = StrReverseFind(methodName, ".");
						if (0 <= i)
							methodName = StrLeft(methodName, i);
						i = StrReverseFind(methodName, "\\");
						if (0 <= i)
							methodName = StrMid(methodName, i + 1, StrGetLength(methodName));
						LoadCarrierBarcodeFileName = GetLogFilesPath() + "\\" + methodName + StringConstants::barcodeFileExt;
					}

					// Load carriers that contained unused samples
					numberOfCarriers = sampleCarriersUnused.GetSize();
					for (i = 0; i < numberOfCarriers; i++)
					{
						// Load carrier
						carrierName = sampleCarriersUnused.ElementAt(i);
						if ("" != carrierName)
						{
							variable j(0);				// Loop index
							variable s(0);				// Array size

							// Carrier has been unloaded
							if (sampleCarriersUsedDict.Exists(carrierName))
							{
								foundAt = sampleCarriersUsedDict.Item(carrierName);
								positions = sampleCarrierPositionsUsed.ElementAt(foundAt);
								labwareIds = sampleCarrierLabwareIdsUsed.ElementAt(foundAt);
							}
							else
							{
								positions = "";
								labwareIds = "";
							}

							// Merge used and loaded positions
							Split(positions, fieldDelimiter, substrings1);
							Split(positionsOfLoadedLabware.ElementAt(i), fieldDelimiter, substrings2);
							s = substrings2.GetSize();
							for (j = 0; j < s; j++)
							{
								if (!FastLookup(substrings1, substrings2.ElementAt(j), foundAt))
								{
									if ("" != positions)
										positions = positions + fieldDelimiter;
									positions = positions + substrings2.ElementAt(j);
								}
							}

							// Load carrier.
							// Don't load the carrier if no labware placed on it is used.
							if ("" != positions)
							{
								#ifdef _DEBUG
								FormatTrace("DEBUG", "ML_STAR.LoadCarrier", TraceStatus::progress, "carrier = ", carrierName);
								FormatTrace("DEBUG", "ML_STAR.LoadCarrier", TraceStatus::progress, "positions = ", positions);
								#endif
								StepReturn::Empty(rc);
								onerror goto LoadCarrierErrorHandler;
								rc = MlStarSteps::StepLoadCarrierEx2_cer(ML_STAR, // use ...Ex2() with special error settings for load and match
																		carrierName,
																		LoadCarrierBarcodeFileName,
																		PTL_Util::CsvToDelimited2(ML_STAR, positions),	// Load positions
																		1,				// Recovery option continue: 1 = visible
																		1,				// Recovery option exclude:  1 = visible
																		0,				// Recovery option default:  0 = continue
																		//ErrorHandling,
                                                      ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, LoadCarrierCustomStepID),
                                                      LoadCarrierCustomStepID,
																		UserResponseTime);
								onerror goto 0;
								if (!StepReturn::Evaluate(ML_STAR, rc, ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, LoadCarrierCustomStepID)))
									Error::RaiseLast();
								StepReturn::Empty(rc);
							}
						}
					}
				}
			}

			return;

			Unexpected:
			{
				// Restore current position of input sequence
				if (0 <= currentPosBck)
					fullSampleSequence.SetCurrentPosition(currentPosBck);

				// Re-throw the error 
				Error::RaiseLast();
			}

			UnloadCarrierErrorHandler:
			{
				// bind error data
				StepReturn::Bind(rc);
				resume next;
			}

			LoadCarrierErrorHandler:
			{
				// bind error data
				StepReturn::Bind(rc);
				resume next;
			}
		}

		static function LoadRequiredSampleTubes(
			device& ML_STAR,
			variable scanAutoloadTray,
			sequence& fullSampleSequence,
			sequence& loadedSampleSequence) variable
		{
			variable i(0);											// Loop counter
			variable j(0);											// Loop counter
			variable size(0);										// Array size
			variable currentPos(-1);							// A current position
			variable currentPosBck(-1);						// Backup of current position of input sequence
			variable prevLabwareId("");						// A previous labware id 
			variable labwareId("");								// A labware id 
			variable positionId("");							// A position id
			variable maxPositionIdWidth(0);					// Max string width of position id
			variable templateSite("");							// A template site
			variable carrierID(0);								// A carrier VectorDb-ID 
			variable carrierBarcode("");						// A carrier barcode 
			variable position("");								// Either a rack position (template site) or a well position
			variable deckID(0); 									// Deck ID (VectorDb)

			variable numberOfJobs(0);							// Number of jobs 
			variable jobStateFilter(0);						// Job state filter
			variable jobIDs[];									// Array to retrieve job data
			variable jobNames[];									// Array to retrieve job data
			variable jobPriorities[];							// Array to retrieve job data
			variable jobStates[];								// Array to retrieve job data
			variable jobUserStates[];							// Array to retrieve job data
			variable sourceLabwareIDs[];						// Array to retrieve job data
			variable sourceBarcodes[];							// Array to retrieve job data
			variable sourceLabwareIds[];						// Array to retrieve job data
			variable sourcePositionIds[];						// Array to retrieve job data
			variable sourceRequiredFlags[];					// Array to retrieve job data
			variable targetLabwareIDs[];						// Array to retrieve job data
			variable targetBarcodes[];							// Array to retrieve job data
			variable targetLabwareIds[];						// Array to retrieve job data
			variable targetPositionIds[];						// Array to retrieve job data
			variable targetVolumes[];							// Array to retrieve job data

			object sourceLabwareIdPositionIdDict;			// Index for arrays sourceLabwareId-sourcePositionId-pair: key = sourceLabwareId + "\\" + sourcePositionId, value = array index in sourceLabwareId
			variable sampleCarriersUsed[];					// Place to hold unique names of carriers containing used samples
			object sampleCarriersUsedDict;					// Index for sampleCarriersUsed
			variable sampleCarrierPositionsUsed[];			// Place to hold carrier positions/sites of carriers containing used samples
			variable sampleCarrierLabwareIdsUsed[];		// Place to hold labware ids of carriers containing used samples
			variable sampleCarriersUnused[];					// Place to hold unique names of carriers containing unused samples
			object sampleCarriersUnusedDict;					// Index for sampleCarriersUnused
			variable sampleCarrierPositionsUnused[];		// Place to hold carrier positions/sites of carriers containing unused samples
			variable fieldDelimiter("");						// The field delimiter of the command associated to the device

			// The following lists will be built during the determination of the sample tubes that must be loaded.
			// They grow in parallel and represent columns in the Required Sample Tubes Report.
			variable carrierNames[];							// Place to hold values of column 'Carrier name' in Required Sample Tubes Report
			variable carrierBarcodes[];						// Place to hold values of column 'Carrier barcode' in Required Sample Tubes Report
			variable labwareNames[];							// Place to hold values of column 'Labware name' in Required Sample Tubes Report
			variable labwarePositions[];						// Place to hold values of column 'Labware position' in Required Sample Tubes Report
			variable unknownBarcodes[];					   // Place to hold values of column 'Source barcode' in Required Sample Tubes Report

			variable foundAt(-1);								// Search index
			variable numberOfCarriers(0);						// Number of carriers
			variable carrierName("");							// A carrier name
			variable positions("");								// Positions string passed to the low-level-step Load
			variable labwareIds("");							// Labware ids associated to positions contained in positions string passed to the low-level-step Load
			variable buttonClicked(0);							// Id of button clicked by the user in the unloading unused samples dialog
			variable substrings1[];								// Place to hold substrings of a string
			variable substrings2[];								// Place to hold substrings of a string
			variable rc[];											// Place to hold step return values
      
			// Activate error handler
			onerror goto Unexpected;

			// Query all jobs, that have not been assigned but that are required
			numberOfJobs = -1;
			jobStateFilter = VectorDb_JobState::Unprocessed;
			jobIDs.SetSize(0);
			jobNames.SetSize(0);
			jobStates.SetSize(0);
			jobUserStates.SetSize(0);
			jobPriorities.SetSize(0);
			sourceBarcodes.SetSize(0);
			sourceLabwareIds.SetSize(0);
			sourcePositionIds.SetSize(0);
			sourceRequiredFlags.SetSize(0);
			targetBarcodes.SetSize(0);
			targetLabwareIds.SetSize(0);
			targetPositionIds.SetSize(0);
			targetVolumes.SetSize(0);
			numberOfJobs = VectorDb::GetJobs(jobStateFilter,
														jobIDs,jobNames,jobPriorities,jobStates,jobUserStates,
														sourceLabwareIDs,sourceBarcodes,sourceLabwareIds,sourcePositionIds,sourceRequiredFlags,
														targetLabwareIDs,targetBarcodes,targetLabwareIds,targetPositionIds,targetVolumes);

			// Create indexes for faster lookup
			sourceLabwareIdPositionIdDict.CreateObject("Scripting.Dictionary");
			sampleCarriersUsedDict.CreateObject("Scripting.Dictionary");
			sampleCarriersUnusedDict.CreateObject("Scripting.Dictionary");

			// Fill indexes for faster lookup
			for (i = 0; i < numberOfJobs; i++)
			{
				if (0 != sourceRequiredFlags.ElementAt(i))
				{
					variable key(0);

					variable labwareId("");
					variable positionId("");

					labwareId = sourceLabwareIds.ElementAt(i);
					positionId = sourcePositionIds.ElementAt(i);
					if ("" != labwareId && "" != positionId)
					{
						key = labwareId + "\\" + positionId;
						if (!sourceLabwareIdPositionIdDict.Exists(key))
							sourceLabwareIdPositionIdDict.Add(key, i);
					}
					else
					{
						//<< SCR 1299
                  // Throw an exception
						//Error::Raise(IDE::noLabIdPosIdFoundForRequiredSource, GetFileName(), GetFunctionName(), GetLineNumber());
					
                  key = sourceBarcodes.ElementAt(i);
                  unknownBarcodes.AddAsLast(key);
                  //>>
               }
				}
			}

			// Check wether there are jobs, that have not been assigned but that are required
			if ((0 == sourceLabwareIdPositionIdDict.Count) && (0 == unknownBarcodes.GetSize()))
			{
				// There are jobs, that have not been assigned but that are required
				return(0);
			}

			// Get deck ID
			deckID = VectorDb_Deck::GetDeckID(ML_STAR.GetInstrumentName());

			// Get the field delimiter of the command associated to the device
			fieldDelimiter = StringConstants::barcodePosDelimiter; // SCR#1503 ML_STAR.GetCfgValueWithKey(MlStarCfgKey::wordSeparator);

			// Backup current position of full sample sequence
			currentPosBck = fullSampleSequence.GetCurrentPosition();

			// Iterate over full sample sequence from position 1 to end position and determine max string width of positionId
			for (currentPos = fullSampleSequence.SetCurrentPosition(1);
				  0 < currentPos;
				  currentPos = fullSampleSequence.Increment(1))
			{
				maxPositionIdWidth = PTL_Util::Max(maxPositionIdWidth, StrGetLength(fullSampleSequence.GetPositionId()));
			}

			// Iterate over full sample sequence from position 1 to end position and collect positions of required samples 
			for (currentPos = fullSampleSequence.SetCurrentPosition(1);
				  0 < currentPos;
				  currentPos = fullSampleSequence.Increment(1))
			{
            variable bLabIdPosIdExists(hslFalse);

				// Get labware and position id of element at current position
				labwareId = fullSampleSequence.GetLabwareId();
				positionId = fullSampleSequence.GetPositionId();

				// Check for a labware change (optimization)
				if (prevLabwareId != labwareId)
				{
					// Get carrier name from labware
					MlStarDeckDef::GetCarrierForLabware(ML_STAR, 
																	labwareId, 
																	carrierName, 
																	0, // deckSite, 
																	templateSite);

					// Get carrier ID from VectorDb
					carrierID = VectorDb_Labware::IsLabwareLoadedByLabwareId(deckID, carrierName);

					// Get carrier barcode VectorDb
					if (0 < carrierID)
					{
						carrierBarcode = VectorDb_Labware::GetLabwareBarcodeByElementID(carrierID);
					}
					else
					{
						carrierBarcode = "";
					}

					// Remember current labware (optimization)
					prevLabwareId = labwareId;
				}

				// Determine labware position depending of labware level (template or rack)
				if ("" != templateSite)
				{
					// Carrier from labware is a template
					position = templateSite;
				}
				else
				{
					// Carrier from labware is not a template, but a rack
					position = positionId;
				}

				// Lookup element at current position in list of jobs, that have not been assigned but that are required
            bLabIdPosIdExists = sourceLabwareIdPositionIdDict.Exists(labwareId + "\\" + positionId);
            
            if ( bLabIdPosIdExists
               // << SCR 1299
               || (0 < unknownBarcodes.GetSize()) // enter always when unknown barcodes were found, as ALL carriers must be unloaded
               ) // >> 
				{					
					// << SCR 1299
               if(bLabIdPosIdExists)
               {
                  // Make position id fixed width, e.g. A1 --> A01, 1 --> 01, 10 --> 10
                  variable positionIdFixed(positionId);
   					MlStarDeckDef::FormatPosition(positionIdFixed, maxPositionIdWidth - 1, maxPositionIdWidth);
               // >> 
                  
					   // Add position to lists that represent columns in the Required Sample Tubes Report 
                  carrierNames.AddAsLast(carrierName);	//carrierNames.AddAsLast(PCB::GetCarrierType(ML_STAR, carrierName));
   					carrierBarcodes.AddAsLast(carrierBarcode);
   					labwareNames.AddAsLast(labwareId);
   					labwarePositions.AddAsLast(positionIdFixed);
               }

					// Add carrier to array containing names of carriers containing required samples
					if (!sampleCarriersUnusedDict.Exists(carrierName))
					{
						sampleCarriersUnused.AddAsLast(carrierName);
						sampleCarriersUnusedDict.Add(carrierName, sampleCarriersUnused.GetSize() - 1);
						sampleCarrierPositionsUnused.AddAsLast(position);
					}
					else
					{
						foundAt = sampleCarriersUnusedDict.Item(carrierName);
						positions = sampleCarrierPositionsUnused.ElementAt(foundAt);
						Split(positions, fieldDelimiter, substrings1);
						if (!FastLookup(substrings1, position, 0 /*index*/))
						{
							sampleCarrierPositionsUnused.SetAt(foundAt, sampleCarrierPositionsUnused.ElementAt(foundAt) + fieldDelimiter + position);
						}
					}
				}

            // << SCR 1299
            if ( ! bLabIdPosIdExists
               || (0 < unknownBarcodes.GetSize()) // enter always when unknown barcodes were found, as ALL carriers must be added to used list
               )
	         // >> 
			   {     
					//>> 20061026
					if (loadedSampleSequence.LookupPosition(labwareId, positionId, 1, hslTrue))
					{
					//<< 20061026
						// Add carrier to array containing names of carriers containing used samples
						if (!sampleCarriersUsedDict.Exists(carrierName))
						{
							sampleCarriersUsed.AddAsLast(carrierName);
							sampleCarriersUsedDict.Add(carrierName, sampleCarriersUsed.GetSize() - 1);
							sampleCarrierPositionsUsed.AddAsLast(position);
							sampleCarrierLabwareIdsUsed.AddAsLast(labwareId);
						}
						else
						{
							foundAt = sampleCarriersUsedDict.Item(carrierName);
							positions = sampleCarrierPositionsUsed.ElementAt(foundAt);
							Split(positions, fieldDelimiter, substrings1);
							if (!FastLookup(substrings1, position, 0 /*index*/))
							{
								sampleCarrierPositionsUsed.SetAt(foundAt, sampleCarrierPositionsUsed.ElementAt(foundAt) + fieldDelimiter + position);
								sampleCarrierLabwareIdsUsed.SetAt(foundAt, sampleCarrierLabwareIdsUsed.ElementAt(foundAt) + fieldDelimiter + labwareId);
							}
						}
					//>> 20061026
					}
					//<< 20061026
				}
			}

			// Restore current position of full sample sequence
			fullSampleSequence.SetCurrentPosition(currentPosBck);

			// Check whether we found carriers containing required samples
			if ( (0 < carrierBarcodes.GetSize()) || (0 < unknownBarcodes.GetSize()) )
			{
				// We found carriers containing required samples
				
				// Write Required Sample Tubes Report 
				//WriteRequiredSampleTubesReport(ML_STAR, carrierNames, carrierBarcodes, labwareNames, labwarePositions);

				// Unload carriers containing required samples
				numberOfCarriers = sampleCarriersUnused.GetSize();
				for (i = 0; i < numberOfCarriers; i++)
				{

					// Unload carrier
					carrierName = sampleCarriersUnused.ElementAt(i);
					if ("" != carrierName)
					{
						// Carrier should be unloaded
						#ifdef _DEBUG
						FormatTrace("DEBUG", "ML_STAR.UnloadCarrier", TraceStatus::progress, "carrier = ", carrierName);
						#endif
						StepReturn::Empty(rc);
						onerror goto UnloadCarrierErrorHandler;
						rc = MlStarSteps::StepUnloadCarrier_cer(ML_STAR,
																carrierName,
																//ErrorHandling,
                                                ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, UnloadCarrierCustomStepID),
                                                UnloadCarrierCustomStepID,
																UserResponseTime);
						onerror goto 0;
						if (!StepReturn::Evaluate(ML_STAR, rc, ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, UnloadCarrierCustomStepID)))
							Error::RaiseLast();
						StepReturn::Empty(rc);
					}
				}

				// Show Required Sample Tubes Report 
				buttonClicked = ShowRequiredSampleTubesReport(carrierNames, carrierBarcodes, labwarePositions, unknownBarcodes);
				if (hslOK == buttonClicked)
				{
					// User confirmed unloading of required samples

					// setup name of barcode file
					if ("" == LoadCarrierBarcodeFileName)
					{
						// barcode file name has not been set by the user,
						// setup default barcode file name
						variable methodName;
						methodName = GetMethodFileName();
						if ("" == methodName)
						{
							methodName = GetWorkflowFileName();
						}
						i = StrReverseFind(methodName, ".");
						if (0 <= i)
							methodName = StrLeft(methodName, i);
						i = StrReverseFind(methodName, "\\");
						if (0 <= i)
							methodName = StrMid(methodName, i + 1, StrGetLength(methodName));
						LoadCarrierBarcodeFileName = GetLogFilesPath() + "\\" + methodName + StringConstants::barcodeFileExt;
					}

					//>> 20071017
					// if required, rescan autoload tray 
					if (scanAutoloadTray && 0 < unknownBarcodes.GetSize())
					{
						variable preloadedCarriers[];
						//variable carrierNames[];									// place to hold names of carriers which should be loaded
						variable carrierCalibrateFlags[];						// place to hold calibrate flag of carriers which should be unloaded/loaded
						//variable carrierBarcodeReadPositions[];				// place to hold barcode read positions of carriers which should be loaded
						variable carrierBarcodeReadLabwareNames[];			// place to hold the carrier barcode read labware names
						variable carrierBarcodeReadPositionNames[];			// place to hold the carrier barcode read position names
						variable carrierRecoveryOptionContinue[];				// place to hold visibility of recovery option Continue (0 = invisible, 1 = visible)
						variable carrierRecoveryOptionExclude[];				// place to hold visibility of recovery option Exclude (0 = invisible, 1 = visible)
						variable carrierRecoveryOptionDefault[];				// place to hold default of recovery options Continue and Exclude (0 = Continue, 1 = Exclude) 
						variable carrierKitLotCheckEnabled[];					// place to hold kit lot check enabled flag

						// detect preloaded carriers
						DetectPreloadedCarriers(ML_STAR, preloadedCarriers);

						// select preloaded carriers
                  carrierCalibrateFlags.SetSize(sampleCarriersUnused.GetSize());
                  carrierBarcodeReadLabwareNames.SetSize(sampleCarriersUnused.GetSize());
                  carrierBarcodeReadPositionNames.SetSize(sampleCarriersUnused.GetSize());
                  carrierRecoveryOptionContinue.SetSize(sampleCarriersUnused.GetSize());
                  carrierRecoveryOptionExclude.SetSize(sampleCarriersUnused.GetSize());
                  carrierRecoveryOptionDefault.SetSize(sampleCarriersUnused.GetSize());
                  carrierKitLotCheckEnabled.SetSize(sampleCarriersUnused.GetSize());
						SelectPreloadedCarriers(ML_STAR, preloadedCarriers,
														sampleCarriersUnused, carrierCalibrateFlags, sampleCarrierPositionsUnused, 
														carrierBarcodeReadLabwareNames, carrierBarcodeReadPositionNames,
														carrierRecoveryOptionContinue, carrierRecoveryOptionExclude, 
														carrierRecoveryOptionDefault, carrierKitLotCheckEnabled);
					}
					//<< 20071017

					// Load carriers that contained required samples
					numberOfCarriers = sampleCarriersUnused.GetSize();
					for (i = 0; i < numberOfCarriers; i++)
					{
						// Load carrier
						carrierName = sampleCarriersUnused.ElementAt(i);
						if ("" != carrierName)
						{
							variable positionsUsed("");

							// Carrier has been unloaded
							positions = sampleCarrierPositionsUnused.ElementAt(i);
							if (sampleCarriersUsedDict.Exists(carrierName))
							{
								foundAt = sampleCarriersUsedDict.Item(carrierName);
								positionsUsed = sampleCarrierPositionsUsed.ElementAt(foundAt);
							}
							Split(positionsUsed, fieldDelimiter, substrings1);
							Split(positions, fieldDelimiter, substrings2);
							size = substrings1.GetSize();
							for (j = 0; j < size; j++)
							{
								if (!FastLookup(substrings2, substrings1.ElementAt(j), 0 /*index*/))
								{
									if ("" != positions)
										positions = positions + fieldDelimiter;
									positions = positions + substrings1.ElementAt(j);
								}
							}

							// Load carrier.
							StepReturn::Empty(rc);
							onerror goto LoadCarrierErrorHandler;
							rc = MlStarSteps::StepLoadCarrierEx2_cer(ML_STAR,  // use ...Ex2() with special error settings for load and match
																	carrierName,
																	LoadCarrierBarcodeFileName,
                                                   // >> 20070702 (SCR#1121)
																	PTL_Util::CsvToDelimited2(ML_STAR, positions), // Load positions
                                                   // >> 20070702
																	1,					// Recovery option continue: 1 = visible
																	//>> 20061026
																	//0,				// Recovery option exclude:  0 = invisible
																	1,					// Recovery option exclude:  1 = invisible
																	//<< 20061026
																	0,					// Recovery option default:  0 = continue
																	//ErrorHandling,
                                                   ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, LoadCarrierCustomStepID),
                                                   LoadCarrierCustomStepID,
																	UserResponseTime);
							onerror goto 0;
							if (!StepReturn::Evaluate(ML_STAR, rc, ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, LoadCarrierCustomStepID)))
								Error::RaiseLast();
							// Check whether required positions have been loaded
							if (5 < rc.GetSize())
							{
								variable p(0);
								variable numberOfPositions(0);
								variable stepReturn3;				// step return 3 (string)
								variable stepReturn5;				// step return 3 (string)
								variable errorCode;					// error code (integer)

								StepReturn::SetBlockDelimiterEx(ML_STAR);
								StepReturn::SetFieldDelimiterEx(ML_STAR);

								stepReturn3 = rc.GetAt(3);
								stepReturn5 = rc.GetAt(5);

								Split(sampleCarrierPositionsUnused.ElementAt(i), fieldDelimiter, substrings1);
								numberOfPositions = StepReturn::GetNumberOfPositions(stepReturn3);
								for (p = 0; p  < numberOfPositions; p++)
								{
									variable pos("");
									variable labId("");
									variable posId("");
									variable mainError(0);
									variable recoveryButton(0);

									pos = StepReturn::GetPosition(p + 1, stepReturn3);
									labId = StepReturn::GetLabwareId(p + 1, stepReturn3);
									posId = StepReturn::GetPositionId(p + 1, stepReturn3);
									mainError = StepReturn::GetMainError(p + 1, stepReturn3);
									recoveryButton = StepReturn::GetRecoveryButton(p + 1, stepReturn3);

									// Check whether this position had an error and was excluded
									if (MainError::noError != mainError && RecoveryButton::exclude == recoveryButton)
									{
										// This position had an error and was excluded
										foundAt = loadedSampleSequence.LookupPosition(labId, posId, 1, hslTrue);
										while (0 < foundAt)
										{
											// Remove this position from sequence containing loaded samples
											loadedSampleSequence.RemoveAt(foundAt);
											foundAt = loadedSampleSequence.LookupPosition(labId, posId, 1, hslTrue);
										}
									}
									else
									{
										// Check whether this position was required
										if (FastLookup(substrings1, IStr(pos), 0 /*index*/))
										{
											// This position was required

											//>> 20061026
											// Check whether required position has been loaded successfully
											//if (MainError::noError != mainError && RecoveryButton::continue == recoveryButton)
											//{
											//	// This position had an error and was continued
											//	foundAt = loadedSampleSequence.LookupPosition(labId, posId, 1, hslTrue);
											//	while (0 < foundAt)
											//	{
											//		// Remove this position from sequence containing loaded samples
											//		loadedSampleSequence.RemoveAt(foundAt);
											//		foundAt = loadedSampleSequence.LookupPosition(labId, posId, 1, hslTrue);
											//	}
											//}
											//else
											//<< 20061026
											{
												if ("" != labId && "" != posId)
												{
													// A tube

													// Add this position to sequence containing loaded samples
													loadedSampleSequence.Add(labId, posId);
												}
												//>> 20061026
												else if ("" != labId && "" == posId)
												{
													// A plate

													// Add this position to sequence containing loaded samples
													currentPosBck = fullSampleSequence.GetCurrentPosition();
													for (currentPos = fullSampleSequence.SetCurrentPosition(1);
														  0 < currentPos;
														  currentPos = fullSampleSequence.Increment(1))
													{
														if (fullSampleSequence.GetLabwareId() == labId)
														{
															loadedSampleSequence.Add(labId, fullSampleSequence.GetPositionId());
														}
													}
													fullSampleSequence.SetCurrentPosition(currentPosBck);
												}
												//<< 20061026
											}
										}
									}
								}
							}
							StepReturn::Empty(rc);
						}
					}
				}
            else // the user pressed Cancel in the required sample tubes dialog
            {
				   Error::Raise(IDE::requiredSamplesDlgCancelled, GetFileName(), GetFunctionName(), GetLineNumber());
            }
			}

			return( labwarePositions.GetSize() + unknownBarcodes.GetSize() );

			Unexpected:
			{
				// Restore current position of input sequence
				if (0 <= currentPosBck)
					fullSampleSequence.SetCurrentPosition(currentPosBck);

				// Re-throw the error 
				Error::RaiseLast();
			}

			UnloadCarrierErrorHandler:
			{
				// bind error data
				StepReturn::Bind(rc);
				resume next;
			}

			LoadCarrierErrorHandler:
			{
				// bind error data
				StepReturn::Bind(rc);
				resume next;
			}
		}
/*
		static function UnassignNotLoadedSampleTubesFromJobs(
			device& ML_STAR,
			sequence& fullSampleSequence,
			sequence& loadedSampleSequence) variable
		{
			variable currentPos(-1);							// A current position
			variable currentPosBck(-1);						// Backup of current position of input sequence
			variable labwareId("");								// A labware id 
			variable positionId("");							// A position id
			variable deckID(0);
			variable elementID(0);
			variable parentElementID(0);
			variable numberOfUnassignedSampleTubes(0);
			object vectorDbTrackingObject;

			// Activate error handler
			onerror goto Unexpected;

			// Get VectorDb Tracking object
			vectorDbTrackingObject = GetVectorDbTrackerObject();

			// Get deck ID
			deckID = VectorDb_Deck::GetDeckID(ML_STAR.GetInstrumentName());

			// Backup current position of full sample sequence
			currentPosBck = fullSampleSequence.GetCurrentPosition();

			// Iterate over full sample sequence from position 1 to end position and collect positions of required samples 
			for (currentPos = fullSampleSequence.SetCurrentPosition(1);
				  0 < currentPos;
				  currentPos = fullSampleSequence.Increment(1))
			{
				// Get labware and position id of element at current position
				labwareId = fullSampleSequence.GetLabwareId();
				positionId = fullSampleSequence.GetPositionId();

				// Lookup element at current position in sequence containing loaded sample only
				if (0 == loadedSampleSequence.LookupPosition(labwareId, positionId, 1, hslTrue))
				{
					// Didn't found element at current position in sequence containing loaded sample only
					// -> unassign not loaded sample tube from jobs
					// Bemerkung: Funktion VectorDb_Labware::GetElementIDByCurrentPositionOfSequence wirft eine Exception falls 
					// Element nicht gegründet -> alte Funktion VectorDb_Labware::IsLabwareLoadedByLabwareIdPositionId beibehalten, 
					// ev. auf Tracking Objekt aufrufen
					//elementID = VectorDb_Labware::GetElementIDByCurrentPositionOfSequence(deckID, fullSampleSequence);
					elementID = vectorDbTrackingObject.IsLabwareLoadedByLabwareIdPositionId(deckID, labwareId, positionId);
					parentElementID = vectorDbTrackingObject.IsLabwareLoadedByLabwareIdPositionId(deckID, labwareId, "");
					if (0 < elementID && 0 < parentElementID)
					{
						//>> 20061026
						//variable grandParentElementID(0);
						//VectorDb_Labware::GetLabwareByElementID(parentElementID,
						//													0, // deckID,
						//													grandParentElementID,
						//													0, // positionId,
						//													0, // labwareLevel,
						//													0, // barcode,
						//													0, // volume,
						//													0, // labwareState,
						//													0, // userLabwareState,
						//													0, // deckCoordinateX,
						//													0, // deckCoordinateY,
						//													0, // deckCoordinateZ,
						//													0); // userLabwareTypeID);
						//if (0 == grandParentElementID)
						//<< 20061026
						{
							// A rack on the deck and not on a template
							vectorDbTrackingObject.UnassignLabwareFromJobs(elementID);
							numberOfUnassignedSampleTubes++;
						}
					}
				}
			}

			// Restore current position of full sample sequence
			fullSampleSequence.SetCurrentPosition(currentPosBck);

			return(numberOfUnassignedSampleTubes);

			Unexpected:
			{
				// Restore current position of input sequence
				if (0 <= currentPosBck)
					fullSampleSequence.SetCurrentPosition(currentPosBck);

				// Re-throw the error 
				Error::RaiseLast();
			}
		}
*/
		static function Load(
			device& ML_STAR,
			variable calibrateSequences,
			variable scanAutoloadTray,
			variable loadRequiredSampleTubes,
			variable unloadUnusedSampleTubes) variable[]
		{
			variable carrierNames[];									// place to hold names of carriers which should be loaded
			variable carrierCalibrateFlags[];						// place to hold calibrate flag of carriers which should be unloaded/loaded
			variable carrierBarcodeReadPositions[];				// place to hold barcode read positions of carriers which should be loaded
			variable carrierBarcodeReadLabwareNames[];			// place to hold the carrier barcode read labware names
			variable carrierBarcodeReadPositionNames[];			// place to hold the carrier barcode read position names
			variable carrierRecoveryOptionContinue[];				// place to hold visibility of recovery option Continue (0 = invisible, 1 = visible)
			variable carrierRecoveryOptionExclude[];				// place to hold visibility of recovery option Exclude (0 = invisible, 1 = visible)
			variable carrierRecoveryOptionDefault[];				// place to hold default of recovery options Continue and Exclude (0 = Continue, 1 = Exclude) 
			variable carrierKitLotCheckEnabled[];					// place to hold kit lot check enabled flag
			variable prepareLoadMode;									// prepare load mode (1 = prepare for reduce, 2 = prepare for load)
			variable numberOfCarriers;									// number of carrier names in carrierNames array
			variable numberOfSequences;								// number of sequences in sequenceObjArr array
			variable prompt("");											// user prompt
			variable index1(0);											// loop index
			variable index2(0);											// loop index
			variable index3(0);											// loop index
			variable carrier("");										// carrier name
			variable positions("");										// carrier barcode read positions
			variable labwareNames("");									// comma separated labware names
			variable positionNames("");								// comma separated position names
			variable qualifiedExcludePositions[];					// place to hold (qualified) positions of elements which should be excluded from the loading sequences
			variable unqualifiedExcludePositions[];				// place to hold (unqualified) positions of elements which should be excluded from the loading sequences
			variable excludeLabwareNames[];							// place to hold labware names of elements which should be excluded from the loading sequences
			variable excludePositionNames[];							// place to hold position names of elements which should be excluded from the loading sequences
			variable recoveryOptionContinue(hslTrue);				// visibility of recovery option Continue (0 = invisible, 1 = visible)
			variable recoveryOptionExclude(hslTrue);				// visibility of recovery option Continue (0 = invisible, 1 = visible)
			variable recoveryOptionDefault(0);						// default of recovery options Continue and Exclude (0 = Continue, 1 = Exclude) 
			variable kitLotCheckEnabled(hslFalse);					// kit lot check enabled flag
			variable expiredKitLots(hslTrue);						// expired kitlots flag
			variable expiredKitLotsStr("");							// list (csv) of expired kitlots, initial value must not be empty
			variable tipEjectChannelVariable("");					// channel pattern to eject tip used to calibrate carriers
			variable rc[];													// step return 
			variable current;												// current of a sequence
			variable first;												// first of a sequence
			variable last;													// last of a sequence
			variable count;												// count of a sequence
			variable total;												// total of a sequence
			variable size;													// array size
			sequence fullSeqObj;											// a full (reseted) sequence as known within decklayout
			sequence fullSampleSequence;								// full sample sequence

			// initialize sequences
			numberOfSequences = sequenceObjArr.GetSize();
			for (index1 = 0; index1 < numberOfSequences; index1++)
			{
				// if sequence is editable, restore original sequence from the deck layout definition file
				if (editableArr.GetAt(index1))
				{
					PCB::InitializeSequenceFromDeckLayout(ML_STAR, sequenceObjArr.ElementAt(index1));
				}
				else
				{
					total = sequenceObjArr[index1].GetTotal();
					sequenceObjArr[index1].SetCount(total);
					sequenceObjArr[index1].SetCurrentPosition(1);
					sequenceObjArr[index1].SetMax(total);
				}

				// update last position
				if (LoadingSequenceInitialization::reset == lastArr.GetAt(index1))
					lastArr.SetAt(index1, sequenceObjArr[index1].GetCount());

				// if tip counting is enabled, read the tip count 
				// from HxElementCounter database in the System directory
				if (ioTipCountArr.GetAt(index1))
				{
					// ube 2005-06-27 begin
					//TipCount::Read2(sequenceObjArr.ElementAt(index1), tipCountIdentifierArr.ElementAt(index1), ML_STAR);
					sequence copySequenceObj;
					
					copySequenceObj = sequenceObjArr.ElementAt(index1);
					
					TipCount::Read2(copySequenceObj, tipCountIdentifierArr.ElementAt(index1), ML_STAR);
					
					if( 0 == copySequenceObj.GetCurrentPosition() )
					{
						// sequence has no more positions -> reset from decklayout, otherwise no tips will be loaded
						if( !ML_STAR.CopyResetSequence(sequenceObjArr[index1].GetName(), sequenceObjArr.ElementAt(index1)) )
						{
							total = sequenceObjArr[index1].GetTotal();
							sequenceObjArr[index1].SetCount(total);
							sequenceObjArr[index1].SetCurrentPosition(1);
							sequenceObjArr[index1].SetMax(total);
						}

						resetSequenceFlagArr.SetAt(index1, hslTrue);
					}
					else
					{
						sequenceObjArr.SetAt(index1, copySequenceObj);
					}
					//end
				}

				// ube 2005-07-08 begin
				// Respect 'Start position' and 'Number of positions' as set within method (Load from Smart Step),
				// do not change anything if it's a local, dynamically created sequence (unknown by decklayout)
				if( ML_STAR.CopyResetSequence(sequenceObjArr[index1].GetName(), fullSeqObj) )
				{
					variable i, seqPos, startPos, lastPos, count;
					variable labId("");
					variable posId("");
					variable currentPosBak;
					sequence copySequenceObj;

					copySequenceObj = sequenceObjArr.ElementAt(index1);

					// Delete all positions out of copySequenceObj from first position of sequence and
					// start position as set within load step
					startPos = firstArr.ElementAt(index1);
					count = copySequenceObj.GetCount();

					// ube 2006-08-09
					//if(count > startPos)
					if(count >= startPos)
					// end
					{
						i = 1;
						while(i < startPos)
						{
							copySequenceObj.RemoveAt(1);
							i++;
						}
					}
					else // make sequence empty
					{
						while(0 != copySequenceObj.GetCount())
						{
							copySequenceObj.RemoveAt(1);
						}						
					}					

					// Delete all positions out of copySequenceObj found between last position of sequence and
					// number of positions as set within load step
					lastPos = lastArr.ElementAt(index1);
					
					while(count > lastPos)
					{
						copySequenceObj.RemoveAt(copySequenceObj.GetCount());
						count--;
					}
					
					// set current position
					if(copySequenceObj.GetCount() > 0)
						copySequenceObj.SetCurrentPosition(1);

					sequenceObjArr.SetAt(index1, copySequenceObj);
				}
				// end
			}

			// check wether we are loading for a subsequent match with a worklist
			if (loadRequiredSampleTubes)
			{
				// we are loading for a subsequent match with a worklist --> 
				// remember full sample sequence, so that we are able to detect when the user removes required positions 
				fullSampleSequence.CopySequence(sequenceObjArr.ElementAt(0));
			}

			if (!scanAutoloadTray)
			{
				// prepare for reduce of sequences
				prepareLoadMode = 1;											// prepare for reduce
				carrierNames.SetSize(0);
				carrierCalibrateFlags.SetSize(0);
				carrierBarcodeReadPositions.SetSize(0);
				carrierBarcodeReadLabwareNames.SetSize(0);
				carrierBarcodeReadPositionNames.SetSize(0);
				carrierRecoveryOptionContinue.SetSize(0);
				carrierRecoveryOptionExclude.SetSize(0);
				carrierRecoveryOptionDefault.SetSize(0);
				carrierKitLotCheckEnabled.SetSize(0);
				ML_STAR.RemoveSequences();
				prompt = StringTable::Load(IDS::loadSequencePrompt) + StringConstants::crlf;
				PrepareLoadOfSequences(	ML_STAR, calibrateSequences, prepareLoadMode, LCB::ErrorHandling,
												carrierNames, carrierCalibrateFlags, carrierBarcodeReadPositions, 
												carrierBarcodeReadLabwareNames, carrierBarcodeReadPositionNames,
												carrierRecoveryOptionContinue, carrierRecoveryOptionExclude, 
												carrierRecoveryOptionDefault, carrierKitLotCheckEnabled,
												prompt, hslFalse);		// 2005-07-11 cjoerg: don't warn, here we get data for unload

				// ask the user graphically to reduce the original sequence to the shape that should be loaded
				numberOfCarriers = carrierNames.GetSize();
				if (0 < numberOfCarriers)
				{
					ML_STAR.EditSequences(StringTable::Load(IDS::loadSequenceTitle), prompt, UserResponseTime,
											 	 Sound::GetSoundFile(PTL_Util::objHxServicesGeneralSettings2.HxServicesSoundEnum_soundLoading));
				}
			}

			// prepare load of sequences
			prepareLoadMode = 2;											// prepare for load
			carrierNames.SetSize(0);
			carrierCalibrateFlags.SetSize(0);
			carrierBarcodeReadPositions.SetSize(0);
			carrierBarcodeReadLabwareNames.SetSize(0);
			carrierBarcodeReadPositionNames.SetSize(0);
			carrierRecoveryOptionContinue.SetSize(0);
			carrierRecoveryOptionExclude.SetSize(0);
			carrierRecoveryOptionDefault.SetSize(0);
			carrierKitLotCheckEnabled.SetSize(0);
			ML_STAR.RemoveSequences();
			prompt = StringTable::Load(IDS::loadSequencePrompt) + StringConstants::crlf;
			PrepareLoadOfSequences(	ML_STAR, calibrateSequences, prepareLoadMode, LCB::ErrorHandling, 
											carrierNames, carrierCalibrateFlags, carrierBarcodeReadPositions, 
											carrierBarcodeReadLabwareNames, carrierBarcodeReadPositionNames,
											carrierRecoveryOptionContinue, carrierRecoveryOptionExclude, 
											carrierRecoveryOptionDefault, carrierKitLotCheckEnabled,
											prompt, hslTrue);		// 2005-07-11 cjoerg: warn if load settings are not for current task

			// write the tip count 
			numberOfSequences = sequenceObjArr.GetSize();
			for (index1 = 0; index1 < numberOfSequences; index1++)
			{
				// update indexes
				total = sequenceObjArr[index1].GetTotal();
				sequenceObjArr[index1].SetCount(total);
				sequenceObjArr[index1].SetCurrentPosition(1);
				sequenceObjArr[index1].SetMax(total);

				// if tip counting is enabled, write the tip count to 
				// the file HxElementCounter.mdb in the System directory
				if (ioTipCountArr.GetAt(index1))
				{
					// write the tip count 
					TipCount::Write2(sequenceObjArr.ElementAt(index1), tipCountIdentifierArr.ElementAt(index1), ML_STAR);
				}
			}

			// setup name of barcode file
			if ("" == LoadCarrierBarcodeFileName)
			{
				// barcode file name has not been set by the user,
				// setup default barcode file name
				variable methodName;
				methodName = GetMethodFileName();
				//>> 20060523
				if ("" == methodName)
				{
					methodName = GetWorkflowFileName();
				}
				//<< 20060523
				index1 = StrReverseFind(methodName, ".");
				if (0 <= index1)
					methodName = StrLeft(methodName, index1);
				index1 = StrReverseFind(methodName, "\\");
				if (0 <= index1)
					methodName = StrMid(methodName, index1 + 1, StrGetLength(methodName));
				LoadCarrierBarcodeFileName = GetLogFilesPath() + "\\" + methodName + StringConstants::barcodeFileExt;
			}

			// if required, scan autoload tray 
			if (scanAutoloadTray)
			{
				variable preloadedCarriers[];

				// detect preloaded carriers
				DetectPreloadedCarriers(ML_STAR, preloadedCarriers);

				// single out preloaded carriers
				SelectPreloadedCarriers(ML_STAR, preloadedCarriers,
												carrierNames, carrierCalibrateFlags, carrierBarcodeReadPositions, 
												carrierBarcodeReadLabwareNames, carrierBarcodeReadPositionNames,
												carrierRecoveryOptionContinue, carrierRecoveryOptionExclude, 
												carrierRecoveryOptionDefault, carrierKitLotCheckEnabled);
			}

			// load carriers
			numberOfCarriers = carrierNames.GetSize();
			for (index1 = 0; index1 < numberOfCarriers; index1++)
			{
				carrier = carrierNames.ElementAt(index1);
				positions = carrierBarcodeReadPositions.ElementAt(index1);
				labwareNames = carrierBarcodeReadLabwareNames.ElementAt(index1);
				positionNames = carrierBarcodeReadPositionNames.ElementAt(index1);
				if (ErrorHandling::continue == LCB::ErrorHandling)
				{
					recoveryOptionContinue = carrierRecoveryOptionContinue.ElementAt(index1);
					recoveryOptionExclude = carrierRecoveryOptionExclude.ElementAt(index1);
					recoveryOptionDefault = carrierRecoveryOptionDefault.ElementAt(index1);
					kitLotCheckEnabled = carrierKitLotCheckEnabled.ElementAt(index1);
				}
				else
				{
					recoveryOptionContinue = LCB::recoveryOptionContinueDefault;
					recoveryOptionExclude = LCB::recoveryOptionExcludeDefault;
					recoveryOptionDefault = LCB::recoveryOptionDefaultDefault;
					kitLotCheckEnabled = LCB::kitLotCheckEnabledDefault;
				}

				// if a kit lot expired, the carrier shall be unloaded and the user has to change the labware
				while (expiredKitLots)
				{

					// debug
					#ifdef _DEBUG
					FormatTrace("DEBUG", "ML_STAR.LoadCarrier", TraceStatus::progress, "carrier = ", carrier, ", positions = ", positions);
					FormatTrace("DEBUG", "ML_STAR.LoadCarrier", TraceStatus::progress, "labwareNames = ", labwareNames);
					FormatTrace("DEBUG", "ML_STAR.LoadCarrier", TraceStatus::progress, "positionNames = ", positionNames);
					FormatTrace("DEBUG", "ML_STAR.LoadCarrier", TraceStatus::progress, "recoveryOptionContinue = ", recoveryOptionContinue);
					FormatTrace("DEBUG", "ML_STAR.LoadCarrier", TraceStatus::progress, "recoveryOptionExclude = ", recoveryOptionExclude);
					if (0 == recoveryOptionDefault)
						FormatTrace("DEBUG", "ML_STAR.LoadCarrier", TraceStatus::progress, "recoveryOptionDefault = continue");
					else
						FormatTrace("DEBUG", "ML_STAR.LoadCarrier", TraceStatus::progress, "recoveryOptionDefault = exclude");
					FormatTrace("DEBUG", "ML_STAR.LoadCarrier", TraceStatus::progress, "kitLotCheckEnabled = ", kitLotCheckEnabled);
					#endif

					StepReturn::Empty(rc);
					qualifiedExcludePositions.SetSize(0);
					unqualifiedExcludePositions.SetSize(0);
					excludeLabwareNames.SetSize(0);
					excludePositionNames.SetSize(0);

					onerror goto LoadCarrierErrorHandler;
               if ( ! loadRequiredSampleTubes )
                  rc = MlStarSteps::StepLoadCarrierEx_cer(	ML_STAR,
   																carrier,
   																LoadCarrierBarcodeFileName,
   																//>> 20070702 (SCR#1121)
   																PTL_Util::CsvToDelimited2(ML_STAR, positions),
   																//<< 20070702
   																recoveryOptionContinue,
   																recoveryOptionExclude,
   																recoveryOptionDefault,
   																//LCB::ErrorHandling,
                                                   ErrorHandling::MapCustomStepErrorHandling(LCB::ErrorHandling, LoadCarrierCustomStepID),
                                                   LoadCarrierCustomStepID,
   																LCB::UserResponseTime);
               else
                  // use ...Ex2() with special error settings for load and match
                  rc = MlStarSteps::StepLoadCarrierEx2_cer(	ML_STAR,
   																carrier,
   																LoadCarrierBarcodeFileName,
   																//>> 20070702 (SCR#1121)
   																PTL_Util::CsvToDelimited2(ML_STAR, positions),
   																//<< 20070702
   																recoveryOptionContinue,
   																recoveryOptionExclude,
   																recoveryOptionDefault,
   																//LCB::ErrorHandling,
                                                   ErrorHandling::MapCustomStepErrorHandling(LCB::ErrorHandling, LoadCarrierCustomStepID),
                                                   LoadCarrierCustomStepID,
   																LCB::UserResponseTime);

					onerror goto 0;
					if (!StepReturn::Evaluate(ML_STAR, rc, ErrorHandling::MapCustomStepErrorHandling(LCB::ErrorHandling, LoadCarrierCustomStepID)))
						Error::RaiseLast();
					if (!StepReturn::EvaluateExx(ML_STAR, rc, ErrorHandling::MapCustomStepErrorHandling(LCB::ErrorHandling, LoadCarrierCustomStepID), 
														  positions, labwareNames, positionNames, 
														  qualifiedExcludePositions, excludeLabwareNames, excludePositionNames))
						Error::RaiseLast();

					// debug
					#ifdef _DEBUG
					{
					variable size(0);
					variable source;
					variable action;
					source = "DEBUG";
					action = GetFunctionName();
					size = excludeLabwareNames.GetSize();
					for (index2 = 0; index2 < size; index2++)
					{
						FormatTrace(source, action, TraceStatus::progress, "qualifiedExcludePositions[", index2, "] = ", qualifiedExcludePositions.ElementAt(index2));
						FormatTrace(source, action, TraceStatus::progress, "excludeLabwareNames[", index2, "] = ", excludeLabwareNames.ElementAt(index2));
						FormatTrace(source, action, TraceStatus::progress, "excludePositionNames[", index2, "] = ", excludePositionNames.ElementAt(index2));
					}
					}
					#endif

					// exclude positions from the sequences
					#ifdef _DEBUG
					Assert(excludeLabwareNames.GetSize() == excludePositionNames.GetSize(), GetFunctionName());
					Assert(excludeLabwareNames.GetSize() == qualifiedExcludePositions.GetSize(), GetFunctionName());
					#endif
					if (0 < excludeLabwareNames.GetSize())
					{
						for (index3 = 0; index3 < numberOfSequences; index3++)
						{
							variable sequenceObjExcludePos[];						// place to hold indexes of excluded sequence positions 
							variable sequenceObjCurrentInc[];						// place to hold increments of current position during sequence exclusion
							variable sequenceObjTrackLabIds[];						// place to hold labware ids of positions which have been excluded
							variable sequenceObjTrackPosIds[];						// place to hold position ids of positions which have been excluded
							variable volumes[];

							ExcludeSequencePositions(sequenceObjArr.ElementAt(index3), 
															 0, volumes, volumes,
															 1, 0,
															 excludeLabwareNames, excludePositionNames, 
															 volumes, volumes,
															 sequenceObjExcludePos, sequenceObjCurrentInc,
															 sequenceObjTrackLabIds, sequenceObjTrackPosIds);
						}
					}

					// process the string of (qualified) positions to be excluded 
					size = qualifiedExcludePositions.GetSize();
					for (index2 = 0; index2 < size; index2++)
					{
						string excludePosition("");	// position of element that should be excluded from the loading sequences
						excludePosition = qualifiedExcludePositions.ElementAt(index2);
						excludePosition = excludePosition.SpanExcluding(".");
						if (0 < excludePosition.GetLength())
						{
							// found a qualified position, e.g. 1.A1,
							// check if the corresponding labware id is still referenced in any of the loading sequences,
							// if not, the position can be removed from the string of positions 
							sequence tempSequence;			// a loading sequence
							variable excludeLabwareName;	// labware name of element that should be excluded from the loading sequences
							excludeLabwareName = excludeLabwareNames.ElementAt(index2);
							for (index3 = 0; index3 < numberOfSequences; index3++)
							{
								tempSequence = sequenceObjArr.ElementAt(index3);
								if (0 < tempSequence.LookupPosition(excludeLabwareName, "", 1, hslTrue))
									// the labware id is still referenced in this loading sequence
									break;
							}
							if (index3 == numberOfSequences)
							{
								// the labware id is not referenced in any of the loading sequences,
								// check if the (unqualified) position is already contained in the collection unqualifiedExcludePositions
								variable arrIndex;
								if (!PTL_Util::Lookup(unqualifiedExcludePositions, excludePosition, arrIndex))
									unqualifiedExcludePositions.AddAsLast(excludePosition);
							}
						}
						else
						{
							// found an unqualified position, e.g. A1,
							// add the position to the collection unqualifiedExcludePositions
							unqualifiedExcludePositions.AddAsLast(qualifiedExcludePositions.ElementAt(index2));
						}
					}

					// update string of positions according to the collection unqualifiedExcludePositions
					if (0 < unqualifiedExcludePositions.GetSize())
						ExcludePositions(positions, unqualifiedExcludePositions);

					// check kitlot
					if (kitLotCheckEnabled)
					{
						// check kitlot
						expiredKitLotsStr = CheckKitLot(qualifiedExcludePositions, rc);

						// if a kit lot expired, the carrier shall be unloaded and the user has to change the labware
						if ("" != expiredKitLotsStr)
						{
							// ba 20050511 begin (SCR#449)
							variable carrierType("");
							carrierType = PCB::GetCarrierType(ML_STAR, carrier);
							// ba 20050511 end (SCR#449)

							// show the user graphically the carriers that will be unloaded
							prompt = StringTable::Load(IDS::expiredKitLotPrompt) + expiredKitLotsStr + StringConstants::crlf;
							// ba 20050511 begin (SCR#449)
							//prompt = prompt + StringTable::Load(IDS::unloadSequencePrompt) + carrier;
							prompt = prompt + StringTable::Load(IDS::unloadSequencePrompt) + carrierType;
							// ba 20050511 end (SCR#449)
							ML_STAR.EditSequences(StringTable::Load(IDS::unloadSequenceTitle), prompt, LCB::UserResponseTime,
											 			 Sound::GetSoundFile(PTL_Util::objHxServicesGeneralSettings2.HxServicesSoundEnum_soundLoading));

							// unload carrier
							#ifdef _DEBUG
							FormatTrace("DEBUG", "ML_STAR.UnloadCarrier", TraceStatus::progress, "carrier = ", carrier);
							#endif

							StepReturn::Empty(rc);
							onerror goto UnloadCarrierErrorHandler;
							rc = MlStarSteps::StepUnloadCarrier_cer(	ML_STAR,
																		carrier,
																		//LCB::ErrorHandling,
                                                      ErrorHandling::MapCustomStepErrorHandling(LCB::ErrorHandling, UnloadCarrierCustomStepID),
                                                      UnloadCarrierCustomStepID,
																		LCB::UserResponseTime);
							onerror goto 0;
							if (!StepReturn::Evaluate(ML_STAR, rc, ErrorHandling::MapCustomStepErrorHandling(LCB::ErrorHandling, UnloadCarrierCustomStepID)))
								Error::RaiseLast();

							// ... ask the user if he wants to reload the carrier
							// ba 20050511 begin (SCR#449)
							//if (hslNo == LCB::AskUserForReload(expiredKitLotsStr, carrier, LCB::UserResponseTime))
							if (hslNo == LCB::AskUserForReload(expiredKitLotsStr, carrierType, LCB::UserResponseTime))
							// ba 20050511 end (SCR#449)
							{
								// user selected No button
								Error::Raise(IDE::loadingCanceled, GetFileName(), GetFunctionName(), GetLineNumber());
							}

							// show the user graphically the carriers that will be loaded
							prompt = StringTable::Load(IDS::expiredKitLotPrompt) + expiredKitLotsStr + StringConstants::crlf;
							// ba 20050511 begin (SCR#449)
							//prompt = prompt + StringTable::Load(IDS::loadSequencePrompt) + carrier;
							prompt = prompt + StringTable::Load(IDS::loadSequencePrompt) + carrierType;
							// ba 20050511 end (SCR#449)
							ML_STAR.EditSequences(StringTable::Load(IDS::loadSequenceTitle), prompt, LCB::UserResponseTime,
														 Sound::GetSoundFile(PTL_Util::objHxServicesGeneralSettings2.HxServicesSoundEnum_soundLoading));
						}
						else
						{
							expiredKitLots = hslFalse;
						}
					}
					else
					{
						expiredKitLots = hslFalse;
					}
				}
				expiredKitLots = hslTrue;
			}

			// load required sample tubes (always true if we are loading for a subsequent match with a worklist)
			while (loadRequiredSampleTubes)
			{
				variable deckID(0);

				// assign loaded labware to jobs
				deckID = VectorDb_Deck::GetDeckID(ML_STAR.GetInstrumentName());
				VectorDb_Labware::AssignLoadedLabwareToJobs(deckID);

				// Unassign not loaded sample tubes from jobs 
				// Remark: this is a workaround as long as the Microlab STAR and the VectorDb are not able to handle not loaded sample tubes correctly.
				//UnassignNotLoadedSampleTubesFromJobs(ML_STAR, fullSampleSequence, sequenceObjArr.ElementAt(0));

				// load required sample tubes
				loadRequiredSampleTubes = LoadRequiredSampleTubes(ML_STAR, scanAutoloadTray, fullSampleSequence, sequenceObjArr.ElementAt(0));
			}

			// unload unused sample tubes
			if (unloadUnusedSampleTubes)
			{
				variable deckID(0);

				// unload unused sample tubes
				UnloadUnusedSampleTubes(ML_STAR, fullSampleSequence, sequenceObjArr.ElementAt(0));

				// assign loaded labware to jobs
				deckID = VectorDb_Deck::GetDeckID(ML_STAR.GetInstrumentName());
				VectorDb_Labware::AssignLoadedLabwareToJobs(deckID);

				// Unassign not loaded sample tubes from jobs 
				// Remark: this is a workaround as long as the Microlab STAR and the VectorDb are not able to handle not loaded sample tubes correctly.
				//UnassignNotLoadedSampleTubesFromJobs(ML_STAR, fullSampleSequence, sequenceObjArr.ElementAt(0));
			}

			// select a channel for calibration
			if (0 == LCB::CalibrateCarrierChannel)
			{
				// channel for calibration has not been set by the user,
				// select the rightmost active channel as default channel for calibration
				if (0 < ML_STAR.GetCfgValueWithKey(MlStarCfgKey::numberOfChannels))
					LCB::CalibrateCarrierChannel = RightmostActiveChannel(TipPickupChannelVariable, tipEjectChannelVariable);
			}
			else
			{
				// channel for calibration has been set by the user,
				// select the this channel for calibration
				SelectChannelPattern(TipPickupChannelVariable, tipEjectChannelVariable, LCB::CalibrateCarrierChannel);
			}

			// calibrate carriers
			numberOfCarriers = carrierNames.GetSize();
			for (index1 = 0; index1 < numberOfCarriers; index1++)
			{
				if (carrierCalibrateFlags.GetAt(index1))
				{
					// carrier supports calibration and carrier should be calibrated,
					// calibrate carrier
					carrier = carrierNames.GetAt(index1);

					// debug
					#ifdef _DEBUG
					FormatTrace("DEBUG", "ML_STAR.Calibrate1536Plate", TraceStatus::progress, "carrier = ", carrier, ", channel = ", LCB::CalibrateCarrierChannel);
					#endif

					onerror goto Calibrate1536PlateErrorHandler;
					rc = MlStarSteps::StepCalibrate1536Plate_cer(ML_STAR,
																	carrier,
																	CalibrateCarrierChannel,
																	//LCB::ErrorHandling,
                                                   ErrorHandling::MapCustomStepErrorHandling(LCB::ErrorHandling, CalibrateCarrierCustomStepID),
                                                   CalibrateCarrierCustomStepID,
																	LCB::UserResponseTime);
					onerror goto 0;
					if (!StepReturn::Evaluate(ML_STAR, rc, ErrorHandling::MapCustomStepErrorHandling(LCB::ErrorHandling, CalibrateCarrierCustomStepID)))
						Error::RaiseLast();
				}
			}

			return(rc);

			LoadCarrierErrorHandler:
			{
				// bind error data
				StepReturn::Bind(rc);
				resume next;
			}

			Calibrate1536PlateErrorHandler:
			{
				// bind error data
				StepReturn::Bind(rc);
				resume next;
			}

			UnloadCarrierErrorHandler:
			{
				// bind error data
				StepReturn::Bind(rc);
				resume next;
			}
		}

		static function PrepareLoadOfSequences(
			device& ML_STAR,
			variable calibrateSequences, 
			variable prepareLoadMode,
			variable errorHandling,
			variable& carrierNames[],
			variable& carrierCalibrateFlags[],
			variable& carrierBarcodeReadPositions[],
			variable& carrierBarcodeReadLabwareNames[],
			variable& carrierBarcodeReadPositionNames[],
			variable& carrierRecoveryOptionContinue[],
			variable& carrierRecoveryOptionExclude[],
			variable& carrierRecoveryOptionDefault[],
			variable& carrierKitLotCheckEnabled[],
			variable& prompt,
			variable bWarnLoadSettingsNotForTask)		// added 2005-07-11 cjoerg
		{
			variable numberOfSequences;								// number of sequences in sequenceObjArr array
			variable index;												// loop counter
			variable size;													// size of carrierNames array
			variable current;												// current of a sequence
			variable first;												// first of a sequence
			variable last;													// last of a sequence
			variable count;												// count of a sequence
			variable total;												// total of a sequence
			variable addCurrentSequence(hslFalse);					// specifies whether to add the current sequence to the collection holding the editable sequences of the device
			variable editableByUser(hslFalse);						// specifies whether sequence editing by the user is enabled
			// ba 20050511 begin (SCR#449)
			variable carrierTypes[];									// place to hold carrier types from carrier names
			variable carrierCounts[];									// place to hold carrier counts of carrier types 
			variable carrierType;										// a carrier type
			variable foundAt(-1);										// search index
			// ba 20050511 end (SCR#449)

			// prepare load modes:
			// 0 = prepare for unload
			// 1 = prepare for reduce
			// 2 = prepare for load

			// add the current sequence to the collection holding the 
			// editable sequences of the device in prepare for reduce mode
			if (0 == prepareLoadMode || 1 == prepareLoadMode || 2 == prepareLoadMode)
				// prepare for reduce mode 
				addCurrentSequence = hslTrue;

			// enable sequence editing by the user in prepare for reduce mode
			if (1 == prepareLoadMode)
				// prepare for reduce mode
				editableByUser = hslTrue;

			// iterate over the sequences
			numberOfSequences = sequenceObjArr.GetSize();
			for (index = 0; index < numberOfSequences; index++)
			{
				// set the actual first and last position in the sequence
				current = sequenceObjArr[index].GetCurrentPosition();
				count = sequenceObjArr[index].GetCount();
				first = PTL_Util::Min(firstArr[index], count);
				first = PTL_Util::Max(1, first);
				if (ioTipCountArr.GetAt(index))
					first = PTL_Util::Max(first, current);
				last = PTL_Util::Min(lastArr[index], count);
				total = sequenceObjArr[index].GetTotal();
				sequenceObjArr[index].SetCount(total);

				// ba 2003-01-20 begin (SCR#330, set the original count to get the names of the carries to unload)
				if (0 == prepareLoadMode)
					// prepare for unload
					sequenceObjArr[index].SetCount(count);
				// end

				// get carrier names 
				PCB::GetCarrierNames(ML_STAR, sequenceObjArr.ElementAt(index), calibrateSequences, errorHandling,
											carrierNames, carrierCalibrateFlags, carrierBarcodeReadPositions, 
											carrierBarcodeReadLabwareNames, carrierBarcodeReadPositionNames,
											carrierRecoveryOptionContinue, carrierRecoveryOptionExclude, 
											carrierRecoveryOptionDefault, carrierKitLotCheckEnabled,
											bWarnLoadSettingsNotForTask);		// added 2005-07-11 cjoerg

				// ba 2003-01-20 begin (SCR#330, set the original count to get the names of the carries to unload)
				if (0 == prepareLoadMode)
					// prepare for unload
					sequenceObjArr[index].SetCount(total);
				// end

				// add the sequence to the collection holding the editable sequences of the device
				if (addCurrentSequence)
				{
					// ube 2005-06-27 begin
					//ML_STAR.AddSequence(	sequenceObjArr.ElementAt(index), hslFalse,
					//						first, last, editableByUser && editableArr.GetAt(index), "");
					sequence baseSequence;

					if(ML_STAR.CopyResetSequence(sequenceObjArr[index].GetName(), baseSequence))
					{
						if(resetSequenceFlagArr.GetAt(index))
						{
							// The sequence was read from HxElementCounter database as an empty sequence and therefore
							// already reseted to allow loading of all carriers underlying this "empty" sequence.
							// Set current and count to zero to have a proper support of EditSequence dialog (all positions grey)
							sequenceObjArr[index].SetCurrentPosition(0);
							sequenceObjArr[index].SetCount(0);

							resetSequenceFlagArr.SetAt(index, hslFalse);
						}

						ML_STAR.AddSequence2( sequenceObjArr.ElementAt(index), baseSequence,
												editableByUser && editableArr.GetAt(index));
					}
					else
					{
						ML_STAR.AddSequence(	sequenceObjArr.ElementAt(index), hslFalse,
												first, last, editableByUser && editableArr.GetAt(index), "");
					}
					// end
				}
			}

			// ba 20050511 begin (SCR#449)
			size = carrierNames.GetSize();
			for (index = 0; index < size; index++)
			{
				carrierType = PCB::GetCarrierType(ML_STAR, carrierNames.GetAt(index));
				if (!PTL_Util::Lookup(carrierTypes, carrierType, foundAt))
				{
					// didn't found current carrier type in collection holding carrier types
					// --> add carrier type
					carrierTypes.AddAsLast(carrierType);
					carrierCounts.AddAsLast(1);
				}
				else
				{
					// found current carrier type in collection holding carrier types
					// --> increment carrier count
					carrierCounts.SetAt(foundAt, carrierCounts.GetAt(foundAt) + 1);
				}
			}
	
			// add carrier types which should be loaded to user prompt
			size = carrierTypes.GetSize();
			for (index = 0; index < size; index++)
			{
				prompt = prompt + IStr(carrierCounts.GetAt(index)) + " " + carrierTypes.GetAt(index);
				if (0 == ((index + 1) % 4))
					prompt = prompt + StringConstants::crlf;
				else
				{
					if (index + 1 < size)
						prompt = prompt + StringConstants::csvDelimiter2;
				}
			}

			// add carrier names which should be loaded to user prompt
			//size = carrierNames.GetSize();
			//for (index = 0; index < size; index++)
			//{
			//	prompt = prompt + carrierNames.GetAt(index);
			//	if (0 == ((index + 1) % 4))
			//		prompt = prompt + StringConstants::crlf;
			//	else
			//	{
			//		if (index + 1 < size)
			//			prompt = prompt + StringConstants::csvDelimiter2;
			//	}
			//}
			// ba 20050511 end (SCR#449)

			return(hslTrue);
		}

		static function Unload(
			device& ML_STAR)
		{
			variable carrierNames[];									// place to hold names of carriers which should be loaded
			variable carrierCalibrateFlags[];						// place to hold calibrate flag of carriers which should be unloaded/loaded
			variable carrierBarcodeReadPositions[];				// place to hold barcode read of positions carriers which should be loaded
			variable carrierBarcodeReadLabwareNames[];			// place to hold the carrier barcode read labware names
			variable carrierBarcodeReadPositionNames[];			// place to hold the carrier barcode read position names
			variable carrierRecoveryOptionContinue[];				// place to hold visibility of recovery option Continue (0 = invisible, 1 = visible)
			variable carrierRecoveryOptionExclude[];				// place to hold visibility of recovery option Exclude (0 = invisible, 1 = visible)
			variable carrierRecoveryOptionDefault[];				// place to hold default of recovery options Continue and Exclude (0 = Continue, 1 = Exclude) 
			variable carrierKitLotCheckEnabled[];					// place to hold kit lot check enabled flag
			variable prepareUnloadMode;								// prepare unload mode (1 = prepare for reduce, 2 = prepare for unload)
			variable numberOfCarriers;									// number of carrier names in carrierNames array
			variable numberOfSequences;								// number of sequences in sequenceObjArr array
			variable prompt("");											// user prompt
			variable index;												// loop counter
			variable carrier("");										// carrier name
			variable rc[];													// step return 

			// if tip counting is enabled, write the tip count 
			numberOfSequences = sequenceObjArr.GetSize();
			for (index = 0; index < numberOfSequences; index++)
			{
				if (ioTipCountArr.GetAt(index))
					TipCount::Write2(sequenceObjArr.ElementAt(index), tipCountIdentifierArr.ElementAt(index), ML_STAR);
			}

			// prepare for unload of sequences
			prepareUnloadMode = 0;											// prepare for unload
			carrierNames.SetSize(0);
			carrierCalibrateFlags.SetSize(0);
			carrierBarcodeReadPositions.SetSize(0);
			carrierBarcodeReadLabwareNames.SetSize(0);
			carrierBarcodeReadPositionNames.SetSize(0);
			carrierRecoveryOptionContinue.SetSize(0);
			carrierRecoveryOptionExclude.SetSize(0);
			carrierRecoveryOptionDefault.SetSize(0);
			carrierKitLotCheckEnabled.SetSize(0);
			ML_STAR.RemoveSequences();
			prompt = StringTable::Load(IDS::unloadSequencePrompt) + StringConstants::crlf;
			PrepareLoadOfSequences(	ML_STAR, hslFalse, prepareUnloadMode, UCB::ErrorHandling, 
											carrierNames, carrierCalibrateFlags, carrierBarcodeReadPositions, 
											carrierBarcodeReadLabwareNames, carrierBarcodeReadPositionNames,
											carrierRecoveryOptionContinue, carrierRecoveryOptionExclude, 
											carrierRecoveryOptionDefault, carrierKitLotCheckEnabled,
											prompt, hslFalse);		// 2005-07-11 cjoerg: don't warn if load settings not for current task. We are unloading here.

			// show the user graphically the sequences that will be unloaded
			numberOfCarriers = carrierNames.GetSize();
			if (0 < numberOfCarriers)
			{
				ML_STAR.EditSequences(StringTable::Load(IDS::unloadSequenceTitle), prompt, UCB::UserResponseTime,
											 Sound::GetSoundFile(PTL_Util::objHxServicesGeneralSettings2.HxServicesSoundEnum_soundLoading));
			}

			// unload carriers
			numberOfCarriers = carrierNames.GetSize();
			for (index = 0; index < numberOfCarriers; index++)
			{
				carrier = carrierNames.GetAt(index);

				// debug
				#ifdef _DEBUG
				FormatTrace("DEBUG", "ML_STAR.UnloadCarrier", TraceStatus::progress, "carrier = ", carrier);
				#endif

				onerror goto UnloadCarrierErrorHandler;
				rc = MlStarSteps::StepUnloadCarrier_cer(	ML_STAR,
															carrier,
															//UCB::ErrorHandling,
                                             ErrorHandling::MapCustomStepErrorHandling(UCB::ErrorHandling, UnloadCarrierCustomStepID),
                                             UnloadCarrierCustomStepID,
															UCB::UserResponseTime);
				onerror goto 0;
				if (!StepReturn::Evaluate(ML_STAR, rc, ErrorHandling::MapCustomStepErrorHandling(UCB::ErrorHandling, UnloadCarrierCustomStepID)))
					Error::RaiseLast();
			}

			// state that the sequence has been unloaded
			numberOfSequences = sequenceObjArr.GetSize();
			for (index = 0; index < numberOfSequences; index++)
				sequenceObjArr[index].SetCount(0);

			return(rc);

			UnloadCarrierErrorHandler:
			{
				// bind error data
				StepReturn::Bind(rc);
				resume next;
			}
		}

		static function DumpSequences()
		{
			#ifdef _DEBUG
			variable index;												// array index
			variable size;													// array size
			variable currentPos(0);										// current position
			variable currentPosBak(0);									// backup of inital current position
			variable source;
			variable action;
			source = "DEBUG";
			action = GetFunctionName();

			size = sequenceObjArr.GetSize();
			for (index = 0; index < size; index++)
			{
				// backup current position
				currentPosBak = sequenceObjArr[index].GetCurrentPosition();

				// dump
				FormatTrace(source, action, TraceStatus::progress, "name = ", sequenceObjArr[index].GetName());
				FormatTrace(source, action, TraceStatus::progress, "current = ", sequenceObjArr[index].GetCurrentPosition());
				FormatTrace(source, action, TraceStatus::progress, "count = ", sequenceObjArr[index].GetCount());
				FormatTrace(source, action, TraceStatus::progress, "total = ", sequenceObjArr[index].GetTotal());
				FormatTrace(source, action, TraceStatus::progress, "maxPos = ", sequenceObjArr[index].GetMax());
				for (currentPos = sequenceObjArr[index].SetCurrentPosition(1); 
					  currentPos != 0; 
					  currentPos = sequenceObjArr[index].Increment(1))
					 FormatTrace(source, action, TraceStatus::progress, 
									"labwareId = ", sequenceObjArr[index].GetLabwareId(), ", positionId = ", sequenceObjArr[index].GetPositionId());

				// restore current position
				sequenceObjArr[index].SetCurrentPosition(currentPosBak);
			}

			#endif
		}

		static function Dump()
		{
			#ifdef _DEBUG
			variable size;
			variable index;
			variable source;
			variable action;

			source = "DEBUG";
			action = GetFunctionName();

			// general settings 
			FormatTrace(source, action, TraceStatus::progress, "UserResponseTime = ", UserResponseTime);
			FormatTrace(source, action, TraceStatus::progress, "ErrorHandling = ", ErrorHandling);
         FormatTrace(source, action, TraceStatus::progress, "InitializeCustomStepID = ", InitializeCustomStepID);
         FormatTrace(source, action, TraceStatus::progress, "LoadCarrierCustomStepID = ", LoadCarrierCustomStepID);
         FormatTrace(source, action, TraceStatus::progress, "CalibrateCarrierCustomStepID = ", CalibrateCarrierCustomStepID);

			// calibrate carrier settings
			FormatTrace(source, action, TraceStatus::progress, "CalibrateCarrierChannel = ", CalibrateCarrierChannel);

			// default loading settings 
			FormatTrace(source, action, TraceStatus::progress, "recoveryOptionContinueDefault = ", recoveryOptionContinueDefault);
			FormatTrace(source, action, TraceStatus::progress, "recoveryOptionExcludeDefault = ", recoveryOptionExcludeDefault);
			FormatTrace(source, action, TraceStatus::progress, "recoveryOptionDefaultDefault = ", recoveryOptionDefaultDefault);
			FormatTrace(source, action, TraceStatus::progress, "kitLotCheckEnabledDefault = ", kitLotCheckEnabledDefault);

			// activate error handler
			onerror goto Unexpected;

			// get access to global data
			SynEnterCriticalSection(ptlCs);

			// advanced load settings 
			size = ptlLcbInstrumentIdArr.GetSize();

			Assert(ptlLcbTaskIdArr.GetSize() == size, GetFunctionName());		// 20050704 cjoerg: added
			Assert(ptlLcbSequenceIdArr.GetSize() == size, GetFunctionName());
			Assert(ptlLcbRecoveryOptionContinueArr.GetSize() == size, GetFunctionName());
			Assert(ptlLcbRecoveryOptionExcludeArr.GetSize() == size, GetFunctionName());
			Assert(ptlLcbRecoveryOptionDefaultArr.GetSize() == size, GetFunctionName());
			Assert(ptlLcbKitLotCheckEnabledArr.GetSize() == size, GetFunctionName());

			for (index = 0; index < size; index++)
			{
				FormatTrace(source, action, TraceStatus::progress, "instrumentId[", index, "] = ", ptlLcbInstrumentIdArr.GetAt(index));
				FormatTrace(source, action, TraceStatus::progress, "taskID[", index, "] = ", ptlLcbTaskIdArr.GetAt(index)); 		// 20050704 cjoerg: added
				FormatTrace(source, action, TraceStatus::progress, "sequenceId[", index, "] = ", ptlLcbSequenceIdArr.GetAt(index));
				FormatTrace(source, action, TraceStatus::progress, "recoveryOptionContinue[", index, "] = ", ptlLcbRecoveryOptionContinueArr.GetAt(index));
				FormatTrace(source, action, TraceStatus::progress, "recoveryOptionExclude[", index, "] = ", ptlLcbRecoveryOptionExcludeArr.GetAt(index));
				FormatTrace(source, action, TraceStatus::progress, "recoveryOptionDefault[", index, "] = ", ptlLcbRecoveryOptionDefaultArr.GetAt(index));
				FormatTrace(source, action, TraceStatus::progress, "kitLotCheckEnabled[", index, "] = ", ptlLcbKitLotCheckEnabledArr.GetAt(index));
			}

			size = sequenceObjArr.GetSize();

			Assert(sequenceObjCopyArr.GetSize() == size, GetFunctionName());
			Assert(firstArr.GetSize() == size, GetFunctionName());
			Assert(lastArr.GetSize() == size, GetFunctionName());
			Assert(editableArr.GetSize() == size, GetFunctionName());
			Assert(ioTipCountArr.GetSize() == size, GetFunctionName());
			Assert(tipCountIdentifierArr.GetSize() == size, GetFunctionName());

			for (index = 0; index < size; index++)
			{
				FormatTrace(source, action, TraceStatus::progress, "sequenceObj[", index, "] = ", sequenceObjArr.GetAt(index));
				FormatTrace(source, action, TraceStatus::progress, "sequenceObjCopy[", index, "] = ", sequenceObjCopyArr.GetAt(index));
				FormatTrace(source, action, TraceStatus::progress, "first[", index, "] = ", firstArr.GetAt(index));
				FormatTrace(source, action, TraceStatus::progress, "last[", index, "] = ", lastArr.GetAt(index));
				FormatTrace(source, action, TraceStatus::progress, "editable[", index, "] = ", editableArr.GetAt(index));
				FormatTrace(source, action, TraceStatus::progress, "ioTipCount[", index, "] = ", ioTipCountArr.GetAt(index));
				FormatTrace(source, action, TraceStatus::progress, "tipCountIdentifier[", index, "] = ", tipCountIdentifierArr.GetAt(index));
			}

			// release access to global data
			SynLeaveCriticalSection(ptlCs);

			return;

			Unexpected:
			{
				// release access to global data
				SynLeaveCriticalSection(ptlCs);
				Error::RaiseLast();
			}

			#endif
		}

		static function Init()
		{
			// data
			sequenceObjArr.SetSize(0);
			sequenceObjCopyArr.SetSize(0);
			firstArr.SetSize(0);
			lastArr.SetSize(0);
			editableArr.SetSize(0);
			ioTipCountArr.SetSize(0);
			tipCountIdentifierArr.SetSize(0);

			// general settings 

			LCB::UserResponseTime = Limits::maxTimeInterval;					// user response time [s]
			LCB::ErrorHandling = ErrorHandling::continue;						// error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue, 4 = custom)
			LCB::CalibrateCarrierChannel = 0;										// calibrate carrier channel, defaults to rightmost active channel
         LCB::InitializeCustomStepID = CustomStepID::stepErrorHandlingDefault;
         LCB::LoadCarrierCustomStepID = CustomStepID::stepErrorHandlingDefault;
         LCB::CalibrateCarrierCustomStepID = CustomStepID::stepErrorHandlingDefault;

			return(hslTrue);
		}

		static function InitEx(
			device& ML_STAR,
			sequence& sequenceObj)
		{
			variable index;												// loop counter
			variable size;													// array size
			variable instrumentId("");									// instrument id
			variable sequenceId("");									// sequence id

			// get instrument name 
			instrumentId = ML_STAR.GetInstrumentName();

			// get sequence name 
			sequenceId = sequenceObj.GetName();

			// activate error handler
			onerror goto Unexpected;

			// get access to global data
			SynEnterCriticalSection(ptlCs);

			// verify array sizes
			size = ptlLcbInstrumentIdArr.GetSize();
			#ifdef _DEBUG
			Assert(ptlLcbTaskIdArr.GetSize() == size, GetFunctionName());		// 20050704 cjoerg: added
			Assert(ptlLcbSequenceIdArr.GetSize() == size, GetFunctionName());
			Assert(ptlLcbRecoveryOptionContinueArr.GetSize() == size, GetFunctionName());
			Assert(ptlLcbRecoveryOptionExcludeArr.GetSize() == size, GetFunctionName());
			Assert(ptlLcbRecoveryOptionDefaultArr.GetSize() == size, GetFunctionName());
			Assert(ptlLcbKitLotCheckEnabledArr.GetSize() == size, GetFunctionName());
			#endif

			// iterate over instrument sequence pairs
			for (index = 0; index < size; index++)
			{
				if (ptlLcbInstrumentIdArr.GetAt(index) == instrumentId && 
					ptlLcbSequenceIdArr.GetAt(index) == sequenceId)
					// found a matching instrument sequence pair
					break;
			}
			if (index < size  && 0 < size)
			{
				// found a matching instrument sequence pair,
				// reset state of instrument sequence pair
				ptlLcbTaskIdArr.SetAt(index, 0);		// 20050704 cjoerg: added, init with zero to work if not scheduled
				ptlLcbRecoveryOptionContinueArr.SetAt(index, recoveryOptionContinueDefault);
				ptlLcbRecoveryOptionExcludeArr.SetAt(index, recoveryOptionExcludeDefault);
				ptlLcbRecoveryOptionDefaultArr.SetAt(index, recoveryOptionDefaultDefault);
				ptlLcbKitLotCheckEnabledArr.SetAt(index, kitLotCheckEnabledDefault);
			}

			// release access to global data
			SynLeaveCriticalSection(ptlCs);

			return(hslTrue);

			Unexpected:
			{
				// release access to global data
				SynLeaveCriticalSection(ptlCs);
				Error::RaiseLast();
			}
		}

		static function CheckKitLot(
			variable& qualifiedExcludePositions[],
			variable& rc[])
		{
			variable kitLotJoker;						// kit lot joker
			variable numberOfPositions1(0);			// number of positions in step return
			variable numberOfPositions2(0);			// number of positions in step return
			variable index1;								// a loop index
			variable index2;								// a loop index
			variable arrIndex;							// an array index
			variable position1;							// position (integer)
			variable position2;							// position (integer)
			variable barcodeValues[];					// barcode values (strings)
			variable barcodeMasks[];					// barcode masks (strings)
			variable barcodePositions[];				// barcode positions (strings)
			variable barcodePosition;					// a barcode position (string)
			variable rc3;									// step return 3
			variable rc4;									// step return 4
			variable rc5;									// step return 5
			variable barcodeValue;						// barcode value (string)
			variable barcodeMask;						// barcode mask (string)
			variable expiredKitLots("");				// list (csv) of expired kitlots
			variable status;								// status of kit lot check

			#ifdef _DEBUG
			variable source;
			variable action;
			source = "DEBUG";
			action = GetFunctionName();
			#endif

			kitLotJoker = GetBarcodeJoker(StringConstants::kitLotJokerKey);

			// iterate over positons
			if (5 < rc.GetSize())
			{
				rc3 = rc.ElementAt(3);
				rc4 = rc.ElementAt(4);
				rc5 = rc.ElementAt(5);
				numberOfPositions1 = StepReturn::GetNumberOfPositions(rc5);
				for (index1 = 0; index1 < numberOfPositions1; index1++)
				{
					position1 = StepReturn::GetPosition(index1 + 1, rc5);
					barcodePosition = StepReturn::GetBarcodePosition(index1 + 1, rc5);

					// check if the position has not been excluded
					if (!PTL_Util::Lookup(qualifiedExcludePositions, barcodePosition, arrIndex))
					{
						// the position has not been excluded,
						// add position to barcode positions
						barcodePositions.AddAsLast(barcodePosition);

						// search corresponding barcode mask
						numberOfPositions2 = StepReturn::GetNumberOfPositions(rc4);
						for (index2 = 0; index2 < numberOfPositions2; index2++)
						{
							position2 = StepReturn::GetPosition(index2 + 1, rc4);
							if (position1 == position2)
							{
								barcodeMasks.AddAsLast(StepReturn::GetBarcodeMask(index2 + 1, rc4));
								break;
							}
						}
						if (index2 == numberOfPositions2)
							barcodeMasks.AddAsLast("");

						// search corresponding barcode value
						numberOfPositions2 = StepReturn::GetNumberOfPositions(rc3);
						for (index2 = 0; index2 < numberOfPositions2; index2++)
						{
							position2 = StepReturn::GetPosition(index2 + 1, rc3);
							if (position1 == position2)
							{
								barcodeValues.AddAsLast(StepReturn::GetBarcode(index2 + 1, rc3));
								break;
							}
						}
						if (index2 == numberOfPositions2)
							barcodeValues.AddAsLast("");

						#ifdef _DEBUG
						FormatTrace(source, action, TraceStatus::progress, "barcodePositions[", barcodePositions.GetSize() - 1, "] = ", barcodePositions.ElementAt(barcodePositions.GetSize() - 1));
						FormatTrace(source, action, TraceStatus::progress, "barcodeMasks[", barcodeMasks.GetSize() - 1, "] = ", barcodeMasks.ElementAt(barcodeMasks.GetSize() - 1));
						FormatTrace(source, action, TraceStatus::progress, "barcodeValues[", barcodeValues.GetSize() - 1, "] = ", barcodeValues.ElementAt(barcodeValues.GetSize() - 1));
						#endif
					}
				}
			}

			numberOfPositions1 = barcodeValues.GetSize();
			for (index1 = 0; index1 < numberOfPositions1; index1++)
			{
				barcodeMask = barcodeMasks.ElementAt(index1);
				barcodeValue = barcodeValues.ElementAt(index1);
				// ba 2002-04-08 begin (SCR#361)
				HSLKitLot::SetAccessRepetition(Limits::maxKitLotOpenRetries);
				// end
				status = HSLKitLot::CheckKitlot(barcodeMask, barcodeValue);

				#ifdef _DEBUG
				FormatTrace(source, action, TraceStatus::progress, "status[", index1, "] = ", status);
				#endif

				// switch over status 
				if (-1 == status)
				{
					// no kit lot in barcode mask
					variable errorDesc;
					errorDesc = StringTable::Load(IDE::noKitLotInBarcodeMask);
					StrReplace(errorDesc, "%s", barcodeMask);
					Error::RaiseEx(IDE::noKitLotInBarcodeMask, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				}
				if (-2 == status)
				{
					// invalid barcode value or barcode mask
					variable errorDesc;
					errorDesc = StringTable::Load(IDE::invalidBarcodeValueOrBarcodeMask);
					StrReplace(errorDesc, "%s1", barcodeValue);
					StrReplace(errorDesc, "%s2", barcodeMask);
					Error::RaiseEx(IDE::invalidBarcodeValueOrBarcodeMask, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				}
				if (-3 == status)
				{
					// kit lot not defined
					variable errorDesc;
					errorDesc = StringTable::Load(IDE::kitLotNotDefined);
					StrReplace(errorDesc, "%s", HSLKitLot::SplitBarcode(barcodeMask, kitLotJoker, barcodeValue));
					Error::RaiseEx(IDE::kitLotNotDefined, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				}
				if (-4 == status)
				{
					// kit lot expired
					if ("" != expiredKitLots)
						 expiredKitLots = expiredKitLots + StringConstants::csvDelimiter2;
					expiredKitLots = expiredKitLots + HSLKitLot::SplitBarcode(barcodeMask, kitLotJoker, barcodeValue);
				}
				// ba 2002-04-08 begin (SCR#361)
				if (-5 == status)
				{
					// kit lot file not found
					variable errorDesc;
					errorDesc = StringTable::Load(IDE::kitLotFileNotFound);
					StrReplace(errorDesc, "%s", GetSystemPath() + "\\" + StringConstants::kitLotFileName);
					Error::RaiseEx(IDE::kitLotFileNotFound, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				}
				// end
			}

			#ifdef _DEBUG
			FormatTrace(source, action, TraceStatus::progress, "expiredKitLots = ", expiredKitLots);
			#endif
			return(expiredKitLots);
		}

		static function AskUserForReload(
			variable& expiredKitLots,
			variable& carrierName,
			variable& userResponseTime)
		{
			// 20050629 cjoerg: show modeless dialog instead of modal MessageBox;
			dialog dlg;
			variable retVal;
			dlg.SetOutput(StringTable::Load(IDS::expiredKitLotPrompt), expiredKitLots, 
							  StringTable::Load(IDS::askUserForReloadText2), " '", carrierName, "' ", StringTable::Load(IDS::questionMark));

			if ( 0 != userResponseTime )
				Sound::Play(PTL_Util::objHxServicesGeneralSettings2.HxServicesSoundEnum_soundQuestion);
			retVal = dlg.ShowOutput(StringTable::Load(IDS::askUserForReloadTitle), 
											hslQuestion	| hslYesNo|hslDefButton1, 
											userResponseTime);
			Sound::Stop();

			return (retVal);

			//return(MessageBox(StringTable::Load(IDS::expiredKitLotPrompt) + expiredKitLots + 
			//						StringTable::Load(IDS::askUserForReloadText2) + " '" + carrierName + "' " + StringTable::Load(IDS::questionMark), 
			//						StringTable::Load(IDS::askUserForReloadTitle), 
			//						hslQuestion	|hslYesNo|hslDefButton1, 
			//						userResponseTime));
		}

		//>> 20070702 (SCR#1121)
/*		static function IsNoReadBarcode(
			device& ML_STAR,
			variable carrierName)
		{
			variable propertyKeys[];
			variable propertyValues[];
			variable propertyValue("0");
			variable isNoReadBarcode(hslFalse);

			propertyKeys.AddAsLast(StringConstants::carNoReadBarcode);

			// check if barcodes of given labware are readable
			ML_STAR.GetLabwareData(carrierName, propertyKeys, propertyValues);
			if (0 < propertyValues.GetSize())
			{
				// found a labware supporting key MlStarCarNoReadBarcode
				propertyValue = propertyValues.GetAt(0);
				isNoReadBarcode = ("1" == propertyValue);
			}
			return(isNoReadBarcode);
		}
		//<< 20070702
*/
	}

	namespace UCB
	{

		static function GetState(
			variable& ucbKey,
			variable& ucbValue)
		{
			// initialize output
			ucbValue = 0;
			
			// get value for unloading control key,
			// switch over UCB entries

			// general settings
			if (ucbKey == "UserResponseTime")
			{
				ucbValue = UserResponseTime;
				return(hslTrue);
			}
			if (ucbKey == "ErrorHandling")
			{
				ucbValue = ErrorHandling;
				return(hslTrue);
			}
			if (ucbKey == "InitializeCustomStepID")
			{
				ucbValue = InitializeCustomStepID;
				return(hslTrue);
			}
			if (ucbKey == "UnloadCarrierCustomStepID")
			{
				ucbValue = UnloadCarrierCustomStepID;
				return(hslTrue);
			}

			// unknown ucbKey
			Error::Raise(IDE::invalidUCBKey, GetFileName(), GetFunctionName(), GetLineNumber());

			return(hslFalse);
		}

		static function SetState(
			variable& ucbKey,
			variable& ucbValue)
		{
			// set value for unloading control key,
			// switch over UCB entries

			// general settings 
			if (ucbKey == "UserResponseTime")
			{
				// check ucbValue to be valid
				if (!PTL_Util::IsNumber(ucbValue))
					Error::Raise(IDE::invalidUCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(ucbValue))
					Error::Raise(IDE::invalidUCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set ucbValue 
				if (Limits::maxTimeInterval < ucbValue)
					UCB::UserResponseTime = Limits::maxTimeInterval;
				else
					UCB::UserResponseTime = ucbValue;
				if (!PTL_Util::IsInteger(UCB::UserResponseTime))
					Error::Raise(IDE::invalidUCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				return(hslTrue);
			}
			if (ucbKey == "ErrorHandling")
			{
				// check ucbValue to be valid
				if (!PTL_Util::IsNumber(ucbValue))
					Error::Raise(IDE::invalidErrorHandling, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(ucbValue))
					Error::Raise(IDE::invalidErrorHandling, GetFileName(), GetFunctionName(), GetLineNumber());
				if (ucbValue < ErrorHandling::first || ErrorHandling::last < ucbValue)
					Error::Raise(IDE::invalidErrorHandling, GetFileName(), GetFunctionName(), GetLineNumber());

				// set ucbValue 
				UCB::ErrorHandling = ucbValue;
				return(hslTrue);
			}
			if (ucbKey == "InitializeCustomStepID")
			{
				// check ucbValue to be valid
				if (!PTL_Util::IsInteger(ucbValue))
					Error::Raise(IDE::invalidUCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set ucbValue 
				UCB::InitializeCustomStepID = ucbValue;
				return(hslTrue);
			}
			if (ucbKey == "UnloadCarrierCustomStepID")
			{
				// check ucbValue to be valid
				if (!PTL_Util::IsInteger(ucbValue))
					Error::Raise(IDE::invalidUCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set ucbValue 
				UCB::UnloadCarrierCustomStepID = ucbValue;
				return(hslTrue);
			}

			// unknown lcbKey
			Error::Raise(IDE::invalidUCBKey, GetFileName(), GetFunctionName(), GetLineNumber());

			return(hslFalse);
		}

		static function Init()
		{
			// data (shared)
			LCB::sequenceObjArr.SetSize(0);
			LCB::sequenceObjCopyArr.SetSize(0);
			LCB::firstArr.SetSize(0);
			LCB::lastArr.SetSize(0);
			LCB::editableArr.SetSize(0);
			LCB::ioTipCountArr.SetSize(0);
			LCB::tipCountIdentifierArr.SetSize(0);

			// general settings 

			UCB::UserResponseTime = Limits::maxTimeInterval;							// user response time [s]
			UCB::ErrorHandling = ErrorHandling::continue;								// error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue, 4 = custom)
         UCB::InitializeCustomStepID = CustomStepID::stepErrorHandlingDefault;
         UCB::UnloadCarrierCustomStepID = CustomStepID::stepErrorHandlingDefault;

			return(hslTrue);
		}
	}
	
	// --------------------------------------------------------------------------------------
	// Washing (part II)
	// --------------------------------------------------------------------------------------

	namespace WCB
	{

		static function GetState(
			device& ML_STAR,
			sequence& washSequence,
			variable firstOnly,
			variable& wcbKey,
			variable& wcbValue[],
			variable& wcbLabId[])
		{
			variable labwareIds[];										// place to hold unique labware ids of the sequence 
			variable index1;												// loop counter
			variable index2;												// loop counter
			variable size1;												// array size
			variable size2;												// array size
			variable instrumentId("");									// instrument id
			variable labId("");											// labware id
			variable unknownWCBKey(hslTrue);							// if 'true', the given wcbKey is unknown

			// initialize output
			wcbValue.SetSize(0);
			wcbLabId.SetSize(0);

			// get instrument name 
			instrumentId = ML_STAR.GetInstrumentName();

			// get unique labware ids of the sequence 
			washSequence.GetLabwareIds(labwareIds);

			// activate error handler
			onerror goto Unexpected;

			// get access to global data
			SynEnterCriticalSection(ptlCs);

			// verify array sizes
			size1 = labwareIds.GetSize();
			size2 = ptlWcbInstrumentIdArr.GetSize();
			#ifdef _DEBUG
			Assert(ptlWcbTaskIdArr.GetSize() == size2, GetFunctionName());		// 20050630 cjoerg: added
			Assert(ptlWcbLabwareIdArr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbUserResponseTimeArr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbErrorHandlingArr.GetSize() == size2, GetFunctionName());
         Assert(ptlWcbInitializeCustomStepIDArr.GetSize() == size2, GetFunctionName());
         Assert(ptlWcbTipPickupCustomStepIDArr.GetSize() == size2, GetFunctionName());
         Assert(ptlWcbTipEjectCustomStepIDArr.GetSize() == size2, GetFunctionName());
         Assert(ptlWcbStartNeedleWashCustomStepIDArr.GetSize() == size2, GetFunctionName());
         Assert(ptlWcbWaitNeedleWashCustomStepIDArr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbNeedlePickupChannelVariableArr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbNeedleEjectChannelVariableArr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbRinseTime1Arr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbSoakTime1Arr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbFlowRate1Arr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbRinseTime2Arr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbSoakTime2Arr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbFlowRate2Arr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbDrainingTimeArr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbStartWashLiquidArr.GetSize() == size2, GetFunctionName());
			#endif

			// iterate over unique labware ids of the sequence 
			for (index1 = 0; index1 < size1; index1++)
			{

				labId = labwareIds.GetAt(index1);
				unknownWCBKey = hslTrue;

				// check if the labware is a wash station or a needle rack
				if (IsWashStation(ML_STAR, labId) || IsNeedleRack(ML_STAR, labId))
				{
					// the labware is a wash station or a needle rack,
					// iterate over instrument labware pairs
					for (index2 = 0; index2 < size2; index2++)
					{
						if (ptlWcbInstrumentIdArr.GetAt(index2) == instrumentId && 
							ptlWcbLabwareIdArr.GetAt(index2) == labId)
							// found a matching instrument labware pair
							break;
					}
					if (index2 < size2 && 0 < size2)
					{
						// get the settings for the instrument labware pair
						// switch over WCB entries
						if (wcbKey == "UserResponseTime")
						{
							wcbValue.AddAsLast(ptlWcbUserResponseTimeArr.GetAt(index2));
							unknownWCBKey = hslFalse;
						}
						if (wcbKey == "ErrorHandling")
						{
							wcbValue.AddAsLast(ptlWcbErrorHandlingArr.GetAt(index2));
							unknownWCBKey = hslFalse;
						}
                  if (wcbKey == "InitializeCustomStepID")
						{
							wcbValue.AddAsLast(ptlWcbInitializeCustomStepIDArr.GetAt(index2));
							unknownWCBKey = hslFalse;
						}
                  if (wcbKey == "TipPickupCustomStepID")
						{
							wcbValue.AddAsLast(ptlWcbTipPickupCustomStepIDArr.GetAt(index2));
							unknownWCBKey = hslFalse;
						}
                  if (wcbKey == "TipEjectCustomStepID")
						{
							wcbValue.AddAsLast(ptlWcbTipEjectCustomStepIDArr.GetAt(index2));
							unknownWCBKey = hslFalse;
						}
                  if (wcbKey == "StartNeedleWashCustomStepID")
						{
							wcbValue.AddAsLast(ptlWcbStartNeedleWashCustomStepIDArr.GetAt(index2));
							unknownWCBKey = hslFalse;
						}
                  if (wcbKey == "WaitNeedleWashCustomStepID")
						{
							wcbValue.AddAsLast(ptlWcbWaitNeedleWashCustomStepIDArr.GetAt(index2));
							unknownWCBKey = hslFalse;
						}
						if (wcbKey == "NeedlePickupChannelVariable")
						{
							wcbValue.AddAsLast(ptlWcbNeedlePickupChannelVariableArr.GetAt(index2));
							unknownWCBKey = hslFalse;
						}
						if (wcbKey == "NeedleEjectChannelVariable")
						{
							wcbValue.AddAsLast(ptlWcbNeedleEjectChannelVariableArr.GetAt(index2));
							unknownWCBKey = hslFalse;
						}
						if (wcbKey == "RinseTime1")
						{
							wcbValue.AddAsLast(ptlWcbRinseTime1Arr.GetAt(index2));
							unknownWCBKey = hslFalse;
						}
						if (wcbKey == "SoakTime1")
						{
							wcbValue.AddAsLast(ptlWcbSoakTime1Arr.GetAt(index2));
							unknownWCBKey = hslFalse;
						}
						if (wcbKey == "FlowRate1")
						{
							wcbValue.AddAsLast(ptlWcbFlowRate1Arr.GetAt(index2));
							unknownWCBKey = hslFalse;
						}
						if (wcbKey == "RinseTime2")
						{
							wcbValue.AddAsLast(ptlWcbRinseTime2Arr.GetAt(index2));
							unknownWCBKey = hslFalse;
						}
						if (wcbKey == "SoakTime2")
						{
							wcbValue.AddAsLast(ptlWcbSoakTime2Arr.GetAt(index2));
							unknownWCBKey = hslFalse;
						}
						if (wcbKey == "FlowRate2")
						{
							wcbValue.AddAsLast(ptlWcbFlowRate2Arr.GetAt(index2));
							unknownWCBKey = hslFalse;
						}
						if (wcbKey == "DrainingTime")
						{
							wcbValue.AddAsLast(ptlWcbDrainingTimeArr.GetAt(index2));
							unknownWCBKey = hslFalse;
						}
						if (wcbKey == "StartWashLiquid")
						{
							wcbValue.AddAsLast(ptlWcbStartWashLiquidArr.GetAt(index2));
							unknownWCBKey = hslFalse;
						}

						if (unknownWCBKey)
							// unknown wcbKey
							Error::Raise(IDE::invalidWCBKey, GetFileName(), GetFunctionName(), GetLineNumber());

						wcbLabId.AddAsLast(labId);

						if (firstOnly)
							break;
					}
				}
			}

			// release access to global data
			SynLeaveCriticalSection(ptlCs);

			return(hslTrue);

			Unexpected:
			{
				// release access to global data
				SynLeaveCriticalSection(ptlCs);
				Error::RaiseLast();
			}
		}

		static function GetWashParams(
			device& ML_STAR,
			variable& washStation,
			variable& rinseTime1,
			variable& soakTime1,
			variable& flowRate1,
			variable& rinseTime2,
			variable& soakTime2,
			variable& flowRate2,
			variable& drainingTime,
			variable& startWashLiquid)
		{
			// initialize output parameters
			rinseTime1 = 0;
			soakTime1 = 0;
			flowRate1 = 0;
			rinseTime2 = 0;
			soakTime2 = 0;
			flowRate2 = 0;
			drainingTime = 0;
			startWashLiquid = 0;

			// check if the labware is a wash station
			if (IsWashStation(ML_STAR, washStation))
			{
				variable index;											// loop counter
				variable size;												// array size
				variable instrumentId("");								// instrument id

				// get instrument name 
				instrumentId = ML_STAR.GetInstrumentName();

				// activate error handler
				onerror goto Unexpected;

				// get access to global data
				SynEnterCriticalSection(ptlCs);

				// verify array sizes
				size = ptlWcbInstrumentIdArr.GetSize();
				#ifdef _DEBUG
				Assert(ptlWcbTaskIdArr.GetSize() == size, GetFunctionName());		// 20050630 cjoerg: added
				Assert(ptlWcbLabwareIdArr.GetSize() == size, GetFunctionName());
				Assert(ptlWcbUserResponseTimeArr.GetSize() == size, GetFunctionName());
				Assert(ptlWcbErrorHandlingArr.GetSize() == size, GetFunctionName());
            Assert(ptlWcbInitializeCustomStepIDArr.GetSize() == size, GetFunctionName());
            Assert(ptlWcbTipPickupCustomStepIDArr.GetSize() == size, GetFunctionName());
            Assert(ptlWcbTipEjectCustomStepIDArr.GetSize() == size, GetFunctionName());
            Assert(ptlWcbStartNeedleWashCustomStepIDArr.GetSize() == size, GetFunctionName());
            Assert(ptlWcbWaitNeedleWashCustomStepIDArr.GetSize() == size, GetFunctionName());
            Assert(ptlWcbNeedlePickupChannelVariableArr.GetSize() == size, GetFunctionName());
				Assert(ptlWcbNeedleEjectChannelVariableArr.GetSize() == size, GetFunctionName());
				Assert(ptlWcbRinseTime1Arr.GetSize() == size, GetFunctionName());
				Assert(ptlWcbSoakTime1Arr.GetSize() == size, GetFunctionName());
				Assert(ptlWcbFlowRate1Arr.GetSize() == size, GetFunctionName());
				Assert(ptlWcbRinseTime2Arr.GetSize() == size, GetFunctionName());
				Assert(ptlWcbSoakTime2Arr.GetSize() == size, GetFunctionName());
				Assert(ptlWcbFlowRate2Arr.GetSize() == size, GetFunctionName());
				Assert(ptlWcbDrainingTimeArr.GetSize() == size, GetFunctionName());
				Assert(ptlWcbStartWashLiquidArr.GetSize() == size, GetFunctionName());
				#endif

				// the labware is a wash station
				// iterate over instrument labware pairs
				for (index = 0; index < size; index++)
				{
					if (ptlWcbInstrumentIdArr.GetAt(index) == instrumentId && 
						ptlWcbLabwareIdArr.GetAt(index) == washStation)
						// found a matching instrument labware pair
						break;
				}
				if (index < size && 0 < size)
				{
					// 20050630 cjoerg
					// Added check that the wash settings are set from the same task that try
					// to get it not.
					// This check forces that if scheduled the 'Needle Wash Settings' must be set from
					// exactly the task that needs to use them.
					// The safest way to ensure this is to programm the 'Needle Wash Settings' within
					// activity where the settings are used (e.g. Pipette or Needle Eject).
					// If not scheduled GetCurrentTaskId() returns zero, equals to the value which 
					// is used to initialze the ptlWcbTaskIdArr[].
					if (ptlWcbTaskIdArr.GetAt(index) != GetCurrentTaskId())
					{
						variable action;
						variable warnText;
						action   = StringTable::Load(IDS::actionNeedleWash);
						warnText = StringTable::Load(IDS::washSettingsNotForCurrentTaskId);
						StrReplace(warnText, "%s", washStation);
						PTL_Util::TraceWarningIfNotValidated(action, warnText);
					}

					// get the settings for the instrument labware pair
					rinseTime1 = ptlWcbRinseTime1Arr.GetAt(index);
					soakTime1 = ptlWcbSoakTime1Arr.GetAt(index);
					flowRate1 = ptlWcbFlowRate1Arr.GetAt(index);
					rinseTime2 = ptlWcbRinseTime2Arr.GetAt(index);
					soakTime2 = ptlWcbSoakTime2Arr.GetAt(index);
					flowRate2 = ptlWcbFlowRate2Arr.GetAt(index);
					drainingTime = ptlWcbDrainingTimeArr.GetAt(index);
					startWashLiquid = ptlWcbStartWashLiquidArr.GetAt(index);

					// release access to global data
					SynLeaveCriticalSection(ptlCs);
					return(hslTrue);
				}
				else
				{
					// 20050704 cjoerg
					// Wash settings are not explicit set for current labware.
					// Defaults may be used but them must not be identical between different methods
					// (e.g. if methods are created with different installations / OEM's).
					// If we are scheduling (GetCurrentTaskId() returns value not equal to zeor)
					// this is a programming failure.
					if (0 != GetCurrentTaskId())
					{
						variable action;
						variable warnText;
						action   = StringTable::Load(IDS::actionNeedleWash);
						warnText = StringTable::Load(IDS::washSettingsNotForCurrentTaskId);
						StrReplace(warnText, "%s", washStation);
						PTL_Util::TraceWarningIfNotValidated(action, warnText);
					}
				}

				// release access to global data
				SynLeaveCriticalSection(ptlCs);
			}

			return(hslTrue);

			Unexpected:
			{
				// release access to global data
				SynLeaveCriticalSection(ptlCs);
				Error::RaiseLast();
			}
		}

		static function SetState(
			device& ML_STAR,
			sequence& washSequence,
			variable& wcbKey,
			variable& wcbValue)
		{
			variable labwareIds[];										// place to hold unique labware ids of the sequence 
			variable index1;												// loop counter
			variable index2;												// loop counter
			variable size1;												// array size
			variable size2;												// array size
			variable instrumentId("");									// instrument id
			variable labId("");											// labware id
			variable unknownWCBKey(hslTrue);							// if 'true', the given wcbKey is unknown
			variable isWashStation(hslFalse);						// if 'true', the given labware is a wash station
			variable isNeedleRack(hslFalse);							// if 'true', the given labware is a needle rack

			// get instrument name 
			instrumentId = ML_STAR.GetInstrumentName();

			// get unique labware ids of the sequence 
			washSequence.GetLabwareIds(labwareIds);

			// activate error handler
			onerror goto Unexpected;

			// get access to global data
			SynEnterCriticalSection(ptlCs);

			// verify array sizes
			size1 = labwareIds.GetSize();
			size2 = ptlWcbInstrumentIdArr.GetSize();
			#ifdef _DEBUG
			Assert(ptlWcbTaskIdArr.GetSize() == size2, GetFunctionName());		// 20050630 cjoerg: added
			Assert(ptlWcbLabwareIdArr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbUserResponseTimeArr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbErrorHandlingArr.GetSize() == size2, GetFunctionName());
         Assert(ptlWcbInitializeCustomStepIDArr.GetSize() == size2, GetFunctionName());
         Assert(ptlWcbTipPickupCustomStepIDArr.GetSize() == size2, GetFunctionName());
         Assert(ptlWcbTipEjectCustomStepIDArr.GetSize() == size2, GetFunctionName());
         Assert(ptlWcbStartNeedleWashCustomStepIDArr.GetSize() == size2, GetFunctionName());
         Assert(ptlWcbWaitNeedleWashCustomStepIDArr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbNeedlePickupChannelVariableArr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbNeedleEjectChannelVariableArr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbRinseTime1Arr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbSoakTime1Arr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbFlowRate1Arr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbRinseTime2Arr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbSoakTime2Arr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbFlowRate2Arr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbDrainingTimeArr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbStartWashLiquidArr.GetSize() == size2, GetFunctionName());
			#endif
			
			// iterate over unique labware ids of the sequence 
			for (index1 = 0; index1 < size1; index1++)
			{

				labId = labwareIds.GetAt(index1);
				unknownWCBKey = hslTrue;
				isWashStation = IsWashStation(ML_STAR, labId);
				isNeedleRack = IsNeedleRack(ML_STAR, labId);

				// check if the labware is a wash station or a needle rack
				if (isWashStation || isNeedleRack)
				{
					// the labware is a wash station or a needle rack,
					// iterate over instrument labware pairs
					for (index2 = 0; index2 < size2; index2++)
					{
						if (ptlWcbInstrumentIdArr.GetAt(index2) == instrumentId && 
							ptlWcbLabwareIdArr.GetAt(index2) == labId)
							// found a matching instrument labware pair
							break;
					}
					if (size2 <= index2)
					{
						// didn't found a matching instrument labware pair,
						// register new instrument labware pair
						ptlWcbInstrumentIdArr.AddAsLast(instrumentId);
						ptlWcbLabwareIdArr.AddAsLast(labId);
						ptlWcbTaskIdArr.AddAsLast(0);		// 20050630 cjoerg: added, must be zero for the case that not used with scheduler
						ptlWcbUserResponseTimeArr.AddAsLast(Limits::maxTimeInterval);
						ptlWcbErrorHandlingArr.AddAsLast(ErrorHandling::continue);
                  ptlWcbInitializeCustomStepIDArr.AddAsLast(CustomStepID::stepErrorHandlingDefault);
                  ptlWcbTipPickupCustomStepIDArr.AddAsLast(CustomStepID::stepErrorHandlingDefault);
                  ptlWcbTipEjectCustomStepIDArr.AddAsLast(CustomStepID::stepErrorHandlingDefault);
                  ptlWcbStartNeedleWashCustomStepIDArr.AddAsLast(CustomStepID::stepErrorHandlingDefault);
                  ptlWcbWaitNeedleWashCustomStepIDArr.AddAsLast(CustomStepID::stepErrorHandlingDefault);
						ptlWcbNeedlePickupChannelVariableArr.AddAsLast(Limits::channelVariable16);
						ptlWcbNeedleEjectChannelVariableArr.AddAsLast(Limits::channelVariable16);
						if (isWashStation)
						{
							ptlWcbRinseTime1Arr.AddAsLast(rinseTime1Default);
							ptlWcbSoakTime1Arr.AddAsLast(soakTime1Default);
							ptlWcbFlowRate1Arr.AddAsLast(flowRate1Default);
							ptlWcbRinseTime2Arr.AddAsLast(rinseTime2Default);
							ptlWcbSoakTime2Arr.AddAsLast(soakTime2Default);
							ptlWcbFlowRate2Arr.AddAsLast(flowRate2Default);
							ptlWcbDrainingTimeArr.AddAsLast(drainingTimeDefault);
							ptlWcbStartWashLiquidArr.AddAsLast(startWashLiquidDefault);
						}
						else
						{
							ptlWcbRinseTime1Arr.AddAsLast(-1);
							ptlWcbSoakTime1Arr.AddAsLast(-1);
							ptlWcbFlowRate1Arr.AddAsLast(-1);
							ptlWcbRinseTime2Arr.AddAsLast(-1);
							ptlWcbSoakTime2Arr.AddAsLast(-1);
							ptlWcbFlowRate2Arr.AddAsLast(-1);
							ptlWcbDrainingTimeArr.AddAsLast(-1);
							ptlWcbStartWashLiquidArr.AddAsLast(-1);
						}

						size2 = ptlWcbInstrumentIdArr.GetSize();
					}
					// set the settings for the instrument labware pair
					// switch over WCB entries
					if (wcbKey == "UserResponseTime")
					{
						// check wcbValue to be valid
						if (!PTL_Util::IsNumber(wcbValue))
							Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
						if (PTL_Util::IsNegative(wcbValue))
							Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

						// set wcbValue 
						if (Limits::maxTimeInterval < wcbValue)
							ptlWcbUserResponseTimeArr.SetAt(index2, Limits::maxTimeInterval);
						else
							ptlWcbUserResponseTimeArr.SetAt(index2, wcbValue);
						if (!PTL_Util::IsInteger(ptlWcbUserResponseTimeArr.GetAt(index2)))
							Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
						unknownWCBKey = hslFalse;
					}
					if (wcbKey == "ErrorHandling")
					{
						// check wcbValue to be valid
						if (!PTL_Util::IsNumber(wcbValue))
							Error::Raise(IDE::invalidErrorHandling, GetFileName(), GetFunctionName(), GetLineNumber());
						if (!PTL_Util::IsInteger(wcbValue))
							Error::Raise(IDE::invalidErrorHandling, GetFileName(), GetFunctionName(), GetLineNumber());
						if (wcbValue < ErrorHandling::first || ErrorHandling::last < wcbValue)
							Error::Raise(IDE::invalidErrorHandling, GetFileName(), GetFunctionName(), GetLineNumber());

						// set pcbValue 
						ptlWcbErrorHandlingArr.SetAt(index2, wcbValue);
						unknownWCBKey = hslFalse;
					}
					if (wcbKey == "InitializeCustomStepID")
					{
						// check wcbValue to be valid
						if (!PTL_Util::IsInteger(wcbValue))
							Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

						// set pcbValue 
						ptlWcbInitializeCustomStepIDArr.SetAt(index2, wcbValue);
						unknownWCBKey = hslFalse;
					}
					if (wcbKey == "TipPickupCustomStepID")
					{
						// check wcbValue to be valid
						if (!PTL_Util::IsInteger(wcbValue))
							Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

						// set pcbValue 
						ptlWcbTipPickupCustomStepIDArr.SetAt(index2, wcbValue);
						unknownWCBKey = hslFalse;
					}
					if (wcbKey == "TipEjectCustomStepID")
					{
						// check wcbValue to be valid
						if (!PTL_Util::IsInteger(wcbValue))
							Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

						// set pcbValue 
						ptlWcbTipEjectCustomStepIDArr.SetAt(index2, wcbValue);
						unknownWCBKey = hslFalse;
					}
   				if (wcbKey == "StartNeedleWashCustomStepID")
					{
						// check wcbValue to be valid
						if (!PTL_Util::IsInteger(wcbValue))
							Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

						// set pcbValue 
						ptlWcbStartNeedleWashCustomStepIDArr.SetAt(index2, wcbValue);
						unknownWCBKey = hslFalse;
					}
					if (wcbKey == "WaitNeedleWashCustomStepID")
					{
						// check wcbValue to be valid
						if (!PTL_Util::IsInteger(wcbValue))
							Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

						// set pcbValue 
						ptlWcbWaitNeedleWashCustomStepIDArr.SetAt(index2, wcbValue);
						unknownWCBKey = hslFalse;
					}
					if (wcbKey == "NeedlePickupChannelVariable")
					{
						// check wcbValue to be valid
						if (!PTL_Util::IsString(wcbValue))
							Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

						// set wcbValue 
						ptlWcbNeedlePickupChannelVariableArr.SetAt(index2, wcbValue);
						unknownWCBKey = hslFalse;
					}
					if (wcbKey == "NeedleEjectChannelVariable")
					{
						// check wcbValue to be valid
						if (!PTL_Util::IsString(wcbValue))
							Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

						// set wcbValue 
						ptlWcbNeedleEjectChannelVariableArr.SetAt(index2, wcbValue);
						unknownWCBKey = hslFalse;
					}
					if (isWashStation)
					{
						// 20050630 cjoerg
						// If one of the wcbKey RinseTime1, SoakTime1, FlowRate1, RinseTime2, SoakTime2
						// FlowRate2, DrainingTime or StartWashLiquid is passed this setting is set from
						// the step 'Needle Wash Settings'.
						// Set also the CurrentTaskId into ptlWcbTaskIdArr because during acces (GetWashParams)
						// we check that the Wask Settings are defined from a step of same task.
						// By this way we force (if a method is scheduled) that the 'Needle Wash Settings' are set for
						// the current task as last and that them are not overridden from an other task.
						// GetCurrentTaskId() returns zero if not not scheduled.
						if (wcbKey == "RinseTime1")
						{
							ptlWcbTaskIdArr.SetAt(index2, GetCurrentTaskId());	// 20050630 cjoerg: added

							// check wcbValue to be valid
							if (!PTL_Util::IsNumber(wcbValue))
								Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
							if (PTL_Util::IsNegative(wcbValue))
								Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

							// set wcbValue 
							ptlWcbRinseTime1Arr.SetAt(index2, wcbValue);
							unknownWCBKey = hslFalse;
						}
						if (wcbKey == "SoakTime1")
						{
							ptlWcbTaskIdArr.SetAt(index2, GetCurrentTaskId());	// 20050630 cjoerg: added

							// check wcbValue to be valid
							if (!PTL_Util::IsNumber(wcbValue))
								Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
							if (PTL_Util::IsNegative(wcbValue))
								Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

							// set wcbValue 
							ptlWcbSoakTime1Arr.SetAt(index2, wcbValue);
							unknownWCBKey = hslFalse;
						}
						if (wcbKey == "FlowRate1")
						{
							ptlWcbTaskIdArr.SetAt(index2, GetCurrentTaskId());	// 20050630 cjoerg: added

							// check wcbValue to be valid
							if (!PTL_Util::IsNumber(wcbValue))
								Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
							if (!PTL_Util::IsInteger(wcbValue))
								Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
							if (PTL_Util::IsNegative(wcbValue))
								Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

							// set wcbValue 
							ptlWcbFlowRate1Arr.SetAt(index2, wcbValue);
							unknownWCBKey = hslFalse;
						}
						if (wcbKey == "RinseTime2")
						{
							ptlWcbTaskIdArr.SetAt(index2, GetCurrentTaskId());	// 20050630 cjoerg: added

							// check wcbValue to be valid
							if (!PTL_Util::IsNumber(wcbValue))
								Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
							if (PTL_Util::IsNegative(wcbValue))
								Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

							// set wcbValue 
							ptlWcbRinseTime2Arr.SetAt(index2, wcbValue);
							unknownWCBKey = hslFalse;
						}
						if (wcbKey == "SoakTime2")
						{
							ptlWcbTaskIdArr.SetAt(index2, GetCurrentTaskId());	// 20050630 cjoerg: added

							// check wcbValue to be valid
							if (!PTL_Util::IsNumber(wcbValue))
								Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
							if (PTL_Util::IsNegative(wcbValue))
								Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

							// set wcbValue 
							ptlWcbSoakTime2Arr.SetAt(index2, wcbValue);
							unknownWCBKey = hslFalse;
						}
						if (wcbKey == "FlowRate2")
						{
							ptlWcbTaskIdArr.SetAt(index2, GetCurrentTaskId());	// 20050630 cjoerg: added

							// check wcbValue to be valid
							if (!PTL_Util::IsNumber(wcbValue))
								Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
							if (!PTL_Util::IsInteger(wcbValue))
								Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
							if (PTL_Util::IsNegative(wcbValue))
								Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

							// set wcbValue 
							ptlWcbFlowRate2Arr.SetAt(index2, wcbValue);
							unknownWCBKey = hslFalse;
						}
						if (wcbKey == "DrainingTime")
						{
							ptlWcbTaskIdArr.SetAt(index2, GetCurrentTaskId());	// 20050630 cjoerg: added

							// check wcbValue to be valid
							if (!PTL_Util::IsNumber(wcbValue))
								Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
							if (PTL_Util::IsNegative(wcbValue))
								Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

							// set wcbValue 
							ptlWcbDrainingTimeArr.SetAt(index2, wcbValue);
							unknownWCBKey = hslFalse;
						}
						if (wcbKey == "StartWashLiquid")
						{
							ptlWcbTaskIdArr.SetAt(index2, GetCurrentTaskId());	// 20050630 cjoerg: added

							// check wcbValue to be valid
							if (!PTL_Util::IsNumber(wcbValue))
								Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
							if (!PTL_Util::IsInteger(wcbValue))
								Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
							if (wcbValue < 0 || 1 < wcbValue)
								Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

							// set wcbValue 
							ptlWcbStartWashLiquidArr.SetAt(index2, wcbValue);
							unknownWCBKey = hslFalse;
						}
					}
					else
					{
						unknownWCBKey = hslFalse;
					}

					if (unknownWCBKey)
						// unknown wcbKey
						Error::Raise(IDE::invalidWCBKey, GetFileName(), GetFunctionName(), GetLineNumber());
				}
			}

			// release access to global data
			SynLeaveCriticalSection(ptlCs);

			return(hslTrue);

			Unexpected:
			{
				// release access to global data
				SynLeaveCriticalSection(ptlCs);
				Error::RaiseLast();
			}
		}

		static function GetStateDefault(
			variable& wcbKey,
			variable& wcbValue)
		{
			variable unknownWCBKey(hslTrue);							// if 'true', the given wcbKey is unknown

			// initialize output param
			wcbValue = 0;

			// switch over WCB entries
			if (wcbKey == "RinseTime1")
			{
				wcbValue = rinseTime1Default;
				unknownWCBKey = hslFalse;
			}
			if (wcbKey == "SoakTime1")
			{
				wcbValue = soakTime1Default;
				unknownWCBKey = hslFalse;
			}
			if (wcbKey == "FlowRate1")
			{
				wcbValue = flowRate1Default;
				unknownWCBKey = hslFalse;
			}
			if (wcbKey == "RinseTime2")
			{
				wcbValue = rinseTime2Default;
				unknownWCBKey = hslFalse;
			}
			if (wcbKey == "SoakTime2")
			{
				wcbValue = soakTime2Default;
				unknownWCBKey = hslFalse;
			}
			if (wcbKey == "FlowRate2")
			{
				wcbValue = flowRate2Default;
				unknownWCBKey = hslFalse;
			}
			if (wcbKey == "DrainingTime")
			{
				wcbValue = drainingTimeDefault;
				unknownWCBKey = hslFalse;
			}
			if (wcbKey == "StartWashLiquid")
			{
				wcbValue = startWashLiquidDefault;
				unknownWCBKey = hslFalse;
			}

			if (unknownWCBKey)
				// unknown wcbKey
				Error::Raise(IDE::invalidWCBKey, GetFileName(), GetFunctionName(), GetLineNumber());

			return(hslTrue);
		}

		static function SetStateDefault(
			variable& wcbKey,
			variable& wcbValue)
		{
			// switch over WCB entries
			if (wcbKey == "RinseTime1")
			{
				// check wcbValue to be valid
				if (!PTL_Util::IsNumber(wcbValue))
					Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(wcbValue))
					Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set wcbDefaultValue 
				rinseTime1Default = wcbValue;
				return(hslTrue);
			}
			if (wcbKey == "SoakTime1")
			{
				// check wcbValue to be valid
				if (!PTL_Util::IsNumber(wcbValue))
					Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(wcbValue))
					Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set wcbDefaultValue 
				soakTime1Default = wcbValue;
				return(hslTrue);
			}
			if (wcbKey == "FlowRate1")
			{
				// check wcbValue to be valid
				if (!PTL_Util::IsNumber(wcbValue))
					Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(wcbValue))
					Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(wcbValue))
					Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set wcbDefaultValue 
				flowRate1Default = wcbValue;
				return(hslTrue);
			}
			if (wcbKey == "RinseTime2")
			{
				// check wcbValue to be valid
				if (!PTL_Util::IsNumber(wcbValue))
					Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(wcbValue))
					Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set wcbDefaultValue 
				rinseTime2Default = wcbValue;
				return(hslTrue);
			}
			if (wcbKey == "SoakTime2")
			{
				// check wcbValue to be valid
				if (!PTL_Util::IsNumber(wcbValue))
					Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(wcbValue))
					Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set wcbDefaultValue 
				soakTime2Default = wcbValue;
				return(hslTrue);
			}
			if (wcbKey == "FlowRate2")
			{
				// check wcbValue to be valid
				if (!PTL_Util::IsNumber(wcbValue))
					Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(wcbValue))
					Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(wcbValue))
					Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set wcbDefaultValue 
				flowRate2Default = wcbValue;
				return(hslTrue);
			}
			if (wcbKey == "DrainingTime")
			{
				// check wcbValue to be valid
				if (!PTL_Util::IsNumber(wcbValue))
					Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(wcbValue))
					Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set wcbDefaultValue 
				drainingTimeDefault = wcbValue;
				return(hslTrue);
			}
			if (wcbKey == "StartWashLiquid")
			{
				// check wcbValue to be valid
				if (!PTL_Util::IsNumber(wcbValue))
					Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(wcbValue))
					Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (wcbValue < 0 || 1 < wcbValue)
					Error::Raise(IDE::invalidWCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set wcbDefaultValue 
				startWashLiquidDefault = wcbValue;
				return(hslTrue);
			}

			// unknown wcbKey
			Error::Raise(IDE::invalidWCBKey, GetFileName(), GetFunctionName(), GetLineNumber());

			return(hslTrue);
		}

		static function Init(
			device& ML_STAR,
			sequence& washSequence)
		{
			variable labwareIds[];										// place to hold unique labware ids of the sequence 
			variable index1;												// loop counter
			variable index2;												// loop counter
			variable size1;												// array size
			variable size2;												// array size
			variable instrumentId("");									// instrument id
			variable labId("");											// labware id
			variable isWashStation(hslFalse);						// if 'true', the given labware is a wash station
			variable isNeedleRack(hslFalse);							// if 'true', the given labware is a needle rack

			// get instrument name 
			instrumentId = ML_STAR.GetInstrumentName();

			// get unique labware ids of the sequence 
			washSequence.GetLabwareIds(labwareIds);

			// activate error handler
			onerror goto Unexpected;

			// get access to global data
			SynEnterCriticalSection(ptlCs);

			// verify array sizes
			size1 = labwareIds.GetSize();
			size2 = ptlWcbInstrumentIdArr.GetSize();
			#ifdef _DEBUG
			Assert(ptlWcbTaskIdArr.GetSize() == size2, GetFunctionName());		// 20050630 cjoerg: added
			Assert(ptlWcbLabwareIdArr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbUserResponseTimeArr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbErrorHandlingArr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbInitializeCustomStepIDArr.GetSize() == size2, GetFunctionName());
         Assert(ptlWcbTipPickupCustomStepIDArr.GetSize() == size2, GetFunctionName());
         Assert(ptlWcbTipEjectCustomStepIDArr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbStartNeedleWashCustomStepIDArr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbWaitNeedleWashCustomStepIDArr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbNeedlePickupChannelVariableArr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbNeedleEjectChannelVariableArr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbRinseTime1Arr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbSoakTime1Arr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbFlowRate1Arr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbRinseTime2Arr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbSoakTime2Arr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbFlowRate2Arr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbDrainingTimeArr.GetSize() == size2, GetFunctionName());
			Assert(ptlWcbStartWashLiquidArr.GetSize() == size2, GetFunctionName());
			#endif
			
			// iterate over unique labware ids of the sequence 
			for (index1 = 0; index1 < size1; index1++)
			{

				labId = labwareIds.GetAt(index1);
				isWashStation = IsWashStation(ML_STAR, labId);
				isNeedleRack = IsNeedleRack(ML_STAR, labId);

				// check if the labware is a wash station or a needle rack
				if (isWashStation || isNeedleRack)
				{
					// the labware is a wash station or a needle rack,
					// iterate over instrument labware pairs
					for (index2 = 0; index2 < size2; index2++)
					{
						if (ptlWcbInstrumentIdArr.GetAt(index2) == instrumentId && 
							ptlWcbLabwareIdArr.GetAt(index2) == labId)
							// found a matching instrument labware pair
							break;
					}
					if (index2 < size2  && 0 < size2)
					{
						// found a matching instrument labware pair,
						// reset state of instrument labware pair
						ptlWcbTaskIdArr.SetAt(index2, 0);		// 20050630 cjoerg: added, must be zero for the case that not used with scheduler
						ptlWcbUserResponseTimeArr.SetAt(index2, Limits::maxTimeInterval);
						ptlWcbErrorHandlingArr.SetAt(index2, ErrorHandling::continue);
                  ptlWcbInitializeCustomStepIDArr.SetAt(index2, CustomStepID::stepErrorHandlingDefault);
                  ptlWcbTipPickupCustomStepIDArr.SetAt(index2, CustomStepID::stepErrorHandlingDefault);
                  ptlWcbTipEjectCustomStepIDArr.SetAt(index2, CustomStepID::stepErrorHandlingDefault);
                  ptlWcbStartNeedleWashCustomStepIDArr.SetAt(index2, CustomStepID::stepErrorHandlingDefault);
                  ptlWcbWaitNeedleWashCustomStepIDArr.SetAt(index2, CustomStepID::stepErrorHandlingDefault);
						ptlWcbNeedlePickupChannelVariableArr.SetAt(index2, Limits::channelVariable16);
						ptlWcbNeedleEjectChannelVariableArr.SetAt(index2, Limits::channelVariable16);
						if (isWashStation)
						{
							ptlWcbRinseTime1Arr.SetAt(index2, rinseTime1Default);
							ptlWcbSoakTime1Arr.SetAt(index2, soakTime1Default);
							ptlWcbFlowRate1Arr.SetAt(index2, flowRate1Default);
							ptlWcbRinseTime2Arr.SetAt(index2, rinseTime2Default);
							ptlWcbSoakTime2Arr.SetAt(index2, soakTime2Default);
							ptlWcbFlowRate2Arr.SetAt(index2, flowRate2Default);
							ptlWcbDrainingTimeArr.SetAt(index2, drainingTimeDefault);
							ptlWcbStartWashLiquidArr.SetAt(index2, startWashLiquidDefault);
						}
						else
						{
							ptlWcbRinseTime1Arr.SetAt(index2, -1);
							ptlWcbSoakTime1Arr.SetAt(index2, -1);
							ptlWcbFlowRate1Arr.SetAt(index2, -1);
							ptlWcbRinseTime2Arr.SetAt(index2, -1);
							ptlWcbSoakTime2Arr.SetAt(index2, -1);
							ptlWcbFlowRate2Arr.SetAt(index2, -1);
							ptlWcbDrainingTimeArr.SetAt(index2, -1);
							ptlWcbStartWashLiquidArr.SetAt(index2, -1);
						}
					}
				}
			}

			// release access to global data
			SynLeaveCriticalSection(ptlCs);

			return(hslTrue);

			Unexpected:
			{
				// release access to global data
				SynLeaveCriticalSection(ptlCs);
				Error::RaiseLast();
			}
		}

		static function Dump()
		{
			#ifdef _DEBUG
			variable size;
			variable index;
			variable source;
			variable action;

			source = "DEBUG";
			action = GetFunctionName();


			// activate error handler
			onerror goto Unexpected;

			// get access to global data
			SynEnterCriticalSection(ptlCs);

			size = ptlWcbInstrumentIdArr.GetSize();

			Assert(ptlWcbLabwareIdArr.GetSize() == size, GetFunctionName());
			Assert(ptlWcbUserResponseTimeArr.GetSize() == size, GetFunctionName());
			Assert(ptlWcbErrorHandlingArr.GetSize() == size, GetFunctionName());
         Assert(ptlWcbInitializeCustomStepIDArr.GetSize() == size, GetFunctionName());
         Assert(ptlWcbTipPickupCustomStepIDArr.GetSize() == size, GetFunctionName());
         Assert(ptlWcbTipEjectCustomStepIDArr.GetSize() == size, GetFunctionName());
         Assert(ptlWcbStartNeedleWashCustomStepIDArr.GetSize() == size, GetFunctionName());
			Assert(ptlWcbWaitNeedleWashCustomStepIDArr.GetSize() == size, GetFunctionName());
         Assert(ptlWcbNeedlePickupChannelVariableArr.GetSize() == size, GetFunctionName());
			Assert(ptlWcbNeedleEjectChannelVariableArr.GetSize() == size, GetFunctionName());
			Assert(ptlWcbRinseTime1Arr.GetSize() == size, GetFunctionName());
			Assert(ptlWcbSoakTime1Arr.GetSize() == size, GetFunctionName());
			Assert(ptlWcbFlowRate1Arr.GetSize() == size, GetFunctionName());
			Assert(ptlWcbRinseTime2Arr.GetSize() == size, GetFunctionName());
			Assert(ptlWcbSoakTime2Arr.GetSize() == size, GetFunctionName());
			Assert(ptlWcbFlowRate2Arr.GetSize() == size, GetFunctionName());
			Assert(ptlWcbDrainingTimeArr.GetSize() == size, GetFunctionName());
			Assert(ptlWcbStartWashLiquidArr.GetSize() == size, GetFunctionName());

			for (index = 0; index < size; index++)
			{
				FormatTrace(source, action, TraceStatus::progress, "instrumentId[", index, "] = ", ptlWcbInstrumentIdArr.GetAt(index));
				FormatTrace(source, action, TraceStatus::progress, "labwareId[", index, "] = ", ptlWcbLabwareIdArr.GetAt(index));
				FormatTrace(source, action, TraceStatus::progress, "userResponseTime[", index, "] = ", ptlWcbUserResponseTimeArr.GetAt(index));
				FormatTrace(source, action, TraceStatus::progress, "errorHandling[", index, "] = ", ptlWcbErrorHandlingArr.GetAt(index));
				FormatTrace(source, action, TraceStatus::progress, "initializeCustomStepID[", index, "] = ", ptlWcbInitializeCustomStepIDArr.GetAt(index));
            FormatTrace(source, action, TraceStatus::progress, "tipPickupCustomStepID[", index, "] = ", ptlWcbTipPickupCustomStepIDArr.GetAt(index));
            FormatTrace(source, action, TraceStatus::progress, "tipEjectCustomStepID[", index, "] = ", ptlWcbTipEjectCustomStepIDArr.GetAt(index));
            FormatTrace(source, action, TraceStatus::progress, "startNeedleWashCustomStepID[", index, "] = ", ptlWcbStartNeedleWashCustomStepIDArr.GetAt(index));
            FormatTrace(source, action, TraceStatus::progress, "waitNeedleWashCustomStepID[", index, "] = ", ptlWcbWaitNeedleWashCustomStepIDArr.GetAt(index));
				FormatTrace(source, action, TraceStatus::progress, "needlePickupChannelVariable[", index, "] = ", ptlWcbNeedlePickupChannelVariableArr.GetAt(index));
				FormatTrace(source, action, TraceStatus::progress, "needleEjectChannelVariable[", index, "] = ", ptlWcbNeedleEjectChannelVariableArr.GetAt(index));
				FormatTrace(source, action, TraceStatus::progress, "rinseTime1[", index, "] = ", ptlWcbRinseTime1Arr.GetAt(index));
				FormatTrace(source, action, TraceStatus::progress, "soakTime1[", index, "] = ", ptlWcbSoakTime1Arr.GetAt(index));
				FormatTrace(source, action, TraceStatus::progress, "flowRate1[", index, "] = ", ptlWcbFlowRate1Arr.GetAt(index));
				FormatTrace(source, action, TraceStatus::progress, "rinseTime2[", index, "] = ", ptlWcbRinseTime2Arr.GetAt(index));
				FormatTrace(source, action, TraceStatus::progress, "soakTime2[", index, "] = ", ptlWcbSoakTime2Arr.GetAt(index));
				FormatTrace(source, action, TraceStatus::progress, "flowRate2[", index, "] = ", ptlWcbFlowRate2Arr.GetAt(index));
				FormatTrace(source, action, TraceStatus::progress, "drainingTime[", index, "] = ", ptlWcbDrainingTimeArr.GetAt(index));
				FormatTrace(source, action, TraceStatus::progress, "startWashLiquid[", index, "] = ", ptlWcbStartWashLiquidArr.GetAt(index));
			}

			// release access to global data
			SynLeaveCriticalSection(ptlCs);

			return;

			Unexpected:
			{
				// release access to global data
				SynLeaveCriticalSection(ptlCs);
				Error::RaiseLast();
			}
			#endif
		}

		static function WaitForNeedleWasher(
		device& ML_STAR,
		sequence& washSequence,
		sequence& WashSequence,
		variable& channelPattern,
		variable& errorHandling,
		variable& userResponseTime,
		variable& currentPos,
		variable waitingStepType)
		{
			variable rc[];											// step return 
			variable index;										// loop index
			variable size;											// array size
			variable clippingCount(0);							// number of positions in clipping wash sequence
			variable currentPosBak(0);							// backup of current position of wash sequence
			variable numberOfActiveChannels(0);				// number of active channels
			variable availableWashStationPositions(0);	// number of available wash station positions in wash sequence
			variable availableNeedleRackPositions(0);		// number of available needle rack positions in wash sequence
			variable maxPositionsPerStep(0);					// max number of positions per step of wash sequence
			variable labwareIds[];								// place to hold unique labware ids of the WashSequence (= clipping wash sequence)
			variable wcbKey;										// WCB key
			variable wcbValue[];									// place to hold WCB values
			variable wcbLabId[];									// place to hold labware ids
			variable washStation("");							// labware id of a wash station
			variable labId("");									// labware id
			variable posId("");									// position id
			variable wrapSequence(hslFalse);					// if 'true', washSequence has to be wrapped at the end of the sequence
			variable canceledByTheUser(hslFalse);			// indicates whether an error recovery has been canceled by the user
         variable waitNeedleWashCustomStepID(CustomStepID::stepErrorHandlingDefault);

			// activate error handler
			onerror goto Unexpected;

			// initalize output parameters
			SeqRemoveAll(WashSequence);
			channelPattern = Limits::channelVariable16;
			errorHandling = ErrorHandling::continue;
			userResponseTime = Limits::maxTimeInterval;
			currentPos = 0;

			// backup current position of wash sequence
			currentPosBak = washSequence.GetCurrentPosition();

			// Remark:
			// The values for the washing control settings 
			// NeedlePickupChannelVariable, NeedleEjectChannelVariable, UserResponsTime
			// are always set immediately before the NeedlePickup or NeedleEject step
			// --> all labware referenced by washSequence has the same value for the 
			// corresponding setting.

			#ifdef _DEBUG
			Assert(StepReturn::StepType::tipPickup == waitingStepType || StepReturn::StepType::tipEject == waitingStepType, GetFunctionName());
			#endif
			if (StepReturn::StepType::tipPickup == waitingStepType)
				wcbKey = "NeedlePickupChannelVariable";
			if (StepReturn::StepType::tipEject == waitingStepType)
				wcbKey = "NeedleEjectChannelVariable";

			// get channel pattern
			GetState(ML_STAR, washSequence, hslTrue, wcbKey, wcbValue, wcbLabId);
			if (0 < wcbValue.GetSize())
				channelPattern = wcbValue.GetAt(0);

			// error handling
			wcbValue.SetSize(0);
			wcbLabId.SetSize(0);
			GetState(ML_STAR, washSequence, hslTrue, "ErrorHandling", wcbValue, wcbLabId);
			if (0 < wcbValue.GetSize())
				errorHandling = wcbValue.GetAt(0);

			// wait needle wash CustomStepID
			wcbValue.SetSize(0);
			wcbLabId.SetSize(0);
			GetState(ML_STAR, washSequence, hslTrue, "WaitNeedleWashCustomStepID", wcbValue, wcbLabId);
			if (0 < wcbValue.GetSize())
				waitNeedleWashCustomStepID = wcbValue.GetAt(0);

			// user response time
			wcbValue.SetSize(0);
			wcbLabId.SetSize(0);
			GetState(ML_STAR, washSequence, hslTrue, "UserResponseTime", wcbValue, wcbLabId);
			if (0 < wcbValue.GetSize())
				userResponseTime = wcbValue.GetAt(0);

			// determine needle pickup constraints 
			numberOfActiveChannels = NumberOfActiveChannels(channelPattern);
			maxPositionsPerStep = washSequence.GetMax();
			currentPos = washSequence.GetCurrentPosition();
			if (0 < currentPos)
			{
				availableWashStationPositions = GetCountFilterByRackType(ML_STAR, washSequence, NeedleRackType::washStation);
				availableNeedleRackPositions = GetCountFilterByRackType(ML_STAR, washSequence, NeedleRackType::needleRack);
			}
			clippingCount = PTL_Util::Min(numberOfActiveChannels, PTL_Util::Min(maxPositionsPerStep, availableWashStationPositions + availableNeedleRackPositions));
			wrapSequence = (0 < availableWashStationPositions);

			// build clipping WashSequence
			for (currentPos = washSequence.SetCurrentPosition(currentPosBak);
				  0 < currentPos && WashSequence.GetCount() < clippingCount; )
			{
				labId = washSequence.GetLabwareId();
				posId = washSequence.GetPositionId();
				if (IsWashStation(ML_STAR, labId) || IsNeedleRack(ML_STAR, labId))
					WashSequence.Add(labId, posId);
				currentPos = washSequence.Increment(1);
				if (wrapSequence && 0 == currentPos)
					// wrap sequence
					currentPos = washSequence.SetCurrentPosition(1);
			}
			WashSequence.SetCount(WashSequence.GetTotal());
			WashSequence.SetCurrentPosition(1);
			WashSequence.SetMax(WashSequence.GetCount());

			// get unique labware ids of WashSequence 
			WashSequence.GetLabwareIds(labwareIds);

			// wait for all wash stations
			size = labwareIds.GetSize();
			for (index = 0; index < size; index++)
			{
				labId = labwareIds.GetAt(index);

				// check if the labware is a wash station
				if (IsWashStation(ML_STAR, labId))
				{
					// the labware is a wash station,
					washStation = labId;

					// debug
					#ifdef _DEBUG
					FormatTrace("DEBUG", "ML_STAR.WaitNeedleWashed", TraceStatus::progress,
									"washStation = ", washStation);
					#endif

					// wait for wash station washStation
					StepReturn::Empty(rc);
					onerror goto WaitNeeldeWashedErrorHandler;
					rc = MlStarSteps::StepWaitNeedleWashed_cer(	ML_STAR,
																	washStation,
																	//errorHandling,
                                                   ErrorHandling::MapCustomStepErrorHandling(errorHandling, waitNeedleWashCustomStepID),
                                                   waitNeedleWashCustomStepID,
																	userResponseTime);
					onerror goto Unexpected;
					if (!StepReturn::Evaluate(ML_STAR, rc, ErrorHandling::MapCustomStepErrorHandling(errorHandling, waitNeedleWashCustomStepID)))
					{
						canceledByTheUser = hslTrue;
						break;
					}
				}
			}

			// restore current position of wash sequence
			washSequence.SetCurrentPosition(currentPosBak);

			// check if an error recovery has been canceled by the user
			if (canceledByTheUser)
				// re-throw error
				Error::RaiseLast();

			return(hslTrue);

			WaitNeeldeWashedErrorHandler:
			{
				// bind error data
				StepReturn::Bind(rc);
				resume next;
			}

			Unexpected:
			{
				// re-throw error
				Error::RaiseLast();
			}
		}

		function NeedlePickup(
			device& ML_STAR,
			sequence& washSequence,
			variable autoIncrement)
		{
			variable rc[];												// step return 
			sequence WashSequence;									// clipping wash sequence
			variable currentPos(0);									// current position
			variable errorHandling(ErrorHandling::continue);// error handling
			variable userResponseTime(0);							// user response time [s]
			variable channelPattern("");							// channel pattern
			variable canceledByTheUser(hslFalse);				// indicates whether an error recovery has been canceled by the user
			variable wcbValue[];									   // place to hold WCB values
			variable wcbLabId[];									   // place to hold labware ids
         variable tipPickupCustomStepID(CustomStepID::stepErrorHandlingDefault);

			// activate error handler
			onerror goto Unexpected;

			// wait for needle pickup
			WaitForNeedleWasher(ML_STAR, washSequence, WashSequence, 
									  channelPattern, errorHandling, userResponseTime, currentPos, 
									  StepReturn::StepType::tipPickup);

			// debug
			#ifdef _DEBUG
			FormatTrace("DEBUG", "ML_STAR.TipPickUp", TraceStatus::progress,
							"name = ", WashSequence.GetName(), 
							", current = ", WashSequence.GetCurrentPosition(), 
							", count = ", WashSequence.GetCount(),
							", maxPos = ", WashSequence.GetMax());
			#endif

			// tip pick up CustomStepID
			wcbValue.SetSize(0);
			wcbLabId.SetSize(0);
			GetState(ML_STAR, washSequence, hslTrue, "TipPickupCustomStepID", wcbValue, wcbLabId);
			if (0 < wcbValue.GetSize())
				tipPickupCustomStepID = wcbValue.GetAt(0);

			// pickup new needls (from WashSequence)
			StepReturn::Empty(rc);
			onerror goto TipPickupErrorHandler;
			rc = MlStarSteps::StepTipPickupEx_cer(	ML_STAR,
													WashSequence,
													SequenceCounting::manually,
													channelPattern,
													ChannelUse::allSequencePositions,
													//>> 20060519
													//errorHandling,
													PCB::MapErrorHandlingContinue(errorHandling, tipPickupCustomStepID),
													//<< 20060519
                                       tipPickupCustomStepID,
													userResponseTime);
			onerror goto Unexpected;
			if (!StepReturn::Evaluate(ML_STAR, rc, PCB::MapErrorHandlingContinue(errorHandling, tipPickupCustomStepID)))
				canceledByTheUser = hslTrue;

			// auto increment wash sequence if required
			if (autoIncrement)
				// auto increment wash sequence 
				washSequence.SetCurrentPosition(currentPos);

			// assign number of used positions from WashSequence to washSequence
			washSequence.SetUsedPositions(WashSequence.GetUsedPositions());

			// check if an error recovery has been canceled by the user
			if (canceledByTheUser)
				// re-throw error
				Error::RaiseLast();

			return(rc);

			TipPickupErrorHandler:
			{
				// bind error data
				StepReturn::Bind(rc);
				resume next;
			}

			Unexpected:
			{
				// re-throw error
				Error::RaiseLast();
			}
		}

		function NeedleEject(
			device& ML_STAR,
			sequence& washSequence,
			variable startWash)
		{
			variable rc[];												// step return 
			sequence WashSequence;									// clipping wash sequence
			variable currentPos(0);									// current position
			variable errorHandling(ErrorHandling::continue);// error handling
			variable userResponseTime(0);							// user response time [s]
			variable channelPattern("");							// channel pattern
			variable canceledByTheUser(hslFalse);				// indicates whether an error recovery has been canceled by the user
			variable wcbValue[];									   // place to hold WCB values
			variable wcbLabId[];									   // place to hold labware ids
         variable tipEjectCustomStepID(CustomStepID::stepErrorHandlingDefault);

			// activate error handler
			onerror goto Unexpected;

			// wait for needle washer
			WaitForNeedleWasher(ML_STAR, washSequence, WashSequence, 
									  channelPattern, errorHandling, userResponseTime, currentPos,
									  StepReturn::StepType::tipEject);

			// debug
			#ifdef _DEBUG
			FormatTrace("DEBUG", "ML_STAR.TipEject", TraceStatus::progress,
							"name = ", WashSequence.GetName(), 
							", current = ", WashSequence.GetCurrentPosition(), 
							", count = ", WashSequence.GetCount(),
							", maxPos = ", WashSequence.GetMax());
			#endif

			// tip eject CustomStepID
			wcbValue.SetSize(0);
			wcbLabId.SetSize(0);
			GetState(ML_STAR, washSequence, hslTrue, "TipEjectCustomStepID", wcbValue, wcbLabId);
			if (0 < wcbValue.GetSize())
				tipEjectCustomStepID = wcbValue.GetAt(0);

			// eject old needls (to WashSequence)
			StepReturn::Empty(rc);
			onerror goto TipEjectErrorHandler;
			rc = MlStarSteps::StepTipEject_cer(	ML_STAR,
												hslFalse,
												WashSequence,
												SequenceCounting::manually,
												channelPattern,
												ChannelUse::allSequencePositions,
												//errorHandling,
                                    ErrorHandling::MapCustomStepErrorHandling(errorHandling, tipEjectCustomStepID),
                                    tipEjectCustomStepID,
												userResponseTime);
			onerror goto Unexpected;
			if (!StepReturn::Evaluate(ML_STAR, rc, ErrorHandling::MapCustomStepErrorHandling(errorHandling, tipEjectCustomStepID)))
				canceledByTheUser = hslTrue;

			// increment wash sequence 
			washSequence.SetCurrentPosition(currentPos);

			// assign number of used positions from WashSequence to washSequence
			washSequence.SetUsedPositions(WashSequence.GetUsedPositions());

			// check if an error recovery has been canceled by the user
			if (canceledByTheUser)
				// re-throw error
				Error::RaiseLast();

			if (startWash)
			{
				variable index;															// loop counter
				variable size;																// array size
				variable labwareIds[];													// place to hold unique labware ids of the WashSequence (= clipping wash sequence)
				variable labId("");														// labware id
				variable washStation("");												// labware id of a wash station
				variable rinseTime1(rinseTime1Default);							// rinse time [s]
				variable soakTime1(soakTime1Default);								// soak time [s]
				variable flowRate1(flowRate1Default);								// flow rate [ml/s]
				variable rinseTime2(rinseTime2Default);							// rinse time [s]
				variable soakTime2(soakTime2Default);								// soak time [s]
				variable flowRate2(flowRate2Default);								// flow rate [ml/s]
				variable drainingTime(drainingTimeDefault);						// draining time [s]
				variable startWashLiquid(startWashLiquidDefault);				// start wash liquid
            variable startNeedleWashCustomStepID(CustomStepID::stepErrorHandlingDefault);

				// get unique labware ids of the sequence 
				WashSequence.GetLabwareIds(labwareIds);

   			// start needle wash CustomStepID
   			wcbValue.SetSize(0);
   			wcbLabId.SetSize(0);
   			GetState(ML_STAR, washSequence, hslTrue, "StartNeedleWashCustomStepID", wcbValue, wcbLabId);
   			if (0 < wcbValue.GetSize())
   				startNeedleWashCustomStepID = wcbValue.GetAt(0);

				// iterate over unique labware ids of the sequence 
				size = labwareIds.GetSize();
				for (index = 0; index < size; index++)
				{

					labId = labwareIds.GetAt(index);

					// check if the labware is a wash station
					if (IsWashStation(ML_STAR, labId))
					{
						// the labware is a wash station
						washStation = labId;

						// get wash settings
						GetWashParams(ML_STAR, labId, 
										  rinseTime1, soakTime1, flowRate1, 
										  rinseTime2, soakTime2, flowRate2, drainingTime, startWashLiquid);

						// debug
						#ifdef _DEBUG
						FormatTrace("DEBUG", "ML_STAR.StartNeedleWash", TraceStatus::progress,
										"washStation = ", washStation, 
										", rinseTime1 = ", rinseTime1,
										", soakTime1 = ", soakTime1,
										", flowRate1 = ", flowRate1,
										", rinseTime2 = ", rinseTime2,
										", soakTime2 = ", soakTime2,
										", flowRate2 = ", flowRate2,
										", drainingTime = ", drainingTime,
										", startWashLiquid = ", startWashLiquid,
                              ", errorHandling = ");
						#endif

						// wash old needls 
						StepReturn::Empty(rc);
						onerror goto StartNeedleWashErrorHandler;
						rc = MlStarSteps::StepStartNeedleWash_cer(ML_STAR,
																	washStation,
																	rinseTime1,
																	soakTime1,
																	flowRate1,
																	rinseTime2,
																	soakTime2,
																	flowRate2,
																	drainingTime,
																	startWashLiquid,
																	//errorHandling,
                                                   ErrorHandling::MapCustomStepErrorHandling(errorHandling, startNeedleWashCustomStepID),
                                                   startNeedleWashCustomStepID,
																	userResponseTime);
						onerror goto Unexpected;
						if (!StepReturn::Evaluate(ML_STAR, rc, ErrorHandling::MapCustomStepErrorHandling(errorHandling, startNeedleWashCustomStepID)))
							Error::RaiseLast();
					}
				}
			}

			return(rc);

			TipEjectErrorHandler:
			{
				// bind error data
				StepReturn::Bind(rc);
				resume next;
			}

			StartNeedleWashErrorHandler:
			{
				// bind error data
				StepReturn::Bind(rc);
				resume next;
			}

			Unexpected:
			{
				// re-throw error
				Error::RaiseLast();
			}
		}

		function IsWashStation(
			device& ML_STAR,
			variable& labId)
		{
			variable propertyValue("0");			// value of MlStarNeedleWashRack property 
			variable isWashStation(hslFalse);	// if 'true', the given labware is a wash station
			variable propertyKeys[];				// place to hold property keys
			variable propertyValues[];				//	place to hold property values

			propertyKeys.AddAsLast(StringConstants::needleWashRackKey);
			ML_STAR.GetLabwareData(labId, propertyKeys, propertyValues);
			if (0 < propertyValues.GetSize())
			{
				propertyValue = propertyValues.GetAt(0);

				// Check if not emtpy string and get the tip class (tip/needle) from objHxStarTipTypes
				if ( "" != propertyValue )
				{
					// the labware supports the key MlStarNeedleWashRack
					variable tipType(-1), tipClass(-1);
					tipType = IVal(propertyValue);
					tipClass = TipType::objHxStarTipTypes.GetTipClass(tipType);

					// 2009-12-07 cjoerg
					//isWashStation = (TipType::HxStarDevTipClassEnum::tcNeedle == tipClass);
					isWashStation = (TipType::objHxStarTipTypes.HxCoreDevTipClassEnum_tcNeedle == tipClass);
				}
			}
			return(isWashStation);
		}

		function IsNeedleRack(
			device& ML_STAR,
			variable& labId)
		{
			variable propertyValue("0");			// value of MlStarNeedleWashRack property 
			variable isNeedleRack(hslFalse);		// if 'true', the given labware is a needle rack
			variable propertyKeys[];				// place to hold property keys
			variable propertyValues[];				//	place to hold property values

			propertyKeys.AddAsLast(StringConstants::tipRackKey);
			ML_STAR.GetLabwareData(labId, propertyKeys, propertyValues);
			if (0 < propertyValues.GetSize())
			{
				propertyValue = propertyValues.GetAt(0);

				// Check if not emtpy string and get the tip class (tip/needle) from objHxStarTipTypes
				if ( "" != propertyValue )
				{
					// the labware supports the key MlStarTipRack
					variable tipType(-1), tipClass(-1);
					tipType = IVal(propertyValue);
					tipClass = TipType::objHxStarTipTypes.GetTipClass(tipType);

					// 20091207 cjoerg
					//isNeedleRack = (TipType::HxStarDevTipClassEnum::tcNeedle == tipClass);
					isNeedleRack = (TipType::objHxStarTipTypes.HxCoreDevTipClassEnum_tcNeedle == tipClass);
				}
			}
			return(isNeedleRack);
		}

		static function GetCountFilterByRackType(
			device& ML_STAR,
			sequence& washSequence,
			variable needleRackTpye)
		{
			variable count(0);						// count
			variable current(0);						// current position 
			variable currentPosBak(0);				// backup of current position of wash sequence
			variable labId("");						// labware id

			// backup current position of wash sequence
			currentPosBak = washSequence.GetCurrentPosition();

			for (current = washSequence.SetCurrentPosition(1);
					0 < current;
					current = washSequence.Increment(1))
			{
				labId = washSequence.GetLabwareId();
				if (NeedleRackType::washStation == needleRackTpye && 
					 IsWashStation(ML_STAR, labId))
					count++;
				if (NeedleRackType::needleRack == needleRackTpye && 
					 IsNeedleRack(ML_STAR, labId))
					count++;
			}

			// restore current position of wash sequence
			washSequence.SetCurrentPosition(currentPosBak);

			return(count);
		}
	}
	
	// --------------------------------------------------------------------------------------
	// Tip Handling 
	// --------------------------------------------------------------------------------------

	function GetTipHandlingState(
		variable& tcbKey,
		variable& tcbValue)
	{
		// initialize pipetting library
		InitPipettingLibrary();

		// validate input
		if (!PTL_Util::IsString(tcbKey))
			// tcbKey must be a string
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());

		return(TCB::GetState(tcbKey, tcbValue));
	}

	function SetTipHandlingState(
		variable& tcbKey,
		variable& tcbValue)
	{

		// initialize pipetting library
		InitPipettingLibrary();

		// check params to be valid
		if (!PTL_Util::IsString(tcbKey))
			// tcbKey must be a string
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());

		// set pipetting control setting
		return(TCB::SetState(tcbKey, tcbValue));
	}

	function ResetTipHandlingState()
	{
		// initialize pipetting library
		InitPipettingLibrary();
	
		return(TCB::Init());
	}

	function TipEject(
		device& ML_STAR)
	{
		variable rc[];													// step return 
		variable traceSource;										// source for formated trace
		variable traceAction;										// action for formated trace
		sequence defaultWasteSequence;							// default waste, Waste or Waste16
		sequence null;													// null sequence

		// activate error handler
		onerror goto Unexpected;

		// initialize pipetting library
		InitPipettingLibrary();

		// trace start of needle eject
		traceSource = StringTable::Load(IDS::traceSource);
		traceAction = StringTable::Load(IDS::smartStepTipEject);
		FormatTrace(traceSource, traceAction, TraceStatus::start);

		// bind all pipetting control setting which have not yet been set to a reasonable value
		PCB::BindStates(ML_STAR);

		// select a default waste
		PCB::SelectDefaultWaste(ML_STAR, defaultWasteSequence);

		// backup default waste
		PCB::BackupSequences(ML_STAR, null, null, null, defaultWasteSequence, "TCB");

		// initialize pipetting device
		rc = InitPipettingDevice(ML_STAR, TCB::ErrorHandling, TCB::InitializeCustomStepID);

		// eject tips
		rc = TCB::TipEject(ML_STAR);

		// trace completion of tip eject
		FormatTrace(traceSource, traceAction, TraceStatus::complete);

		return(hslTrue);

		Unexpected:
		{

			// trace completion with error of tip eject
			FormatTrace(traceSource, traceAction, TraceStatus::completeWithError);

			Error::RaiseLast();
		}
	}

	function TipPickup(
		device& ML_STAR,
		sequence& tipPickupSequence)
	{
		variable rc[];													// step return 
		variable traceSource;										// source for formated trace
		variable traceAction;										// action for formated trace
		sequence defaultWasteSequence;							// default waste, Waste or Waste16
		sequence null;													// null sequence
		variable restorePCBControlSettingsAndSequences(hslFalse);// indicates whether to restore PCB control settings and sequences

		// activate error handler
		onerror goto Unexpected;

		// initialize pipetting library
		InitPipettingLibrary();

		// trace start of tip pickup
		traceSource = StringTable::Load(IDS::traceSource);
		traceAction = StringTable::Load(IDS::smartStepTipPickup);
		FormatTrace(traceSource, traceAction, TraceStatus::start);

		// backup the PCB control settings and sequences which are relevant for the reloading procedure
		if (TipPickupSequenceReloadable)
		{
			restorePCBControlSettingsAndSequences = PCB::BackupControlSettingsAndSequences();

			// ba 2002-09-09 begin SCR#558 ML_STAR Smart Step: Tip Pick UP reload fails. (Moved statement 3 lines down)
			// set the PCB control settings and sequences which are relevant for the reloading procedure
			//TCB::SetPCBControlSettingsAndSequences();
			// end
		}

		// bind all pipetting control setting which have not yet been set to a reasonable value
		PCB::BindStates(ML_STAR);

		// select a default waste
		PCB::SelectDefaultWaste(ML_STAR, defaultWasteSequence);

		// backup default waste
		PCB::BackupSequences(ML_STAR, tipPickupSequence, null, null, defaultWasteSequence, "TCB");

		// ba 2002-09-09 begin SCR#558 ML_STAR Smart Step: Tip Pick UP reload fails.
		// set the PCB control settings and sequences which are relevant for the reloading procedure
		if (TipPickupSequenceReloadable)
		{
			TCB::SetPCBControlSettingsAndSequences();
		}
		// end

		// initialize pipetting device
		rc = InitPipettingDevice(ML_STAR, TCB::ErrorHandling, TCB::InitializeCustomStepID);

		// preload tip pickup sequence (if necessary),
		// this is an optimization path to keep pattern matching in sync
		if (PCB::TipPickupSequenceNeedsPreload(tipPickupSequence, TCB::TipPickupSequence17, TCB::TipPickupSequence17, DrivingMode::undefined))
		{
			PCB::ReloadSequences(ML_STAR, tipPickupSequence, null, null, 
										0, 0, DrivingMode::undefined, hslFalse);

			// check if reload of non-driving sequence was canceled by the user
			if (PCB::ReloadWasCanceled(tipPickupSequence, null, null, DrivingMode::undefined))
			{
				// user canceled reload of non-driving sequence,
				Error::Raise(IDE::loadingCanceled, GetFileName(), GetFunctionName(), GetLineNumber());
			}
		}

		// pickup tips
		rc = TCB::TipPickup(ML_STAR, tipPickupSequence);

		//ba 2004-03-01 begin (Unnecessary re-load of Carriers in Smart step 'Tip Pickup')
		/*
		// reload tip sequence
		if (PCB::NeedsReload(tipPickupSequence, null, null,
									0, 0, DrivingMode::undefined, hslFalse))
		{
			PCB::ReloadSequences(ML_STAR, tipPickupSequence, null, null, 
										0, 0, DrivingMode::undefined, hslFalse);

			// check if reload of non-driving sequence was canceled by the user
			if (PCB::ReloadWasCanceled(tipPickupSequence, null, null, DrivingMode::undefined))
			{
				// user canceled reload of non-driving sequence,
				Error::Raise(IDE::loadingCanceled, GetFileName(), GetFunctionName(), GetLineNumber());
			}
		}
		*/
		//end

		// restore the PCB control settings and sequences which are relevant for the reloading procedure
		if (restorePCBControlSettingsAndSequences)
			PCB::RestoreControlSettingsAndSequences();

		// trace completion of tip pickup
		FormatTrace(traceSource, traceAction, TraceStatus::complete);

		return(hslTrue);

		Unexpected:
		{
			// restore the PCB control settings and sequences which are relevant for the reloading procedure
			if (restorePCBControlSettingsAndSequences)
				PCB::RestoreControlSettingsAndSequences();

			// eject pipetting tips (if necessary)
			if (!StepReturn::IsEmpty(rc))
			{
				// keep TipEjectChannelVariable in sync with TipPickupChannelVariable
				TipEjectChannelVariable = TipPickupChannelVariable;
				TipEject(ML_STAR);
			}

			// trace completion with error of tip pickup
			FormatTrace(traceSource, traceAction, TraceStatus::completeWithError);

			Error::RaiseLast();
		}
	}

	namespace TCB
	{

		static function GetState(
			variable& tcbKey,
			variable& tcbValue)
		{
			// initialize output
			tcbValue = 0;
			
			// get value for tip handling control key,
			// switch over TCB entries

			// general settings
			if (tcbKey == "UserResponseTime")
			{
				if (UserResponseTime == Limits::maxTimeInterval)
					tcbValue = hslInfinite;
				else
					tcbValue = UserResponseTime;
				return(hslTrue);
			}
			if (tcbKey == "ErrorHandling")
			{
				tcbValue = ErrorHandling;
				return(hslTrue);
			}
			if (tcbKey == "TipCountingEnabled")
			{
				tcbValue = TipCountingEnabled;
				return(hslTrue);
			}
			if (tcbKey == "TipCountingIdentifier")
			{
				tcbValue = TipCountingIdentifier;
				return(hslTrue);
			}
			if (tcbKey == "InitializeCustomStepID")
			{
				tcbValue = InitializeCustomStepID;
				return(hslTrue);
			}

			// tip pickup settings 
			if (tcbKey == "TipPickupChannelVariable")
			{
				tcbValue = TipPickupChannelVariable;
				return(hslTrue);
			}
			if (tcbKey == "TipPickupSequenceCounting")
			{
				tcbValue = TipPickupSequenceCounting;
				return(hslTrue);
			}
			if (tcbKey == "TipPickupChannelUse")
			{
				tcbValue = TipPickupChannelUse;
				return(hslTrue);
			}
			if (tcbKey == "TipPickupSequenceReloadable")
			{
				tcbValue = TipPickupSequenceReloadable;
				return(hslTrue);
			}
			if (tcbKey == "TipPickupSequenceReducible")
			{
				tcbValue = TipPickupSequenceReducible;
				return(hslTrue);
			}
			if (tcbKey == "TipPickupReverseSequenceCount")
			{
				tcbValue = TipPickupReverseSequenceCount;
				return(hslTrue);
			}
			if (tcbKey == "TipPickupCustomStepID")
			{
				tcbValue = TipPickupCustomStepID;
				return(hslTrue);
			}

			// tip eject settings 
			if (tcbKey == "TipEjectUseDefaultWaste")
			{
				tcbValue = TipEjectUseDefaultWaste;
				return(hslTrue);
			}
			if (tcbKey == "TipEjectChannelVariable")
			{
				tcbValue = TipEjectChannelVariable;
				return(hslTrue);
			}
			if (tcbKey == "TipEjectChannelUse")
			{
				tcbValue = TipEjectChannelUse;
				return(hslTrue);
			}
			if (tcbKey == "TipEjectSequenceCounting")
			{
				tcbValue = TipEjectSequenceCounting;
				return(hslTrue);
			}
			if (tcbKey == "TipEjectWasteDestinationReloadable")
			{
				tcbValue = TipEjectWasteDestinationReloadable;
				return(hslTrue);
			}
			if (tcbKey == "TipEjectWasteDestinationReducible")
			{
				tcbValue = TipEjectWasteDestinationReducible;
				return(hslTrue);
			}
         if (tcbKey == "TipEjectCustomStepID")
			{
				tcbValue = TipEjectCustomStepID;
				return(hslTrue);
			}

			// unknown tcbValue
			Error::Raise(IDE::invalidTCBKey, GetFileName(), GetFunctionName(), GetLineNumber());

			return(hslFalse);
		}

		static function SetState(
			variable& tcbKey,
			variable& tcbValue)
		{
			// set value for tip handling control key,
			// switch over TCB entries

			// general settings 
			if (tcbKey == "UserResponseTime")
			{
				// check tcbValue to be valid
				if (!PTL_Util::IsNumber(tcbValue))
					Error::Raise(IDE::invalidTCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(tcbValue))
					Error::Raise(IDE::invalidTCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set tcbValue 
				if (Limits::maxTimeInterval < tcbValue)
					UserResponseTime = Limits::maxTimeInterval;
				else
					UserResponseTime = tcbValue;
				if (!PTL_Util::IsInteger(UserResponseTime))
					Error::Raise(IDE::invalidTCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				return(hslTrue);
			}
			if (tcbKey == "ErrorHandling")
			{
				// check tcbValue to be valid
				if (!PTL_Util::IsNumber(tcbValue))
					Error::Raise(IDE::invalidErrorHandling, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(tcbValue))
					Error::Raise(IDE::invalidErrorHandling, GetFileName(), GetFunctionName(), GetLineNumber());
				if (tcbValue < ErrorHandling::first || ErrorHandling::last < tcbValue)
					Error::Raise(IDE::invalidErrorHandling, GetFileName(), GetFunctionName(), GetLineNumber());

				// set tcbValue 
				ErrorHandling = tcbValue;
				return(hslTrue);
			}
			if (tcbKey == "TipCountingEnabled")
			{
				// check tcbValue to be valid
				if (!PTL_Util::IsNumber(tcbValue))
					Error::Raise(IDE::invalidTCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsFloat(tcbValue))
					Error::Raise(IDE::invalidTCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set tcbValue 
				TipCountingEnabled = tcbValue;
				return(hslTrue);
			}
			if (tcbKey == "TipCountingIdentifier")
			{
				// check tcbValue to be valid
				if (!PTL_Util::IsString(tcbValue))
					Error::Raise(IDE::invalidTipCountingIdentifier, GetFileName(), GetFunctionName(), GetLineNumber());

				// set tcbValue 
				TipCountingIdentifier = tcbValue;
				return(hslTrue);
			}
			if (tcbKey == "InitializeCustomStepID")
			{
				// check tcbValue to be valid
				if (!PTL_Util::IsInteger(tcbValue))
					Error::Raise(IDE::invalidTCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set tcbValue 
				InitializeCustomStepID = tcbValue;
				return(hslTrue);
			}

			// tip pickup settings 
			if (tcbKey == "TipPickupChannelVariable")
			{
				// check tcbValue to be valid
				if (!PTL_Util::IsString(tcbValue))
					Error::Raise(IDE::invalidTCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set tcbValue 
				TipPickupChannelVariable = tcbValue;
				// keep TipEjectChannelVariable in sync with TipPickupChannelVariable
				TipEjectChannelVariable = tcbValue;
				return(hslTrue);
			}
			if (tcbKey == "TipPickupSequenceCounting")
			{
				// check tcbValue to be valid
				if (!PTL_Util::IsNumber(tcbValue))
					Error::Raise(IDE::invalidSequenceCounting, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(tcbValue))
					Error::Raise(IDE::invalidSequenceCounting, GetFileName(), GetFunctionName(), GetLineNumber());
				if (tcbValue < SequenceCounting::first || SequenceCounting::last < tcbValue)
					Error::Raise(IDE::invalidSequenceCounting, GetFileName(), GetFunctionName(), GetLineNumber());

				// set tcbValue 
				TipPickupSequenceCounting = tcbValue;
				return(hslTrue);
			}
			if (tcbKey == "TipPickupChannelUse")
			{
				// check tcbValue to be valid
				if (!PTL_Util::IsNumber(tcbValue))
					Error::Raise(IDE::invalidChannelUse, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(tcbValue))
					Error::Raise(IDE::invalidChannelUse, GetFileName(), GetFunctionName(), GetLineNumber());
				if (tcbValue < ChannelUse::first || ChannelUse::last < tcbValue)
					Error::Raise(IDE::invalidChannelUse, GetFileName(), GetFunctionName(), GetLineNumber());

				// set tcbValue 
				TipPickupChannelUse = tcbValue;
				return(hslTrue);
			}
			if (tcbKey == "TipPickupSequenceReloadable")
			{
				// check tcbValue to be valid
				if (!PTL_Util::IsNumber(tcbValue))
					Error::Raise(IDE::invalidTCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsFloat(tcbValue))
					Error::Raise(IDE::invalidTCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set tcbValue 
				TipPickupSequenceReloadable = tcbValue;
				return(hslTrue);
			}
			if (tcbKey == "TipPickupSequenceReducible")
			{
				// check tcbValue to be valid
				if (!PTL_Util::IsNumber(tcbValue))
					Error::Raise(IDE::invalidTCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsFloat(tcbValue))
					Error::Raise(IDE::invalidTCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set tcbValue 
				TipPickupSequenceReducible = tcbValue;
				return(hslTrue);
			}
			if (tcbKey == "TipPickupReverseSequenceCount")
			{
				// check tcbValue to be valid
				if (!PTL_Util::IsNumber(tcbValue))
					Error::Raise(IDE::invalidTCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(tcbValue))
					Error::Raise(IDE::invalidTCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsNegative(tcbValue))
					Error::Raise(IDE::invalidTCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set tcbValue 
				TipPickupReverseSequenceCount = tcbValue;
				return(hslTrue);
			}
			if (tcbKey == "TipPickupCustomStepID")
			{
				// check tcbValue to be valid
				if (!PTL_Util::IsInteger(tcbValue))
					Error::Raise(IDE::invalidTCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set tcbValue 
				TipPickupCustomStepID = tcbValue;
				return(hslTrue);
			}

			// tip eject settings 
			if (tcbKey == "TipEjectUseDefaultWaste")
			{
				// check tcbValue to be valid
				if (!PTL_Util::IsNumber(tcbValue))
					Error::Raise(IDE::invalidTCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(tcbValue))
					Error::Raise(IDE::invalidTCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (tcbValue < 0 || 1 < tcbValue)
					Error::Raise(IDE::invalidTCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set tcbValue 
				TipEjectUseDefaultWaste = tcbValue;
				return(hslTrue);
			}
			if (tcbKey == "TipEjectChannelVariable")
			{
				// check tcbValue to be valid
				if (!PTL_Util::IsString(tcbValue))
					Error::Raise(IDE::invalidTCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set tcbValue 
				TipEjectChannelVariable = tcbValue;
				return(hslTrue);
			}
			if (tcbKey == "TipEjectChannelUse")
			{
				// check tcbValue to be valid
				if (!PTL_Util::IsNumber(tcbValue))
					Error::Raise(IDE::invalidChannelUse, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(tcbValue))
					Error::Raise(IDE::invalidChannelUse, GetFileName(), GetFunctionName(), GetLineNumber());
				if (tcbValue < ChannelUse::first || ChannelUse::last < tcbValue)
					Error::Raise(IDE::invalidChannelUse, GetFileName(), GetFunctionName(), GetLineNumber());

				// set tcbValue 
				TipEjectChannelUse = tcbValue;
				return(hslTrue);
			}
			if (tcbKey == "TipEjectSequenceCounting")
			{
				// check tcbValue to be valid
				if (!PTL_Util::IsNumber(tcbValue))
					Error::Raise(IDE::invalidSequenceCounting, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!PTL_Util::IsInteger(tcbValue))
					Error::Raise(IDE::invalidSequenceCounting, GetFileName(), GetFunctionName(), GetLineNumber());
				if (tcbValue < SequenceCounting::first || SequenceCounting::last < tcbValue)
					Error::Raise(IDE::invalidSequenceCounting, GetFileName(), GetFunctionName(), GetLineNumber());

				// set tcbValue 
				TipEjectSequenceCounting = tcbValue;
				return(hslTrue);
			}
			if (tcbKey == "TipEjectWasteDestinationReloadable")
			{
				// check tcbValue to be valid
				if (!PTL_Util::IsNumber(tcbValue))
					Error::Raise(IDE::invalidTCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsFloat(tcbValue))
					Error::Raise(IDE::invalidTCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set tcbValue 
				TipEjectWasteDestinationReloadable = tcbValue;
				return(hslTrue);
			}
			if (tcbKey == "TipEjectWasteDestinationReducible")
			{
				// check tcbValue to be valid
				if (!PTL_Util::IsNumber(tcbValue))
					Error::Raise(IDE::invalidTCBValue, GetFileName(), GetFunctionName(), GetLineNumber());
				if (PTL_Util::IsFloat(tcbValue))
					Error::Raise(IDE::invalidTCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set tcbValue 
				TipEjectWasteDestinationReducible = tcbValue;
				return(hslTrue);
			}
			if (tcbKey == "TipEjectCustomStepID")
			{
				// check tcbValue to be valid
				if (!PTL_Util::IsInteger(tcbValue))
					Error::Raise(IDE::invalidTCBValue, GetFileName(), GetFunctionName(), GetLineNumber());

				// set tcbValue 
				TipEjectCustomStepID = tcbValue;
				return(hslTrue);
			}

			// unknown tcbKey
			Error::Raise(IDE::invalidTCBKey, GetFileName(), GetFunctionName(), GetLineNumber());

			return(hslFalse);
		}

		static function Init()
		{
			variable channel;													// loop counter
			sequence null;														// null sequence

			// general settings 

			UserResponseTime = Limits::maxTimeInterval;				// user response time [s]
			ErrorHandling = ErrorHandling::continue;					// error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
			TipCountingEnabled = hslFalse;								// tip counting enabled flag
			TipCountingIdentifier = StringConstants::tipCountingId;// tip count identifier
         InitializeCustomStepID = CustomStepID::stepErrorHandlingDefault;

			// tip pickup settings 

			TipPickupSequence = null;										// tip pickup sequence
			TipPickupChannelVariable = Limits::channelVariable16;	// channel variable (0 = unused, 1 = used)
			TipPickupSequenceCounting = SequenceCounting::manually;// sequence counting (0 = manually, 1 = automatic)
			TipPickupChannelUse = ChannelUse::allSequencePositions;// channel use (1 = all sequence positions, 2 = channel pattern)
			TipPickupSequenceReloadable = hslTrue;						// sequence reloadable flag 
			TipPickupSequenceReducible = hslTrue;						// sequence reducible flag 
			TipPickupReverseSequenceCount = Limits::reverseSequenceCount;// count of reverse tip pickup sequence
         TipPickupCustomStepID = CustomStepID::stepErrorHandlingDefault;

			// tip eject settings 

			TipEjectUseDefaultWaste = hslTrue;							// indicates whether to use the default waste (0 = off, 1 = on)
			TipEjectWasteDestination = null;								// tip eject sequence
			TipEjectChannelVariable = Limits::channelVariable16;	// channel variable (0 = unused, 1 = used)
			TipEjectChannelUse = ChannelUse::allSequencePositions;// channel use (1 = all sequence positions, 2 = channel pattern)
			TipEjectSequenceCounting = SequenceCounting::manually;// sequence counting (0 = manually, 1 = automatic)
			TipEjectWasteDestinationReloadable = hslFalse;			// waste destination reloadable flag 
			TipEjectWasteDestinationReducible = hslFalse;			// waste destination reducible flag 
         TipEjectCustomStepID = CustomStepID::stepErrorHandlingDefault;

			// 
			TipPickupSequence17 = null;
			for (channel = 0; channel <= Limits::channelUpperBound; channel++)
				TipPickupSequence17.Add("", "");
			TipPickupSequence17.SetCount(TipPickupSequence17.GetTotal());
			TipPickupSequence17.SetCurrentPosition(1);
			TipPickupSequence17.SetMax(TipPickupSequence17.GetTotal());

			return(hslTrue);
		}

		static function Dump()
		{
			#ifdef _DEBUG
			variable source;
			variable action;
			variable userResponseTime;

			source = "DEBUG";
			action = GetFunctionName();

			userResponseTime = UserResponseTime;
			if (Limits::maxTimeInterval == UserResponseTime)
				userResponseTime = "infinite";

			// general settings 
			FormatTrace(source, action, TraceStatus::progress, "UserResponseTime = ", userResponseTime);
			FormatTrace(source, action, TraceStatus::progress, "ErrorHandling = ", ErrorHandling::AsString(ErrorHandling));
			FormatTrace(source, action, TraceStatus::progress, "TipCountingEnabled = ", TipCountingEnabled);
			FormatTrace(source, action, TraceStatus::progress, "TipCountingIdentifier = ", TipCountingIdentifier);
         FormatTrace(source, action, TraceStatus::progress, "InitializeCustomStepID = ", InitializeCustomStepID);

			// tip pickup settings 
			FormatTrace(source, action, TraceStatus::progress, "TipPickupSequence.name = ", TipPickupSequence.GetName());
			FormatTrace(source, action, TraceStatus::progress, "TipPickupSequence.current = ", TipPickupSequence.GetCurrentPosition());
			FormatTrace(source, action, TraceStatus::progress, "TipPickupSequence.count = ", TipPickupSequence.GetCount());
			FormatTrace(source, action, TraceStatus::progress, "TipPickupSequence.total = ", TipPickupSequence.GetTotal());
			FormatTrace(source, action, TraceStatus::progress, "TipPickupSequence.maxPos = ", TipPickupSequence.GetMax());
			FormatTrace(source, action, TraceStatus::progress, "TipPickupChannelVariable = ", TipPickupChannelVariable);
			FormatTrace(source, action, TraceStatus::progress, "TipPickupSequenceCounting = ", SequenceCounting::AsString(TipPickupSequenceCounting));
			FormatTrace(source, action, TraceStatus::progress, "TipPickupChannelUse = ", ChannelUse::AsString(TipPickupChannelUse));
			FormatTrace(source, action, TraceStatus::progress, "TipPickupSequenceReloadable = ", TipPickupSequenceReloadable);
			FormatTrace(source, action, TraceStatus::progress, "TipPickupSequenceReducible = ", TipPickupSequenceReducible);
			FormatTrace(source, action, TraceStatus::progress, "TipPickupReverseSequenceCount = ", TipPickupReverseSequenceCount);
         FormatTrace(source, action, TraceStatus::progress, "TipPickupCustomStepID = ", TipPickupCustomStepID);

			// tip eject settings 
			FormatTrace(source, action, TraceStatus::progress, "TipEjectUseDefaultWaste = ", TipEjectUseDefaultWaste);
			FormatTrace(source, action, TraceStatus::progress, "TipEjectWasteDestination.name = ", TipEjectWasteDestination.GetName());
			FormatTrace(source, action, TraceStatus::progress, "TipEjectWasteDestination.current = ", TipEjectWasteDestination.GetCurrentPosition());
			FormatTrace(source, action, TraceStatus::progress, "TipEjectWasteDestination.count = ", TipEjectWasteDestination.GetCount());
			FormatTrace(source, action, TraceStatus::progress, "TipEjectWasteDestination.total = ", TipEjectWasteDestination.GetTotal());
			FormatTrace(source, action, TraceStatus::progress, "TipEjectWasteDestination.maxPos = ", TipEjectWasteDestination.GetMax());
			FormatTrace(source, action, TraceStatus::progress, "TipEjectChannelVariable = ", TipEjectChannelVariable);
			FormatTrace(source, action, TraceStatus::progress, "TipEjectChannelUse = ", ChannelUse::AsString(TipEjectChannelUse));
			FormatTrace(source, action, TraceStatus::progress, "TipEjectSequenceCounting = ", SequenceCounting::AsString(TipEjectSequenceCounting));
			FormatTrace(source, action, TraceStatus::progress, "TipEjectWasteDestinationReloadable = ", TipEjectWasteDestinationReloadable);
			FormatTrace(source, action, TraceStatus::progress, "TipEjectWasteDestinationReducible = ", TipEjectWasteDestinationReducible);
         FormatTrace(source, action, TraceStatus::progress, "TipEjectCustomStepID = ", TipEjectCustomStepID);
			#endif
		}

		function TipPickup(
			device& ML_STAR,
			sequence& tipPickupSequence)
		{
			variable rc[];									// step return 
			variable copyCount(0);						// number of positions to copy
			variable currentPos(0);						// current position
			variable numberOfActiveChannels(0);		// number of active channels
			variable availablePositions(0);			// number of available positions 
			variable maxPositionsPerStep(0);			// max number of positions per step
			variable usedPositions(0);					// number of used positions 
			sequence reverseTipPickupSequence;		// place to hold reverses order of positions of the tip pickup sequence
			variable channelPattern("");				// tip pickup channel pattern
			variable canceledByTheUser(hslFalse);	// indicates whether an error recovery has been canceled by the user

			// activate error handler
			onerror goto Unexpected;

			// pickup new tips
			// Remark:
			// To keep the shape of the tip pickup sequence optimal if tips are used in 
			// the error handling, the tip pickup sequence is partially reversed. The 
			// first copyCount positions are copied from the begin of the original tip 
			// pickup sequence and the remaining TipPickupReverseSequenceCount are 
			// copied in reverse order from the end of the original tip pickup sequence.

			// determine tip pickup constraints 
			numberOfActiveChannels = NumberOfActiveChannels(TipPickupChannelVariable);
			maxPositionsPerStep = tipPickupSequence.GetMax();
			currentPos = tipPickupSequence.GetCurrentPosition();
			if (0 < currentPos)
				availablePositions = tipPickupSequence.GetCount() - currentPos + 1;
			copyCount = PTL_Util::Min(numberOfActiveChannels, PTL_Util::Min(maxPositionsPerStep, availablePositions));

			// reverse tip pickup sequence
			ReverseSequence(tipPickupSequence, reverseTipPickupSequence, 
								 tipPickupSequence.GetCurrentPosition(), copyCount, TipPickupReverseSequenceCount);

			// debug
			#ifdef _DEBUG
			FormatTrace("DEBUG", "ML_STAR.TipPickUp", TraceStatus::progress,
							"name = ", tipPickupSequence.GetName(), 
							", current = ", tipPickupSequence.GetCurrentPosition(), 
							", count = ", tipPickupSequence.GetCount(),
							", maxPos = ", tipPickupSequence.GetMax());
			#endif

			// pickup new tips (from reverseTipPickupSequence)
			onerror goto TipPickUpErrorHandler;
			rc = MlStarSteps::StepTipPickup_cer(ML_STAR,
												reverseTipPickupSequence,
												TipPickupSequenceCounting,
												TipPickupChannelVariable,
												TipPickupChannelUse,
												//>> 20060519
												//ErrorHandling,
												PCB::MapErrorHandlingContinue(ErrorHandling, TipPickupCustomStepID),
												//<< 20060519
                                    TipPickupCustomStepID,
												UserResponseTime);
			onerror goto Unexpected;
			if (!StepReturn::Evaluate(ML_STAR, rc, PCB::MapErrorHandlingContinue(ErrorHandling, TipPickupCustomStepID)))
				canceledByTheUser = hslTrue;

			// update tip presence
			//PCB::SetTipPresence(TipPickupChannelVariable, 
			//						  reverseTipPickupSequence.GetUsedPositions(), hslTrue);

			// increment tip pickup sequence 
			if (SequenceCounting::manually == TipPickupSequenceCounting)
				// manual sequence counting
				tipPickupSequence.Increment(copyCount);

			// get number of used positions and update the count of the tip pickup sequence
			usedPositions = reverseTipPickupSequence.GetUsedPositions();
			if (copyCount < usedPositions)
				tipPickupSequence.SetCount(tipPickupSequence.GetCount() - usedPositions + copyCount);

			// set number of used positions of tipPickupSequence
			tipPickupSequence.SetUsedPositions(usedPositions);

			// if tip counting is enabled, write indexes of tipPickupSequence to file
			if (TipCountingEnabled)
				TipCount::Write2(tipPickupSequence, TipCountingIdentifier, ML_STAR);

			// check if an error recovery has been canceled by the user
			if (canceledByTheUser)
				// re-throw error
				Error::RaiseLast();
			return(rc);

			TipPickUpErrorHandler:
			{
				// if tip counting is enabled, write indexes of tipPickupSequence to file
				if (TipCountingEnabled)
					TipCount::Write2(tipPickupSequence, TipCountingIdentifier, ML_STAR);

				// bind error data
				StepReturn::Bind(rc);
				resume next;
			}

			Unexpected:
			{
				// if tip counting is enabled, write indexes of tipPickupSequence to file
				if (TipCountingEnabled)
					TipCount::Write2(tipPickupSequence, TipCountingIdentifier, ML_STAR);

				// re-throw error
				Error::RaiseLast();
			}
		}

		function TipEject(
			device& ML_STAR)
		{
			variable rc[];																// step return 

			// ba 2003-05-16 begin
			// The max number of positions of the tip eject waste destination has been 
			// aligned with the tip pickup the aspirate and the dispense sequence to 
			// prevent errors when redespesing the rest volume into the waste. So we have 
			// to re-align the max number of positions of the tip eject waste destination.
			AlignSequences(hslTrue, TipEjectWasteDestination, 1);

			#ifdef _DEBUG
			FormatTrace("DEBUG", "ML_STAR.TipEject", TraceStatus::progress,
							"name = ", TipEjectWasteDestination.GetName(), 
							", current = ", TipEjectWasteDestination.GetCurrentPosition(), 
							", count = ", TipEjectWasteDestination.GetCount(),
							", maxPos = ", TipEjectWasteDestination.GetMax());
			#endif
			// end

			// eject the tips
			onerror goto TipEjectErrorHandler;
			rc = MlStarSteps::StepTipEject_cer(	ML_STAR,
												TipEjectUseDefaultWaste,
												TipEjectWasteDestination,
												TipEjectSequenceCounting,
												TipEjectChannelVariable,
												TipEjectChannelUse,
												//ErrorHandling,
                                    ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, TipEjectCustomStepID),
                                    TipEjectCustomStepID,
												UserResponseTime);
			onerror goto 0;
			if (!StepReturn::Evaluate(ML_STAR, rc, ErrorHandling::MapCustomStepErrorHandling(ErrorHandling, TipEjectCustomStepID)))
				Error::RaiseLast();

			// update tip presence
			//PCB::SetTipPresence(TipEjectChannelVariable, 
			//						  StrGetLength(TipEjectChannelVariable), hslFalse);

			return(rc);

			TipEjectErrorHandler:
			{
				// bind error data
				StepReturn::Bind(rc);
				resume next;
			}
		}

		static function SetPCBControlSettingsAndSequences()
		{
			// general settings 

			PTL::UserResponseTime = UserResponseTime;
			PTL::ErrorHandling = ErrorHandling;
			PTL::TipCountingEnabled = TipCountingEnabled;
			PTL::TipCountingIdentifier = TipCountingIdentifier;

			// tip pickup settings 

			PTL::TipPickupSequence = TipPickupSequence;
			PTL::TipPickupChannelVariable = TipPickupChannelVariable;
			PTL::TipPickupSequenceCounting = TipPickupSequenceCounting;
			PTL::TipPickupChannelUse = TipPickupChannelUse;
			PTL::TipPickupSequenceReloadable = TipPickupSequenceReloadable;
			PTL::TipPickupSequenceReducible = TipPickupSequenceReducible;
			PTL::TipPickupReverseSequenceCount = TipPickupReverseSequenceCount;

			// tip eject settings 

			PTL::TipEjectUseDefaultWaste = TipEjectUseDefaultWaste;
			PTL::TipEjectWasteDestination = TipEjectWasteDestination;
			PTL::TipEjectChannelVariable = TipEjectChannelVariable;
			PTL::TipEjectChannelUse = TipEjectChannelUse;
			PTL::TipEjectSequenceCounting = TipEjectSequenceCounting;
			PTL::TipEjectWasteDestinationReloadable = TipEjectWasteDestinationReloadable;
			PTL::TipEjectWasteDestinationReducible = TipEjectWasteDestinationReducible;

			// initialize settings 
			PTL::InitializeChannelVariable = StrLeft("1111111111111111", StrGetLength(TipPickupChannelVariable));
			PTL::InitializeWasteDestinationReloadable = hslFalse;

			// aspirate settings 
			PTL::AspirateSequenceReloadable = hslFalse;
			PTL::AspirateChannelVariable = TipPickupChannelVariable;

			// dispense settings 
			PTL::DispenseSequenceReloadable = hslFalse;
			PTL::DispenseChannelVariable = TipPickupChannelVariable;
		}
	}

	// --------------------------------------------------------------------------------------
	// Error Handling
	// --------------------------------------------------------------------------------------

	static function RaiseRuntimeError(
		variable errorId,
		variable stepNameStrTblId,
		variable errorDescriptionStrTblId,
		variable& moduleName)
	{

		// check params to be valid
		if (!PTL_Util::IsNumber(errorId))
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());
		if (!PTL_Util::IsInteger(errorId))
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());
		if (!PTL_Util::IsNumber(stepNameStrTblId))
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());
		if (!PTL_Util::IsInteger(stepNameStrTblId))
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());
		if (PTL_Util::IsNegative(stepNameStrTblId))
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());
		if (!PTL_Util::IsNumber(errorDescriptionStrTblId))
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());
		if (!PTL_Util::IsInteger(errorDescriptionStrTblId))
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());
		if (PTL_Util::IsNegative(errorDescriptionStrTblId))
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());
		if (!PTL_Util::IsString(moduleName))
			Error::Raise(IDE::invalidParameter, GetFileName(), GetFunctionName(), GetLineNumber());

		err.Raise(errorId, 
					 StringTable::Load(IDS::smartStepRuntimeError) + 
					 StringTable::Load(IDS::openingBracket) + 
					 StringTable::Load(stepNameStrTblId) + 
					 StringTable::Load(IDS::closingBracket) + 
					 StringTable::Load(IDS::period) + 
					 StringConstants::crlf +
					 StringTable::Load(errorDescriptionStrTblId),
					 moduleName + GetLanguage() + StringConstants::helpFileExt);
	}
}

#endif
// $$author=wbarmettler$$valid=1$$time=2017-03-14 13:14$$checksum=df89673d$$length=088$$