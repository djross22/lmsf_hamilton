// ======================================================================
// Implementation of Hamilton DriverTools used in HSL libraries
//
// Copyright(C) by HAMILTON Bonaduz AG, CH-7402 Bonaduz.
// All rights reserved.
// ======================================================================
//
// Modification History
//      2012-10-05, v1.0: Bernd Huf,          created
//      2012-12-19, v1.1: Bernd Huf,          changed name and namespace to Hamilton DriverTools
//      2013-02-04, v1.2: Bernd Huf,          new functions:
//                                            - StatusTraceArray
//                                            - Uppercase, Lowercase
//                                            enabled function:
//                                            - FillLeft, FillRight
//                                            - TrimLeft, TrimRight
//                                            - IsDigit
//      2013-04-04, v1.3: Bernd Huf,          validated version
//      2013-04-10, v1.4: Bernd Huf,          new function:
//                                            - Delay
//                                            fixed bug:
//                                            - set function _CheckInteger to private
//      2013-04-22, v1.5: Bernd Huf,          new functions:
//                                            - TraceArrayFaceToFace
//                                            - FindInArray
//                                            - _ExtractFunctionName
//                                            - _TrimLeft
//                                            - _TrimRight
//                                            fixed bug:
//                                            - function _FillRight
//                                            - function TraceArrayFaceToFace checking of trace level added
//                                            new functionality:
//                                            - all "external" functions (no Checkxx functions) trace parameter errors with library context
//      2013-07-18  v1.6  Daniel Kaufmann     added function: 
//                                            - CheckSimulationMode
//                                            - CheckInitialization
//      2013-08-12, v1.7: Bernd Huf           new function
//                                            - CheckArrayEquality to check if two arrays are equal
//                                            fixed bugs:
//                                            - set return value of function CheckString to ASWGLOBAL::BOOL-constants instead of hsl-constants
//                                            - set return value of function CheckFloatRange to ASWGLOBAL::BOOL-constants instead of hsl-constants
//                                            - function CheckIntegerValue: changed parameter order to match other functions
//                                            - removed unnecessary private function '_CheckFloatRange'
//                                            - removed unnecessary private function '_IsDigit'
//      2014-03-26, v1.8: Bernd Huf           fixed bug:
//                                            - function TraceArrayFaceToFace: array ref. out of bounds
//      2014-03-26, v1.9: Bernd Huf           new function:
//                                            - CheckFloatFactorRange (check float values for factors, e.g. 0.25, 0.5, 0.75, ... and range)
//                                            fixed bug:
//                                            - function CheckFloatValue (mixed up variables)
//      2014-08-08, v2.0: Bernd Huf           new function
//                                            - Replace to replace all occurences of a substring in a string with another string
//      2014-09-02, v2.1  Daniel Kaufmann     added function CheckChannelPattern
//      2014-11-03, v2.2  Bernd Huf           fixed parameter error in function CheckFloatValue (implementation part)
//      2015-01-07, v2.3  Bernd Huf           changed function TraceArrayFaceToFace to omit the numbering in case no description is given
//      2015-01-26, v2.5  Bernd Huf           removed initialization of variables with function returns due to possible problems with scheduler
//      2015-01-28, v2.6  Bernd Huf           new function:
//                                            - FloatToString (handle tracing of float values)
//      2015-02-12, v2.7  Bernd Huf           new functions:
//                                            - CheckArraySize (check array for size)
//                                            - CheckArrayType (check all array elements for same type)
//                                            bugfix:
//                                            - removed trace entries with HSL TOOLS instead of calling library name
//                                            update:
//                                            - StatusTraceArray: trace info in case of empty array
//      2015-03-09, v2.8  DKaufmann           new function:
//                                            - _ConvertToString (converts all types to string)
//                                            - CheckTypRange (Check all types for type and range und sets default in error case)
//                                            - static testMethod() library function tests
//      2015-05-01, v2.9  DKaufmann           BugFix in CheckTypRange
//      2015-05-21, v3.0  Bernd Huf           new function:
//                                            - CheckStringLength (only accept strings in a defined min/max length)
//                                            - CheckArraysForSameSize (only accept arrays of the same size)
//                                            - added enum TYPE with speaking names
//      2015-06-23, v3.1  Bernd Huf           new function:
//                                            - CheckIntegerFactorRange (check integer values for factors, e.g. 0, 5, 10, ... and range)
//                                            - extended private function _CheckTraceStrings with parameter FunctionName to trace better
//      2015-09-23  v3.2  DKaufmann           new functionality
//                                            - Set/Get IniFile Values (DLL)
//      2016-01-12  v3.3  DKaufmann           files validated
// ======================================================================

#ifndef __Hamilton_DriverTools_hsl__
  #define __Hamilton_DriverTools_hsl__ 1

  #ifndef __TraceLevel_hsl__
    #include "ASWStandard\\TraceLevel\\TraceLevel.hsl"
  #endif

  #ifndef __ASWGLOBAL_hsl__
    #include "ASWStandard\\ASWGlobal\\ASWGlobal.hsl"
  #endif

  namespace Hamilton_DriverTools
  {
    namespace ACTION
    {
      const variable START                (1);
      const variable COMPLETE             (2);
      const variable ERROR                (3);
      const variable PROGRESS             (4);
      const variable COMPLETE_WITH_ERROR  (5);
    }

    namespace VALUE_RANGE
    {
      const variable POSITIVE_ZERO        (0);
      const variable POSITIVE             (1);
      const variable NEGATIVE_ZERO        (2);
      const variable NEGATIVE             (3);
    }

    namespace DATA_TYPE
    {
      const variable INTEGER                ("i");
      const variable FLOAT                  ("f");
      const variable STRING                 ("s");
    }

    namespace TYPE
    {
      const variable INTEGER                ("integer");
      const variable FLOAT                  ("float");
      const variable STRING                 ("string");
    }

    const static variable Hamilton_DriverTools_ModuleName           ("Hamilton DriverTools");
    const static variable NetDriverTools                            ("Hamilton.HSL.DriverTools");

    // declarations of public functions 
    // Trace functions
    function StatusTrace(variable i_intState,
                         variable i_intTraceLevel,
                         variable i_strMessage,
                         variable i_strFunctionName,
                         variable i_intReferenceTraceLevel,
                         variable i_strReferenceModuleName) variable;

    function StatusTraceArray(variable i_intState,
                              variable i_intTraceLevel,
                              variable i_arrvarToTrace[],
                              variable i_strDescription,
                              variable i_strFunctionName,
                              variable i_intReferenceTraceLevel,
                              variable i_strReferenceModuleName) variable;

    function ExtractFunctionName(variable i_strFunctionName,
                                 variable& o_strExtractedFunctionName,
                                 variable i_strReferenceModuleName) variable;

    function TraceArrayFaceToFace(variable i_intState,
                                  variable i_intTraceLevel,
                                  variable i_strDescription_1,
                                  variable i_arrvarArray_1[],
                                  variable i_strDescription_2,
                                  variable i_arrvarArray_2[],
                                  variable i_strFunctionName,
                                  variable i_intReferenceTraceLevel,
                                  variable i_strReferenceModuleName) variable;

    // Check functions
    function CheckTypeRange(variable i_strType,               //i, s, f
                            variable i_strVariableToCheck,    // variable name
                            variable& io_varVariable,         // variable to check
                            variable i_varMin,                // min value(f, i) min length (s)
                            variable i_varMax,                // max value(f, i) max length (s)
                            variable i_varDefault,            // default value on error
                            variable i_strFunctionName,       // calling funcktion
                            variable i_strReferenceModuleName) variable; //calling module

    function CheckInteger(variable i_varVariableToCheck,
                          variable i_strTraceEntry,
                          variable i_strFunctionName,
                          variable i_strReferenceModuleName) variable;

    function CheckIntegerRange(variable i_varVariableToCheck,
                               variable i_strTraceEntry,
                               variable i_intMin,
                               variable i_intMax,
                               variable i_strFunctionName,
                               variable i_strReferenceModuleName) variable;

    function CheckIntegerInArray(variable i_varVariableToCheck,
                                 variable i_strTraceEntry,
                                 variable i_arrintAllowedValues[],
                                 variable i_strFunctionName,
                                 variable i_strReferenceModuleName) variable;

    function CheckIntegerValue(variable i_varVariableToCheck,
                               variable i_strTraceEntry,
                               variable i_intValueRange,
                               variable i_strFunctionName,
                               variable i_strReferenceModuleName) variable;

    function CheckIntegerFactorRange(variable i_varVariableToCheck,
                                     variable i_strTraceEntry,
                                     variable i_intMin,
                                     variable i_intMax,
                                     variable i_intFactor,
                                     variable i_strFunctionName,
                                     variable i_strReferenceModuleName) variable;

    function CheckBool(variable i_varVariableToCheck,
                       variable i_strTraceEntry,
                       variable i_strFunctionName,
                       variable i_strReferenceModuleName) variable;

    function CheckFloat(variable i_varVariableToCheck,
                        variable i_strTraceEntry,
                        variable i_strFunctionName,
                        variable i_strReferenceModuleName) variable;

    function CheckFloatRange(variable i_varVariableToCheck,
                             variable i_strTraceEntry,
                             variable i_fltMin,
                             variable i_fltMax,
                             variable i_strFunctionName,
                             variable i_strReferenceModuleName) variable;

    function CheckFloatValue(variable i_varVariableToCheck,
                             variable i_strTraceEntry,
                             variable i_intValueRange,
                             variable i_strFunctionName,
                             variable i_strReferenceModuleName) variable;

    function CheckFloatFactorRange(variable i_varVariableToCheck,
                                   variable i_strTraceEntry,
                                   variable i_fltMin,
                                   variable i_fltMax,
                                   variable i_fltFactor,
                                   variable i_strFunctionName,
                                   variable i_strReferenceModuleName) variable;

    function CheckString(variable i_varVariableToCheck,
                         variable i_strTraceEntry,
                         variable i_strFunctionName,
                         variable i_strReferenceModuleName) variable;

    function CheckStringLength(variable i_varVariableToCheck,
                               variable i_strTraceEntry,
                               variable i_intLengthMin,
                               variable i_intLengthMax,
                               variable i_strFunctionName,
                               variable i_strReferenceModuleName) variable;

    function CheckChannelPattern(string i_varVariableToCheck,
                                 variable i_strTraceEntry,
                                 variable i_intChannelCount,
                                 variable i_strFunctionName,
                                 variable i_strReferenceModuleName) variable;

    function CheckArrayEquality(variable i_arrvarCheck_1[],
                                variable i_arrvarCheck_2[],
                                variable i_strFunctionName,
                                variable i_strReferenceModuleName) variable;

    function CheckArraysForSameSize(variable i_arrvarCheck_1[],
                                    variable i_arrvarCheck_2[],
                                    variable i_strTraceEntry1,
                                    variable i_strTraceEntry2,
                                    variable i_strFunctionName,
                                    variable i_strReferenceModuleName) variable;

    function CheckArraySize(variable i_arrvarCheck[],
                            variable i_strTraceEntry,
                            variable i_intMinSize,
                            variable i_intMaxSize,
                            variable i_strFunctionName,
                            variable i_strReferenceModuleName) variable;

    function CheckArrayType(variable i_arrvarCheck[],
                            variable i_strTraceEntry,
                            variable i_strType,
                            variable i_strFunctionName,
                            variable i_strReferenceModuleName) variable;

    // String functions
    function ReverseFind(variable i_strStringToParse,
                         variable i_strSubstringToFind,
                         variable i_strFunctionName,
                         variable i_strReferenceModuleName)variable;

    function FillRight(variable i_strStringToFill,
                       variable i_strFillCharacter,
                       variable i_intLength,
                       variable i_strFunctionName,
                       variable i_strReferenceModuleName) variable;

    function FillLeft(variable i_strStringToFill,
                      variable i_strFillCharacter,
                      variable i_intLength,
                      variable i_strFunctionName,
                      variable i_strReferenceModuleName) variable;

    function TrimLeft(variable i_strStringToTrim,
                      variable i_strToRemove,
                      variable i_strFunctionName,
                      variable i_strReferenceModuleName) variable;

    function TrimRight(variable i_strStringToTrim,
                       variable i_strToRemove,
                       variable i_strFunctionName,
                       variable i_strReferenceModuleName) variable;

    function Uppercase(variable i_strStringToChange,
                       variable i_strFunctionName,
                       variable i_strReferenceModuleName) variable;

    function Lowercase(variable i_strStringToChange,
                       variable i_strFunctionName,
                       variable i_strReferenceModuleName) variable;

    function IsDigit(variable i_strCharacter,
                     variable i_strTraceEntry,
                     variable i_strFunctionName,
                     variable i_strReferenceModuleName) variable;

    function Replace(variable i_strToChange,
                     variable i_strToReplace,
                     variable i_strReplaceWith,
                     variable i_strFunctionName,
                     variable i_strReferenceModuleName) variable;

    function FloatToString(variable i_fltValue,
                           variable i_strFunctionName,
                           variable i_strReferenceModuleName) variable;

    // Miscellaneous functions
    function Delay(variable i_fltDelayTime,
                   variable i_strFunctionName,
                   variable i_strReferenceModuleName) variable;

    function FindInArray(variable i_arrvarArrayToCheck[],
                         variable i_varValueToFind,
                         variable i_strFunctionName,
                         variable i_strReferenceModuleName) variable;

    function CheckSimulationMode(variable i_blnReferenceSimulationMode,
                                 variable i_strFunctionName,
                                 variable i_strReferenceModuleName) variable;

    function CheckInitialization(variable i_blnReferenceLibraryInitialized,
                                 variable i_strFunctionName,
                                 variable i_strReferenceModuleName) variable;

    function GetIniFileValue(variable i_strFunctionName,
                             variable i_strReferenceModuleName,
                             variable i_strFilePath,
                             variable i_strSection,
                             variable i_strKey,
                             variable& o_strValue,
                             variable& o_strErrorMessage) variable;

    function SetIniFileValue(variable i_strFunctionName,
                             variable i_strReferenceModuleName,
                             variable i_strFilePath,
                             variable i_strSection,
                             variable i_strKey,
                             variable i_strValue,
                             variable& o_strErrorMessage)variable;

    // declarations of private functions
    private function _CheckBool(variable i_varVariableToCheck,
                                variable i_strTraceEntry,
                                variable i_strFunctionName,
                                variable i_strReferenceModuleName) variable;

    private function _CheckInteger(variable i_varVariableToCheck,
                                   variable i_strTraceEntry,
                                   variable i_strFunctionName,
                                   variable i_strReferenceModuleName) variable;

    private function _CheckIntegerRange(variable i_varVariableToCheck,
                                        variable i_strTraceEntry,
                                        variable i_intMin,
                                        variable i_intMax,
                                        variable i_strFunctionName,
                                        variable i_strReferenceModuleName) variable;

    private function _CheckFloat(variable i_varVariableToCheck,
                                 variable i_strTraceEntry,
                                 variable i_strFunctionName,
                                 variable i_strReferenceModuleName) variable;

    private function _CheckString(variable i_varVariableToCheck,
                                  variable i_strTraceEntry,
                                  variable i_strFunctionName,
                                  variable i_strReferenceModuleName) variable;

    private function _ReverseFind(string i_strStringToParse,
                                  string i_strSubstringToFind) variable;

    private function _CheckTraceStrings(variable i_strReferenceModuleName,
                                        variable i_strReferenceFunctionName,
                                        variable i_strFunctionName) variable;

    private function _FillLeft(string i_strStringToFill,
                               variable i_strFillCharacter,
                               variable i_intLength) variable;

    private function _FillRight(string i_strStringToFill,
                                variable i_strFillCharacter,
                                variable i_intLength) variable;

    private function _TrimLeft(string i_strStringToTrim,
                               string i_strToRemove) variable;

    private function _TrimRight(string i_strStringToTrim,
                                string i_strToRemove) variable;

    private function _ToString(variable i_varValue) variable;

    private function _GetComma() string;

    private function _FindInArray(variable i_arrvarArrayToCheck[],
                                  variable i_varValueToFind) variable;

    private function _ExtractFunctionName(variable i_strFunctionName) variable;

    private function _StringLength(string i_strStringToCheck) variable;

    private function _LongestElementSize(variable i_arrvarToCheck[]) variable;

    private function _ConvertToString(variable i_varVariableToConvert) variable;
    //********************************************************************************
    //* functions
    //********************************************************************************
    static function LibraryTest() void
    {
      variable var;
      var = 4; Trace("StartValue = ", var); CheckTypeRange(DATA_TYPE::INTEGER, "TestValue", var, 0, 10, 5, GetFunctionName(), Hamilton_DriverTools_ModuleName); Trace("Result = ", var);
      var = -10; Trace("StartValue = ", var); CheckTypeRange(DATA_TYPE::INTEGER, "TestValue", var, 0, 10, 5, GetFunctionName(), Hamilton_DriverTools_ModuleName); Trace("Result = ", var);
      var = 25; Trace("StartValue = ", var); CheckTypeRange(DATA_TYPE::INTEGER, "TestValue", var, 0, 10, 5, GetFunctionName(), Hamilton_DriverTools_ModuleName); Trace("Result = ", var);
      var = -0.1; Trace("StartValue = ", var); CheckTypeRange(DATA_TYPE::FLOAT, "TestValue", var, 0, 10, 5, GetFunctionName(), Hamilton_DriverTools_ModuleName); Trace("Result = ", var);
      var = 4.1; Trace("StartValue = ", var); CheckTypeRange(DATA_TYPE::FLOAT, "TestValue", var, 0, 10, 5, GetFunctionName(), Hamilton_DriverTools_ModuleName); Trace("Result = ", var);
      var = 10.5; Trace("StartValue = ", var); CheckTypeRange(DATA_TYPE::FLOAT, "TestValue", var, 0, 10, 5, GetFunctionName(), Hamilton_DriverTools_ModuleName); Trace("Result = ", var);
      var = "OK"; Trace("StartValue = ", var); CheckTypeRange(DATA_TYPE::STRING, "TestValue", var, 1, 10, "default", GetFunctionName(), Hamilton_DriverTools_ModuleName); Trace("Result = ", var);
      var = "too long"; Trace("StartValue = ", var); CheckTypeRange(DATA_TYPE::STRING, "TestValue", var, 1, 3, "default", GetFunctionName(), Hamilton_DriverTools_ModuleName); Trace("Result = ", var);
      var = "short"; Trace("StartValue = ", var); CheckTypeRange(DATA_TYPE::STRING, "TestValue", var, 6, 10, "default", GetFunctionName(), Hamilton_DriverTools_ModuleName); Trace("Result = ", var);

      var = 33; Trace("StartValue = ", var); CheckTypeRange(DATA_TYPE::STRING, "TestValue", var, 6, 10, "default", GetFunctionName(), Hamilton_DriverTools_ModuleName); Trace("Result = ", var);
      var = "25"; Trace("StartValue = ", var); CheckTypeRange(DATA_TYPE::INTEGER, "TestValue", var, 0, 10, 5, GetFunctionName(), Hamilton_DriverTools_ModuleName); Trace("Result = ", var);
      var = 22; Trace("StartValue = ", var); CheckTypeRange(DATA_TYPE::FLOAT, "TestValue", var, 0.0, 10.0, 5.0, GetFunctionName(), Hamilton_DriverTools_ModuleName); Trace("Result = ", var);
      var = "22"; Trace("StartValue = ", var); CheckTypeRange(DATA_TYPE::FLOAT, "TestValue", var, 0.0, 10.0, 5.0, GetFunctionName(), Hamilton_DriverTools_ModuleName); Trace("Result = ", var);
   }
    //----------------------------------------------------------------------------------------------
    // function StatusTrace
    //----------------------------------------------------------------------------------------------
    function StatusTrace(variable i_intState,
                         variable i_intTraceLevel,
                         variable i_strMessage,
                         variable i_strFunctionName,
                         variable i_intReferenceTraceLevel,
                         variable i_strReferenceModuleName) variable
    {
      variable strFunctionName("");

      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "StatusTrace")) return(ASWGLOBAL::BOOL::FALSE);
      strFunctionName = i_strFunctionName + " - " + Hamilton_DriverTools_ModuleName + "::" + _ExtractFunctionName(GetFunctionName());
      if(!_CheckIntegerRange(i_intState, "i_intState", ACTION::START, ACTION::COMPLETE_WITH_ERROR, strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckIntegerRange(i_intTraceLevel, "i_intTraceLevel", TRACE_LEVEL_NONE, TRACE_LEVEL_DEBUG, strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strMessage, "i_strMessage", strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strFunctionName, "i_strFunctionName", strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckIntegerRange(i_intReferenceTraceLevel, "i_intReferenceTraceLevel", TRACE_LEVEL_NONE, TRACE_LEVEL_DEBUG, strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strReferenceModuleName, "i_strReferenceModuleName", strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

      if(i_intTraceLevel <= i_intReferenceTraceLevel)
        FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, i_intState, " ", i_strMessage);
      return(ASWGLOBAL::BOOL::TRUE);
    } // _StatusTrace

    //----------------------------------------------------------------------------------------------
    // function StatusTraceArray
    //----------------------------------------------------------------------------------------------
    function StatusTraceArray(variable i_intState,
                              variable i_intTraceLevel,
                              variable i_arrvarToTrace[],
                              variable i_strDescription,
                              variable i_strFunctionName,
                              variable i_intReferenceTraceLevel,
                              variable i_strReferenceModuleName) variable
    {
      variable intActualPosition, intArraySize, intFillupSize;
      variable strFunctionName("");

      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "StatusTraceArray")) return(ASWGLOBAL::BOOL::FALSE);
      strFunctionName = i_strFunctionName + " - " + Hamilton_DriverTools_ModuleName + "::" + _ExtractFunctionName(GetFunctionName());
      if(!_CheckIntegerRange(i_intState, "i_intState", ACTION::START, ACTION::COMPLETE_WITH_ERROR, strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckIntegerRange(i_intTraceLevel, "i_intTraceLevel", TRACE_LEVEL_NONE, TRACE_LEVEL_DEBUG, strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strDescription, "i_strDescription", strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckIntegerRange(i_intReferenceTraceLevel, "i_intReferenceTraceLevel", TRACE_LEVEL_NONE, TRACE_LEVEL_DEBUG, strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

      if(i_intTraceLevel <= i_intReferenceTraceLevel)
      {
        intArraySize = i_arrvarToTrace.GetSize();
        if(intArraySize >0)
        {
          intFillupSize = _StringLength(IStr(intArraySize));
          for(intActualPosition = 0; intActualPosition < intArraySize; intActualPosition++)
            FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, i_intState,
                        i_strDescription + " [" + _FillLeft(IStr(intActualPosition), "0", intFillupSize) + "] : ",
                        i_arrvarToTrace.GetAt(intActualPosition));
        }
        else
          FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, i_intState,
                      i_strDescription + ": empty array.");
      }
      return(ASWGLOBAL::BOOL::TRUE);
    } // StatusTraceArray

    //----------------------------------------------------------------------------------------------
    // function TraceArrayFaceToFace
    //----------------------------------------------------------------------------------------------
    function TraceArrayFaceToFace(variable i_intState,
                                  variable i_intTraceLevel,
                                  variable i_strDescription_1,
                                  variable i_arrvarArray_1[],
                                  variable i_strDescription_2,
                                  variable i_arrvarArray_2[],
                                  variable i_strFunctionName,
                                  variable i_intReferenceTraceLevel,
                                  variable i_strReferenceModuleName) variable
    {
      variable intActualPosition, intArraySize_1, intArraySize_2, intArraySizeMax, intFillupSize_1, intFillupSize_2, intGapLength;
      variable strFunctionName(""), strToTrace("");

      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "TraceArrayFaceToFace")) return(ASWGLOBAL::BOOL::FALSE);
      strFunctionName = i_strFunctionName + " - " + Hamilton_DriverTools_ModuleName + "::" + _ExtractFunctionName(GetFunctionName());
      if(!_CheckIntegerRange(i_intState, "i_intState", ACTION::START, ACTION::COMPLETE_WITH_ERROR, strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckIntegerRange(i_intTraceLevel, "i_intTraceLevel", TRACE_LEVEL_NONE, TRACE_LEVEL_DEBUG, strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strDescription_1, "i_strDescription_1", strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strDescription_2, "i_strDescription_2", strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckIntegerRange(i_intReferenceTraceLevel, "i_intReferenceTraceLevel", TRACE_LEVEL_NONE, TRACE_LEVEL_DEBUG, strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

      if(i_intTraceLevel > i_intReferenceTraceLevel) return(ASWGLOBAL::BOOL::TRUE);

      // save array size for later usage
      intArraySize_1 = i_arrvarArray_1.GetSize();
      intArraySize_2 = i_arrvarArray_2.GetSize();

      // calculate the size of the position information (example: [001] for array with 100 to 999 elements)
      intFillupSize_1 = _StringLength(IStr(intArraySize_1));
      intFillupSize_2 = _StringLength(IStr(intArraySize_2));

      // in case of empty array, "fake" the entry that is written in this case
      if(intArraySize_1 == 0) i_arrvarArray_1.AddAsLast("empty array");
      if(intArraySize_2 == 0) i_arrvarArray_2.AddAsLast("empty array");

      // check for the longest element in array 1 to calculate the gap to fill up for shorter elements
      intGapLength = _LongestElementSize(i_arrvarArray_1);

      if(intArraySize_1 == 0) i_arrvarArray_1.SetSize(0);
      if(intArraySize_2 == 0) i_arrvarArray_2.SetSize(0);

      if(intGapLength > 0) intGapLength = intGapLength + _StringLength(i_strDescription_1) + intFillupSize_1;

      if(i_strDescription_1 != "") intGapLength = intGapLength + 8;

      if(intArraySize_1 > intArraySize_2) intArraySizeMax = intArraySize_1; else intArraySizeMax = intArraySize_2;

      for(intActualPosition = 0; intActualPosition < intArraySizeMax; intActualPosition++)
      {
        strToTrace = "";
        if(intActualPosition < intArraySize_1)
        {
          if(i_strDescription_1 != "")
          {
            strToTrace = i_strDescription_1 +
                         " [" +
                         _FillLeft(IStr(intActualPosition + 1), "0", intFillupSize_1) +
                         "]: ";
          }
          strToTrace = strToTrace + _ToString(i_arrvarArray_1.GetAt(intActualPosition));
        }

        if(intActualPosition == 0 && intArraySize_1 == 0)
        {
          if(i_strDescription_1 != "")
          {
            strToTrace = i_strDescription_1 + ": ";
          }
          strToTrace = strToTrace + "empty array";
        }

        strToTrace = _FillRight(strToTrace, " ", intGapLength);

        if(intActualPosition < intArraySize_2)
        {
          if(i_strDescription_2 != "")
          {
            strToTrace = strToTrace +
                         i_strDescription_2 +
                         " [" +
                         _FillLeft(IStr(intActualPosition + 1), "0", intFillupSize_2) +
                         "]: ";
          }
          strToTrace = strToTrace + _ToString(i_arrvarArray_2.GetAt(intActualPosition));
        }

        if(intActualPosition == 0 && intArraySize_2 == 0)
        {
          if(i_strDescription_2 != "")
          {
            strToTrace = strToTrace + i_strDescription_2 + ": ";
          }
          strToTrace = strToTrace + "empty array";
        }
        FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, i_intState, strToTrace);
      }
      return(ASWGLOBAL::BOOL::TRUE);
    } // TraceArrayFaceToFace

    //----------------------------------------------------------------------------------------------
    // function CheckTypeRange
    //----------------------------------------------------------------------------------------------
    function CheckTypeRange(variable i_strType,                         // i, s, f
                            variable i_strVariableToCheck,              // variable name
                            variable& io_varVariable,                   // variable to check
                            variable i_varMin,                          // min value(f, i) min length (s)
                            variable i_varMax,                          // max value(f, i) max length (s)
                            variable i_varDefault,                      // default value on error
                            variable i_strFunctionName,                 // calling funcktion
                            variable i_strReferenceModuleName) variable // calling module
    {
      string tmp;
      //IMNPUT CHECK
      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "CheckTypeRange")) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strVariableToCheck, "i_strVariableToCheck", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

      if(i_strType == DATA_TYPE::INTEGER || i_strType == DATA_TYPE::STRING)
      {
        if(!_CheckInteger(i_varMin, "i_varMin", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
        if(!_CheckInteger(i_varMax, "i_varMax", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      }
      if(i_strType == DATA_TYPE::FLOAT) 
      {
        if(GetType(i_varMin) != "f")
        {
          if(GetType(i_varMin) == "i")
          {
            i_varMin = i_varMin * 1.0; 
          }
          else
          {
            FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, 
            " ", "Value [" + _ConvertToString(i_varMin) + "] is not a Number!");
            return(ASWGLOBAL::BOOL::FALSE);
          }
        }
        if(GetType(i_varMax) != "f")
        {
          if(GetType(i_varMax) == "i")
          {
            i_varMax = i_varMax * 1.0; 
          }
          else
          {
            FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, 
            " ", "Value [" + _ConvertToString(i_varMax) + "] is not a Number!");
            return(ASWGLOBAL::BOOL::FALSE);
          }
        }
      }
      if(GetType(i_varDefault) == DATA_TYPE::STRING)
      {
        if(GetType(i_varDefault) != DATA_TYPE::STRING)
        FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, 
        " ", "DefaultValue is not of Type string!");
        return(ASWGLOBAL::BOOL::FALSE);         
      }

      if(GetType(i_varDefault) != i_strType)
      {
        if(GetType(i_varDefault) != DATA_TYPE::STRING)
        {
          i_varDefault = i_varDefault * 1.0;
        }
        else
        {
          FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, 
          " ", "DefaultValue [" + _ConvertToString(i_varMax) + "] is not of Type " + _ConvertToString(i_strType) + "!");
          return(ASWGLOBAL::BOOL::FALSE);
        }
      }

     // FLOAT / INTEGER
      if(i_strType == DATA_TYPE::INTEGER)
      {
        if(!_CheckInteger(io_varVariable, "io_varVariable", i_strFunctionName, i_strReferenceModuleName)) 
        {
          FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE, 
          " ", "Dwfault Value [" + _ConvertToString(i_varMax) + "] has been set!");
          io_varVariable = i_varDefault;
          return(ASWGLOBAL::BOOL::TRUE);
        }

        if(io_varVariable < i_varMin)
        {
          FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE, 
          " ", "Min Value [" + _ConvertToString(i_varMin) + "] has been set!");
          io_varVariable = i_varMin;
          return(ASWGLOBAL::BOOL::TRUE);
        }
        if(io_varVariable > i_varMax)
        {
          FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE, 
          " ", "Max Value [" + _ConvertToString(i_varMax) + "] has been set!");
          io_varVariable = i_varMax;
          return(ASWGLOBAL::BOOL::TRUE);
        }
      }
      //STRING
      if(i_strType == DATA_TYPE::STRING)
      {
        if(!_CheckString(io_varVariable, "io_varVariable", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

        tmp = io_varVariable;
        if(tmp.GetLength() < i_varMin || tmp.GetLength() > i_varMin)
        {
          FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, 
          " ", "String length must be between " + _ConvertToString(i_varMin) + " and " + _ConvertToString(i_varMax) + " characters long!");
          io_varVariable = i_varDefault;
          return(ASWGLOBAL::BOOL::FALSE);
        }
      }
      return(ASWGLOBAL::BOOL::TRUE);
    }

    //----------------------------------------------------------------------------------------------
    // function CheckInteger
    //----------------------------------------------------------------------------------------------
    function CheckInteger(variable i_varVariableToCheck,
                          variable i_strTraceEntry,
                          variable i_strFunctionName,
                          variable i_strReferenceModuleName) variable
    {
      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "CheckInteger")) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strTraceEntry, "i_strTraceEntry", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

      if(GetType(i_varVariableToCheck) == "i")
        return (ASWGLOBAL::BOOL::TRUE);
      else
        FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ", "Parameter '" + i_strTraceEntry + "' is not of type integer !");
      return(ASWGLOBAL::BOOL::FALSE);
    } // CheckInteger

    //----------------------------------------------------------------------------------------------
    // function CheckIntegerRange
    //----------------------------------------------------------------------------------------------
    function CheckIntegerRange(variable i_varVariableToCheck,
                               variable i_strTraceEntry,
                               variable i_intMin,
                               variable i_intMax,
                               variable i_strFunctionName,
                               variable i_strReferenceModuleName) variable
    {
      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "CheckIntegerRange")) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strTraceEntry, "i_strTraceEntry", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckInteger(i_intMin, "i_intMin", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckInteger(i_intMax, "i_intMax", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

      if(GetType(i_varVariableToCheck) == "i")
        if(i_varVariableToCheck >= i_intMin && i_varVariableToCheck <= i_intMax)
          return (ASWGLOBAL::BOOL::TRUE);
        else
          FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ", "Parameter '" + i_strTraceEntry +
                      "'  Value " + IStr(i_varVariableToCheck) + " is out of range (" + IStr(i_intMin) + ".." + IStr(i_intMax) + ") !");
      else
        FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ", "Parameter '" + i_strTraceEntry + "' is not of type integer !");
      return(ASWGLOBAL::BOOL::FALSE);
    } // CheckIntegerRange

    //----------------------------------------------------------------------------------------------
    // function CheckIntegerFactorRange
    //----------------------------------------------------------------------------------------------
    function CheckIntegerFactorRange(variable i_varVariableToCheck,
                                     variable i_strTraceEntry,
                                     variable i_intMin,
                                     variable i_intMax,
                                     variable i_intFactor,
                                     variable i_strFunctionName,
                                     variable i_strReferenceModuleName) variable
    {
      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "CheckIntegerFactorRange")) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strTraceEntry, "i_strTraceEntry", "CheckIntegerFactorRange", "Hamilton DriverTools")) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckInteger(i_intMin, "i_intMin", "CheckIntegerFactorRange", "Hamilton DriverTools")) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckInteger(i_intMax, "i_intMax", "CheckIntegerFactorRange", "Hamilton DriverTools")) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckInteger(i_intFactor, "i_intFactor", "CheckIntegerFactorRange", "Hamilton DriverTools")) return(ASWGLOBAL::BOOL::FALSE);

      if(GetType(i_varVariableToCheck) == "i")
        if(i_varVariableToCheck >= i_intMin && i_varVariableToCheck <= i_intMax)
          if(i_varVariableToCheck % i_intFactor == 0.0)
            return (ASWGLOBAL::BOOL::TRUE);
          else
          FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ",
                      "Parameter '" + i_strTraceEntry + "': outside factor (" + IStr(i_intFactor) + ")");
        else
          FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ",
                      "Parameter '" + i_strTraceEntry + "'  is out of range (" + IStr(i_intMin) + ".." + IStr(i_intMax) + ") !");
      else
        FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ",
                    "Parameter '" + i_strTraceEntry + "' is not of type integer !");
      return (ASWGLOBAL::BOOL::FALSE);
    } // CheckIntegerFactorRange

    //----------------------------------------------------------------------------------------------
    // function CheckIntegerInArray
    //----------------------------------------------------------------------------------------------
    function CheckIntegerInArray(variable i_varVariableToCheck,
                                 variable i_strTraceEntry,
                                 variable i_arrintAllowedValues[],
                                 variable i_strFunctionName,
                                 variable i_strReferenceModuleName) variable
    {
      variable intActualArrayPosition;
      variable blnReturnValue(ASWGLOBAL::BOOL::FALSE);
      variable strArrayTrace("");
      variable varActualValue;

      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "CheckIntegerInArray")) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strTraceEntry, "i_strTraceEntry", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

      if(GetType(i_varVariableToCheck) != "i")
      {
        FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ", "Parameter '" + i_strTraceEntry + "' is not of type integer !");
        return(ASWGLOBAL::BOOL::FALSE);
      }
      else
      {
        for(intActualArrayPosition = 0; intActualArrayPosition < i_arrintAllowedValues.GetSize(); intActualArrayPosition++)
        {
          varActualValue = i_arrintAllowedValues.GetAt(intActualArrayPosition);
          if(GetType(varActualValue) != "i")
            FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::PROGRESS, " ", "Value at array index '" + IStr(intActualArrayPosition) +
            " in array i_arrintAllowedValues is not of type integer!");
          else
          {
            if(i_varVariableToCheck == varActualValue) blnReturnValue = ASWGLOBAL::BOOL::TRUE;
            strArrayTrace = strArrayTrace + IStr(varActualValue) + ", ";
          }
        }
      }
      if(blnReturnValue == ASWGLOBAL::BOOL::FALSE)
      {
        strArrayTrace = TrimRight(strArrayTrace, ", ",i_strFunctionName, i_strReferenceModuleName);
        FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ",
                    "Parameter '" + i_strTraceEntry + "' with value of " + IStr(i_varVariableToCheck) +
                    " not found in array of allowed values (" + strArrayTrace + ") !");
      }
      return(blnReturnValue);
    } // CheckIntegerInArray

    //----------------------------------------------------------------------------------------------
    // function CheckFloat
    //----------------------------------------------------------------------------------------------
    function CheckFloat(variable i_varVariableToCheck,
                        variable i_strTraceEntry,
                        variable i_strFunctionName,
                        variable i_strReferenceModuleName) variable
    {
      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "CheckFloat")) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strTraceEntry, "i_strTraceEntry", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

      if(GetType(i_varVariableToCheck) == "f")
        return (ASWGLOBAL::BOOL::TRUE);
      else
        FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ", "Parameter '" + i_strTraceEntry + "' is not of type float !");
      return(ASWGLOBAL::BOOL::FALSE);
    } // CheckFloat

    //----------------------------------------------------------------------------------------------
    // function CheckFloatRange
    //----------------------------------------------------------------------------------------------
    function CheckFloatRange(variable i_varVariableToCheck,
                             variable i_strTraceEntry,
                             variable i_fltMin,
                             variable i_fltMax,
                             variable i_strFunctionName,
                             variable i_strReferenceModuleName) variable
    {
      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "CheckFloatRange")) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strTraceEntry, "i_strTraceEntry", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckFloat(i_fltMin, "i_fltMin", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckFloat(i_fltMax, "i_fltMax", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

      if(GetType(i_varVariableToCheck) == "f")
        if(i_varVariableToCheck >= i_fltMin && i_varVariableToCheck <= i_fltMax)
          return (ASWGLOBAL::BOOL::TRUE);
        else
          FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ", "Parameter '" + i_strTraceEntry + "'  is out of range ("
                      + FStr(i_fltMin) + ".." + FStr(i_fltMax) + ") !");
      else
        FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ", "Parameter '" + i_strTraceEntry + "' is not of type float !");
      return (ASWGLOBAL::BOOL::FALSE);
    } // CheckFloatRange

    //----------------------------------------------------------------------------------------------
    // function CheckFloatFactorRange
    //----------------------------------------------------------------------------------------------
    function CheckFloatFactorRange(variable i_varVariableToCheck,
                                   variable i_strTraceEntry,
                                   variable i_fltMin,
                                   variable i_fltMax,
                                   variable i_fltFactor,
                                   variable i_strFunctionName,
                                   variable i_strReferenceModuleName) variable
    {
      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "CheckFloatFactorRange")) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strTraceEntry, "i_strTraceEntry", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckFloat(i_fltMin, "i_fltMin", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckFloat(i_fltMax, "i_fltMax", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckFloat(i_fltFactor, "i_fltFactor", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

      if(GetType(i_varVariableToCheck) == "f")
        if(i_varVariableToCheck >= i_fltMin && i_varVariableToCheck <= i_fltMax)
          if(i_varVariableToCheck % i_fltFactor == 0.0)
            return (ASWGLOBAL::BOOL::TRUE);
          else
          FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ", "Parameter '" + i_strTraceEntry + "': outside factor ("
                      + FStr(i_fltFactor)) + ")";
        else
          FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ", "Parameter '" + i_strTraceEntry + "'  is out of range ("
                      + FStr(i_fltMin) + ".." + FStr(i_fltMax) + ") !");
      else
        FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ", "Parameter '" + i_strTraceEntry + "' is not of type float !");
      return (ASWGLOBAL::BOOL::FALSE);
    } // CheckFloatFactorRange

    //----------------------------------------------------------------------------------------------
    // function CheckString
    //----------------------------------------------------------------------------------------------
    function CheckString(variable i_varVariableToCheck,
                         variable i_strTraceEntry,
                         variable i_strFunctionName,
                         variable i_strReferenceModuleName) variable
    {
      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "CheckString")) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strTraceEntry, "i_strTraceEntry", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

      if(GetType(i_varVariableToCheck) == "s")
        return (ASWGLOBAL::BOOL::TRUE);
      FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ",
                  "Parameter '", i_strTraceEntry, "' is not of type string !");
      return (ASWGLOBAL::BOOL::FALSE);
    } // CheckString

    //----------------------------------------------------------------------------------------------
    // function CheckStringLength
    //----------------------------------------------------------------------------------------------
    function CheckStringLength(variable i_varVariableToCheck,
                               variable i_strTraceEntry,
                               variable i_intLengthMin,
                               variable i_intLengthMax,
                               variable i_strFunctionName,
                               variable i_strReferenceModuleName) variable
    {
      string strTemp("");
      variable intLength(-1);

      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "CheckStringLength")) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strTraceEntry, "i_strTraceEntry", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckInteger(i_intLengthMin, "i_intLengthMin", "Hamilton DriverTools::CheckStringLength", i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckInteger(i_intLengthMax, "i_intLengthMax", "Hamilton DriverTools::CheckStringLength", i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

      if(GetType(i_varVariableToCheck) == "s")
      {
        strTemp = i_varVariableToCheck;
        intLength = strTemp.GetLength();
        if(intLength >= i_intLengthMin && intLength <= i_intLengthMax)
          return (ASWGLOBAL::BOOL::TRUE);
        else
          FormatTrace("LIBRARY: " + i_strReferenceModuleName,
                      i_strFunctionName, ACTION::COMPLETE_WITH_ERROR,
                      " ", "Parameter '" + i_strTraceEntry + "' = '" + i_varVariableToCheck +
                      "': length is out of range (" + IStr(i_intLengthMin) + ".." + IStr(i_intLengthMin) + ") !");
      }
      FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ",
                  "Parameter '", i_strTraceEntry, "' is not of type string !");
      return (ASWGLOBAL::BOOL::FALSE);
    } // CheckStringLength

    //----------------------------------------------------------------------------------------------
    // function CheckChannelPattern
    //----------------------------------------------------------------------------------------------
    function CheckChannelPattern(string i_varVariableToCheck,
                                 variable i_strTraceEntry,
                                 variable i_intChannelCount,
                                 variable i_strFunctionName,
                                 variable i_strReferenceModuleName) variable
    {
      variable intLength(0), intChannelNumber(0);
      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "CheckChannelPattern")) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strTraceEntry, "i_strTraceEntry", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

      if(GetType(i_varVariableToCheck) == "s")
      {
        intLength = i_varVariableToCheck.GetLength();
        if(intLength != i_intChannelCount)
        {
          FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ",
                      "Parameter '", i_varVariableToCheck, "' does not match the Channel Number on this System");
          return (ASWGLOBAL::BOOL::FALSE);
        }
        for(intChannelNumber = 0; intChannelNumber < i_intChannelCount; intChannelNumber++)
        {
          if(intLength <= i_intChannelCount)
            i_varVariableToCheck = i_varVariableToCheck + "0";
          if(i_varVariableToCheck.Mid(intChannelNumber, 1) == "0" || i_varVariableToCheck.Mid(intChannelNumber, 1) == "1"){}
          else
          {
            FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ",
                        "Parameter '", i_varVariableToCheck, "' contains charactor that are not allowed in a Channelpattern [0/1]");
            return (ASWGLOBAL::BOOL::FALSE);
          }
        }
      }
        return (ASWGLOBAL::BOOL::TRUE);
      FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ",
                  "Parameter '", i_strTraceEntry, "' is not of type string !");
      return (ASWGLOBAL::BOOL::FALSE);
    } // CheckChannelPattern  

    //----------------------------------------------------------------------------------------------
    // function CheckBool
    //----------------------------------------------------------------------------------------------
    function CheckBool(variable i_varVariableToCheck,
                       variable i_strTraceEntry,
                       variable i_strFunctionName,
                       variable i_strReferenceModuleName) variable
    {
      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "CheckBool")) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strTraceEntry, "i_strTraceEntry", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

      if(GetType(i_varVariableToCheck) == "i")
        if(i_varVariableToCheck == ASWGLOBAL::BOOL::TRUE || i_varVariableToCheck == ASWGLOBAL::BOOL::FALSE)
          return (ASWGLOBAL::BOOL::TRUE);
        else
          FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ",
                      "Parameter '", i_strTraceEntry, "' Value ", i_varVariableToCheck, " is not of type bool !");
      else
        FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ",
                    "Parameter '", i_strTraceEntry, "' is not of type bool !");
      return(ASWGLOBAL::BOOL::FALSE);
    } // CheckBool

    //----------------------------------------------------------------------------------------------
    // function CheckIntegerValue
    //----------------------------------------------------------------------------------------------
    function CheckIntegerValue(variable i_varVariableToCheck,
                               variable i_strTraceEntry,
                               variable i_intValueRange,
                               variable i_strFunctionName,
                               variable i_strReferenceModuleName) variable
    {
      variable strTemp("");

      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "CheckIntegerValue")) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strTraceEntry, "i_strTraceEntry", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckIntegerRange(i_intValueRange, "i_intValueRange", VALUE_RANGE::POSITIVE_ZERO, VALUE_RANGE::NEGATIVE,i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

      strTemp = GetType(i_varVariableToCheck);
      if(strTemp == "i")
        if((i_intValueRange == VALUE_RANGE::POSITIVE_ZERO && i_varVariableToCheck >= 0) ||
           (i_intValueRange == VALUE_RANGE::NEGATIVE_ZERO && i_varVariableToCheck <= 0) ||
           (i_intValueRange == VALUE_RANGE::POSITIVE && i_varVariableToCheck > 0) ||
           (i_intValueRange == VALUE_RANGE::NEGATIVE && i_varVariableToCheck < 0))
          return (ASWGLOBAL::BOOL::TRUE);
        else
        {
          strTemp = strTemp = "Parameter '" + i_strTraceEntry + "' with value of " + IStr(i_varVariableToCheck) + " is out of allowed range ";
          if(i_intValueRange == VALUE_RANGE::POSITIVE_ZERO) strTemp = strTemp + "(>= 0)";
          if(i_intValueRange == VALUE_RANGE::POSITIVE) strTemp = strTemp + "(> 0)";
          if(i_intValueRange == VALUE_RANGE::NEGATIVE_ZERO) strTemp = strTemp + "(<= 0)";
          if(i_intValueRange == VALUE_RANGE::NEGATIVE) strTemp = strTemp + "(< 0)";
        }
      else
        strTemp = "Parameter '" + i_strTraceEntry + "' is not of type integer";
      FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ", strTemp + " !");
      return(ASWGLOBAL::BOOL::FALSE);
    } // CheckIntegerValue

    //----------------------------------------------------------------------------------------------
    // function CheckFloatValue
    //----------------------------------------------------------------------------------------------
    function CheckFloatValue(variable i_varVariableToCheck,
                             variable i_strTraceEntry,
                             variable i_intValueRange,
                             variable i_strFunctionName,
                             variable i_strReferenceModuleName) variable
    {
      variable strTemp("");

      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "CheckFloatValue")) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strTraceEntry, "i_strTraceEntry", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckIntegerRange(i_intValueRange, "i_intValueRange", VALUE_RANGE::POSITIVE_ZERO, VALUE_RANGE::NEGATIVE,i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

      strTemp = GetType(i_varVariableToCheck);
      if(strTemp == "f")
        if((i_intValueRange == VALUE_RANGE::POSITIVE_ZERO && i_varVariableToCheck >= 0) ||
           (i_intValueRange == VALUE_RANGE::NEGATIVE_ZERO && i_varVariableToCheck <= 0) ||
           (i_intValueRange == VALUE_RANGE::POSITIVE && i_varVariableToCheck > 0) ||
           (i_intValueRange == VALUE_RANGE::NEGATIVE && i_varVariableToCheck < 0))
          return (ASWGLOBAL::BOOL::TRUE);
        else
        {
          strTemp = strTemp = "Parameter '" + i_strTraceEntry + "' with value of " + FStr(i_varVariableToCheck) + " is out of allowed range ";
          if(i_intValueRange == VALUE_RANGE::POSITIVE_ZERO) strTemp = strTemp + "(>= 0)";
          if(i_intValueRange == VALUE_RANGE::POSITIVE) strTemp = strTemp + "(> 0)";
          if(i_intValueRange == VALUE_RANGE::NEGATIVE_ZERO) strTemp = strTemp + "(<= 0)";
          if(i_intValueRange == VALUE_RANGE::NEGATIVE) strTemp = strTemp + "(< 0)";
        }
      else
        strTemp = "Parameter '" + i_strTraceEntry + "' is not of type float !";
      FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ", strTemp + " !");
      return(ASWGLOBAL::BOOL::FALSE);
    } // CheckFloatValue

    //----------------------------------------------------------------------------------------------
    // function CheckArrayEquality
    //----------------------------------------------------------------------------------------------
    function CheckArrayEquality(variable i_arrvarCheck_1[],
                                variable i_arrvarCheck_2[],
                                variable i_strFunctionName,
                                variable i_strReferenceModuleName) variable
    {
      variable intArraySize_1(0), intArraySize_2(0), intLoopCounterCheckEntries(0);
      variable blnReturnValue(ASWGLOBAL::BOOL::TRUE);
      variable varSingleEntry_1, varSingleEntry_2;

      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "CheckArrayEquality")) return(ASWGLOBAL::BOOL::FALSE);

      intArraySize_1 = i_arrvarCheck_1.GetSize();
      intArraySize_2 = i_arrvarCheck_2.GetSize();

      if(intArraySize_1 != intArraySize_2)
      {
        FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ",
                    "Unequal array sizes: (", intArraySize_1, " != ", intArraySize_2, ")!");
        blnReturnValue = ASWGLOBAL::BOOL::FALSE;
      }
      else
      {
        for(intLoopCounterCheckEntries = 0; intLoopCounterCheckEntries < intArraySize_1; intLoopCounterCheckEntries++)
        {
          varSingleEntry_1 = i_arrvarCheck_1.ElementAt(intLoopCounterCheckEntries);
          varSingleEntry_2 = i_arrvarCheck_2.ElementAt(intLoopCounterCheckEntries);

          if(GetType(varSingleEntry_1) == GetType(varSingleEntry_2))
          {
            if(varSingleEntry_1 != varSingleEntry_2)
            {
              FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::PROGRESS, " ",
                          "Elements at index ", intLoopCounterCheckEntries, " are unequal (", varSingleEntry_1, " != ", varSingleEntry_2, ")!");
              blnReturnValue = ASWGLOBAL::BOOL::FALSE;
            }
          }
          else
          {
              FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::PROGRESS, " ",
                          "Elements at index ", intLoopCounterCheckEntries, " are of differnt type (",
                          GetType(varSingleEntry_1), " != ", GetType(varSingleEntry_2), ")!");
            blnReturnValue = ASWGLOBAL::BOOL::FALSE;
          }
        }
      }
      if(blnReturnValue == ASWGLOBAL::BOOL::FALSE) FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR);
      return(blnReturnValue);
    } // CheckArrayEquality

    //----------------------------------------------------------------------------------------------
    // function CheckArraysForSameSize
    //----------------------------------------------------------------------------------------------
    function CheckArraysForSameSize(variable i_arrvarCheck_1[],
                                    variable i_arrvarCheck_2[],
                                    variable i_strTraceEntry1,
                                    variable i_strTraceEntry2,
                                    variable i_strFunctionName,
                                    variable i_strReferenceModuleName) variable
    {
      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "CheckArraysForSameSize")) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strTraceEntry1, "i_strTraceEntry1", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strTraceEntry2, "i_strTraceEntry2", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

      if(i_arrvarCheck_1.GetSize() == i_arrvarCheck_2.GetSize()) return(ASWGLOBAL::BOOL::TRUE);

      FormatTrace("LIBRARY: " + i_strReferenceModuleName,
                  i_strFunctionName,
                  ACTION::COMPLETE_WITH_ERROR,
                  " ",
                  "Size of array ", i_strTraceEntry1, "(", i_arrvarCheck_1.GetSize(), ") != ",
                  "size of array ", i_strTraceEntry2, "(", i_arrvarCheck_2.GetSize(), ") !");
      return(ASWGLOBAL::BOOL::FALSE);
    } // CheckArraysForSameSize

    //----------------------------------------------------------------------------------------------
    // function CheckArraySize
    //----------------------------------------------------------------------------------------------
    function CheckArraySize(variable i_arrvarCheck[],
                            variable i_strTraceEntry,
                            variable i_intMinSize,
                            variable i_intMaxSize,
                            variable i_strFunctionName,
                            variable i_strReferenceModuleName) variable
    {
      variable intArraySize(0);

      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "CheckArraySize")) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strTraceEntry, "i_strTraceEntry", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

      intArraySize = i_arrvarCheck.GetSize();

      if(i_intMinSize <= intArraySize && i_intMaxSize >= intArraySize)
        return(ASWGLOBAL::BOOL::TRUE);
      else
          FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ", "Parameter '", i_strTraceEntry,
                      "'  Array size of ", IStr(intArraySize), " is out of range (", IStr(i_intMinSize), "..", IStr(i_intMaxSize), ") !");

      return(ASWGLOBAL::BOOL::FALSE);
    } // CheckArraySize

    //----------------------------------------------------------------------------------------------
    // function CheckArrayType
    //----------------------------------------------------------------------------------------------
    function CheckArrayType(variable i_arrvarCheck[],
                            variable i_strTraceEntry,
                            variable i_strType,
                            variable i_strFunctionName,
                            variable i_strReferenceModuleName) variable
    {
      string strTemp("");
      variable intArraySize(0), intFillupSize(0), intLoopCounterCheckEntries(0);
      variable blnReturnValue(ASWGLOBAL::BOOL::TRUE);
      variable varSingleEntry;

      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "CheckArrayType")) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strTraceEntry, "i_strTraceEntry", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strType, "i_strType", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(i_strType != "integer" && i_strType != "float" && i_strType != "string")
      {
        FormatTrace("call to LIBRARY: Hamilton DriverTools", "CheckArrayType", ACTION::COMPLETE_WITH_ERROR, " ", "Parameter 'i_strType' ('" +
                    i_strType + "') is not 'integer', 'float' or 'string'!");
        return(ASWGLOBAL::BOOL::FALSE);
      }
      // 
      intArraySize = i_arrvarCheck.GetSize();
      strTemp = IStr(intArraySize);
      intFillupSize = strTemp.GetLength();

      strTemp = i_strType;
      for(intLoopCounterCheckEntries = 0; intLoopCounterCheckEntries < intArraySize; intLoopCounterCheckEntries++)
      {
        varSingleEntry = i_arrvarCheck.ElementAt(intLoopCounterCheckEntries);

        if(GetType(varSingleEntry) != strTemp.Mid(0,1))
        {
          FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::ERROR, " ",
                      "Element [", _FillLeft(IStr(intLoopCounterCheckEntries), "0", intFillupSize), "] = ", varSingleEntry, " is not of type ", i_strType, "!");
          blnReturnValue = ASWGLOBAL::BOOL::FALSE;
        }
      }
      if(blnReturnValue == ASWGLOBAL::BOOL::FALSE) FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR);
      return(blnReturnValue);
    } // CheckArrayType

    //----------------------------------------------------------------------------------------------
    // function ExtractFunctionName
    //----------------------------------------------------------------------------------------------
    function ExtractFunctionName(variable i_strFunctionName,
                                 variable& o_strExtractedFunctionName,
                                 variable i_strReferenceModuleName) variable
    {
      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "ExtractFunctionName")) return(ASWGLOBAL::BOOL::FALSE);

      o_strExtractedFunctionName = _ExtractFunctionName(i_strFunctionName);

      return (ASWGLOBAL::BOOL::TRUE);
    } // ExtractFunctionName

    //----------------------------------------------------------------------------------------------
    // function ReverseFind
    //----------------------------------------------------------------------------------------------
    function ReverseFind(variable i_strStringToParse,
                         variable i_strSubstringToFind,
                         variable i_strFunctionName,
                         variable i_strReferenceModuleName)variable
    {
      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "ReverseFind")) return(ASWGLOBAL::BOOL::FALSE);
      i_strFunctionName = i_strFunctionName + " - " + Hamilton_DriverTools_ModuleName + "::" + _ExtractFunctionName(GetFunctionName());
      if(!_CheckString(i_strStringToParse, "i_strStringToParse", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strSubstringToFind, "i_strSubstringToFind", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

      return(_ReverseFind(i_strStringToParse, i_strSubstringToFind));
    } // ReverseFind

    //----------------------------------------------------------------------------------------------
    // function FillLeft
    //----------------------------------------------------------------------------------------------
    function FillLeft(variable i_strStringToFill,
                      variable i_strFillCharacter,
                      variable i_intLength,
                      variable i_strFunctionName,
                      variable i_strReferenceModuleName) variable
    {
      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "FillLeft")) return(ASWGLOBAL::BOOL::FALSE);
      i_strFunctionName = i_strFunctionName + " - " + Hamilton_DriverTools_ModuleName + "::" + _ExtractFunctionName(GetFunctionName());
      if(!_CheckString(i_strStringToFill, "i_strStringToFill", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strFillCharacter, "i_strFillCharacter", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckInteger(i_intLength, "i_intLength", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

      return(_FillLeft(i_strStringToFill, i_strFillCharacter, i_intLength));
    } // FillLeft

    //----------------------------------------------------------------------------------------------
    // function FillRight
    //----------------------------------------------------------------------------------------------
    function FillRight(variable i_strStringToFill,
                       variable i_strFillCharacter,
                       variable i_intLength,
                       variable i_strFunctionName,
                       variable i_strReferenceModuleName) variable
    {
      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "FillRight")) return(ASWGLOBAL::BOOL::FALSE);
      i_strFunctionName = i_strFunctionName + " - " + Hamilton_DriverTools_ModuleName + "::" + _ExtractFunctionName(GetFunctionName());
      if(!_CheckString(i_strStringToFill, "i_strStringToFill", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strFillCharacter, "i_strFillCharacter", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckInteger(i_intLength, "i_intLength", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

      return(_FillRight(i_strStringToFill, i_strFillCharacter, i_intLength));
    } // FillRight


    //----------------------------------------------------------------------------------------------
    // function TrimLeft
    //----------------------------------------------------------------------------------------------
    function TrimLeft(variable i_strStringToTrim,
                      variable i_strToRemove,
                      variable i_strFunctionName,
                      variable i_strReferenceModuleName) variable
    {
      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "TrimLeft")) return(ASWGLOBAL::BOOL::FALSE);
      i_strFunctionName = i_strFunctionName + " - " + Hamilton_DriverTools_ModuleName + "::" + _ExtractFunctionName(GetFunctionName());
      if(!_CheckString(i_strStringToTrim, "i_strStringToTrim", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strToRemove, "i_strToRemove", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

      return(_TrimLeft(i_strStringToTrim, i_strToRemove));
    } // TrimLeft

    //----------------------------------------------------------------------------------------------
    // function TrimRight
    //----------------------------------------------------------------------------------------------
    function TrimRight(variable i_strStringToTrim,
                       variable i_strToRemove,
                       variable i_strFunctionName,
                       variable i_strReferenceModuleName) variable
    {
      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "TrimRight")) return(ASWGLOBAL::BOOL::FALSE);
      i_strFunctionName = i_strFunctionName + " - " + Hamilton_DriverTools_ModuleName + "::" + _ExtractFunctionName(GetFunctionName());
      if(!_CheckString(i_strStringToTrim, "i_strStringToTrim", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strToRemove, "i_strToRemove", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

      return(_TrimRight(i_strStringToTrim, i_strToRemove));
    } // TrimRight

    //----------------------------------------------------------------------------------------------
    // function Uppercase
    //----------------------------------------------------------------------------------------------
    function Uppercase(variable i_strStringToChange,
                       variable i_strFunctionName,
                       variable i_strReferenceModuleName) variable
    {
      string strReturn("");

      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "Uppercase")) return(ASWGLOBAL::BOOL::FALSE);
      i_strFunctionName = i_strFunctionName + " - " + Hamilton_DriverTools_ModuleName + "::" + _ExtractFunctionName(GetFunctionName());
      if(!_CheckString(i_strStringToChange, "i_strStringToChange", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

      strReturn = i_strStringToChange;

      return(strReturn.MakeUpper());
    } // Uppercase

    //----------------------------------------------------------------------------------------------
    // function Lowercase
    //----------------------------------------------------------------------------------------------
    function Lowercase(variable i_strStringToChange,
                       variable i_strFunctionName,
                       variable i_strReferenceModuleName) variable
    {
      string strReturn("");

      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "Lowercase")) return(ASWGLOBAL::BOOL::FALSE);
      i_strFunctionName = i_strFunctionName + " - " + Hamilton_DriverTools_ModuleName + "::" + _ExtractFunctionName(GetFunctionName());
      if(!_CheckString(i_strStringToChange, "i_strStringToChange", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

      strReturn = i_strStringToChange;

      return(strReturn.MakeLower());
    } // Lowercase

    //----------------------------------------------------------------------------------------------
    // function IsDigit
    //----------------------------------------------------------------------------------------------
    function IsDigit(variable i_strCharacter,
                     variable i_strTraceEntry,
                     variable i_strFunctionName,
                     variable i_strReferenceModuleName) variable
    {
      string strDigits("0123456789");

      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "IsDigit")) return(ASWGLOBAL::BOOL::FALSE);
      i_strFunctionName = i_strFunctionName + " - " + Hamilton_DriverTools_ModuleName + "::" + _ExtractFunctionName(GetFunctionName());
      if(!_CheckString(i_strCharacter, "i_strCharacter", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strTraceEntry, "i_strTraceEntry", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

      if(_StringLength(i_strCharacter) == 1)
        if(strDigits.Find(i_strCharacter) != -1)
          return(ASWGLOBAL::BOOL::TRUE);
        else
          FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ", "Parameter '" + i_strTraceEntry + "' is no digit");
      else
        FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ", "Parameter '" + i_strTraceEntry + "': not a single character!");
      return(ASWGLOBAL::BOOL::FALSE);
    } // IsDigit

    //----------------------------------------------------------------------------------------------
    // function Replace
    //----------------------------------------------------------------------------------------------
    function Replace(variable i_strToChange,
                     variable i_strToReplace,
                     variable i_strReplaceWith,
                     variable i_strFunctionName,
                     variable i_strReferenceModuleName) variable
    {
      variable intCutPosition(0), intReplaceLength(0);
      string strTemp("");

      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "Replace")) return(ASWGLOBAL::BOOL::FALSE);
      i_strFunctionName = i_strFunctionName + " - " + Hamilton_DriverTools_ModuleName + "::" + _ExtractFunctionName(GetFunctionName());
      if(!_CheckString(i_strToChange, "i_strToChange", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strToReplace, "i_strToReplace", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strReplaceWith, "i_strReplaceWith", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

      strTemp = i_strToReplace;
      intReplaceLength = strTemp.GetLength();
      strTemp = i_strToChange;
      intCutPosition = strTemp.Find(i_strToReplace);
      while(intCutPosition != -1)
      {
        i_strToChange = strTemp.Mid(0, intCutPosition) + i_strReplaceWith;
        intCutPosition = intCutPosition + intReplaceLength;
        i_strToChange = i_strToChange + strTemp.Mid(intCutPosition, strTemp.GetLength());
        strTemp = i_strToChange;
        intCutPosition = strTemp.Find(i_strToChange);
      }

      return(i_strToChange);
    } // Replace

    //----------------------------------------------------------------------------------------------
    // function FloatToString
    //----------------------------------------------------------------------------------------------
    function FloatToString(variable i_fltValue,
                           variable i_strFunctionName,
                           variable i_strReferenceModuleName) variable
    {
      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "FloatToString")) return(ASWGLOBAL::BOOL::FALSE);
      i_strFunctionName = i_strFunctionName + " - " + Hamilton_DriverTools_ModuleName + "::" + _ExtractFunctionName(GetFunctionName());
      if(!_CheckFloat(i_fltValue, "i_fltValue", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

      return(_ToString(i_fltValue));
    } // FloatToString

    //----------------------------------------------------------------------------------------------
    // function Delay
    //----------------------------------------------------------------------------------------------
    function Delay(variable i_fltDelayTime,
                   variable i_strFunctionName,
                   variable i_strReferenceModuleName) variable
    {
      timer hdlDelay;

      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "Delay")) return(ASWGLOBAL::BOOL::FALSE);
      i_strFunctionName = i_strFunctionName + " - " + Hamilton_DriverTools_ModuleName + "::" + _ExtractFunctionName(GetFunctionName());
      if(!_CheckFloat(i_fltDelayTime, "i_fltDelayTime", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

      hdlDelay.SetTimer(i_fltDelayTime);
      hdlDelay.WaitTimer(hslFalse, hslFalse);
      
      return(ASWGLOBAL::BOOL::TRUE);
    } // Delay

    //----------------------------------------------------------------------------------------------
    // function FindInArray
    //----------------------------------------------------------------------------------------------
    function FindInArray(variable i_arrvarArrayToCheck[],
                         variable i_varValueToFind,
                         variable i_strFunctionName,
                         variable i_strReferenceModuleName) variable
    {
      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "FindInArray")) return(ASWGLOBAL::BOOL::FALSE);

      return(_FindInArray(i_arrvarArrayToCheck, i_varValueToFind));
    } // FindInArray

    //----------------------------------------------------------------------------------------------
    // function CheckSimulationMode
    //----------------------------------------------------------------------------------------------

    function CheckSimulationMode(variable i_blnReferenceSimulationMode,
                                 variable i_strFunctionName,
                                 variable i_strReferenceModuleName) variable
    {
      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "CheckSimulationMode")) return(ASWGLOBAL::BOOL::FALSE);
      i_strFunctionName = i_strFunctionName + " - " + Hamilton_DriverTools_ModuleName + "::" + _ExtractFunctionName(GetFunctionName());
      if(!_CheckBool(i_blnReferenceSimulationMode, "i_blnReferenceSimulationMode", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

      if(i_blnReferenceSimulationMode == ASWGLOBAL::BOOL::TRUE) 
      {
        FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE, " ", "Library is used in simulation mode!");
        return(ASWGLOBAL::BOOL::TRUE);
      }
      else
      {
        return(ASWGLOBAL::BOOL::FALSE);
      }
    }// CheckSimulationMode

    //----------------------------------------------------------------------------------------------
    // function CheckInitialization
    //----------------------------------------------------------------------------------------------
    function CheckInitialization(variable i_blnReferenceLibraryInitialized,
                                 variable i_strFunctionName,
                                 variable i_strReferenceModuleName) variable
    {
      if(!_CheckTraceStrings(i_strReferenceModuleName, i_strFunctionName, "CheckInitialization")) return(ASWGLOBAL::BOOL::FALSE);
      i_strFunctionName = i_strFunctionName + " - " + Hamilton_DriverTools_ModuleName + "::" + _ExtractFunctionName(GetFunctionName());
      if(!_CheckBool(i_blnReferenceLibraryInitialized, "i_blnReferenceLibraryInitialized", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

      if(i_blnReferenceLibraryInitialized == ASWGLOBAL::BOOL::TRUE) return(ASWGLOBAL::BOOL::TRUE);
      else
      {
        FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ", "Library is not Initialized!");
        return(ASWGLOBAL::BOOL::FALSE);
      }
    }// CheckInitialization

    //----------------------------------------------------------------------------------------------
    // function GetIniFileValue
    //----------------------------------------------------------------------------------------------
    function GetIniFileValue(variable i_strFunctionName,
                             variable i_strReferenceModuleName,
                             variable i_strFilePath,
                             variable i_strSection,
                             variable i_strKey,
                             variable& o_strValue,
                             variable& o_strErrorMessage) variable
    {
      object objDriverTools;
      if(!_CheckString(i_strFunctionName, "i_strFunctionName", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strReferenceModuleName, "i_strReferenceModuleName", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strFilePath, "i_strFilePath", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strSection, "i_strSection", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strFilePath, "i_strFilePath", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strKey, "i_strKey", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      
      if(objDriverTools.IsNull()) {
        if(!objDriverTools.CreateObject(NetDriverTools, hslTrue)) {
          FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ", "Could could create Object Driver Tools - check if Dll is registered!");
          return(ASWGLOBAL::BOOL::FALSE); 
        }
      }
      if(!objDriverTools.GetIniValue(i_strFilePath, i_strSection, i_strKey, o_strValue, o_strErrorMessage))
        return(ASWGLOBAL::BOOL::FALSE); 
      return(ASWGLOBAL::BOOL::TRUE); 
    }//GetIniFileValue

    //----------------------------------------------------------------------------------------------
    // function SetIniFileValue
    //----------------------------------------------------------------------------------------------
    function SetIniFileValue(variable i_strFunctionName,
                             variable i_strReferenceModuleName,
                             variable i_strFilePath,
                             variable i_strSection,
                             variable i_strKey,
                             variable i_strValue,
                             variable& o_strErrorMessage)variable
    {
      object objDriverTools;
      if(!_CheckString(i_strFunctionName, "i_strFunctionName", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strReferenceModuleName, "i_strReferenceModuleName", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strFilePath, "i_strFilePath", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strSection, "i_strSection", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strFilePath, "i_strFilePath", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strKey, "i_strKey", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);
      if(!_CheckString(i_strValue, "i_strValue", i_strFunctionName, i_strReferenceModuleName)) return(ASWGLOBAL::BOOL::FALSE);

      if(objDriverTools.IsNull()) {
        if(!objDriverTools.CreateObject(NetDriverTools, hslTrue)) {
          FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ", "Could could create Object Driver Tools - check if Dll is registered!");
          return(ASWGLOBAL::BOOL::FALSE); 
        }
      }
      if(!objDriverTools.SetIniValue(i_strFilePath, i_strSection, i_strKey, i_strValue, o_strErrorMessage))
        return(ASWGLOBAL::BOOL::FALSE); 
      return(ASWGLOBAL::BOOL::TRUE); 
    }//SetIniFileValue


    //----------------------------------------------------------------------------------------------
    // private function _CheckBool
    //----------------------------------------------------------------------------------------------
    private function _CheckBool(variable i_varVariableToCheck,
                                variable i_strTraceEntry,
                                variable i_strFunctionName,
                                variable i_strReferenceModuleName) variable
    {
      if(GetType(i_varVariableToCheck) == "i")
        if(i_varVariableToCheck == ASWGLOBAL::BOOL::TRUE || i_varVariableToCheck == ASWGLOBAL::BOOL::FALSE)
          return (hslTrue);
      FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ", "Parameter '" + i_strTraceEntry +  "' is not of type boolean!");
      return (hslFalse);
    } // _CheckBool

    //----------------------------------------------------------------------------------------------
    // private function _CheckInteger
    //----------------------------------------------------------------------------------------------
    function _CheckInteger(variable i_varVariableToCheck,
                           variable i_strTraceEntry,
                           variable i_strFunctionName,
                           variable i_strReferenceModuleName) variable
    {
      if(GetType(i_varVariableToCheck) == "i")
        return (hslTrue);
      FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ", "Parameter '" + i_strTraceEntry + "' is not of type integer!");
      return (hslFalse);
    } // _CheckInteger

    //----------------------------------------------------------------------------------------------
    // private function _CheckIntegerRange
    //----------------------------------------------------------------------------------------------
    private function _CheckIntegerRange(variable i_varVariableToCheck,
                                        variable i_strTraceEntry,
                                        variable i_intMin,
                                        variable i_intMax,
                                        variable i_strFunctionName,
                                        variable i_strReferenceModuleName) variable
    {
      if(GetType(i_varVariableToCheck) == "i")
        if(i_varVariableToCheck >= i_intMin && i_varVariableToCheck <= i_intMax)
          return (hslTrue);
        else
          FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ", "Parameter '" + i_strTraceEntry + "'  is out of range ("
                      + IStr(i_intMin) + ".." + IStr(i_intMax) + ") !");
      else
        FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ", "Parameter '" + i_strTraceEntry + "' is not of type integer!");
      return (hslFalse);
    } // CheckIntegerRange

    //----------------------------------------------------------------------------------------------
    // private function _CheckFloat
    //----------------------------------------------------------------------------------------------
    private function _CheckFloat(variable i_varVariableToCheck,
                                 variable i_strTraceEntry,
                                 variable i_strFunctionName,
                                 variable i_strReferenceModuleName) variable
    {
      if(GetType(i_varVariableToCheck) == "f")
        return (hslTrue);
      FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ", "Parameter '" + i_strTraceEntry + "' is not of type float!");
      return (hslFalse);
    } // _CheckFloat

    //----------------------------------------------------------------------------------------------
    // private function _CheckString
    //----------------------------------------------------------------------------------------------
    private function _CheckString(variable i_varVariableToCheck,
                                  variable i_strTraceEntry,
                                  variable i_strFunctionName,
                                  variable i_strReferenceModuleName) variable
    {
      if(GetType(i_varVariableToCheck) == "s")
        return (hslTrue);
      FormatTrace("LIBRARY: " + i_strReferenceModuleName, i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ", "Parameter '" + i_strTraceEntry + "' is not of type string!");
      return (hslFalse);
    } // _CheckString

    //----------------------------------------------------------------------------------------------
    // private function _ReverseFind
    //----------------------------------------------------------------------------------------------
    private function _ReverseFind(string i_strStringToParse,
                                  string i_strSubstringToFind) variable
    {
      variable intIndex;
      variable intResult(-1);
      variable intStringLength;
      string strTempString("");

      strTempString = i_strStringToParse;
      intStringLength = strTempString.GetLength();
      for (intIndex = strTempString.Find(i_strSubstringToFind); intIndex != -1; intIndex = strTempString.Find(i_strSubstringToFind))
      {
        intResult = intResult + intIndex + 1;
        strTempString = strTempString.Mid(intIndex + 1, intStringLength);
      }
      return(intResult);
    } // _ReverseFind

    //-----------------------------------------------------------------------------------------------
    //private function _CheckTraceStrings
    //-----------------------------------------------------------------------------------------------
    private function _CheckTraceStrings(variable i_strReferenceModuleName,
                                        variable i_strReferenceFunctionName,
                                        variable i_strFunctionName) variable
    {
      if(GetType(i_strReferenceModuleName) != "s")
      {
        if(GetType(i_strReferenceFunctionName) != "s")
        {
          FormatTrace("LIBRARY: Hamilton DriverTools", i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ",
                      "Parameter 'i_strReferenceModuleName' and 'i_strReferenceFunctionName' are not of type string!");
          return(hslFalse);
        }
        else
        {
          FormatTrace("LIBRARY: Hamilton DriverTools", i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ",
                      "Parameter 'i_strReferenceModuleName' is not of type string!");
          return(hslFalse);
        }
      }
      else
      {
        if(GetType(i_strReferenceFunctionName) != "s")
        {
          FormatTrace("LIBRARY: Hamilton DriverTools", i_strFunctionName, ACTION::COMPLETE_WITH_ERROR, " ",
                      "Parameter 'i_strFunctionName' is not of type string!");
          return(hslFalse);
        }
      }
      return(hslTrue);
    } // _CheckTraceStrings

    //----------------------------------------------------------------------------------------------
    // private function _FillLeft
    //----------------------------------------------------------------------------------------------
    private function _FillLeft(string i_strStringToFill,
                               variable i_strFillCharacter,
                               variable i_intLength) variable
    {
      variable strReturn("");
      variable intCount;

      strReturn = i_strStringToFill;
      for(intCount = i_strStringToFill.GetLength(); intCount < i_intLength; intCount++) strReturn = i_strFillCharacter + strReturn;
      return(strReturn);
    } // _FillLeft

    //----------------------------------------------------------------------------------------------
    // private function _FillRight
    //----------------------------------------------------------------------------------------------
    private function _FillRight(string i_strStringToFill,
                                variable i_strFillCharacter,
                                variable i_intLength) variable
    {
      variable strReturn("");
      variable intLength(0);
      variable intCount;

      strReturn = i_strStringToFill;
      intLength = i_strStringToFill.GetLength();
      for(intCount = intLength; intCount < i_intLength; intCount++) strReturn = strReturn + i_strFillCharacter;
      return(strReturn);
    } // _FillRight

    //----------------------------------------------------------------------------------------------
    // private function _TrimLeft
    //----------------------------------------------------------------------------------------------
    private function _TrimLeft(string i_strStringToTrim,
                               string i_strToRemove) variable
    {
      variable strReturn("");
      variable intLength(0), intRemoveLength(0), intCount(0);
      string strTemp("");

      strReturn = i_strStringToTrim;
      intLength = i_strStringToTrim.GetLength();
      intRemoveLength = i_strToRemove.GetLength();
      for(intCount = 0; intCount < intLength; intCount = intCount + intRemoveLength)
      {
        strTemp = i_strStringToTrim.Mid(intCount, intRemoveLength);
        if(strTemp.Compare(i_strToRemove) != 0) break;
        strReturn = i_strStringToTrim.Mid(intCount + intRemoveLength, intLength);
      }
      return(strReturn);
    } // _TrimLeft

    //----------------------------------------------------------------------------------------------
    // private function _TrimRight
    //----------------------------------------------------------------------------------------------
    private function _TrimRight(string i_strStringToTrim,
                                string i_strToRemove) variable
    {
      variable strReturn("");
      variable intLength(0), intRemoveLength(0), intCount(0);
      string strTemp("");

      strReturn = i_strStringToTrim;
      intLength = i_strStringToTrim.GetLength();
      intRemoveLength = i_strToRemove.GetLength();
      for(intCount = intLength - intRemoveLength; intCount > 0; intCount = intCount - intRemoveLength)
      {
        strTemp = i_strStringToTrim.Mid(intCount, intRemoveLength);
        if(strTemp.Compare(i_strToRemove) != 0) break;
        strReturn = i_strStringToTrim.Mid(0, intCount);
      }

      return(strReturn);
    } // _TrimRight

    //----------------------------------------------------------------------------------------------
    // private function _ToString
    //----------------------------------------------------------------------------------------------
    private function _ToString(variable i_varValue) variable
    {
      string strVariableType(""), strTempFloat(""), strComma("");

      strVariableType = GetType(i_varValue);
      if(strVariableType.Compare(hslString) == 0)
        return(i_varValue);
      if(strVariableType.Compare(hslInteger) == 0) return(IStr(i_varValue));
      if(strVariableType.Compare(hslFloat) == 0)
      {
        strComma = _GetComma();
        strTempFloat = FStr(i_varValue, hslTrue, 1000);
        if(strTempFloat.Find(strComma) == -1)
        {
          strTempFloat = strTempFloat + strComma;
          strTempFloat = strTempFloat + "0";
        }
        return(strTempFloat);
      }
      return("");
    } // _ToString

    //----------------------------------------------------------------------------------------------
    // private function _GetComma
    //----------------------------------------------------------------------------------------------
    private function _GetComma() string
    {
      string strComma("");

      strComma = FStr(1.2, hslTrue);
      return(strComma.Mid(1,1));
    } // _GetComma

     //----------------------------------------------------------------------------------------------
    // private function _FindInArray
    //----------------------------------------------------------------------------------------------
    private function _FindInArray(variable i_arrvarArrayToCheck[],
                                  variable i_varValueToFind) variable
    {
      variable intPosInArray(0), intArraySize(0);
      variable varValueToCheck;

      intArraySize = i_arrvarArrayToCheck.GetSize();
      for (intPosInArray = 0; intPosInArray <  intArraySize; intPosInArray++)
      {
        varValueToCheck = i_arrvarArrayToCheck.GetAt(intPosInArray);
        if((GetType(varValueToCheck) == GetType(i_varValueToFind)) && (varValueToCheck == i_varValueToFind))
          return(intPosInArray);
      }
      return(-1);
    } // _FindInArray

    //----------------------------------------------------------------------------------------------
    // private function _ExtractFunctionName
    //----------------------------------------------------------------------------------------------
    private function _ExtractFunctionName(variable i_strFunctionName) variable
    {
      string strFunctionName("");

      strFunctionName = i_strFunctionName;
      return(strFunctionName.Mid(_ReverseFind(i_strFunctionName, ":") + 1, strFunctionName.GetLength()));
    } // _ExtractFunctionName

    //----------------------------------------------------------------------------------------------
    // private function _StringLength
    //----------------------------------------------------------------------------------------------
    private function _StringLength(string i_strStringToCheck) variable
    {
      return(i_strStringToCheck.GetLength());
    } // _StringLength

    // --------------------------------------------------------------------------------------
    // private function _LongestElementSize
    // --------------------------------------------------------------------------------------
    private function _LongestElementSize(variable i_arrvarToCheck[]) variable
    {
      variable intActualPosition, intArraySize, intMaxLength;
      string strTemp;

      intArraySize = i_arrvarToCheck.GetSize();

      for(intActualPosition = 0; intActualPosition < intArraySize; intActualPosition++)
      {
        strTemp = _ToString(i_arrvarToCheck.GetAt(intActualPosition));
        if(strTemp.GetLength() > intMaxLength) intMaxLength = strTemp.GetLength();
      }
      return(intMaxLength);
    } // _LongestElementSize
    // --------------------------------------------------------------------------------------
    // private function _LongestElementSize
    // --------------------------------------------------------------------------------------
    function _ConvertToString(variable i_varVariableToConvert) variable
    {
      if(GetType(i_varVariableToConvert) == "i")
        return(IStr(i_varVariableToConvert));
      if(GetType(i_varVariableToConvert) == "f")
        return(FStr(i_varVariableToConvert));
      if(GetType(i_varVariableToConvert) == "s")
        return(i_varVariableToConvert);
    }
  }
#endif
// $$author=Daniel$$valid=1$$time=2016-02-26 10:13$$checksum=ac101b09$$length=085$$