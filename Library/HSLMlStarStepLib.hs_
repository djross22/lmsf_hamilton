// This is a part of the Microlab® STAR Step Library.
// Copyright (C) by HAMILTON Bonaduz AG, CH-7402 Bonaduz.
// All rights reserved.
//
// Modification History
// 2001-12-19  bandenmatten : Initial file creation.
// 2001-02-11  bandenmatten : Added function MlStar::StepAspirateEx() to 
//										handle individual volumes per channel.
// 2001-02-11  bandenmatten : Added function MlStar::StepDispenseEx() to 
//										handle individual volumes per channel.
//	2002-04-22	cjoerg       :	Function StepLoadCarrier() set barcodeReadPositions to "?"
//										Function StepLoadCarrierEx()
//										- LoadCarrier for abort and cancel/abort:
//											- Use variable 'barcodeReadPositions' in the corresponding field.
//											- Use variable 'userResponseTime' also for the error 'wrong carrier loaded'.
//											- Set the default and visible options for the error 'wrong carrier loaded'.
// 2001-07-01  bandenmatten : Added function MlStar::StepTipPickupEx().
// 2002-11-07  bandenmatten : Updated recovery options of low level steps.
// 2003-04-29  bandenmatten : Updated recovery options of low level steps.
// 2003-06-13  bandenmatten : Updated error recovery of the low-lovel step Dispense (Insufficient Liquid Error).
// 2004-01-23  bandenmatten : Edited low level steps.
// 2004-03-24  cjoerg       : Edited low level steps but error settings not checked against specs (not changed since last edit).
//                            - Step StepAspirateEx: Fixed bug that the MixPosition and MixVolume was not set by
//                                                   the passed variable (lost during last edit of low level steps)
//                            - Step StepDispenseEx: Fixed bug that the MixPosition and MixVolume was not set by
//                                                   the passed variable (lost during last edit of low level steps)
// 2004-06-04  bandenmatten : Disabled error recovery option 'Continue' for 'Wrong Carrier Error' in load steps.
// 2005-05-11  bandenmatten : Edited low level steps.
//                            - TipPickUp / Aspirate / Dispense / LoadCarrier:
//                              for ErrorHandling::continue for 'Not Executed Error' set default to 'Repeat'. 
//                            - Dispense:
//                              configure for new error 'Hardware Error'. 
// 20005-06-22  cjoerg      : Added debug switch (#define _DEBUG_STEPPARAMS 1).
//                            Added namespace DEBUG and functions to trace the parameters of a function.
//                            Added debug-traces for each step... function, trace all the parameter values passed to the function.
// 2006-03-26  bandenmatten : Added function MlStar::StepFirmwareCommand().
// 2006-05-15  bandenmatten : SCR#433 : Enabled recovery option 'Exclude' in functions MlStar::StepTipPickup() and MlStar::StepTipPickupEx().
// 2006-05-15  bandenmatten : SCR#433 : Added new error handling option 'ErrorHandling::continue_2' to function MlStar::StepTipPickup() and MlStar::StepTipPickupEx(). 
//													 This option is identical with 'ErrorHandling::continue', but has the recovery option 'Exclude' disabled.
// 2006-05-15  bandenmatten : SCR#433 : Enabled recovery option 'Exclude' in function MlStar::StepAspirate().
// 2006-05-15  bandenmatten : SCR#433 : Enabled recovery option 'Exclude' in function MlStar::StepDispense().
// 2006-09-13  bandenmatten : Edited low level steps. Verified error settings.
// 2007-05-14  fgarcia      : - SCR#1299: Added function StepLoadCarrierEx2() where the default handling of 'No Labware Error' is 'Exclude'
//                              (for use with Load and Match) and timeout is 0 (immediately).
//                            - StepLoadCarrierEx() modified that 'No Labware Error' is also 'Exclude', but using the timeout of adv. settings
// 2007-11-15  bandenmatten : Edited low level steps. Verified error settings.
// 2007-11-26  bandenmatten : Added new function MlStar::StepInitialize2() that has all the default waste parameters removed.
// 2009-12-17  cjoerg       : Edited low level steps with current runmaster 4.3. Verified/updated error settings.

#ifndef __HSLMlStarStepLib_hsl__
#define __HSLMlStarStepLib_hsl__	1

//device ML_STAR;

// --------------------------------------------------------------------------------------
// Debugging
// --------------------------------------------------------------------------------------
#ifdef HSL_RUNTIME
namespace MlStar
{
	//#define _DEBUG_STEPPARAMS		1			// traces all the parameters passed to the Star-Steps...
}
#endif


// Interface to the Microlab® STAR Step Library
#ifndef HSL_RUNTIME
namespace MlStar
{
	// --------------------------------------------------------------------------------------
	// Functions
	// --------------------------------------------------------------------------------------

	function StepInitialize(												// Initialize step
		device& ML_STAR,														// i: pipetting device
		variable initializeUseDefaultWaste,								// i: indicates whether to use the default waste (0 = Off, 1 = On)
		sequence& initializeWasteDestination,							// i: initialize waste destination
		variable initializeSequenceCounting,							// i: sequence counting (0 = manually, 1 = automatic)
		variable& initializeChannelVariable,							// i: channel variable (0 = unused, 1 = used)
		variable initializeChannelUse,									// i: channel use (1 = all sequence positions, 2 = channel pattern)
		variable initializeAlways,											// i: initialize always flag
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepInitialize2(												// Initialize step
		device& ML_STAR,														// i: pipetting device
		variable initializeAlways,											// i: initialize always flag
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepTipPickup(													// Tip Pickup step
		device& ML_STAR,														// i: pipetting device
		sequence& tipPickupSequence,										// i: tip pickup sequence
		variable tipPickupSequenceCounting,								// i: sequence counting (0 = manually, 1 = automatic)
		variable& tipPickupChannelVariable,								// i: channel variable (0 = unused, 1 = used)
		variable tipPickupChannelUse,										// i: channel use (1 = all sequence positions, 2 = channel pattern)
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepTipPickupEx(												// Tip Pickup step, error handlig tailored to pickup needles
		device& ML_STAR,														// i: pipetting device
		sequence& tipPickupSequence,										// i: tip pickup sequence
		variable tipPickupSequenceCounting,								// i: sequence counting (0 = manually, 1 = automatic)
		variable& tipPickupChannelVariable,								// i: channel variable (0 = unused, 1 = used)
		variable tipPickupChannelUse,										// i: channel use (1 = all sequence positions, 2 = channel pattern)
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepTipEject(													// Tip Eject step
		device& ML_STAR,														// i: pipetting device
		variable tipEjectUseDefaultWaste,								// i: indicates whether to use the default waste (0 = Off, 1 = On)
		sequence& tipEjectSequence,										// i: tip eject waste destination
		variable tipEjectSequenceCounting,								// i: sequence counting (0 = manually, 1 = automatic)
		variable& tipEjectChannelVariable,								// i: channel variable (0 = unused, 1 = used)
		variable tipEjectChannelUse,										// i: channel use (1 = all sequence positions, 2 = channel pattern)
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepAspirate(													// Aspirate step
		device& ML_STAR,														// i: pipetting device
		sequence& aspirateSequence,										// i: aspirate sequence
		variable aspirateSequenceCounting,								// i: sequence counting (0 = manually, 1 = automatic)
		variable aspirateVolume,											// i: aspirate volume [ul]
		variable aspirateMode,												// i: aspirate mode (0 = aspiration, 1 = consecutive aspiration, 2 = empty cup aspiration)
		variable aspirateCLLDSensitivity,								// i: capacitive liquid level detection (0 = off, 1 = very high, 2 = high, 3 = middle, 4 = low)
		variable aspiratePLLDSensitivity,								// i: pressure liquid level detection (0 = off, 1 = very high, 2 = high, 3 = middle, 4 = low)
		variable aspirateSubmergeDepth,									// i: submerge depth after the liquid level detection [mm]
		variable aspirateFluidHeight,										// i: liquid height from bottom if liquid level detection is disabled
		variable aspirateMaxHeightDiff,									// i: the maximum difference between the two liquid level detection measurements [mm]
		variable& aspirateChannelVariable,								// i: channel variable (0 = unused, 1 = used)
		variable aspirateChannelUse,										// i: channel use (1 = all sequence positions, 2 = channel pattern)
		variable aspirateLiquidFollowing,								// i: liquid following during aspirate and mix (0 = disabled, 1 = enabled)
		variable aspiratePrerinsingMixCycles,							// i: prerinsing / mix cycles 
		variable aspiratePrerinsingMixPosition,						// i: prerinsing / mix position [mm]
		variable aspiratePrerinsingMixVolume,							// i: prerinsing / mix volume [ul]
		variable& aspirateUserDefinedLiquidClass,						// i: liquid class, will be automatically selected if not explicitly set
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepAspirateEx(												// Aspirate step extension
		device& ML_STAR,														// i: pipetting device
		sequence& aspirateSequence,										// i: aspirate sequence
		variable aspirateSequenceCounting,								// i: sequence counting (0 = manually, 1 = automatic)
		variable& aspirateVolumes[],										// i: aspirate volumes per channel [ul]
		variable aspirateMode,												// i: aspirate mode (0 = aspiration, 1 = consecutive aspiration, 2 = empty cup aspiration)
		variable aspirateCLLDSensitivity,								// i: capacitive liquid level detection (0 = off, 1 = very high, 2 = high, 3 = middle, 4 = low)
		variable aspiratePLLDSensitivity,								// i: pressure liquid level detection (0 = off, 1 = very high, 2 = high, 3 = middle, 4 = low)
		variable aspirateSubmergeDepth,									// i: submerge depth after the liquid level detection [mm]
		variable aspirateFluidHeight,										// i: liquid height from bottom if liquid level detection is disabled
		variable aspirateMaxHeightDiff,									// i: the maximum difference between the two liquid level detection measurements [mm]
		variable& aspirateChannelVariable,								// i: channel variable (0 = unused, 1 = used)
		variable aspirateChannelUse,										// i: channel use (1 = all sequence positions, 2 = channel pattern)
		variable aspirateLiquidFollowing,								// i: liquid following during aspirate and mix (0 = disabled, 1 = enabled)
		variable aspiratePrerinsingMixCycles,							// i: prerinsing / mix cycles 
		variable aspiratePrerinsingMixPosition,						// i: prerinsing / mix position [mm]
		variable aspiratePrerinsingMixVolume,							// i: prerinsing / mix volume [ul]
		variable& aspirateUserDefinedLiquidClass,						// i: liquid class, will be automatically selected if not explicitly set
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepDispense(													// Dispense step
		device& ML_STAR,														// i: pipetting device
		sequence& dispenseSequence,										// i: dispense sequence
		variable dispenseSequenceCounting,								// i: sequence counting (0 = manually, 1 = automatic)
		variable dispenseVolume,											// i: dispense volume [ul]
		variable dispenseMode,												// i: dispense mode (0 = aspiration, 1 = consecutive dispense, 2 = empty cup aspiration)
		variable dispenseCLLDSensitivity,								// i: capacitive liquid level detection (0 = off, 1 = very high, 2 = high, 3 = middle, 4 = low)
		variable dispenseSubmergeDepth,									// i: submerge depth after the liquid level detection [mm]
		variable dispenseFluidHeight,										// i: liquid height from bottom if liquid level detection is disabled
		variable& dispenseChannelVariable,								// i: channel variable (0 = unused, 1 = used)
		variable dispenseChannelUse,										// i: channel use (1 = all sequence positions, 2 = channel pattern)
		variable dispenseLiquidFollowing,								// i: liquid following during dispense and mix (0 = disabled, 1 = enabled)
		variable dispensePrerinsingMixCycles,							// i: prerinsing / mix cycles 
		variable dispensePrerinsingMixPosition,						// i: prerinsing / mix position [mm]
		variable dispensePrerinsingMixVolume,							// i: prerinsing / mix volume [ul]
		variable& dispenseUserDefinedLiquidClass,						// i: liquid class, will be automatically selected if not explicitly set
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepDispenseEx(												// Dispense step extension
		device& ML_STAR,														// i: pipetting device
		sequence& dispenseSequence,										// i: dispense sequence
		variable dispenseSequenceCounting,								// i: sequence counting (0 = manually, 1 = automatic)
		variable& dispenseVolumes[],										// i: dispense volumes per channel [ul]
		variable dispenseMode,												// i: dispense mode (0 = aspiration, 1 = consecutive dispense, 2 = empty cup aspiration)
		variable dispenseCLLDSensitivity,								// i: capacitive liquid level detection (0 = off, 1 = very high, 2 = high, 3 = middle, 4 = low)
		variable dispenseSubmergeDepth,									// i: submerge depth after the liquid level detection [mm]
		variable dispenseFluidHeight,										// i: liquid height from bottom if liquid level detection is disabled
		variable& dispenseChannelVariable,								// i: channel variable (0 = unused, 1 = used)
		variable dispenseChannelUse,										// i: channel use (1 = all sequence positions, 2 = channel pattern)
		variable dispenseLiquidFollowing,								// i: liquid following during dispense and mix (0 = disabled, 1 = enabled)
		variable dispensePrerinsingMixCycles,							// i: prerinsing / mix cycles 
		variable dispensePrerinsingMixPosition,						// i: prerinsing / mix position [mm]
		variable dispensePrerinsingMixVolume,							// i: prerinsing / mix volume [ul]
		variable& dispenseUserDefinedLiquidClass,						// i: liquid class, will be automatically selected if not explicitly set
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepLoadCarrier(												// Load Carrier step
		device& ML_STAR,														// i: pipetting device
		variable& loadCarrier,												// i: load carrier name
		variable loadCarrierBarcodeFileName,							// i: load carrier barcode file name
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepLoadCarrierEx(											// Load Carrier step extension
		device& ML_STAR,														// i: pipetting device
		variable& loadCarrier,												// i: load carrier name
		variable loadCarrierBarcodeFileName,							// i: load carrier barcode file name
		variable barcodeReadPositions,									// i: load carrier barcode read positions
		variable recoveryOptionContinue,									// i: visibility of recovery option Continue (0 = invisible, 1 = visible)
		variable recoveryOptionExclude,									// i: visibility of recovery option Exclude (0 = invisible, 1 = visible)
		variable recoveryOptionDefault,									// i: default of recovery options Continue and Exclude (0 = Continue, 1 = Exclude) 
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepLoadCarrierEx2(											// Load Carrier step extension for special use with Load And Match
		device& ML_STAR,														// i: pipetting device
		variable& loadCarrier,												// i: load carrier name
		variable loadCarrierBarcodeFileName,							// i: load carrier barcode file name
		variable barcodeReadPositions,									// i: load carrier barcode read positions
		variable recoveryOptionContinue,									// i: visibility of recovery option Continue (0 = invisible, 1 = visible)
		variable recoveryOptionExclude,									// i: visibility of recovery option Exclude (0 = invisible, 1 = visible)
		variable recoveryOptionDefault,									// i: default of recovery options Continue and Exclude (0 = Continue, 1 = Exclude) 
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepUnloadCarrier(											// Unload Carrier step
		device& ML_STAR,														// i: pipetting device
		variable& unloadCarrier,											// i: unload carrier name
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepCalibrate1536Plate(										// Calibrate Carrier step
		device& ML_STAR,														// i: pipetting device
		variable& calibrateCarrier,										// i: calibrate carrier name
		variable calibrateCarrierChannel,								// i: calibrate carrier channel
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepWaitNeedleWashed(										// Wait Needle Washed step
		device& ML_STAR,														// i: pipetting device
		variable& washStation,												// i: wash station
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepStartNeedleWash(											// Start Needle Wash step
		device& ML_STAR,														// i: pipetting device
		variable& washStation,												// i: wash station
		variable rinseTime1,													// i: rinse time [s]
		variable soakTime1,													// i: soak time [s]
		variable flowRate1,													// i: flow rate [ml/s]
		variable rinseTime2,													// i: rinse time [s]
		variable soakTime2,													// i: soak time [s]
		variable flowRate2,													// i: flow rate [ml/s]
		variable drainingTime,												// i: draining time [s]
		variable startWashLiquid,											// i: start wash liquid
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepFirmwareCommand(											// Executes a firmware command
		device& ML_STAR,														// i: Specifies the device context.
		variable& commandString,											// i: Command string.
		variable& parameterString,											// i: Parameter string.
		variable& returnValues[]) void									// o: Step return values.
	{}
}
#endif

// Implementation of Microlab® STAR Step Library
#ifdef HSL_RUNTIME
namespace MlStar
{
	#ifdef _DEBUG_STEPPARAMS
	namespace DEBUG
	{
		// Helper function, returns the variable converted to a string
		static function StrStr(variable& var) variable
		{
			variable type;
			type = GetType(var);
			if (hslInteger.Compare(type) == 0)
			{
				var = IStr(var);
			}
			else
			{
				if (hslFloat.Compare(type) == 0)
				{
					var = FStr(var);
				}
				else
				{
					if (hslString.Compare(type) != 0)
					{
						var = "";
					}
				}
			}
			return(var);
		}

		static function TraceStepParamVariable(variable& stepName, variable& key, variable& value) void
		{
			FormatTrace("DEBUG", stepName, 4, key, ": ", value);
		}

		static function TraceStepParamVariableArray(variable& stepName, variable& key, variable& value[]) void
		{
			variable values;
			variable index, count;
			count = value.GetSize();
			FormatTrace("DEBUG", stepName, 4, key, "[] Size: ", count);
			values = "";
			for(index=0; index<count; index++)
			{
				values = values + DEBUG::StrStr(value[index]);
				if ( index<(count-1) )
				{
					values = values + ", ";
				}
			}
			FormatTrace("DEBUG", stepName, 4, key, "[] Values: ", values);
		}

		static function TraceStepParamSequence(variable& stepName, variable& key, sequence& value) void
		{
			FormatTrace("DEBUG", stepName, 4,
							key, ": name = ", value.GetName(), 
							", current = ", value.GetCurrentPosition(), 
							", count = ",   value.GetCount(),
							", maxPos = ",  value.GetMax());
		}

		static function TraceStepParamDevice(variable& stepName, variable& key, device& value) void
		{
			FormatTrace("DEBUG", stepName, 4, key, ": ", value.GetInstrumentName());
		}
	}
	#endif	// _DEBUG_STEPPARAMS


	// --------------------------------------------------------------------------------------
	// Error Handling
	// --------------------------------------------------------------------------------------

	namespace ErrorHandling
	{
		static const variable first(1);									// guard
		static const variable abort_(first);							// error handling
		static const variable cancel(first + 1);						// error handling
		static const variable continue(first + 2);					// error handling
		static const variable continue_2(first + 3);					// error handling
		static const variable last(first + 3);							// guard
	}

	// --------------------------------------------------------------------------------------
	// Functions
	// --------------------------------------------------------------------------------------

	function StepInitialize2(
		device& ML_STAR,
		variable initializeAlways,
		variable errorHandling,
		variable userResponseTime)
	{
		variable rc[];

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamVariable(stepName, "initializeAlways", initializeAlways);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif

		if (ErrorHandling::abort_ == errorHandling)
			rc = ML_STAR._1C0C0CB0_7C87_11D3_AD83_0004ACB1DCB2( "9e73215e_ed8a_4485_a577321944135f3a" ); // Initialize
		if (ErrorHandling::cancel == errorHandling)
			rc = ML_STAR._1C0C0CB0_7C87_11D3_AD83_0004ACB1DCB2( "af60c527_3cdc_4130_a2866d14f7cfeda7" ); // Initialize
		if (ErrorHandling::continue == errorHandling)
			rc = ML_STAR._1C0C0CB0_7C87_11D3_AD83_0004ACB1DCB2( "e329e547_7c0f_4ea2_93653f27ee3e1ac0" ); // Initialize

		return(rc);
	}

	function StepInitialize(
		device& ML_STAR,
		variable initializeUseDefaultWaste,
		sequence& initializeWasteDestination,
		variable initializeSequenceCounting,
		variable& initializeChannelVariable,
		variable initializeChannelUse,
		variable initializeAlways,
		variable errorHandling,
		variable userResponseTime)
	{
		variable rc[];

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamVariable(stepName, "initializeUseDefaultWaste  (IGNORED!)", initializeUseDefaultWaste);
			DEBUG::TraceStepParamSequence(stepName, "initializeWasteDestination (IGNORED!)", initializeWasteDestination);
			DEBUG::TraceStepParamVariable(stepName, "initializeSequenceCounting (IGNORED!)", initializeSequenceCounting);
			DEBUG::TraceStepParamVariable(stepName, "initializeChannelVariable  (IGNORED!)", initializeChannelVariable);
			DEBUG::TraceStepParamVariable(stepName, "initializeChannelUse       (IGNORED!)", initializeChannelUse);
			DEBUG::TraceStepParamVariable(stepName, "initializeAlways",     initializeAlways);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling",        errorHandling);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime",     userResponseTime);
		}
		#endif

		// 2009-12-17/cjoerg: Forward to StepInitialize2 only
		rc = StepInitialize2(ML_STAR, initializeAlways, errorHandling, userResponseTime);
		
		return(rc);
	}


	function StepTipPickup(
		device& ML_STAR,
		sequence& tipPickupSequence,
		variable tipPickupSequenceCounting,
		variable& tipPickupChannelVariable,
		variable tipPickupChannelUse,
		variable errorHandling,
		variable userResponseTime)
	{
		variable rc[];

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamSequence(stepName, "tipPickupSequence", tipPickupSequence);
			DEBUG::TraceStepParamVariable(stepName, "tipPickupSequenceCounting", tipPickupSequenceCounting);
			DEBUG::TraceStepParamVariable(stepName, "tipPickupChannelVariable", tipPickupChannelVariable);
			DEBUG::TraceStepParamVariable(stepName, "tipPickupChannelUse", tipPickupChannelUse);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif

		if (ErrorHandling::abort_ == errorHandling)
			rc = ML_STAR._541143FA_7FA2_11D3_AD85_0004ACB1DCB2( "97dbaf11_5084_41dd_8a44f0ac915ef29f" ); // TipPickUp
		if (ErrorHandling::cancel == errorHandling)
			rc = ML_STAR._541143FA_7FA2_11D3_AD85_0004ACB1DCB2( "14066b9f_7dc7_4cf6_b817ed3d34feaf28" ); // TipPickUp
		if (ErrorHandling::continue == errorHandling)
			rc = ML_STAR._541143FA_7FA2_11D3_AD85_0004ACB1DCB2( "1f0bc128_757b_4a80_a0046d8f1895b3b8" ); // TipPickUp
		if (ErrorHandling::continue_2 == errorHandling)
			rc = ML_STAR._541143FA_7FA2_11D3_AD85_0004ACB1DCB2( "a72a588d_26f6_4065_b10f30465e088c8b" ); // TipPickUp

		return(rc);
	}

	function StepTipPickupEx(
		device& ML_STAR,
		sequence& tipPickupSequence,
		variable tipPickupSequenceCounting,
		variable& tipPickupChannelVariable,
		variable tipPickupChannelUse,
		variable errorHandling,
		variable userResponseTime)
	{
		variable rc[];

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamSequence(stepName, "tipPickupSequence", tipPickupSequence);
			DEBUG::TraceStepParamVariable(stepName, "tipPickupSequenceCounting", tipPickupSequenceCounting);
			DEBUG::TraceStepParamVariable(stepName, "tipPickupChannelVariable", tipPickupChannelVariable);
			DEBUG::TraceStepParamVariable(stepName, "tipPickupChannelUse", tipPickupChannelUse);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif

		if (ErrorHandling::abort_ == errorHandling)
			rc = ML_STAR._541143FA_7FA2_11D3_AD85_0004ACB1DCB2( "c4a94bbc_7db6_4052_b37e98851b78dd21" ); // TipPickUp
		if (ErrorHandling::cancel == errorHandling)
			rc = ML_STAR._541143FA_7FA2_11D3_AD85_0004ACB1DCB2( "305a5f24_1b35_483f_8114122d25ef51b0" ); // TipPickUp
		if (ErrorHandling::continue == errorHandling)
			rc = ML_STAR._541143FA_7FA2_11D3_AD85_0004ACB1DCB2( "320e25f1_dc1f_455e_894d3f98f6204c56" ); // TipPickUp
		if (ErrorHandling::continue_2 == errorHandling)
			rc = ML_STAR._541143FA_7FA2_11D3_AD85_0004ACB1DCB2( "db54747f_55b1_443d_b6052373717af691" ); // TipPickUp

		return(rc);
	}

	function StepTipEject(
		device& ML_STAR,
		variable tipEjectUseDefaultWaste,
		sequence& tipEjectSequence,
		variable tipEjectSequenceCounting,
		variable& tipEjectChannelVariable,
		variable tipEjectChannelUse,
		variable errorHandling,
		variable userResponseTime)
	{
		variable rc[];

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamVariable(stepName, "tipEjectUseDefaultWaste", tipEjectUseDefaultWaste);
			DEBUG::TraceStepParamSequence(stepName, "tipEjectSequence", tipEjectSequence);
			DEBUG::TraceStepParamVariable(stepName, "tipEjectSequenceCounting", tipEjectSequenceCounting);
			DEBUG::TraceStepParamVariable(stepName, "tipEjectChannelVariable", tipEjectChannelVariable);
			DEBUG::TraceStepParamVariable(stepName, "tipEjectChannelUse", tipEjectChannelUse);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif

		if (ErrorHandling::abort_ == errorHandling)
			rc = ML_STAR._541143FC_7FA2_11D3_AD85_0004ACB1DCB2( "99b24a5e_7d7f_4ca4_b6bfad1877a91483" ); // TipEject
		if (ErrorHandling::cancel == errorHandling)
			rc = ML_STAR._541143FC_7FA2_11D3_AD85_0004ACB1DCB2( "28b3dcff_ece1_4cac_a9436b503c220974" ); // TipEject
		if (ErrorHandling::continue == errorHandling)
			rc = ML_STAR._541143FC_7FA2_11D3_AD85_0004ACB1DCB2( "204673c6_2795_4fad_b1909e591f978779" ); // TipEject

		return(rc);
	}

	static function StepAspirateEx(
		device& ML_STAR,
		sequence& aspirateSequence,
		variable aspirateSequenceCounting,
		variable& aspirateVolumes[],
		variable aspirateMode,
		variable aspirateCLLDSensitivity,
		variable aspiratePLLDSensitivity,
		variable aspirateSubmergeDepth,
		variable aspirateFluidHeight,
		variable aspirateMaxHeightDiff,
		variable& aspirateChannelVariable,
		variable aspirateChannelUse,
		variable aspirateLiquidFollowing,
		variable aspiratePrerinsingMixCycles,
		variable aspiratePrerinsingMixPosition,
		variable aspiratePrerinsingMixVolume,
		variable& aspirateUserDefinedLiquidClass,
		variable errorHandling,
		variable userResponseTime)
	{
		variable rc[];
		variable size;
		variable aspirateVolume1(0);
		variable aspirateVolume2(0);
		variable aspirateVolume3(0);
		variable aspirateVolume4(0);
		variable aspirateVolume5(0);
		variable aspirateVolume6(0);
		variable aspirateVolume7(0);
		variable aspirateVolume8(0);
		variable aspirateVolume9(0);
		variable aspirateVolume10(0);
		variable aspirateVolume11(0);
		variable aspirateVolume12(0);
		variable aspirateVolume13(0);
		variable aspirateVolume14(0);
		variable aspirateVolume15(0);
		variable aspirateVolume16(0);

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamSequence(stepName, "aspirateSequence", aspirateSequence);
			DEBUG::TraceStepParamVariable(stepName, "aspirateSequenceCounting", aspirateSequenceCounting);
			DEBUG::TraceStepParamVariableArray(stepName, "aspirateVolumes", aspirateVolumes);
			DEBUG::TraceStepParamVariable(stepName, "aspirateMode", aspirateMode);
			DEBUG::TraceStepParamVariable(stepName, "aspirateCLLDSensitivity", aspirateCLLDSensitivity);
			DEBUG::TraceStepParamVariable(stepName, "aspiratePLLDSensitivity", aspiratePLLDSensitivity);
			DEBUG::TraceStepParamVariable(stepName, "aspirateSubmergeDepth", aspirateSubmergeDepth);
			DEBUG::TraceStepParamVariable(stepName, "aspirateFluidHeight", aspirateFluidHeight);
			DEBUG::TraceStepParamVariable(stepName, "aspirateMaxHeightDiff", aspirateMaxHeightDiff);
			DEBUG::TraceStepParamVariable(stepName, "aspirateChannelVariable", aspirateChannelVariable);
			DEBUG::TraceStepParamVariable(stepName, "aspirateChannelUse", aspirateChannelUse);
			DEBUG::TraceStepParamVariable(stepName, "aspirateLiquidFollowing", aspirateLiquidFollowing);
			DEBUG::TraceStepParamVariable(stepName, "aspiratePrerinsingMixCycles", aspiratePrerinsingMixCycles);
			DEBUG::TraceStepParamVariable(stepName, "aspiratePrerinsingMixPosition", aspiratePrerinsingMixPosition);
			DEBUG::TraceStepParamVariable(stepName, "aspiratePrerinsingMixVolume", aspiratePrerinsingMixVolume);
			DEBUG::TraceStepParamVariable(stepName, "aspirateUserDefinedLiquidClass", aspirateUserDefinedLiquidClass);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif

		size = aspirateVolumes.GetSize();
		if (0 < size)
			aspirateVolume1 = aspirateVolumes.GetAt(0);
		if (1 < size)
			aspirateVolume2 = aspirateVolumes.GetAt(1);
		if (2 < size)
			aspirateVolume3 = aspirateVolumes.GetAt(2);
		if (3 < size)
			aspirateVolume4 = aspirateVolumes.GetAt(3);
		if (4 < size)
			aspirateVolume5 = aspirateVolumes.GetAt(4);
		if (5 < size)
			aspirateVolume6 = aspirateVolumes.GetAt(5);
		if (6 < size)
			aspirateVolume7 = aspirateVolumes.GetAt(6);
		if (7 < size)
			aspirateVolume8 = aspirateVolumes.GetAt(7);
		if (8 < size)
			aspirateVolume9 = aspirateVolumes.GetAt(8);
		if (9 < size)
			aspirateVolume10 = aspirateVolumes.GetAt(9);
		if (10 < size)
			aspirateVolume11 = aspirateVolumes.GetAt(10);
		if (11 < size)
			aspirateVolume12 = aspirateVolumes.GetAt(11);
		if (12 < size)
			aspirateVolume13 = aspirateVolumes.GetAt(12);
		if (13 < size)
			aspirateVolume14 = aspirateVolumes.GetAt(13);
		if (14 < size)
			aspirateVolume15 = aspirateVolumes.GetAt(14);
		if (15 < size)
			aspirateVolume16 = aspirateVolumes.GetAt(15);

		if (ErrorHandling::abort_ == errorHandling)
			rc = ML_STAR._541143F5_7FA2_11D3_AD85_0004ACB1DCB2( "bd01f18c_bc3e_4f57_ac66536897955dae" ); // Aspirate
		if (ErrorHandling::cancel == errorHandling)
			rc = ML_STAR._541143F5_7FA2_11D3_AD85_0004ACB1DCB2( "8551166e_22f5_4de4_a30031089fc16019" ); // Aspirate
		if (ErrorHandling::continue == errorHandling)
			rc = ML_STAR._541143F5_7FA2_11D3_AD85_0004ACB1DCB2( "ac8a2ef9_0c12_4803_ba63768925292445" ); // Aspirate

		return(rc);
	}

	static function StepAspirate(
		device& ML_STAR,
		sequence& aspirateSequence,
		variable aspirateSequenceCounting,
		variable aspirateVolume,
		variable aspirateMode,
		variable aspirateCLLDSensitivity,
		variable aspiratePLLDSensitivity,
		variable aspirateSubmergeDepth,
		variable aspirateFluidHeight,
		variable aspirateMaxHeightDiff,
		variable& aspirateChannelVariable,
		variable aspirateChannelUse,
		variable aspirateLiquidFollowing,
		variable aspiratePrerinsingMixCycles,
		variable aspiratePrerinsingMixPosition,
		variable aspiratePrerinsingMixVolume,
		variable& aspirateUserDefinedLiquidClass,
		variable errorHandling,
		variable userResponseTime)
	{
		variable size;
		variable index;
		variable aspirateVolumes[];
		string aspirateChannelVariableCopy;

		aspirateChannelVariableCopy = aspirateChannelVariable;
		size = aspirateChannelVariableCopy.GetLength();
		for (index = 0; index < size; index++)
		{
			aspirateVolumes.AddAsLast(aspirateVolume);
		}
		return(StepAspirateEx(	ML_STAR,
										aspirateSequence,
										aspirateSequenceCounting,
										aspirateVolumes,
										aspirateMode,
										aspirateCLLDSensitivity,
										aspiratePLLDSensitivity,
										aspirateSubmergeDepth,
										aspirateFluidHeight,
										aspirateMaxHeightDiff,
										aspirateChannelVariable,
										aspirateChannelUse,
										aspirateLiquidFollowing,
										aspiratePrerinsingMixCycles,
										aspiratePrerinsingMixPosition,
										aspiratePrerinsingMixVolume,
										aspirateUserDefinedLiquidClass,
										errorHandling,
										userResponseTime));
	}

	function StepDispenseEx(
		device& ML_STAR,
		sequence& dispenseSequence,
		variable dispenseSequenceCounting,
		variable& dispenseVolumes[],
		variable dispenseMode,
		variable dispenseCLLDSensitivity,
		variable dispenseSubmergeDepth,
		variable dispenseFluidHeight,
		variable& dispenseChannelVariable,
		variable dispenseChannelUse,
		variable dispenseLiquidFollowing,
		variable dispensePrerinsingMixCycles,
		variable dispensePrerinsingMixPosition,
		variable dispensePrerinsingMixVolume,
		variable& dispenseUserDefinedLiquidClass,
		variable errorHandling,
		variable userResponseTime)
	{
		variable rc[];
		variable size;
		variable dispenseVolume1(0);
		variable dispenseVolume2(0);
		variable dispenseVolume3(0);
		variable dispenseVolume4(0);
		variable dispenseVolume5(0);
		variable dispenseVolume6(0);
		variable dispenseVolume7(0);
		variable dispenseVolume8(0);
		variable dispenseVolume9(0);
		variable dispenseVolume10(0);
		variable dispenseVolume11(0);
		variable dispenseVolume12(0);
		variable dispenseVolume13(0);
		variable dispenseVolume14(0);
		variable dispenseVolume15(0);
		variable dispenseVolume16(0);

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamSequence(stepName, "dispenseSequence", dispenseSequence);
			DEBUG::TraceStepParamVariable(stepName, "dispenseSequenceCounting", dispenseSequenceCounting);
			DEBUG::TraceStepParamVariableArray(stepName, "dispenseVolumes", dispenseVolumes);
			DEBUG::TraceStepParamVariable(stepName, "dispenseMode", dispenseMode);
			DEBUG::TraceStepParamVariable(stepName, "dispenseCLLDSensitivity", dispenseCLLDSensitivity);
			DEBUG::TraceStepParamVariable(stepName, "dispenseSubmergeDepth", dispenseSubmergeDepth);
			DEBUG::TraceStepParamVariable(stepName, "dispenseFluidHeight", dispenseFluidHeight);
			DEBUG::TraceStepParamVariable(stepName, "dispenseChannelVariable", dispenseChannelVariable);
			DEBUG::TraceStepParamVariable(stepName, "dispenseChannelUse", dispenseChannelUse);
			DEBUG::TraceStepParamVariable(stepName, "dispenseLiquidFollowing", dispenseLiquidFollowing);
			DEBUG::TraceStepParamVariable(stepName, "dispensePrerinsingMixCycles", dispensePrerinsingMixCycles);
			DEBUG::TraceStepParamVariable(stepName, "dispensePrerinsingMixPosition", dispensePrerinsingMixPosition);
			DEBUG::TraceStepParamVariable(stepName, "dispensePrerinsingMixVolume", dispensePrerinsingMixVolume);
			DEBUG::TraceStepParamVariable(stepName, "dispenseUserDefinedLiquidClass", dispenseUserDefinedLiquidClass);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif

		size = dispenseVolumes.GetSize();
		if (0 < size)
			dispenseVolume1 = dispenseVolumes.GetAt(0);
		if (1 < size)
			dispenseVolume2 = dispenseVolumes.GetAt(1);
		if (2 < size)
			dispenseVolume3 = dispenseVolumes.GetAt(2);
		if (3 < size)
			dispenseVolume4 = dispenseVolumes.GetAt(3);
		if (4 < size)
			dispenseVolume5 = dispenseVolumes.GetAt(4);
		if (5 < size)
			dispenseVolume6 = dispenseVolumes.GetAt(5);
		if (6 < size)
			dispenseVolume7 = dispenseVolumes.GetAt(6);
		if (7 < size)
			dispenseVolume8 = dispenseVolumes.GetAt(7);
		if (8 < size)
			dispenseVolume9 = dispenseVolumes.GetAt(8);
		if (9 < size)
			dispenseVolume10 = dispenseVolumes.GetAt(9);
		if (10 < size)
			dispenseVolume11 = dispenseVolumes.GetAt(10);
		if (11 < size)
			dispenseVolume12 = dispenseVolumes.GetAt(11);
		if (12 < size)
			dispenseVolume13 = dispenseVolumes.GetAt(12);
		if (13 < size)
			dispenseVolume14 = dispenseVolumes.GetAt(13);
		if (14 < size)
			dispenseVolume15 = dispenseVolumes.GetAt(14);
		if (15 < size)
			dispenseVolume16 = dispenseVolumes.GetAt(15);

		if (ErrorHandling::abort_ == errorHandling)
			rc = ML_STAR._541143F8_7FA2_11D3_AD85_0004ACB1DCB2( "2846b0ac_5dde_4a9d_9e87f8604e5587a6" ); // Dispense
		if (ErrorHandling::cancel == errorHandling)
			rc = ML_STAR._541143F8_7FA2_11D3_AD85_0004ACB1DCB2( "00e401c9_0cd8_4f80_95bc3825df158925" ); // Dispense
		if (ErrorHandling::continue == errorHandling)
			rc = ML_STAR._541143F8_7FA2_11D3_AD85_0004ACB1DCB2( "e23effa6_2e01_47a5_bee949c9095c27ac" ); // Dispense

		return(rc);
	}

	function StepDispense(
		device& ML_STAR,
		sequence& dispenseSequence,
		variable dispenseSequenceCounting,
		variable dispenseVolume,
		variable dispenseMode,
		variable dispenseCLLDSensitivity,
		variable dispenseSubmergeDepth,
		variable dispenseFluidHeight,
		variable& dispenseChannelVariable,
		variable dispenseChannelUse,
		variable dispenseLiquidFollowing,
		variable dispensePrerinsingMixCycles,
		variable dispensePrerinsingMixPosition,
		variable dispensePrerinsingMixVolume,
		variable& dispenseUserDefinedLiquidClass,
		variable errorHandling,
		variable userResponseTime)
	{
		variable size;
		variable index;
		variable dispenseVolumes[];
		string dispenseChannelVariableCopy;

		dispenseChannelVariableCopy = dispenseChannelVariable;
		size = dispenseChannelVariableCopy.GetLength();
		for (index = 0; index < size; index++)
		{
			dispenseVolumes.AddAsLast(dispenseVolume);
		}
		return(StepDispenseEx(	ML_STAR,
										dispenseSequence,
										dispenseSequenceCounting,
										dispenseVolumes,
										dispenseMode,
										dispenseCLLDSensitivity,
										dispenseSubmergeDepth,
										dispenseFluidHeight,
										dispenseChannelVariable,
										dispenseChannelUse,
										dispenseLiquidFollowing,
										dispensePrerinsingMixCycles,
										dispensePrerinsingMixPosition,
										dispensePrerinsingMixVolume,
										dispenseUserDefinedLiquidClass,
										errorHandling,
										userResponseTime));
	}

	function StepLoadCarrierEx(
		device& ML_STAR,
		variable& loadCarrier,
		variable loadCarrierBarcodeFileName,
		variable barcodeReadPositions,
		variable recoveryOptionContinue,
		variable recoveryOptionExclude,
		variable recoveryOptionDefault,
		variable errorHandling,
		variable userResponseTime)
	{
		variable rc[];

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamVariable(stepName, "loadCarrier", loadCarrier);
			DEBUG::TraceStepParamVariable(stepName, "loadCarrierBarcodeFileName", loadCarrierBarcodeFileName);
			DEBUG::TraceStepParamVariable(stepName, "barcodeReadPositions", barcodeReadPositions);
			DEBUG::TraceStepParamVariable(stepName, "recoveryOptionContinue", recoveryOptionContinue);
			DEBUG::TraceStepParamVariable(stepName, "recoveryOptionExclude", recoveryOptionExclude);
			DEBUG::TraceStepParamVariable(stepName, "recoveryOptionDefault", recoveryOptionDefault);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif

		if (ErrorHandling::abort_ == errorHandling)
			rc = ML_STAR._54114402_7FA2_11D3_AD85_0004ACB1DCB2( "51fa936b_e34c_4bd6_9d7138bfa9130fd4" ); // LoadCarrier
		if (ErrorHandling::cancel == errorHandling)
			rc = ML_STAR._54114402_7FA2_11D3_AD85_0004ACB1DCB2( "40a190e8_8836_4b88_a25dc7672ab91bcd" ); // LoadCarrier
		if (ErrorHandling::continue == errorHandling)
		{
			if (1 == recoveryOptionContinue && 	// visible
				 1 == recoveryOptionExclude &&  	// visible
				 1 == recoveryOptionDefault)		// =exclude
			{
				rc = ML_STAR._54114402_7FA2_11D3_AD85_0004ACB1DCB2( "333c9a62_9cb5_4ad4_961d4cfe30b03222" ); // LoadCarrier
				return(rc);
			}
			if (1 == recoveryOptionContinue && 	// visible 
				 1 == recoveryOptionExclude && 	// visible 
				 0 == recoveryOptionDefault)		// =continue
			{
				rc = ML_STAR._54114402_7FA2_11D3_AD85_0004ACB1DCB2( "122a5c91_bfdd_453b_9f3f34f761651253" ); // LoadCarrier
				return(rc);
			}
			if (1 == recoveryOptionContinue &&  // visible
				 0 == recoveryOptionExclude &&  	// hidden
				 0 == recoveryOptionDefault)		// =continue
			{
				rc = ML_STAR._54114402_7FA2_11D3_AD85_0004ACB1DCB2( "7c9427b6_a944_4858_819a05b6cd9c37c2" ); // LoadCarrier
				return(rc);
			}
			if (0 == recoveryOptionContinue &&  // hidden
				 1 == recoveryOptionExclude &&  	// visible
				 1 == recoveryOptionDefault)		// =exclude
			{
				rc = ML_STAR._54114402_7FA2_11D3_AD85_0004ACB1DCB2( "aea4e3f3_64ce_47e4_8d2891ee2b0545f7" ); // LoadCarrier
				return(rc);
			}
		}
		return(rc);
	}

	// Load Carrier step extension for special use with Load And Match
	function StepLoadCarrierEx2(
		device& ML_STAR,
		variable& loadCarrier,
		variable loadCarrierBarcodeFileName,
		variable barcodeReadPositions,
		variable recoveryOptionContinue,
		variable recoveryOptionExclude,
		variable recoveryOptionDefault,
		variable errorHandling,
		variable userResponseTime)
	{
		variable rc[];

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamVariable(stepName, "loadCarrier", loadCarrier);
			DEBUG::TraceStepParamVariable(stepName, "loadCarrierBarcodeFileName", loadCarrierBarcodeFileName);
			DEBUG::TraceStepParamVariable(stepName, "barcodeReadPositions", barcodeReadPositions);
			DEBUG::TraceStepParamVariable(stepName, "recoveryOptionContinue", recoveryOptionContinue);
			DEBUG::TraceStepParamVariable(stepName, "recoveryOptionExclude", recoveryOptionExclude);
			DEBUG::TraceStepParamVariable(stepName, "recoveryOptionDefault", recoveryOptionDefault);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif

		if (ErrorHandling::abort_ == errorHandling)
			rc = ML_STAR._54114402_7FA2_11D3_AD85_0004ACB1DCB2( "4249db47_36e7_47b7_88fc7b4f89159bbe" ); // LoadCarrier
		if (ErrorHandling::cancel == errorHandling)
			rc = ML_STAR._54114402_7FA2_11D3_AD85_0004ACB1DCB2( "b08179f5_df3c_4acf_a05724bb17a18712" ); // LoadCarrier
		if (ErrorHandling::continue == errorHandling)
		{
			// Special error settings in StepLoadCarrierEx2
			// Error "No Labware Error" is recovered with 'exclude' immediately (timeout=0) and 'continue' is hidden.

			if (1 == recoveryOptionContinue && 	// visible 
				 1 == recoveryOptionExclude && 	// visible 
				 1 == recoveryOptionDefault)		// =exclude
			{
				rc = ML_STAR._54114402_7FA2_11D3_AD85_0004ACB1DCB2( "b0254f02_0e42_4d7d_9f07e3edceac61e1" ); // LoadCarrier
				return(rc);
			}
			if (1 == recoveryOptionContinue && 	// visible 
				 1 == recoveryOptionExclude && 	// visible 
				 0 == recoveryOptionDefault)		// =continue
			{
				rc = ML_STAR._54114402_7FA2_11D3_AD85_0004ACB1DCB2( "2fe8a1f8_4d65_4edb_8860b62e24440d2e" ); // LoadCarrier
				return(rc);
			}
			if (1 == recoveryOptionContinue && 	// visible 
				 0 == recoveryOptionExclude && 	// hidden  
				 0 == recoveryOptionDefault)		// =continue
			{
				rc = ML_STAR._54114402_7FA2_11D3_AD85_0004ACB1DCB2( "861d419c_ab6f_4d82_9e40ae1014b5e438" ); // LoadCarrier
				return(rc);
			}
			if (0 == recoveryOptionContinue && 	// hidden 
				 1 == recoveryOptionExclude && 	// visible 
				 1 == recoveryOptionDefault)		// =exclude
			{
				rc = ML_STAR._54114402_7FA2_11D3_AD85_0004ACB1DCB2( "4684ef2c_c114_4941_9e2766dfd5b4d9a4" ); // LoadCarrier
				return(rc);
			}
		}
		return(rc);
	}

	function StepLoadCarrier(
		device& ML_STAR,
		variable& loadCarrier,
		variable loadCarrierBarcodeFileName,
		variable errorHandling,
		variable userResponseTime)
	{
		variable barcodeReadPositions("?");						// load carrier barcode read positions
		variable recoveryOptionContinue(hslTrue);				// visibility of recovery option Continue (0 = invisible, 1 = visible)
		variable recoveryOptionExclude(hslTrue);				// visibility of recovery option Continue (0 = invisible, 1 = visible)
		variable recoveryOptionDefault(0);						// default of recovery options Continue and Exclude (0 = Continue, 1 = Exclude) 

		return(StepLoadCarrierEx(	ML_STAR,
											loadCarrier,
											loadCarrierBarcodeFileName,
											barcodeReadPositions,
											recoveryOptionContinue,
											recoveryOptionExclude,
											recoveryOptionDefault,
											errorHandling,
											userResponseTime));
	}

	function StepUnloadCarrier(
		device& ML_STAR,
		variable& unloadCarrier,
		variable errorHandling,
		variable userResponseTime)
	{
		variable rc[];

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamVariable(stepName, "unloadCarrier", unloadCarrier);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif

		if (ErrorHandling::abort_ == errorHandling)
			rc = ML_STAR._54114400_7FA2_11D3_AD85_0004ACB1DCB2( "7c957da4_e37b_4567_8b421aaeb8da4b99" ); // UnloadCarrier
		if (ErrorHandling::cancel == errorHandling)
			rc = ML_STAR._54114400_7FA2_11D3_AD85_0004ACB1DCB2( "109856e6_ecea_491c_94f89013d28128cf" ); // UnloadCarrier
		if (ErrorHandling::continue == errorHandling)
			rc = ML_STAR._54114400_7FA2_11D3_AD85_0004ACB1DCB2( "942fdf58_55c4_469c_8d20cc89a906c119" ); // UnloadCarrier

		return(rc);
	}

	function StepCalibrate1536Plate(
		device& ML_STAR,
		variable& calibrateCarrier,
		variable calibrateCarrierChannel,
		variable errorHandling,
		variable userResponseTime)
	{
		variable rc[];

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamVariable(stepName, "calibrateCarrier", calibrateCarrier);
			DEBUG::TraceStepParamVariable(stepName, "calibrateCarrierChannel", calibrateCarrierChannel);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif

		if (ErrorHandling::abort_ == errorHandling)
			rc = ML_STAR._81DA4251_3BA9_11d4_AE21_0004ACB1DCB2( "b58fc08f_3e8a_4f01_8f612ec59f871425" ); // Calibrate1536Plate
		if (ErrorHandling::cancel == errorHandling)
			rc = ML_STAR._81DA4251_3BA9_11d4_AE21_0004ACB1DCB2( "c2a4a543_b657_4484_824b2e35b4386662" ); // Calibrate1536Plate
		if (ErrorHandling::continue == errorHandling)
			rc = ML_STAR._81DA4251_3BA9_11d4_AE21_0004ACB1DCB2( "b8732fdf_840a_47d8_9aa1ca8edf6a313c" ); // Calibrate1536Plate

		return(rc);
	}

	function StepWaitNeedleWashed(
		device& ML_STAR,
		variable& washStation,
		variable errorHandling,
		variable userResponseTime)
	{
		variable rc[];

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamVariable(stepName, "washStation", washStation);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif

		if (ErrorHandling::abort_ == errorHandling)
			rc = ML_STAR._BCAAD4F5_0BD2_4d9c_8243_70DD893496CB( "5bef4e69_24df_4657_ba12c8d89d5a63da" ); // WaitNeedleWashed
		if (ErrorHandling::cancel == errorHandling)
			rc = ML_STAR._BCAAD4F5_0BD2_4d9c_8243_70DD893496CB( "7b76554d_f9f1_439d_82cfae27e7de15e9" ); // WaitNeedleWashed
		if (ErrorHandling::continue == errorHandling)
			rc = ML_STAR._BCAAD4F5_0BD2_4d9c_8243_70DD893496CB( "1f205970_6cc7_42f4_ad59587bc0995713" ); // WaitNeedleWashed

		return(rc);
	}

	function StepStartNeedleWash(
		device& ML_STAR,
		variable& washStation,
		variable rinseTime1,
		variable soakTime1,
		variable flowRate1,
		variable rinseTime2,
		variable soakTime2,
		variable flowRate2,
		variable drainingTime,
		variable startWashLiquid,
		variable errorHandling,
		variable userResponseTime)
	{
		variable rc[];

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamVariable(stepName, "washStation", washStation);
			DEBUG::TraceStepParamVariable(stepName, "rinseTime1", rinseTime1);
			DEBUG::TraceStepParamVariable(stepName, "soakTime1", soakTime1);
			DEBUG::TraceStepParamVariable(stepName, "flowRate1", flowRate1);
			DEBUG::TraceStepParamVariable(stepName, "rinseTime2", rinseTime2);
			DEBUG::TraceStepParamVariable(stepName, "soakTime2", soakTime2);
			DEBUG::TraceStepParamVariable(stepName, "flowRate2", flowRate2);
			DEBUG::TraceStepParamVariable(stepName, "drainingTime", drainingTime);
			DEBUG::TraceStepParamVariable(stepName, "startWashLiquid", startWashLiquid);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif

		if (ErrorHandling::abort_ == errorHandling)
			rc = ML_STAR._C3B1B9A6_5B2F_4069_B9CB_68A675EC480D( "09b85c79_1970_4ffd_9967c2970b7cfe50" ); // StartNeedleWash
		if (ErrorHandling::cancel == errorHandling)
			rc = ML_STAR._C3B1B9A6_5B2F_4069_B9CB_68A675EC480D( "50f13c0d_d4c5_45d2_a4cf9de7e1f22b73" ); // StartNeedleWash
		if (ErrorHandling::continue == errorHandling)
			rc = ML_STAR._C3B1B9A6_5B2F_4069_B9CB_68A675EC480D( "215ff88b_bcab_43fc_adad659b825c2ef3" ); // StartNeedleWash

		return(rc);
	}

	function StepFirmwareCommand(
		device& ML_STAR,
		variable& commandString,
		variable& parameterString,
		variable& returnValues[]) void
	{
		returnValues.SetSize(0);
		returnValues = ML_STAR._1FB5DA01_3ACB_11d4_AE1F_0004ACB1DCB2( "3b96af1f_dd44_4c8c_8eb9fa4e2c9963e6" ); // FirmwareCommand
	}
}
#endif
#endif
// $$author=wbarmettler$$valid=1$$time=2017-03-14 13:14$$checksum=52644606$$length=090$$