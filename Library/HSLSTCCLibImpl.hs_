//  ------------------------------------------------------------------------------------
//  Hamilton Company Software Product.
//  File: HSLSTCCLibImpl.hs_
//
//  This is a part of the module HxSTCompCmd.
//  Implementation of the MECC Template Library.
//
//  File creation date:  2004-03-16 by CJo
//  Last revision date:  2008-12-18 by CJo
//
//  Copyright (c) 2008 by Hamilton Bonaduz AG.
//
//
//  Modification History
//  --------------------
//  1.00  2004-03-16 by CJo  Initial file creation.
//  1.10  2004-04-02 by CJo  SetElementBarcodeForSequencePos() and RemoveElementAtSequencePos()
//                           The passed position number is only valid if:
//                           seqPos >= 1 and seqPos <= seq.Count()
//                           (before it was testet by: seqPos >= 1 and seqPos <= seq.Total(), 
//                           we must test against .Count() because SetCurrentPosition() is not
//                           possible by passing a value greather than .Count().
//  1.20  2007-07-25 by UBe  Use of HSLUtilLib2 to check input params.
//                           Implemented functions GenerateMappingFileV42() and GenerateMappingFileV42Ex1()
//  1.05  2008-12-18 by CJo  Implemented functions GenerateMappingFileV43() and GenerateMappingFileV43Ex1()
//                           From the old V42 functions forward to the V43 functions.
//  ------------------------------------------------------------------------------------

#pragma once

#ifndef __HSLUtilLib2_hsl__
	#include "HSLUtilLib2.hsl"
#endif

#ifndef __HSLUtilLib2Def_hs___
	#include "HSLUtilLib2Def.hs_"
#endif

namespace STCC
{
	// Library provides implementation of the step
	// It's included in the STCC namespace to not work in the same context
	// with the same library if it's already included in the method (e.g. by the programmer).
	#include "HSLMappingReportImpl.hs_"


	namespace STR							// Include the StringTable library in its own namespace!
	{
		#ifndef __HSLStringTableLib_hsl__
		#include "HSLStringTableLib.hs_"
		#endif
	}

	// --------------------------------------------------------------------------------------
	// Debugging
	// --------------------------------------------------------------------------------------

	//#define _DEBUG_STCC		1				// specifies the debug version of the STCC library


	// ======================================================================================
	// "Exported" functions, used by the generated code
	// ======================================================================================

	// Step 'Generate Mapping File'
	static function ResetFilterSequences() void;	// Resets all previous addded filter sequences.

	static function AddFilterSequence(				// Adds a filter sequence used by the next GenerateMappingFile
		device    deviceContext,						// i: instrument on which the filter sequence must be valid
		sequence& filterSequence) void;				// i: its labware between first and end position used as filter
																// Throws an exception if failed.

	static function GenerateMappingFile(			// Generates a mapping file for each rack in target sequence. Resets
																// the added filter sequences if the function is done.
		device    deviceContext,						// i: instrument on which the target sequence must be valid
		sequence& targetSequence,						// i: a mapping file for racks between first and end position is generated
		variable& strFilename,							// i: file name (with placeholders) used for file generation
		variable& strPath,								// i: path into which the mapping files should be generated (may be empty)
		variable& arrStrGeneratedFiles[]) void;	// o: array contains the generated files names as string.
																// Throws an exception if failed.

	static function GenerateMappingFileEx1(		// same as GenerateMappingFile, but without the out parameter arrStrGeneratedFiles
		device    deviceContext,						// i:
		sequence& targetSequence,						// i:
		variable& strFilename,							// i:
		variable& strPath) void;						// i:

	static function GenerateMappingFileV42(		// Generates a mapping file for each rack in target sequence. Resets
																// the added filter sequences if the function is done.
		device    deviceContext,						// i: instrument on which the target sequence must be valid
		sequence& targetSequence,						// i: a mapping file for racks between first and end position is generated
		variable  filterMode,							// i: filter mode to be used
		variable& arrFilters[],							// i: array contains the filter to be used (may be empty)
		variable  sortMode,								// i: sort mode to be used
		variable& arrColumnIds[],						// i: array contains the column identifier
		variable& arrColumnNames[],					// i: array contains the column names to be used
		variable& arrExperiments[],					// i: array contains the experiment names (may be empty)
		variable  arrExpStartIndex,					// i: start index
		variable  arrExpEndIndex,						// i: end index
		variable& strFilename,							// i: file name (with placeholders) used for file generation
		variable  createOneFile,						// i: flag, indicating wheter one file must be created
		variable  openFileToAppend,					// i: flag, indicating wheter data shall be appended to an existing file
		variable& strPath,								// i: path into which the mapping files should be generated (may be empty)
		variable& arrStrGeneratedFiles[]) void;	// o: array contains the generated files names as string.

	static function GenerateMappingFileV42Ex1(	// same as GenerateMappingFileV42, but without the out parameter arrStrGeneratedFiles
		device    deviceContext,						// i:
		sequence& targetSequence,						// i:
		variable  filterMode,							// i:
		variable& arrFilters[],							// i:
		variable  sortMode,								// i:
		variable& arrColumnIds[],						// i:
		variable& arrColumnNames[],					// i:
		variable& arrExperiments[],					// i:
		variable  arrExpStartIndex,					// i:
		variable  arrExpEndIndex,						// i:
		variable& strFilename,							// i:
		variable  createOneFile,						// i:
		variable  openFileToAppend,					// i:
		variable& strPath) void;						// i:

	static function GenerateMappingFileV43(		// Same as function GenerateMappingFileV42 with the following changes:
																// - removed arrExperiments start/end index because this was never working
																//   and is not longer supported by the dialog.
																// - added filterFlagsEx parameter
		device    deviceContext,						// i: instrument on which the target sequence must be valid
		sequence& targetSequence,						// i: a mapping file for racks between first and end position is generated
      variable  filterMode,                     // i: filter mode to be used
      variable& arrFilters[],                   // i: array contains the filter to be used (may be empty)
      variable  sortMode,                       // i: sort mode to be used
      variable& arrColumnIds[],                 // i: array contains the column identifier
      variable& arrColumnNames[],               // i: array contains the column names to be used
      variable& arrExperiments[],               // i: array contains the experiment names (may be empty)
		variable& strFilename,							// i: file name (with placeholders) used for file generation
      variable  createOneFile,                  // i: flag, indicating wheter one file must be created
      variable  openFileToAppend,               // i: flag, indicating wheter data shall be appended to an existing file
		variable& strPath,								// i: path into which the mapping files should be generated (may be empty)
		variable  filterFlagsEx,						// i: added in V4.3: Additional FilterFlagsEx, bitwise combination.
		variable& arrStrGeneratedFiles[]) void;	// o: array contains the generated files names as string.

	static function GenerateMappingFileV43Ex1(	// same as GenerateMappingFileV43, but without the out parameter arrStrGeneratedFiles
		device    deviceContext,						// i:
      sequence& targetSequence,						// i:
      variable  filterMode,                     // i:
      variable& arrFilters[],                   // i:
      variable  sortMode,                       // i:
      variable& arrColumnIds[],                 // i:
      variable& arrColumnNames[],               // i:
      variable& arrExperiments[],               // i:
		variable& strFilename,							// i:
      variable  createOneFile,                  // i:
      variable  openFileToAppend,               // i:
		variable& strPath,								// i:
		variable  filterFlagsEx) void; 				// i: added in V4.3: Additional FilterFlagsEx, bitwise combination.



	static function SetElementBarcode(				// Sets the element barcode for a rack or a well/cup position.
																// if positionID is an empty string the barcode is set for the rack.
		device    deviceContext,						// i: instrument on which LabId / PosID must be a valid labware
		variable& labwareID,								// i: the labware for which the barcode should be set (string)
		variable& positionID,							// i: the position for which the barcode should be set (string, may be empty)
		variable& barcode) void;						// i: barcode to set for specified posID /labID (string).

	static function SetElementBarcodeForSequencePos(	// Sets the element barcode for a rack or a well/cup position
																		// specifed by a sequence position.
																		// if sequencePosition is less than zero the element barcode is set
																		// for the current sequence position.
		device    deviceContext,						// i: instrument on which the sequence must be valid
		sequence& targetSequence,						// i: the sequence from which the labID / posID is evaluated
		variable  sequencePosition,					// i: the sequence position identifies the labID / posID of interest (integer, ignored if less than zero)
		variable  setBarcodeForRack,					// i: hslTrue if the barcode should be set for the rack
																//    hslFalse if the barcode should be set for the well/cup
		variable& barcode) void;						// i: barcode to set for specified posID /labID (string).


	static function RemoveElement(					// Removes an element from sample tracker (rack or well/cup)
																// if positionID is an empty string the barcode is set for the rack.
		device    deviceContext,						// i: instrument on which LabId / PosID must be a valid labware
		variable& labwareID,								// i: the labware to remove (string)
		variable& positionID) void;					// i: the position to remove (string, may be empty)

	static function RemoveElementAtSequencePos(	// Removes an element from sample tracker (rack or well/cup)
																// specifed by a sequence position.
																// if sequencePosition is less than zero the element at
																// the current sequence position is removed.
		device    deviceContext,						// i: instrument on which the sequence must be valid
		sequence& targetSequence,						// i: the sequence from which the labID / posID is evaluated
		variable  sequencePosition,					// i: the sequence position identifies the labID / posID to remove (integer, ignored if less than zero)
		variable  removeRack) void;					// i: hslTrue if the rack should be removed
																//    hslFalse if the well/cup should be removed


	// ======================================================================================
	// Constants
	// ======================================================================================
	namespace Const
	{
		static const variable crlf("\013\010");					// Carriage return linefeed combination
		static const variable hxModuleName("HxSTCompCmd");		// Hamilton module name
		static const variable thisFileExtension(".hs_");		// file extension of this file
		static const variable helpFileExtension(".chm");		// HTML Help file

		// additional error description (check input parameter)
		static const variable traceActionGenerateMappingFile            ("HSLSTCCLib > STCC::GenerateMappingFile");
		static const variable traceActionGenerateMappingFileV43         ("HSLSTCCLib > STCC::GenerateMappingFileV43");
		static const variable traceActionSetElementBarcode              ("HSLSTCCLib > STCC::SetElementBarcode");
		static const variable traceActionSetElementBarcodeForSequencePos("HSLSTCCLib > STCC::SetElementBarcodeForSequencePos");
		static const variable traceActionRemoveElement                  ("HSLSTCCLib > STCC::RemoveElement");
		static const variable traceActionRemoveElementAtSequencePos     ("HSLSTCCLib > STCC::RemoveElementAtSequencePos");
	}

	// --------------------------------------------------------------------------------------
	// Error Ids
	// --------------------------------------------------------------------------------------

	namespace IDE
	{
		static const variable noError						(0);								// No error.

			static const variable firstCommon			(noError+1);
		static const variable unexpectedError			(firstCommon + 0);			// Unecpected Error
		static const variable invalidParam				(firstCommon + 1);			// A parameter is incorrect
		static const variable invalidParam_sequence	(firstCommon + 2);			// A parameter is incorrect, sequence
		static const variable invalidParam_intExp		(firstCommon + 3);			// A parameter is incorrect, integer expected
		static const variable invalidParam_floatExp	(firstCommon + 4);			// A parameter is incorrect, float expected
		static const variable invalidParam_stringExp	(firstCommon + 5);			// A parameter is incorrect, string expected
		static const variable invalidParam_arrSameSizeExp(firstCommon + 6);		// A parameter is incorrect, arrays not of same size
			static const variable lastCommon				(firstCommon + 6);		

		static const variable last							( lastCommon );				// guard
	}

	// --------------------------------------------------------------------------------------
	// String Ids
	// --------------------------------------------------------------------------------------

	namespace IDS
	{
		static const variable first							(IDE::last + 1);			// guard

		// private: common strings
			static const variable firstCommon				(first+0);
		static const variable openingBracket				(firstCommon + 0);		// opening bracket 
		static const variable closingBracket				(firstCommon + 1);		// closing bracket
		static const variable point							(firstCommon + 2);		// point (.)
		static const variable runtimeError					(firstCommon + 3);		// runtime error step ....
		static const variable moduleShowName				(firstCommon + 4);		// the name of the STCC module
			static const variable lastCommon 				(firstCommon + 4);

		// private: step names
			static const variable firstStepName				(lastCommon+1);
		static const variable stepNameGenMapFile			(firstStepName+0);		// Step 'Generate Mapping File'
		static const variable stepNameSetElementBC		(firstStepName+1);		// Step 'Set Element Barcode'
		static const variable stepNameRemoveElement		(firstStepName+2);		// Step 'Remove Element'
			static const variable lastStepName 				(firstStepName+2);

		// private: Parameter validation, additional information
			static const variable firstParamValid				(lastStepName+1);
		static const variable paramLabwareID					(firstParamValid+0);	// Invalid parameter 'labID'
		static const variable paramPositionID_EmptyIsValid	(firstParamValid+1);	// Invalid parameter 'posID'
		static const variable paramBarcode						(firstParamValid+2);	// Invalid parameter 'barcode'
		static const variable paramSeqPosInvalidForSeq		(firstParamValid+3);	// Invalid parameter 'Position Number for Sequence' range
		static const variable paramSeqPosParamSeqPos 		(firstParamValid+4);	// Invalid parameter 'Position Number for Sequence' type
			static const variable lastParamValid				(firstParamValid+4);

		// private: step strings 'Generate Mapping File'
			static const variable firstStpGenMapFile		(lastParamValid+1);
		static const variable stpGenMapFileParamFile		(firstStpGenMapFile+0);	// Invalid parameter 'filename'
		static const variable stpGenMapFileParamPath		(firstStpGenMapFile+1);	// Invalid parameter 'directory'
		static const variable stpGenMapFileParamExperiments(firstStpGenMapFile+2); // Invalid parameter 'Experiments'
		static const variable arrayValueAtIndex			(firstStpGenMapFile+3);	//	Invalid value at array index...
			static const variable lastStpGenMapFile		(firstStpGenMapFile+3);

		static const variable last								(lastStpGenMapFile);		// guard
	}


	// --------------------------------------------------------------------------------------
	// FormatTrace 'actionStatus' definition
	// --------------------------------------------------------------------------------------
	namespace ActionStatus
	{
		static const variable start(1);					// action status for formated trace
		static const variable complete(2);				// action status for formated trace
		static const variable error_(3);					// action status for formated trace
		static const variable progress(4);				// action status for formated trace
		static const variable completeWithError(5);	// action status for formated trace
	}


	// ======================================================================================
	// Privat step specific functions / members
	// ======================================================================================

	// --------------------------------------------------------------------------------------
	// Step 'Generate Mapping File'
	// --------------------------------------------------------------------------------------

	// Trace 'step start' if not already done.
	static function stpGenMapFileTraceStart() void;	

	// Trace 'step completed .....' with the passed ActionStatus.
	// Reset the flag that if the ...Start function is called it traces the start again.
	static function stpGenMapFileTraceEnd(variable endActionStatus) void;

	// parameter check within input params 
	static function stpGenMapFileCheckFilters(variable& arrFilters[], variable& errorDesc) void;
	static function stpGenMapFileCheckColumnIdsAndColumnNames(
		variable& arrColumnIds[], variable& arrColumnNames[], variable& errorDesc) void;
	static function stpGenMapFileCheckExperiments(variable& arrExperiments[], variable& errorDesc) void;
	
	static variable m_stpGenMapFile_isStartTraced(hslFalse);		// set to true if start is traced but step not end.
	

	// ======================================================================================
	// "Private" functions
	// ======================================================================================

	// --------------------------------------------------------------------------------------
	// Library Initialization 
	// --------------------------------------------------------------------------------------
	static function InitSTCCLibrary() variable;						// initializes the STCC library (only once)

	static variable m_initializedLib(hslFalse);						// initialization state of the STCC library


	// --------------------------------------------------------------------------------------
	// Tracing
	// --------------------------------------------------------------------------------------

	static function TraceStatus(
		variable stepNameStrTblId,
		variable actionStatus) void;


	// --------------------------------------------------------------------------------------
	// Exception/Error handling
	// --------------------------------------------------------------------------------------

	namespace Error
	{
		// Raises a runtime error. Generates a detailed description by using the passed arguments
		static function RaiseRuntimeError(
			variable  errorId,							// i: integer, the error id
			variable  stepNameStrTblId,				// i: integer, string-ID of the step name
			variable  errorDescriptionStrTblId,		// i: integer, string-ID of the error description
			variable& additionalDescription,			// i: string, additional error description
			variable& fileName,							// i: string, file name where the error is occured
			variable& functionName,						// i: string, funciton name where the error is occured
			variable& lineNumber) void;				// i: string, line number where the error is occured

/*
		// Display an ASSERT-message if the expression is evaluated to false.
		// Only if the debug switch is set a message is shown, otherwise the function returns immediately.
		// The message box may be closed with 'ignore' or 'abort'.
		// If 'abort' is clicked the method is aborted.
		static function ASSERT(
			variable expression,							// i: boolean, if false a ASSERT message is shown
			variable& description,						// i: string, description
			variable& fileName,							// i: string, file name 
			variable& functionName,						// i: string, funciton name 
			variable& lineNumber) void;				// i: string, line number 
*/

		
		// Generates a descriptive string includes the file, function and line number.
		// Return: Formatted string
		static function GetLocationDescription(
			variable& fileName,							// i: string, file name 		
			variable& functionName,						// i: string, funciton name
			variable& lineNumber) variable;			// i: string, line number 

	}


	// ======================================================================================
	// Implementation 
	// ======================================================================================

	// --------------------------------------------------------------------------------------
	// Step 'Generate Mapping File' functions
	// --------------------------------------------------------------------------------------

	static function ResetFilterSequences() void
	{
		InitSTCCLibrary();

		err.Clear();
		onerror goto ERROR;

		stpGenMapFileTraceStart();		// Traces 'start' if not already done

		#ifdef _DEBUG_STCC
		FormatTrace("DEBUG", GetFunctionName(), ActionStatus::progress,
						"Parameters: none");
		#endif

		#ifndef _DEBUG_STCC
		HSLMapReport::DisableEnhancedLibraryTraces();
		#endif

		#ifdef _DEBUG_STCC
		FormatTrace("DEBUG", GetFunctionName(), ActionStatus::progress,
						"Call HSLMapReport::RemoveAllFilterSequences()");
		#endif

		HSLMapReport::RemoveAllFilterSequences();

		onerror goto 0;
		return;

		///////////////////////////////////////////////////
		ERROR:
		{
			stpGenMapFileTraceEnd(ActionStatus::completeWithError);

			if ( err.GetDescription() == "")
			{
				// No error-description, assume its an unhandled exception
				Error::RaiseRuntimeError(IDE::unexpectedError, 
												 IDS::stepNameGenMapFile,
												 IDE::unexpectedError,
												 "",
												 GetFileName(), GetFunctionName(), GetLineNumber());
			}

			err.Raise();	// Rethrow last error.
		}
	}


	static function AddFilterSequence(
		device    deviceContext,
		sequence& filterSequence) void
	{
		InitSTCCLibrary();

		err.Clear();
		onerror goto ERROR;

		stpGenMapFileTraceStart();		// Traces 'start' if not already done

		#ifdef _DEBUG_STCC
		FormatTrace("DEBUG", GetFunctionName(), ActionStatus::progress,
						"Parameters: device=", deviceContext.GetInstrumentName(),
						", FilterSequence=", filterSequence.GetName(), " -> current=", filterSequence.GetCurrentPosition(),
							" count=", filterSequence.GetCount(), " total=", filterSequence.GetTotal());
		#endif

		#ifndef _DEBUG_STCC
		HSLMapReport::DisableEnhancedLibraryTraces();
		#endif

		#ifdef _DEBUG_STCC
		FormatTrace("DEBUG", GetFunctionName(), ActionStatus::progress,
						"Call HSLMapReport::AddFilterSequence()");
		#endif

		HSLMapReport::AddFilterSequence(deviceContext, filterSequence);

		onerror goto 0;
		return;

		///////////////////////////////////////////////////
		ERROR:
		{
			stpGenMapFileTraceEnd(ActionStatus::completeWithError);

			if ( err.GetDescription() == "")
			{
				// No error-description, assume its an unhandled exception
				Error::RaiseRuntimeError(IDE::unexpectedError, 
												 IDS::stepNameGenMapFile,
												 IDE::unexpectedError,
												 "",
												 GetFileName(), GetFunctionName(), GetLineNumber());
			}

			err.Raise();	// Rethrow last error.
		}
	}


	static function GenerateMappingFile(
		device    deviceContext,
		sequence& targetSequence,
		variable& strFilename,
		variable& strPath,
		variable& arrStrGeneratedFiles[]) void
	{
		variable errorDesc;
		variable arrEmpty[];
		arrStrGeneratedFiles = arrEmpty;		// Clear the out parameter first

		InitSTCCLibrary();

		err.Clear();
		onerror goto ERROR;

		stpGenMapFileTraceStart();		// Traces 'start' if not already done

		#ifdef _DEBUG_STCC
		FormatTrace("DEBUG", GetFunctionName(), ActionStatus::progress,
						"Parameters: device=", deviceContext.GetInstrumentName(),
						", TargetSequence=", targetSequence.GetName(), " -> current=", targetSequence.GetCurrentPosition(),
							" count=", targetSequence.GetCount(), " total=", targetSequence.GetTotal(),
						", Filename='", strFilename, "' (", GetType(strFilename), ")",
						", Path='",     strPath,     "' (", GetType(strPath),     ")");
		#endif

		// Parameter validation
		errorDesc = Const::traceActionGenerateMappingFile + Const::crlf;
		Util2::CheckValueType(strFilename, Util2::ValueType::String, errorDesc + STR::StringTable::Load(IDS::stpGenMapFileParamFile));
		Util2::CheckValueType(strPath, Util2::ValueType::String, errorDesc + STR::StringTable::Load(IDS::stpGenMapFileParamPath));
		
		#ifndef _DEBUG_STCC
		HSLMapReport::DisableEnhancedLibraryTraces();
		#endif

		#ifdef _DEBUG_STCC
		FormatTrace("DEBUG", GetFunctionName(), ActionStatus::progress,
						"Call HSLMapReport::GenerateMappingFile()");
		#endif

		HSLMapReport::GenerateMappingFile(deviceContext, targetSequence, strFilename, strPath, arrStrGeneratedFiles);

		#ifdef _DEBUG_STCC
		FormatTrace("DEBUG", GetFunctionName(), ActionStatus::progress,
						"Call HSLMapReport::RemoveAllFilterSequences()");
		#endif

		HSLMapReport::RemoveAllFilterSequences();

		stpGenMapFileTraceEnd(ActionStatus::complete);

		onerror goto 0;
		return;

		///////////////////////////////////////////////////
		ERROR:
		{
			stpGenMapFileTraceEnd(ActionStatus::completeWithError);
			
			if ( err.GetDescription() == "")
			{
				// No error-description, assume its an unhandled exception
				Error::RaiseRuntimeError(IDE::unexpectedError, 
												 IDS::stepNameGenMapFile,
												 IDE::unexpectedError,
												 "",
												 GetFileName(), GetFunctionName(), GetLineNumber());
			}

			err.Raise();	// Rethrow last error.
		}
	}

	static function GenerateMappingFileEx1(
		device    deviceContext,
		sequence& targetSequence,
		variable& strFilename,
		variable& strPath) void
	{
		// Declare the local [out] parameter and forward to GenerateMappingFile() only.
		variable localArrStrGeneratedFiles[];
		GenerateMappingFile(deviceContext, targetSequence, strFilename, strPath, localArrStrGeneratedFiles);
	}



	static function GenerateMappingFileV43(		// Same as function GenerateMappingFileV43 with the following changes:
																// - removed arrExperiments start/end index because this was never working
																//   and is not longer supported by the dialog.
																// - added filterFlagsEx parameter
		device    deviceContext,						// i: instrument on which the target sequence must be valid
		sequence& targetSequence,						// i: a mapping file for racks between first and end position is generated
      variable  filterMode,                     // i: filter mode to be used
      variable& arrFilters[],                   // i: array contains the filter to be used (may be empty)
      variable  sortMode,                       // i: sort mode to be used
      variable& arrColumnIds[],                 // i: array contains the column identifier
      variable& arrColumnNames[],               // i: array contains the column names to be used
      variable& arrExperiments[],               // i: array contains the experiment names (may be empty)
		variable& strFilename,							// i: file name (with placeholders) used for file generation
      variable  createOneFile,                  // i: flag, indicating wheter one file must be created
      variable  openFileToAppend,               // i: flag, indicating wheter data shall be appended to an existing file
		variable& strPath,								// i: path into which the mapping files should be generated (may be empty)
		variable  filterFlagsEx,						// i: added in V4.3: Additional FilterFlagsEx, bitwise combination.
		variable& arrStrGeneratedFiles[]) void 	// o: array contains the generated files names as string.
	{
		variable errorDesc;
		variable arrEmpty[];
		variable arrMaxValue;
		arrStrGeneratedFiles = arrEmpty;				// Clear the out parameter first

		InitSTCCLibrary();

		err.Clear();
		onerror goto ERROR;

		stpGenMapFileTraceStart();						// Traces 'start' if not already done

		#ifdef _DEBUG_STCC
		FormatTrace("DEBUG", GetFunctionName(), ActionStatus::progress,
						"Parameters: device=", deviceContext.GetInstrumentName(),
						", TargetSequence=", targetSequence.GetName(), " -> current=", targetSequence.GetCurrentPosition(),
							" count=", targetSequence.GetCount(), " total=", targetSequence.GetTotal(),
						", FilterMode='",				filterMode, 					"' (", GetType(filterMode), ")",
						", ArrFilters(size)='",		arrFilters.GetSize(),		"'",
						", SortMode='",				sortMode, 						"' (", GetType(sortMode), ")",
						", ArrColumnIds(size)='",	arrColumnIds.GetSize(), 	"'",
						", ArrColumnNames(size)='",arrColumnNames.GetSize(),	"'",
						", ArrExperiments(size)='",arrExperiments.GetSize(),	"'",
						", Filename='",  				strFilename, 					"' (", GetType(strFilename), ")",
						", CreateOneFile='",			createOneFile, 				"' (", GetType(createOneFile), ")",
						", OpenFileToAppend='",		openFileToAppend, 			"' (", GetType(openFileToAppend), ")",
						", Path='",						strPath,							"' (", GetType(strPath), ")",
						", FilterFlagsEx='",			filterFlagsEx,					"' (", GetType(filterFlagsEx), ")");
		#endif

		// Parameter validation
		errorDesc = Const::traceActionGenerateMappingFileV43 + Const::crlf;
		Util2::CheckValueType(strFilename, Util2::ValueType::String, errorDesc + STR::StringTable::Load(IDS::stpGenMapFileParamFile));
		Util2::CheckValueTypeAndRangeMinMax(filterMode, Util2::ValueType::Integer,
														HSLMapReport::FilterMode::first, HSLMapReport::FilterMode::last, errorDesc + "filterMode");
		Util2::CheckValueTypeAndRangeMinMax(sortMode, Util2::ValueType::Integer,
														HSLMapReport::SortMode::first, HSLMapReport::SortMode::last, errorDesc + "sortMode");
		Util2::CheckValueTypeAndRangeMinMax(createOneFile, Util2::ValueType::Integer,
														hslFalse, hslTrue, errorDesc + "createOneFile");
		Util2::CheckValueTypeAndRangeMinMax(openFileToAppend, Util2::ValueType::Integer,
														hslFalse, hslTrue, errorDesc + "openFileToAppend");
		Util2::CheckValueTypeAndRangeMinMax(filterFlagsEx, Util2::ValueType::Integer,
														HSLMapReport::FilterFlagsEx::none, HSLMapReport::FilterFlagsEx::all, errorDesc + "filterFlagsEx");
		Util2::CheckValueType(strPath, Util2::ValueType::String, errorDesc + STR::StringTable::Load(IDS::stpGenMapFileParamPath));

		// Check filters to be valid.
		if(filterMode == HSLMapReport::FilterMode::combinationOf)
			stpGenMapFileCheckFilters(arrFilters, errorDesc);

		// Check column mapping to be valid.
		errorDesc = Const::traceActionGenerateMappingFileV43 + Const::crlf;
		stpGenMapFileCheckColumnIdsAndColumnNames(arrColumnIds, arrColumnNames, errorDesc);

		// Check experiments to be valid
		errorDesc = Const::traceActionGenerateMappingFileV43 + STR::StringTable::Load(IDS::stpGenMapFileParamExperiments) + Const::crlf;
		stpGenMapFileCheckExperiments(arrExperiments, errorDesc);

		#ifndef _DEBUG_STCC
		HSLMapReport::DisableEnhancedLibraryTraces();
		#endif

		#ifdef _DEBUG_STCC
		FormatTrace("DEBUG", GetFunctionName(), ActionStatus::progress,
						"Call HSLMapReport::GenerateMappingFileV42()");
		#endif

		HSLMapReport::GenerateMappingFileV43(deviceContext, targetSequence, filterMode, arrFilters, sortMode,
														 arrColumnIds, arrColumnNames, arrExperiments, 
														 strFilename, createOneFile, openFileToAppend, strPath, filterFlagsEx,
														 arrStrGeneratedFiles);

		#ifdef _DEBUG_STCC
		FormatTrace("DEBUG", GetFunctionName(), ActionStatus::progress,
						"Call HSLMapReport::RemoveAllFilterSequences()");
		#endif

		HSLMapReport::RemoveAllFilterSequences();

		stpGenMapFileTraceEnd(ActionStatus::complete);

		onerror goto 0;
		return;

		///////////////////////////////////////////////////
		ERROR:
		{
			stpGenMapFileTraceEnd(ActionStatus::completeWithError);
			
			if ( err.GetDescription() == "")
			{
				// No error-description, assume its an unhandled exception
				Error::RaiseRuntimeError(IDE::unexpectedError, 
												 IDS::stepNameGenMapFile,
												 IDE::unexpectedError,
												 "",
												 GetFileName(), GetFunctionName(), GetLineNumber());
			}

			err.Raise();	// Rethrow last error.
		}   
	}


	static function GenerateMappingFileV43Ex1(	// same as GenerateMappingFileV43, but without the out parameter arrStrGeneratedFiles
		device    deviceContext,						// i:
      sequence& targetSequence,						// i:
      variable  filterMode,                     // i:
      variable& arrFilters[],                   // i:
      variable  sortMode,                       // i:
      variable& arrColumnIds[],                 // i:
      variable& arrColumnNames[],               // i:
      variable& arrExperiments[],               // i:
		variable& strFilename,							// i:
      variable  createOneFile,                  // i:
      variable  openFileToAppend,               // i:
		variable& strPath,								// i:
		variable  filterFlagsEx) void 				// i: added in V4.3: Additional FilterFlagsEx, bitwise combination.
	{
		// Declare the local [out] parameter and forward to GenerateMappingFileV42() only.
		variable localArrStrGeneratedFiles[];

		GenerateMappingFileV43(deviceContext, targetSequence, filterMode, arrFilters, sortMode,
		 							  arrColumnIds, arrColumnNames, arrExperiments,
									  strFilename, createOneFile, openFileToAppend,
									  strPath, filterFlagsEx, localArrStrGeneratedFiles);
	}


	// obsolete function, only called from generated HSL code from existing steps created with 4.2.x
	static function GenerateMappingFileV42(		// Generates a mapping file for each rack in target sequence. Resets
																// the added filter sequences if the function is done.
		device    deviceContext,						// i: instrument on which the target sequence must be valid
		sequence& targetSequence,						// i: a mapping file for racks between first and end position is generated
		variable  filterMode,                     // i: filter mode to be used
		variable& arrFilters[],                   // i: array, contains the filter (HSLMapReport::ErrorId) to be used
		variable  sortMode,                       // i: sort mode to be used
		variable& arrColumnIds[],                 // i: array contains the column identifier
		variable& arrColumnNames[],               // i: array contains the column names to be used
		variable& arrExperiments[],               // i: array contains the experiment names (may be empty)
		variable  arrExpStartIndex,					// i: start index
		variable  arrExpEndIndex,						// i: end index
		variable& strFilename,							// i: file name (with placeholders) used for file generation
		variable  createOneFile,                  // i: flag, indicating wheter one file must be created
		variable  openFileToAppend,               // i: flag, indicating wheter data shall be appended to an existing file
		variable& strPath,								// i: path into which the mapping files should be generated (may be empty)
		variable& arrStrGeneratedFiles[]) void 	// o: array contains the generated files names as string.
   {
		variable filterFlagsEx(HSLMapReport::FilterFlagsEx::none);			// new in 4.3

		// 2008-12-18/cjoerg
		// arrExpStartIndex and arrExpEndIndex are not longer used with 4.3
		// following use cases was possible to be defined by using the GenerateReportMappingStep with 4.2:
		// (arrExp contains as example the values "EXP1", "EXP2", "EXP3")

		//    UI input in field		arrExperiments		arrExpStartIndex		arrExpEndIndex			effective used Filter in 4.2
		//   'Filter Experiments'																					(allways all elements from array)
		// 1.   "EXP1"					"EXP1" size=1		0							0							"EXP1"
		// 2.   varExp					size=1				0							0							value varExp
		// 3.   arrExp[*]				arrExp size=3		0							Size()-1					"EXP1", "EXP2", "EXP3"
		// 4.   arrExp[2]				arrExp size=3		2 (one based!)			2 (one based!)			"EXP1", "EXP2", "EXP3"
		// 5.   arrExp[*2]			arrExp size=3		2 (one based!)			Size()-1					"EXP1", "EXP2", "EXP3"

		// In 4.2 the start/end indexes has never been interpreted - therefore the one based / zero based index
		// mix up has never been made a problem.
		// Use cases 1, 2 and 3 was working as expected/described.
		// Use case 4 was not working as expected/described: Should be 'use ONE element out of the array with index 2 (one based)'.
		// Use case 5 was not working as expected/described: Should be 'use all elements out of the array starting with index 2 (one based)'.

		// For exising steps programmed with 4.2 we forward to the 4.3 function by KEEPING the behaviour as it was in 4.2, allways use all
		// array elements from arrExperiments. We continue to not interpret any of the indexes.

		// finally forward to the actual GenerateMappingFileV43 only
		GenerateMappingFileV43(deviceContext, targetSequence, filterMode, arrFilters, sortMode,
		 							  arrColumnIds, arrColumnNames, arrExperiments,
									  strFilename, createOneFile, openFileToAppend,
									  strPath, filterFlagsEx, arrStrGeneratedFiles);
	}


	// obsolete function, only called from generated HSL code from existing steps created with 4.2.x
	static function GenerateMappingFileV42Ex1(	// same as GenerateMappingFileV42, but without the out parameter arrStrGeneratedFiles
		device    deviceContext,						// i:
		sequence& targetSequence,						// i:
		variable  filterMode,                     // i:
		variable& arrFilters[],                   // i:
		variable  sortMode,                       // i:
		variable& arrColumnIds[],                 // i:
		variable& arrColumnNames[],               // i:
		variable& arrExperiments[],               // i:
		variable  arrExpStartIndex,					// i: start index
		variable  arrExpEndIndex,						// i: end index
		variable& strFilename,							// i:
		variable  createOneFile,                  // i:
		variable  openFileToAppend,               // i:
		variable& strPath) void 						// i:
   {
		// Declare the local [out] parameter and forward to GenerateMappingFileV42() only.
		variable localArrStrGeneratedFiles[];
		GenerateMappingFileV42(deviceContext, targetSequence, filterMode, arrFilters, sortMode,
		 							  arrColumnIds, arrColumnNames, arrExperiments, arrExpStartIndex, 
									  arrExpEndIndex, strFilename, createOneFile, openFileToAppend,
									  strPath, localArrStrGeneratedFiles);
   }

	static function stpGenMapFileTraceStart() void
	{
		if ( ! m_stpGenMapFile_isStartTraced )
		{
			// First function called from the Step 'Generate Mapping File'
			TraceStatus(IDS::stepNameGenMapFile, ActionStatus::start);
			m_stpGenMapFile_isStartTraced = hslTrue;
		}
	}


	static function stpGenMapFileTraceEnd(variable endActionStatus) void
	{
		TraceStatus(IDS::stepNameGenMapFile, endActionStatus);
		m_stpGenMapFile_isStartTraced = hslFalse;
	}

	static function stpGenMapFileCheckFilters(
		variable& arrFilters[],
		variable& errorDesc) void
	{
		variable i(0);											// Loop index

		for (i = 0; i < arrFilters.GetSize(); i++)
		{
			Util2::CheckValueTypeAndRangeMinMax(arrFilters.ElementAt(i), hslInteger, 
															HSLMapReport::ErrorId::first, HSLMapReport::ErrorId::last, 
															errorDesc + "arrFilters[" + IStr(i) + "]");
		}
	}

	static function stpGenMapFileCheckColumnIdsAndColumnNames(
		variable& arrColumnIds[],
		variable& arrColumnNames[],
		variable& errorDesc) void
	{
		variable i(0);											// Loop index

		if (arrColumnIds.GetSize() != arrColumnNames.GetSize())
		{
			Error::RaiseRuntimeError(IDE::invalidParam_arrSameSizeExp, 
											 IDS::stepNameGenMapFile,
											 IDE::invalidParam_arrSameSizeExp,
											 errorDesc,
											 GetFileName(), GetFunctionName(), GetLineNumber());
		}

		for (i = 0; i < arrColumnIds.GetSize(); i++)
		{
			Util2::CheckValueTypeAndRangeMinMax(arrColumnIds.ElementAt(i), hslInteger,
															HSLMapReport::ColId::first, HSLMapReport::ColId::last, 
															errorDesc + "arrColumnIds[" + IStr(i) + "]");

			Util2::CheckValueTypeAndRange(arrColumnNames.ElementAt(i), hslString,
													Util2::ValueCheck::RangeStringNotEmpty,
													errorDesc + "arrColumnNames[" + IStr(i) + "]");
		}
	}

	static function stpGenMapFileCheckExperiments(
		variable& arrExperiments[],
		variable& errorDesc) void
	{
		variable i(0);											// Loop index

		for (i = 0; i < arrExperiments.GetSize(); i++)
		{
			variable errExtDesc("");

			errExtDesc = STR::StringTable::Load(IDS::arrayValueAtIndex);

			StrReplace(errExtDesc, "%s", IStr(i + 1));

			Util2::CheckValueTypeAndRange(arrExperiments.ElementAt(i), hslString, 
										 			Util2::ValueCheck::RangeStringNotEmpty,
										 			errorDesc + errExtDesc);
		}
	}

	// --------------------------------------------------------------------------------------
	// Step 'Set Element Barcode' functions
	// --------------------------------------------------------------------------------------

	static function SetElementBarcode(
		device    deviceContext,
		variable& labwareID,
		variable& positionID,
		variable& barcode) void
	{
		variable errorDesc;
		InitSTCCLibrary();

		err.Clear();
		onerror goto ERROR;

		TraceStatus(IDS::stepNameSetElementBC, ActionStatus::start);

		#ifdef _DEBUG_STCC
		FormatTrace("DEBUG", GetFunctionName(), ActionStatus::progress,
						"Parameters: device=", deviceContext.GetInstrumentName(),
						", LabwareID='",  labwareID,  "' (", GetType(labwareID),  ")",
						", PositionID='", positionID, "' (", GetType(positionID), ")",
						", Barcode='",    barcode,    "' (", GetType(barcode),    ")");
		#endif

		// Parameter validation
		errorDesc = Const::traceActionSetElementBarcode + Const::crlf;
		Util2::CheckValueType(labwareID, Util2::ValueType::String, errorDesc + STR::StringTable::Load(IDS::paramLabwareID));
		Util2::CheckValueType(positionID, Util2::ValueType::String, errorDesc + STR::StringTable::Load(IDS::paramPositionID_EmptyIsValid));
		Util2::CheckValueType(barcode, Util2::ValueType::String, errorDesc + STR::StringTable::Load(IDS::paramBarcode));

		#ifndef _DEBUG_STCC
		HSLMapReport::DisableEnhancedLibraryTraces();
		#endif

		#ifdef _DEBUG_STCC
		FormatTrace("DEBUG", GetFunctionName(), ActionStatus::progress,
						"Call HSLMapReport::SetElementBarcode with: ",
						"LabwareID='", labwareID, "', PositionID='", positionID, "', Barcode='", barcode, "'");
		#endif

		HSLMapReport::SetElementBarcode(deviceContext, labwareID, positionID, barcode);

		onerror goto 0;

		TraceStatus(IDS::stepNameSetElementBC, ActionStatus::complete);

		return;

		///////////////////////////////////////////////////
		ERROR:
		{
			TraceStatus(IDS::stepNameSetElementBC, ActionStatus::completeWithError);

			if ( err.GetDescription() == "")
			{
				// No error-description, assume its an unhandled exception
				Error::RaiseRuntimeError(IDE::unexpectedError, 
												 IDS::stepNameSetElementBC,
												 IDE::unexpectedError,
												 "",
												 GetFileName(), GetFunctionName(), GetLineNumber());
			}

			err.Raise();	// Rethrow last error.
		}
	}


	static function SetElementBarcodeForSequencePos(
		device    deviceContext,
		sequence& targetSequence,
		variable  sequencePosition,
		variable  setBarcodeForRack,
		variable& barcode) void
	{
		variable errorDesc;
		variable labID, posID;	// Evaluated from passed sequence

		InitSTCCLibrary();

		err.Clear();
		onerror goto ERROR;

		TraceStatus(IDS::stepNameSetElementBC, ActionStatus::start);

		#ifdef _DEBUG_STCC
		FormatTrace("DEBUG", GetFunctionName(), ActionStatus::progress,
						"Parameters: device=", deviceContext.GetInstrumentName(),
						", Sequence=", targetSequence.GetName(), " -> current=", targetSequence.GetCurrentPosition(),
							" count=", targetSequence.GetCount(), " total=", targetSequence.GetTotal(),
						", SequencePosition='", sequencePosition, "' (", GetType(sequencePosition), ")",
						", SetForRack-flag='",  setBarcodeForRack,"' (", GetType(setBarcodeForRack),")",
						", Barcode='",          barcode,          "' (", GetType(barcode),          ")");
		#endif

		// Parameter validation
		errorDesc = Const::traceActionSetElementBarcodeForSequencePos + Const::crlf;
		Util2::CheckValueType(sequencePosition, Util2::ValueType::Integer,
									 errorDesc + STR::StringTable::Load(IDS::paramSeqPosParamSeqPos));
		Util2::CheckValueTypeAndRangeMinMax(setBarcodeForRack, Util2::ValueType::Integer, hslFalse, hslTrue,
									 errorDesc + "setBarcodeForRack <<<Parameter only internaly used, not in hand of programmer!>>>");		
		Util2::CheckValueType(barcode, Util2::ValueType::String,
									 errorDesc + STR::StringTable::Load(IDS::paramBarcode));

		if ( 0 > sequencePosition )
		{
			// Current sequence position identifies the sequence element
			if ( 0 == targetSequence.GetCurrentPosition() )
			{
				Error::RaiseRuntimeError(IDE::invalidParam_sequence, IDS::stepNameSetElementBC,
												 IDE::invalidParam_sequence,
												 targetSequence.GetName(),
												 GetFileName(), GetFunctionName(), GetLineNumber());
			}

			labID = targetSequence.GetLabwareId();
			posID = targetSequence.GetPositionId();
		}
		else
		{
			variable oldCurrent;
			oldCurrent = targetSequence.GetCurrentPosition();
			targetSequence.SetCurrentPosition(sequencePosition);

			if ( targetSequence.GetCurrentPosition() == 0 )
			{
				// Passed sequencePosition is invalid for passed Sequence
				// Reset old current
				targetSequence.SetCurrentPosition(oldCurrent);

				Error::RaiseRuntimeError(IDE::invalidParam, IDS::stepNameSetElementBC,
											 IDE::invalidParam,
											 STR::StringTable::Load(IDS::paramSeqPosInvalidForSeq),
											 GetFileName(), GetFunctionName(), GetLineNumber());
			}

			labID = targetSequence.GetLabwareId();
			posID = targetSequence.GetPositionId();

			targetSequence.SetCurrentPosition(oldCurrent);
		}

		if ( hslFalse != setBarcodeForRack )
		{
			// Barcode should be set for the rack and not for the well/cup
			posID = "";
		}

		#ifndef _DEBUG_STCC
		HSLMapReport::DisableEnhancedLibraryTraces();
		#endif

		#ifdef _DEBUG_STCC
		FormatTrace("DEBUG", GetFunctionName(), ActionStatus::progress,
						"Call HSLMapReport::SetElementBarcode with ",
						"LabwareID='", labID, "', PositionID='", posID, "', Barcode='", barcode, "'");
		#endif

		HSLMapReport::SetElementBarcode(deviceContext, labID, posID, barcode);

		onerror goto 0;

		TraceStatus(IDS::stepNameSetElementBC, ActionStatus::complete);

		return;

		///////////////////////////////////////////////////
		ERROR:
		{
			TraceStatus(IDS::stepNameSetElementBC, ActionStatus::completeWithError);

			if ( err.GetDescription() == "")
			{
				// No error-description, assume its an unhandled exception
				Error::RaiseRuntimeError(IDE::unexpectedError, 
												 IDS::stepNameSetElementBC,
												 IDE::unexpectedError,
												 "",
												 GetFileName(), GetFunctionName(), GetLineNumber());
			}

			err.Raise();	// Rethrow last error.
		}
	}



	// --------------------------------------------------------------------------------------
	// Step 'Remove Element' functions
	// --------------------------------------------------------------------------------------

	static function RemoveElement(
		device    deviceContext,
		variable& labwareID,
		variable& positionID) void
	{
		variable errorDesc;

		InitSTCCLibrary();

		err.Clear();
		onerror goto ERROR;

		TraceStatus(IDS::stepNameRemoveElement, ActionStatus::start);

		#ifdef _DEBUG_STCC
		FormatTrace("DEBUG", GetFunctionName(), ActionStatus::progress,
						"Parameters: device=", deviceContext.GetInstrumentName(),
						", LabwareID='",  labwareID,  "' (", GetType(labwareID),  ")",
						", PositionID='", positionID, "' (", GetType(positionID), ")");
		#endif

		// Parameter validation
		errorDesc = Const::traceActionRemoveElement + Const::crlf;
		Util2::CheckValueType(labwareID, Util2::ValueType::String,
									 errorDesc + STR::StringTable::Load(IDS::paramLabwareID));
		Util2::CheckValueType(positionID, Util2::ValueType::String,
									 errorDesc + STR::StringTable::Load(IDS::paramPositionID_EmptyIsValid));

		#ifndef _DEBUG_STCC
		HSLMapReport::DisableEnhancedLibraryTraces();
		#endif

		#ifdef _DEBUG_STCC
		FormatTrace("DEBUG", GetFunctionName(), ActionStatus::progress,
						"Call HSLMapReport::RemoveElement with ",
						"LabwareID='", labwareID, "', PositionID='", positionID, "'");
		#endif

		HSLMapReport::RemoveElement(deviceContext, labwareID, positionID);

		onerror goto 0;

		TraceStatus(IDS::stepNameRemoveElement, ActionStatus::complete);

		return;

		///////////////////////////////////////////////////
		ERROR:
		{
			TraceStatus(IDS::stepNameRemoveElement, ActionStatus::completeWithError);

			if ( err.GetDescription() == "")
			{
				// No error-description, assume its an unhandled exception
				Error::RaiseRuntimeError(IDE::unexpectedError, 
												 IDS::stepNameRemoveElement,
												 IDE::unexpectedError,
												 "",
												 GetFileName(), GetFunctionName(), GetLineNumber());
			}

			err.Raise();	// Rethrow last error.
		}
	}



	static function RemoveElementAtSequencePos(
		device    deviceContext,
		sequence& targetSequence,
		variable  sequencePosition,
		variable  removeRack) void
	{
		variable errorDesc;
		variable labID, posID;	// Evaluated from passed sequence

		InitSTCCLibrary();

		err.Clear();
		onerror goto ERROR;

		TraceStatus(IDS::stepNameRemoveElement, ActionStatus::start);

		#ifdef _DEBUG_STCC
		FormatTrace("DEBUG", GetFunctionName(), ActionStatus::progress,
						"Parameters: device=", deviceContext.GetInstrumentName(),
						", Sequence=", targetSequence.GetName(), " -> current=", targetSequence.GetCurrentPosition(),
							" count=", targetSequence.GetCount(), " total=", targetSequence.GetTotal(),
						", SequencePosition='", sequencePosition, "' (", GetType(sequencePosition), ")",
						", RemoveRack-flag='",  removeRack,       "' (", GetType(removeRack), ")");
		#endif

		// Parameter validation
		errorDesc = Const::traceActionRemoveElementAtSequencePos + Const::crlf;
		Util2::CheckValueType(sequencePosition, Util2::ValueType::Integer,
									 errorDesc + STR::StringTable::Load(IDS::paramSeqPosParamSeqPos));
		Util2::CheckValueTypeAndRangeMinMax(removeRack, Util2::ValueType::Integer, hslFalse, hslTrue,
									 errorDesc + "removeRack <<<Parameter only internaly used, not in hand of programmer!>>>");

		if ( 0 > sequencePosition )
		{
			// Current sequence position identifies the sequence element
			if ( 0 == targetSequence.GetCurrentPosition() )
			{
				Error::RaiseRuntimeError(IDE::invalidParam_sequence, IDS::stepNameRemoveElement,
												 IDE::invalidParam_sequence,
												 targetSequence.GetName(),
												 GetFileName(), GetFunctionName(), GetLineNumber());
			}

			labID = targetSequence.GetLabwareId();
			posID = targetSequence.GetPositionId();
		}
		else
		{
			variable oldCurrent;
			oldCurrent = targetSequence.GetCurrentPosition();
			targetSequence.SetCurrentPosition(sequencePosition);

			if ( targetSequence.GetCurrentPosition() == 0 )
			{
				// Passed sequencePosition is invalid for passed Sequence
				// Reset old current
				targetSequence.SetCurrentPosition(oldCurrent);

				Error::RaiseRuntimeError(IDE::invalidParam, IDS::stepNameRemoveElement,
											 IDE::invalidParam,
											 STR::StringTable::Load(IDS::paramSeqPosInvalidForSeq),
											 GetFileName(), GetFunctionName(), GetLineNumber());
			}

			labID = targetSequence.GetLabwareId();
			posID = targetSequence.GetPositionId();

			targetSequence.SetCurrentPosition(oldCurrent);
		}

		if ( hslFalse != removeRack )
		{
			// Barcode should be set for the rack and not for the well/cup
			posID = "";
		}

		#ifndef _DEBUG_STCC
		HSLMapReport::DisableEnhancedLibraryTraces();
		#endif

		#ifdef _DEBUG_STCC
		FormatTrace("DEBUG", GetFunctionName(), ActionStatus::progress,
						"Call HSLMapReport::RemoveElement with ",
						"LabwareID='", labID, "', PositionID='", posID, "'");
		#endif

		HSLMapReport::RemoveElement(deviceContext, labID, posID);

		onerror goto 0;

		TraceStatus(IDS::stepNameRemoveElement, ActionStatus::complete);

		return;

		///////////////////////////////////////////////////
		ERROR:
		{
			TraceStatus(IDS::stepNameRemoveElement, ActionStatus::completeWithError);

			if ( err.GetDescription() == "")
			{
				// No error-description, assume its an unhandled exception
				Error::RaiseRuntimeError(IDE::unexpectedError, 
												 IDS::stepNameRemoveElement,
												 IDE::unexpectedError,
												 "",
												 GetFileName(), GetFunctionName(), GetLineNumber());
			}

			err.Raise();	// Rethrow last error.
		}

	}




	// --------------------------------------------------------------------------------------
	// Library Initialization 
	// --------------------------------------------------------------------------------------

	static function InitSTCCLibrary() variable
	{
		// initialize the STCC library once only
		if ( ! m_initializedLib)
		{
			string fileWithPath("");
			string extension(Const::thisFileExtension);
			variable stringTableFileWithoutExtensions("");

			fileWithPath = GetFileName();
			stringTableFileWithoutExtensions = fileWithPath.Left(fileWithPath.GetLength() - extension.GetLength());

			#ifdef _DEBUG_STCC
			FormatTrace("DEBUG", GetFunctionName(), ActionStatus::progress,
							"Init string table with: ", stringTableFileWithoutExtensions);
			#endif

			STR::StringTable::Init(stringTableFileWithoutExtensions);

			#ifdef _DEBUG_STCC
			STR::StringTable::Dump();
			#endif

			m_initializedLib = hslTrue;
		}
		return(m_initializedLib);
	}


	// --------------------------------------------------------------------------------------
	// Tracing
	// --------------------------------------------------------------------------------------

	static function TraceStatus(
		variable stepNameStrTblId,
		variable actionStatus) void
	{
		FormatTrace(STR::StringTable::Load(IDS::moduleShowName),
						STR::StringTable::Load(stepNameStrTblId),
						actionStatus);
	}

	// --------------------------------------------------------------------------------------
	// Helpers
	// --------------------------------------------------------------------------------------
	static function GetModuleHelpFileName() variable
	{
		variable helpFile("");
		variable thisFilePath("");
		variable lastBackSlashPos(-1);

		// Note: The help for this library must be located in same directory as this file.
		// Evaluate the path to concatniate it with the MolduleName+Extension.
		thisFilePath = GetFileName();
		lastBackSlashPos = StrReverseFind(thisFilePath, "\\");
		if ( -1 < lastBackSlashPos )
		{
			thisFilePath = StrLeft(thisFilePath, lastBackSlashPos+1);
		}

		helpFile = thisFilePath + Const::hxModuleName + GetLanguage() + Const::helpFileExtension;		// current language
		if ("" == SearchPath(helpFile))
		{
			helpFile = thisFilePath + Const::hxModuleName + "Enu" + Const::helpFileExtension;			// default language, fixed to enu
			if ("" == SearchPath(helpFile))
			{
				helpFile = thisFilePath + Const::hxModuleName + Const::helpFileExtension;					// no language
				if ("" == SearchPath(helpFile))
				{
					// no help file found within the search directory
					// return the helpFileName with current language, but without path.
					// Maybe its existing/found at other place or its registered and found by this way.
					helpFile = Const::hxModuleName + GetLanguage() + Const::helpFileExtension;
				}
			}
		}
		
		#ifdef _DEBUG_STCC
			FormatTrace("DEBUG", GetFunctionName(), ActionStatus::progress, "Module Help File: ", helpFile);
		#endif

		return( helpFile );
	}

	// --------------------------------------------------------------------------------------
	// Exception handling
	// --------------------------------------------------------------------------------------

	static function Error::RaiseRuntimeError(
		variable  errorId,
		variable  stepNameStrTblId,
		variable  errorDescriptionStrTblId,
		variable& additionalDescription,
		variable& fileName,
		variable& functionName,
		variable& lineNumber) void
	{
		// initialize the library
		variable description;

		InitSTCCLibrary();

		description = STR::StringTable::Load(IDS::moduleShowName) +
					 	  "\n\n" + 
						  STR::StringTable::Load(IDS::runtimeError) + 
						  STR::StringTable::Load(IDS::openingBracket) + 
						  STR::StringTable::Load(stepNameStrTblId) + 
						  STR::StringTable::Load(IDS::closingBracket) + 
						  STR::StringTable::Load(IDS::point) + 
						  "\n" + Error::GetLocationDescription(fileName, functionName, lineNumber) + "\n\n" +
						  STR::StringTable::Load(errorDescriptionStrTblId) + 
						  "\n" + additionalDescription;

		err.Raise(errorId, description, GetModuleHelpFileName());
	}


	static function Error::GetLocationDescription(
		variable& fileName,
		variable& functionName,
		variable& lineNumber) variable
	{
		variable location;
		location = fileName + "("+lineNumber+") : " + functionName + "().";
		return( location );
	}


/* currently not used
	static function Error::ASSERT(
		variable expression,
		variable& description,
		variable& fileName,
		variable& functionName,
		variable& lineNumber) void
	{
		#ifndef _DEBUG_STCC
		return;
		#endif

		if ( hslFalse == expression )
		{
			variable retVal(hslRetry);

			while ( hslRetry == retVal )
			{
				retVal = MessageBox(Error::GetLocationDescription(fileName, functionName, lineNumber) + 
										  "\n\n" + description + "\n\n",
										  "DEBUG ASSERTION FAILED",
										  hslExclamation | hslAbortRetryIgnore | hslDefButton3);
				if ( hslAbort == retVal )
				{
					abort;
				}
			}
		}
	}
*/

}	// namespace STCC

// $$author=wbarmettler$$valid=1$$time=2017-03-09 07:27$$checksum=a72e7352$$length=088$$