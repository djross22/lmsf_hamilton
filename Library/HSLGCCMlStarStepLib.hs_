// This is a part of the GCC Microlab® STAR Step Library (aka Microlab® STAR Smart Steps).
// Copyright (C) by HAMILTON Bonaduz AG, CH-7402 Bonaduz.
// All rights reserved.
//
// Modification History
// 2016-08-25  ubernhard    : - library based on HSLMlStarStepLib (copy of)
//                            - changed namespace from MlStar to MlStarSteps
//                            - Edited low level steps with current runmaster 4.5
//                            - Added new error handling option 'ErrorHandling::custom'
//                            - Add new function StepInitialize_cer() to handle customizable error revovery
//                            - Add new function StepTipPickup_cer() to handle customizable error revovery
//                            - Add new function StepTipPickupEx_cer() to handle customizable error revovery
//                            - Add new function StepTipEject_cer() to handle customizable error revovery
//                            - Add new function StepAspirate_cer() to handle customizable error revovery
//                            - Add new function StepAspirateEx_cer() to handle customizable error revovery
//                            - Add new function StepDispense_cer() to handle customizable error revovery
//                            - Add new function StepDispenseEx_cer() to handle customizable error revovery
//                            - Add new function StepLoadCarrierEx_cer() to handle customizable error revovery
//                            - Add new function StepLoadCarrierEx2_cer() to handle customizable error revovery
//                            - Add new function StepUnloadCarrier_cer() to handle customizable error revovery
//                            - Add new function StepCalibrate1536Plate_cer() to handle customizable error revovery
//                            - Add new function StepWaitNeedleWashed_cer() to handle customizable error revovery
//                            - Add new function StepStartNeedleWash_cer() to handle customizable error revovery

#ifndef __HSLGCCMlStarStepLib_hsl__
#define __HSLGCCMlStarStepLib_hsl__	1

//device ML_STAR;
//#define HSL_RUNTIME 1 // enable only for syntax check
// --------------------------------------------------------------------------------------
// Debugging
// --------------------------------------------------------------------------------------
#ifdef HSL_RUNTIME
namespace MlStarSteps
{
	//#define _DEBUG_STEPPARAMS		1			// traces all the parameters passed to the Star-Steps...
}
#endif


// Interface to the Microlab® STAR Step Library
#ifndef HSL_RUNTIME
namespace MlStarSteps
{
	// --------------------------------------------------------------------------------------
	// Functions
	// --------------------------------------------------------------------------------------

	function StepInitialize(												// Initialize step
		device& ML_STAR,														// i: pipetting device
		variable initializeUseDefaultWaste,								// i: indicates whether to use the default waste (0 = Off, 1 = On)
		sequence& initializeWasteDestination,							// i: initialize waste destination
		variable initializeSequenceCounting,							// i: sequence counting (0 = manually, 1 = automatic)
		variable& initializeChannelVariable,							// i: channel variable (0 = unused, 1 = used)
		variable initializeChannelUse,									// i: channel use (1 = all sequence positions, 2 = channel pattern)
		variable initializeAlways,											// i: initialize always flag
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
      variable userResponseTime)											// i: user response time [s]
	{}

	function StepInitialize2(												// Initialize step
		device& ML_STAR,														// i: pipetting device
		variable initializeAlways,											// i: initialize always flag
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepInitialize_cer(											// Initialize step
		device& ML_STAR,														// i: pipetting device
		variable initializeAlways,											// i: initialize always flag
				variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue, 4 = custom)
      variable customStepID,             								// i: identifier for used single step defined for custom error handling
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepTipPickup(													// Tip Pickup step
		device& ML_STAR,														// i: pipetting device
		sequence& tipPickupSequence,										// i: tip pickup sequence
		variable tipPickupSequenceCounting,								// i: sequence counting (0 = manually, 1 = automatic)
		variable& tipPickupChannelVariable,								// i: channel variable (0 = unused, 1 = used)
		variable tipPickupChannelUse,										// i: channel use (1 = all sequence positions, 2 = channel pattern)
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepTipPickup_cer(											// Tip Pickup step
		device& ML_STAR,														// i: pipetting device
		sequence& tipPickupSequence,										// i: tip pickup sequence
		variable tipPickupSequenceCounting,								// i: sequence counting (0 = manually, 1 = automatic)
		variable& tipPickupChannelVariable,								// i: channel variable (0 = unused, 1 = used)
		variable tipPickupChannelUse,										// i: channel use (1 = all sequence positions, 2 = channel pattern)
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue, 4 = custom)
      variable customStepID,             								// i: identifier for used single step defined for custom error handling
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepTipPickupEx(												// Tip Pickup step, error handlig tailored to pickup needles
		device& ML_STAR,														// i: pipetting device
		sequence& tipPickupSequence,										// i: tip pickup sequence
		variable tipPickupSequenceCounting,								// i: sequence counting (0 = manually, 1 = automatic)
		variable& tipPickupChannelVariable,								// i: channel variable (0 = unused, 1 = used)
		variable tipPickupChannelUse,										// i: channel use (1 = all sequence positions, 2 = channel pattern)
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepTipPickupEx_cer(											// Tip Pickup step, error handlig tailored to pickup needles
		device& ML_STAR,														// i: pipetting device
		sequence& tipPickupSequence,										// i: tip pickup sequence
		variable tipPickupSequenceCounting,								// i: sequence counting (0 = manually, 1 = automatic)
		variable& tipPickupChannelVariable,								// i: channel variable (0 = unused, 1 = used)
		variable tipPickupChannelUse,										// i: channel use (1 = all sequence positions, 2 = channel pattern)
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue, 4 = custom)
      variable customStepID,             								// i: identifier for used single step defined for custom error handling
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepTipEject(													// Tip Eject step
		device& ML_STAR,														// i: pipetting device
		variable tipEjectUseDefaultWaste,								// i: indicates whether to use the default waste (0 = Off, 1 = On)
		sequence& tipEjectSequence,										// i: tip eject waste destination
		variable tipEjectSequenceCounting,								// i: sequence counting (0 = manually, 1 = automatic)
		variable& tipEjectChannelVariable,								// i: channel variable (0 = unused, 1 = used)
		variable tipEjectChannelUse,										// i: channel use (1 = all sequence positions, 2 = channel pattern)
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepTipEject_cer(												// Tip Eject step
		device& ML_STAR,														// i: pipetting device
		variable tipEjectUseDefaultWaste,								// i: indicates whether to use the default waste (0 = Off, 1 = On)
		sequence& tipEjectSequence,										// i: tip eject waste destination
		variable tipEjectSequenceCounting,								// i: sequence counting (0 = manually, 1 = automatic)
		variable& tipEjectChannelVariable,								// i: channel variable (0 = unused, 1 = used)
		variable tipEjectChannelUse,										// i: channel use (1 = all sequence positions, 2 = channel pattern)
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue, 4 = custom)
      variable customStepID,             								// i: identifier for used single step defined for custom error handling
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepAspirate(													// Aspirate step
		device& ML_STAR,														// i: pipetting device
		sequence& aspirateSequence,										// i: aspirate sequence
		variable aspirateSequenceCounting,								// i: sequence counting (0 = manually, 1 = automatic)
		variable aspirateVolume,											// i: aspirate volume [ul]
		variable aspirateMode,												// i: aspirate mode (0 = aspiration, 1 = consecutive aspiration, 2 = empty cup aspiration)
		variable aspirateCLLDSensitivity,								// i: capacitive liquid level detection (0 = off, 1 = very high, 2 = high, 3 = middle, 4 = low)
		variable aspiratePLLDSensitivity,								// i: pressure liquid level detection (0 = off, 1 = very high, 2 = high, 3 = middle, 4 = low)
		variable aspirateSubmergeDepth,									// i: submerge depth after the liquid level detection [mm]
		variable aspirateFluidHeight,										// i: liquid height from bottom if liquid level detection is disabled
		variable aspirateMaxHeightDiff,									// i: the maximum difference between the two liquid level detection measurements [mm]
		variable& aspirateChannelVariable,								// i: channel variable (0 = unused, 1 = used)
		variable aspirateChannelUse,										// i: channel use (1 = all sequence positions, 2 = channel pattern)
		variable aspirateLiquidFollowing,								// i: liquid following during aspirate and mix (0 = disabled, 1 = enabled)
		variable aspiratePrerinsingMixCycles,							// i: prerinsing / mix cycles 
		variable aspiratePrerinsingMixPosition,						// i: prerinsing / mix position [mm]
		variable aspiratePrerinsingMixVolume,							// i: prerinsing / mix volume [ul]
		variable& aspirateUserDefinedLiquidClass,						// i: liquid class, will be automatically selected if not explicitly set
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepAspirate_cer(													// Aspirate step
		device& ML_STAR,														// i: pipetting device
		sequence& aspirateSequence,										// i: aspirate sequence
		variable aspirateSequenceCounting,								// i: sequence counting (0 = manually, 1 = automatic)
		variable aspirateVolume,											// i: aspirate volume [ul]
		variable aspirateMode,												// i: aspirate mode (0 = aspiration, 1 = consecutive aspiration, 2 = empty cup aspiration)
		variable aspirateCLLDSensitivity,								// i: capacitive liquid level detection (0 = off, 1 = very high, 2 = high, 3 = middle, 4 = low)
		variable aspiratePLLDSensitivity,								// i: pressure liquid level detection (0 = off, 1 = very high, 2 = high, 3 = middle, 4 = low)
		variable aspirateSubmergeDepth,									// i: submerge depth after the liquid level detection [mm]
		variable aspirateFluidHeight,										// i: liquid height from bottom if liquid level detection is disabled
		variable aspirateMaxHeightDiff,									// i: the maximum difference between the two liquid level detection measurements [mm]
		variable& aspirateChannelVariable,								// i: channel variable (0 = unused, 1 = used)
		variable aspirateChannelUse,										// i: channel use (1 = all sequence positions, 2 = channel pattern)
		variable aspirateLiquidFollowing,								// i: liquid following during aspirate and mix (0 = disabled, 1 = enabled)
		variable aspiratePrerinsingMixCycles,							// i: prerinsing / mix cycles 
		variable aspiratePrerinsingMixPosition,						// i: prerinsing / mix position [mm]
		variable aspiratePrerinsingMixVolume,							// i: prerinsing / mix volume [ul]
		variable& aspirateUserDefinedLiquidClass,						// i: liquid class, will be automatically selected if not explicitly set
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue, 4 = custom)
      variable customStepID,             								// i: identifier for used single step defined for custom error handling
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepAspirateEx(												// Aspirate step extension
		device& ML_STAR,														// i: pipetting device
		sequence& aspirateSequence,										// i: aspirate sequence
		variable aspirateSequenceCounting,								// i: sequence counting (0 = manually, 1 = automatic)
		variable& aspirateVolumes[],										// i: aspirate volumes per channel [ul]
		variable aspirateMode,												// i: aspirate mode (0 = aspiration, 1 = consecutive aspiration, 2 = empty cup aspiration)
		variable aspirateCLLDSensitivity,								// i: capacitive liquid level detection (0 = off, 1 = very high, 2 = high, 3 = middle, 4 = low)
		variable aspiratePLLDSensitivity,								// i: pressure liquid level detection (0 = off, 1 = very high, 2 = high, 3 = middle, 4 = low)
		variable aspirateSubmergeDepth,									// i: submerge depth after the liquid level detection [mm]
		variable aspirateFluidHeight,										// i: liquid height from bottom if liquid level detection is disabled
		variable aspirateMaxHeightDiff,									// i: the maximum difference between the two liquid level detection measurements [mm]
		variable& aspirateChannelVariable,								// i: channel variable (0 = unused, 1 = used)
		variable aspirateChannelUse,										// i: channel use (1 = all sequence positions, 2 = channel pattern)
		variable aspirateLiquidFollowing,								// i: liquid following during aspirate and mix (0 = disabled, 1 = enabled)
		variable aspiratePrerinsingMixCycles,							// i: prerinsing / mix cycles 
		variable aspiratePrerinsingMixPosition,						// i: prerinsing / mix position [mm]
		variable aspiratePrerinsingMixVolume,							// i: prerinsing / mix volume [ul]
		variable& aspirateUserDefinedLiquidClass,						// i: liquid class, will be automatically selected if not explicitly set
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepAspirateEx_cer(											// Aspirate step extension
		device& ML_STAR,														// i: pipetting device
		sequence& aspirateSequence,										// i: aspirate sequence
		variable aspirateSequenceCounting,								// i: sequence counting (0 = manually, 1 = automatic)
		variable& aspirateVolumes[],										// i: aspirate volumes per channel [ul]
		variable aspirateMode,												// i: aspirate mode (0 = aspiration, 1 = consecutive aspiration, 2 = empty cup aspiration)
		variable aspirateCLLDSensitivity,								// i: capacitive liquid level detection (0 = off, 1 = very high, 2 = high, 3 = middle, 4 = low)
		variable aspiratePLLDSensitivity,								// i: pressure liquid level detection (0 = off, 1 = very high, 2 = high, 3 = middle, 4 = low)
		variable aspirateSubmergeDepth,									// i: submerge depth after the liquid level detection [mm]
		variable aspirateFluidHeight,										// i: liquid height from bottom if liquid level detection is disabled
		variable aspirateMaxHeightDiff,									// i: the maximum difference between the two liquid level detection measurements [mm]
		variable& aspirateChannelVariable,								// i: channel variable (0 = unused, 1 = used)
		variable aspirateChannelUse,										// i: channel use (1 = all sequence positions, 2 = channel pattern)
		variable aspirateLiquidFollowing,								// i: liquid following during aspirate and mix (0 = disabled, 1 = enabled)
		variable aspiratePrerinsingMixCycles,							// i: prerinsing / mix cycles 
		variable aspiratePrerinsingMixPosition,						// i: prerinsing / mix position [mm]
		variable aspiratePrerinsingMixVolume,							// i: prerinsing / mix volume [ul]
		variable& aspirateUserDefinedLiquidClass,						// i: liquid class, will be automatically selected if not explicitly set
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue, 4 = custom)
      variable customStepID,             								// i: identifier for used single step defined for custom error handling
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepDispense(													// Dispense step
		device& ML_STAR,														// i: pipetting device
		sequence& dispenseSequence,										// i: dispense sequence
		variable dispenseSequenceCounting,								// i: sequence counting (0 = manually, 1 = automatic)
		variable dispenseVolume,											// i: dispense volume [ul]
		variable dispenseMode,												// i: dispense mode (0 = aspiration, 1 = consecutive dispense, 2 = empty cup aspiration)
		variable dispenseCLLDSensitivity,								// i: capacitive liquid level detection (0 = off, 1 = very high, 2 = high, 3 = middle, 4 = low)
		variable dispenseSubmergeDepth,									// i: submerge depth after the liquid level detection [mm]
		variable dispenseFluidHeight,										// i: liquid height from bottom if liquid level detection is disabled
		variable& dispenseChannelVariable,								// i: channel variable (0 = unused, 1 = used)
		variable dispenseChannelUse,										// i: channel use (1 = all sequence positions, 2 = channel pattern)
		variable dispenseLiquidFollowing,								// i: liquid following during dispense and mix (0 = disabled, 1 = enabled)
		variable dispensePrerinsingMixCycles,							// i: prerinsing / mix cycles 
		variable dispensePrerinsingMixPosition,						// i: prerinsing / mix position [mm]
		variable dispensePrerinsingMixVolume,							// i: prerinsing / mix volume [ul]
		variable& dispenseUserDefinedLiquidClass,						// i: liquid class, will be automatically selected if not explicitly set
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepDispense_cer(												// Dispense step
		device& ML_STAR,														// i: pipetting device
		sequence& dispenseSequence,										// i: dispense sequence
		variable dispenseSequenceCounting,								// i: sequence counting (0 = manually, 1 = automatic)
		variable dispenseVolume,											// i: dispense volume [ul]
		variable dispenseMode,												// i: dispense mode (0 = aspiration, 1 = consecutive dispense, 2 = empty cup aspiration)
		variable dispenseCLLDSensitivity,								// i: capacitive liquid level detection (0 = off, 1 = very high, 2 = high, 3 = middle, 4 = low)
		variable dispenseSubmergeDepth,									// i: submerge depth after the liquid level detection [mm]
		variable dispenseFluidHeight,										// i: liquid height from bottom if liquid level detection is disabled
		variable& dispenseChannelVariable,								// i: channel variable (0 = unused, 1 = used)
		variable dispenseChannelUse,										// i: channel use (1 = all sequence positions, 2 = channel pattern)
		variable dispenseLiquidFollowing,								// i: liquid following during dispense and mix (0 = disabled, 1 = enabled)
		variable dispensePrerinsingMixCycles,							// i: prerinsing / mix cycles 
		variable dispensePrerinsingMixPosition,						// i: prerinsing / mix position [mm]
		variable dispensePrerinsingMixVolume,							// i: prerinsing / mix volume [ul]
		variable& dispenseUserDefinedLiquidClass,						// i: liquid class, will be automatically selected if not explicitly set
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue, 4 = custom)
      variable customStepID,             								// i: identifier for used single step defined for custom error handling
      variable dispenseType,                                   // i: dispenseType (0 = regular dispense, 1 = pre-dispense, 2 = post-dispense)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepDispenseEx(												// Dispense step extension
		device& ML_STAR,														// i: pipetting device
		sequence& dispenseSequence,										// i: dispense sequence
		variable dispenseSequenceCounting,								// i: sequence counting (0 = manually, 1 = automatic)
		variable& dispenseVolumes[],										// i: dispense volumes per channel [ul]
		variable dispenseMode,												// i: dispense mode (0 = aspiration, 1 = consecutive dispense, 2 = empty cup aspiration)
		variable dispenseCLLDSensitivity,								// i: capacitive liquid level detection (0 = off, 1 = very high, 2 = high, 3 = middle, 4 = low)
		variable dispenseSubmergeDepth,									// i: submerge depth after the liquid level detection [mm]
		variable dispenseFluidHeight,										// i: liquid height from bottom if liquid level detection is disabled
		variable& dispenseChannelVariable,								// i: channel variable (0 = unused, 1 = used)
		variable dispenseChannelUse,										// i: channel use (1 = all sequence positions, 2 = channel pattern)
		variable dispenseLiquidFollowing,								// i: liquid following during dispense and mix (0 = disabled, 1 = enabled)
		variable dispensePrerinsingMixCycles,							// i: prerinsing / mix cycles 
		variable dispensePrerinsingMixPosition,						// i: prerinsing / mix position [mm]
		variable dispensePrerinsingMixVolume,							// i: prerinsing / mix volume [ul]
		variable& dispenseUserDefinedLiquidClass,						// i: liquid class, will be automatically selected if not explicitly set
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepDispenseEx_cer(											// Dispense step extension
		device& ML_STAR,														// i: pipetting device
		sequence& dispenseSequence,										// i: dispense sequence
		variable dispenseSequenceCounting,								// i: sequence counting (0 = manually, 1 = automatic)
		variable& dispenseVolumes[],										// i: dispense volumes per channel [ul]
		variable dispenseMode,												// i: dispense mode (0 = aspiration, 1 = consecutive dispense, 2 = empty cup aspiration)
		variable dispenseCLLDSensitivity,								// i: capacitive liquid level detection (0 = off, 1 = very high, 2 = high, 3 = middle, 4 = low)
		variable dispenseSubmergeDepth,									// i: submerge depth after the liquid level detection [mm]
		variable dispenseFluidHeight,										// i: liquid height from bottom if liquid level detection is disabled
		variable& dispenseChannelVariable,								// i: channel variable (0 = unused, 1 = used)
		variable dispenseChannelUse,										// i: channel use (1 = all sequence positions, 2 = channel pattern)
		variable dispenseLiquidFollowing,								// i: liquid following during dispense and mix (0 = disabled, 1 = enabled)
		variable dispensePrerinsingMixCycles,							// i: prerinsing / mix cycles 
		variable dispensePrerinsingMixPosition,						// i: prerinsing / mix position [mm]
		variable dispensePrerinsingMixVolume,							// i: prerinsing / mix volume [ul]
		variable& dispenseUserDefinedLiquidClass,						// i: liquid class, will be automatically selected if not explicitly set
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue, 4 = custom)
      variable customStepID,             								// i: identifier for used single step defined for custom error handling
      variable dispenseType,                                   // i: dispenseType (0 = regular dispense, 1 = pre-dispense, 2 = post-dispense)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepLoadCarrier(												// Load Carrier step
		device& ML_STAR,														// i: pipetting device
		variable& loadCarrier,												// i: load carrier name
		variable loadCarrierBarcodeFileName,							// i: load carrier barcode file name
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepLoadCarrierEx(											// Load Carrier step extension
		device& ML_STAR,														// i: pipetting device
		variable& loadCarrier,												// i: load carrier name
		variable loadCarrierBarcodeFileName,							// i: load carrier barcode file name
		variable barcodeReadPositions,									// i: load carrier barcode read positions
		variable recoveryOptionContinue,									// i: visibility of recovery option Continue (0 = invisible, 1 = visible)
		variable recoveryOptionExclude,									// i: visibility of recovery option Exclude (0 = invisible, 1 = visible)
		variable recoveryOptionDefault,									// i: default of recovery options Continue and Exclude (0 = Continue, 1 = Exclude) 
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepLoadCarrierEx_cer(										// Load Carrier step extension
		device& ML_STAR,														// i: pipetting device
		variable& loadCarrier,												// i: load carrier name
		variable loadCarrierBarcodeFileName,							// i: load carrier barcode file name
		variable barcodeReadPositions,									// i: load carrier barcode read positions
		variable recoveryOptionContinue,									// i: visibility of recovery option Continue (0 = invisible, 1 = visible)
		variable recoveryOptionExclude,									// i: visibility of recovery option Exclude (0 = invisible, 1 = visible)
		variable recoveryOptionDefault,									// i: default of recovery options Continue and Exclude (0 = Continue, 1 = Exclude) 
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue, 4 = custom)
      variable customStepID,             								// i: identifier for used single step defined for custom error handling
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepLoadCarrierEx2(											// Load Carrier step extension for special use with Load And Match
		device& ML_STAR,														// i: pipetting device
		variable& loadCarrier,												// i: load carrier name
		variable loadCarrierBarcodeFileName,							// i: load carrier barcode file name
		variable barcodeReadPositions,									// i: load carrier barcode read positions
		variable recoveryOptionContinue,									// i: visibility of recovery option Continue (0 = invisible, 1 = visible)
		variable recoveryOptionExclude,									// i: visibility of recovery option Exclude (0 = invisible, 1 = visible)
		variable recoveryOptionDefault,									// i: default of recovery options Continue and Exclude (0 = Continue, 1 = Exclude) 
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepLoadCarrierEx2_cer(										// Load Carrier step extension for special use with Load And Match
		device& ML_STAR,														// i: pipetting device
		variable& loadCarrier,												// i: load carrier name
		variable loadCarrierBarcodeFileName,							// i: load carrier barcode file name
		variable barcodeReadPositions,									// i: load carrier barcode read positions
		variable recoveryOptionContinue,									// i: visibility of recovery option Continue (0 = invisible, 1 = visible)
		variable recoveryOptionExclude,									// i: visibility of recovery option Exclude (0 = invisible, 1 = visible)
		variable recoveryOptionDefault,									// i: default of recovery options Continue and Exclude (0 = Continue, 1 = Exclude) 
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue, 4 = custom)
      variable customStepID,             								// i: identifier for used single step defined for custom error handling
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepUnloadCarrier(											// Unload Carrier step
		device& ML_STAR,														// i: pipetting device
		variable& unloadCarrier,											// i: unload carrier name
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepUnloadCarrier_cer(										// Unload Carrier step
		device& ML_STAR,														// i: pipetting device
		variable& unloadCarrier,											// i: unload carrier name
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue, 4 = custom)
      variable customStepID,             								// i: identifier for used single step defined for custom error handling
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepCalibrate1536Plate(										// Calibrate Carrier step
		device& ML_STAR,														// i: pipetting device
		variable& calibrateCarrier,										// i: calibrate carrier name
		variable calibrateCarrierChannel,								// i: calibrate carrier channel
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepCalibrate1536Plate_cer(								// Calibrate Carrier step
		device& ML_STAR,														// i: pipetting device
		variable& calibrateCarrier,										// i: calibrate carrier name
		variable calibrateCarrierChannel,								// i: calibrate carrier channel
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue, 4 = custom)
      variable customStepID,             								// i: identifier for used single step defined for custom error handling
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepWaitNeedleWashed(										// Wait Needle Washed step
		device& ML_STAR,														// i: pipetting device
		variable& washStation,												// i: wash station
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepWaitNeedleWashed_cer(									// Wait Needle Washed step
		device& ML_STAR,														// i: pipetting device
		variable& washStation,												// i: wash station
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue, 4 = custom)
      variable customStepID,             								// i: identifier for used single step defined for custom error handling
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepStartNeedleWash(											// Start Needle Wash step
		device& ML_STAR,														// i: pipetting device
		variable& washStation,												// i: wash station
		variable rinseTime1,													// i: rinse time [s]
		variable soakTime1,													// i: soak time [s]
		variable flowRate1,													// i: flow rate [ml/s]
		variable rinseTime2,													// i: rinse time [s]
		variable soakTime2,													// i: soak time [s]
		variable flowRate2,													// i: flow rate [ml/s]
		variable drainingTime,												// i: draining time [s]
		variable startWashLiquid,											// i: start wash liquid
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepStartNeedleWash_cer(									// Start Needle Wash step
		device& ML_STAR,														// i: pipetting device
		variable& washStation,												// i: wash station
		variable rinseTime1,													// i: rinse time [s]
		variable soakTime1,													// i: soak time [s]
		variable flowRate1,													// i: flow rate [ml/s]
		variable rinseTime2,													// i: rinse time [s]
		variable soakTime2,													// i: soak time [s]
		variable flowRate2,													// i: flow rate [ml/s]
		variable drainingTime,												// i: draining time [s]
		variable startWashLiquid,											// i: start wash liquid
		variable errorHandling,												// i: error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue, 4 = custom)
      variable customStepID,             								// i: identifier for used single step defined for custom error handling
		variable userResponseTime)											// i: user response time [s]
	{}

	function StepFirmwareCommand(											// Executes a firmware command
		device& ML_STAR,														// i: Specifies the device context.
		variable& commandString,											// i: Command string.
		variable& parameterString,											// i: Parameter string.
		variable& returnValues[]) void									// o: Step return values.
	{}
}
#endif

// Implementation of Microlab® STAR Step Library
#ifdef HSL_RUNTIME

#include "SmartStepCustomizedErrorHandling\SmartStepCustomErrorHandling.hs_"
#include "HSLStrLib.hsl"

namespace MlStarSteps
{
	#ifdef _DEBUG_STEPPARAMS
	namespace DEBUG
	{
		// Helper function, returns the variable converted to a string
		static function StrStr(variable& var) variable
		{
			variable type;
			type = GetType(var);
			if (hslInteger.Compare(type) == 0)
			{
				var = IStr(var);
			}
			else
			{
				if (hslFloat.Compare(type) == 0)
				{
					var = FStr(var);
				}
				else
				{
					if (hslString.Compare(type) != 0)
					{
						var = "";
					}
				}
			}
			return(var);
		}

		static function TraceStepParamVariable(variable& stepName, variable& key, variable& value) void
		{
			FormatTrace("DEBUG", stepName, 4, key, ": ", value);
		}

		static function TraceStepParamVariableArray(variable& stepName, variable& key, variable& value[]) void
		{
			variable values;
			variable index, count;
			count = value.GetSize();
			FormatTrace("DEBUG", stepName, 4, key, "[] Size: ", count);
			values = "";
			for(index=0; index<count; index++)
			{
				values = values + DEBUG::StrStr(value[index]);
				if ( index<(count-1) )
				{
					values = values + ", ";
				}
			}
			FormatTrace("DEBUG", stepName, 4, key, "[] Values: ", values);
		}

		static function TraceStepParamSequence(variable& stepName, variable& key, sequence& value) void
		{
			FormatTrace("DEBUG", stepName, 4,
							key, ": name = ", value.GetName(), 
							", current = ", value.GetCurrentPosition(), 
							", count = ",   value.GetCount(),
							", maxPos = ",  value.GetMax());
		}

		static function TraceStepParamDevice(variable& stepName, variable& key, device& value) void
		{
			FormatTrace("DEBUG", stepName, 4, key, ": ", value.GetInstrumentName());
		}
	}
	#endif	// _DEBUG_STEPPARAMS

	// --------------------------------------------------------------------------------------
	// Error Handling
	// --------------------------------------------------------------------------------------

	namespace ErrorHandling
	{
		static const variable first(1);									// guard
		static const variable abort_(first);							// error handling
		static const variable cancel(first + 1);						// error handling
		static const variable continue(first + 2);					// error handling
		static const variable continue_2(first + 3);					// error handling
		static const variable custom(first + 4);					   // error handling
		static const variable last(first + 4);							// guard
	}

   namespace DispenseType
   {
		static const variable first(1);									// guard
		static const variable regularDispense(first);				// dispense type
		static const variable preDispense(first + 1);      		// dispense type
		static const variable postDispense(first + 2);				// dispense type
		static const variable last(first + 2);							// guard
   }

   namespace CustomStepID
   {
      static const variable default(0);
   }

	// --------------------------------------------------------------------------------------
	// Traceing
	// --------------------------------------------------------------------------------------

	namespace TraceStatus
	{
		static const variable start(1);									// action status for formated trace
		static const variable complete(2);								// action status for formated trace
		static const variable error_(3);									// action status for formated trace
		static const variable progress(4);								// action status for formated trace
		static const variable completeWithError(5);					// action status for formated trace
	}

   static function TraceCustomStep(variable& stepName, variable customStepID) void
   {
      string trace(Translate("SmartStepCustomErrorHandling - %s1 with step ID %s2"));

      StrReplace(trace, "%s1", stepName);
      StrReplace(trace, "%s2", IStr(customStepID));

      FormatTrace("SYSTEM", trace, TraceStatus::progress);
   }

	// --------------------------------------------------------------------------------------
	// Functions
	// --------------------------------------------------------------------------------------

	function StepInitialize_cer(
		device& ML_STAR,
		variable initializeAlways,
		variable errorHandling,
      variable customStepID,
		variable userResponseTime)
	{
		variable rc[];

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamVariable(stepName, "initializeAlways", initializeAlways);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
			DEBUG::TraceStepParamVariable(stepName, "customStepID", customStepID);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif

		if (ErrorHandling::abort_ == errorHandling)
			rc = ML_STAR._1C0C0CB0_7C87_11D3_AD83_0004ACB1DCB2( "9e73215e_ed8a_4485_a577321944135f3a" ); // Initialize
		if (ErrorHandling::cancel == errorHandling)
			rc = ML_STAR._1C0C0CB0_7C87_11D3_AD83_0004ACB1DCB2( "af60c527_3cdc_4130_a2866d14f7cfeda7" ); // Initialize
		if (ErrorHandling::continue == errorHandling)
			rc = ML_STAR._1C0C0CB0_7C87_11D3_AD83_0004ACB1DCB2( "e329e547_7c0f_4ea2_93653f27ee3e1ac0" ); // Initialize
      if (ErrorHandling::custom == errorHandling)
      {
         TraceCustomStep("Intialize", customStepID);

         // call sub-method library function
         SMARTSTEPCUSTOMERRORHANDLING::Initialize(ML_STAR,  customStepID, initializeAlways, userResponseTime, rc);
      }

		return(rc);
	}


	function StepInitialize2(
		device& ML_STAR,
		variable initializeAlways,
		variable errorHandling,
		variable userResponseTime)
	{
		variable rc[];

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamVariable(stepName, "initializeAlways", initializeAlways);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif
	
   	// 2016-08-08/ubernhard: Forward to StepInitialize_cer only
		rc = StepInitialize_cer(ML_STAR, initializeAlways, errorHandling, CustomStepID::default, userResponseTime);
		
		return(rc);
   }


	function StepInitialize(
		device& ML_STAR,
		variable initializeUseDefaultWaste,
		sequence& initializeWasteDestination,
		variable initializeSequenceCounting,
		variable& initializeChannelVariable,
		variable initializeChannelUse,
		variable initializeAlways,
		variable errorHandling,
		variable userResponseTime)
	{
		variable rc[];

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamVariable(stepName, "initializeUseDefaultWaste  (IGNORED!)", initializeUseDefaultWaste);
			DEBUG::TraceStepParamSequence(stepName, "initializeWasteDestination (IGNORED!)", initializeWasteDestination);
			DEBUG::TraceStepParamVariable(stepName, "initializeSequenceCounting (IGNORED!)", initializeSequenceCounting);
			DEBUG::TraceStepParamVariable(stepName, "initializeChannelVariable  (IGNORED!)", initializeChannelVariable);
			DEBUG::TraceStepParamVariable(stepName, "initializeChannelUse       (IGNORED!)", initializeChannelUse);
			DEBUG::TraceStepParamVariable(stepName, "initializeAlways",     initializeAlways);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling",        errorHandling);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime",     userResponseTime);
		}
		#endif

		// 2009-12-17/cjoerg: Forward to StepInitialize2 only
		rc = StepInitialize2(ML_STAR, initializeAlways, errorHandling, userResponseTime);
		
		return(rc);
	}


	function StepTipPickup_cer(
		device& ML_STAR,
		sequence& tipPickupSequence,
		variable tipPickupSequenceCounting,
		variable& tipPickupChannelVariable,
		variable tipPickupChannelUse,
		variable errorHandling,
      variable customStepID,
		variable userResponseTime)
	{
		variable rc[];

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamSequence(stepName, "tipPickupSequence", tipPickupSequence);
			DEBUG::TraceStepParamVariable(stepName, "tipPickupSequenceCounting", tipPickupSequenceCounting);
			DEBUG::TraceStepParamVariable(stepName, "tipPickupChannelVariable", tipPickupChannelVariable);
			DEBUG::TraceStepParamVariable(stepName, "tipPickupChannelUse", tipPickupChannelUse);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
         DEBUG::TraceStepParamVariable(stepName, "customStepID", customStepID);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif

		if (ErrorHandling::abort_ == errorHandling)
			rc = ML_STAR._541143FA_7FA2_11D3_AD85_0004ACB1DCB2( "97dbaf11_5084_41dd_8a44f0ac915ef29f" ); // TipPickUp
		if (ErrorHandling::cancel == errorHandling)
			rc = ML_STAR._541143FA_7FA2_11D3_AD85_0004ACB1DCB2( "14066b9f_7dc7_4cf6_b817ed3d34feaf28" ); // TipPickUp
		if (ErrorHandling::continue == errorHandling)
			rc = ML_STAR._541143FA_7FA2_11D3_AD85_0004ACB1DCB2( "1f0bc128_757b_4a80_a0046d8f1895b3b8" ); // TipPickUp
		if (ErrorHandling::continue_2 == errorHandling)
			rc = ML_STAR._541143FA_7FA2_11D3_AD85_0004ACB1DCB2( "a72a588d_26f6_4065_b10f30465e088c8b" ); // TipPickUp
      if (ErrorHandling::custom == errorHandling)
      {
         TraceCustomStep("Tip Pick Up", customStepID);

         // call sub-method library function
         SMARTSTEPCUSTOMERRORHANDLING::TipPickUp(ML_STAR, customStepID, tipPickupSequence, tipPickupSequenceCounting,
            tipPickupChannelVariable, tipPickupChannelUse, userResponseTime, rc);
      }

		return(rc);
	}


	function StepTipPickup(
		device& ML_STAR,
		sequence& tipPickupSequence,
		variable tipPickupSequenceCounting,
		variable& tipPickupChannelVariable,
		variable tipPickupChannelUse,
		variable errorHandling,
		variable userResponseTime)
	{
		variable rc[];

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamSequence(stepName, "tipPickupSequence", tipPickupSequence);
			DEBUG::TraceStepParamVariable(stepName, "tipPickupSequenceCounting", tipPickupSequenceCounting);
			DEBUG::TraceStepParamVariable(stepName, "tipPickupChannelVariable", tipPickupChannelVariable);
			DEBUG::TraceStepParamVariable(stepName, "tipPickupChannelUse", tipPickupChannelUse);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif

   	// 2016-08-08/ubernhard: Forward to StepTipPickup_cer only
		rc = StepTipPickup_cer(ML_STAR, tipPickupSequence, tipPickupSequenceCounting, tipPickupChannelVariable,
		                        tipPickupChannelUse, errorHandling, CustomStepID::default, userResponseTime);
		return(rc);
	}


	function StepTipPickupEx_cer(
		device& ML_STAR,
		sequence& tipPickupSequence,
		variable tipPickupSequenceCounting,
		variable& tipPickupChannelVariable,
		variable tipPickupChannelUse,
		variable errorHandling,
      variable customStepID,
		variable userResponseTime)
	{
		variable rc[];

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamSequence(stepName, "tipPickupSequence", tipPickupSequence);
			DEBUG::TraceStepParamVariable(stepName, "tipPickupSequenceCounting", tipPickupSequenceCounting);
			DEBUG::TraceStepParamVariable(stepName, "tipPickupChannelVariable", tipPickupChannelVariable);
			DEBUG::TraceStepParamVariable(stepName, "tipPickupChannelUse", tipPickupChannelUse);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
         DEBUG::TraceStepParamVariable(stepName, "customStepID", customStepID);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif

		if (ErrorHandling::abort_ == errorHandling)
			rc = ML_STAR._541143FA_7FA2_11D3_AD85_0004ACB1DCB2( "c4a94bbc_7db6_4052_b37e98851b78dd21" ); // TipPickUp
		if (ErrorHandling::cancel == errorHandling)
			rc = ML_STAR._541143FA_7FA2_11D3_AD85_0004ACB1DCB2( "305a5f24_1b35_483f_8114122d25ef51b0" ); // TipPickUp
		if (ErrorHandling::continue == errorHandling)
			rc = ML_STAR._541143FA_7FA2_11D3_AD85_0004ACB1DCB2( "320e25f1_dc1f_455e_894d3f98f6204c56" ); // TipPickUp
		if (ErrorHandling::continue_2 == errorHandling)
			rc = ML_STAR._541143FA_7FA2_11D3_AD85_0004ACB1DCB2( "db54747f_55b1_443d_b6052373717af691" ); // TipPickUp
      if (ErrorHandling::custom == errorHandling)
      {
         TraceCustomStep("Tip Pick Up", customStepID);

         // call sub-method library function
         SMARTSTEPCUSTOMERRORHANDLING::TipPickUp(ML_STAR, customStepID, tipPickupSequence, tipPickupSequenceCounting,
            tipPickupChannelVariable, tipPickupChannelUse, userResponseTime, rc);
      }

		return(rc);
	}


	function StepTipPickupEx(
		device& ML_STAR,
		sequence& tipPickupSequence,
		variable tipPickupSequenceCounting,
		variable& tipPickupChannelVariable,
		variable tipPickupChannelUse,
		variable errorHandling,
		variable userResponseTime)
	{
		variable rc[];

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamSequence(stepName, "tipPickupSequence", tipPickupSequence);
			DEBUG::TraceStepParamVariable(stepName, "tipPickupSequenceCounting", tipPickupSequenceCounting);
			DEBUG::TraceStepParamVariable(stepName, "tipPickupChannelVariable", tipPickupChannelVariable);
			DEBUG::TraceStepParamVariable(stepName, "tipPickupChannelUse", tipPickupChannelUse);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif

   	// 2016-08-08/ubernhard: Forward to StepTipPickupEx_cer only
		rc = StepTipPickupEx_cer(ML_STAR, tipPickupSequence, tipPickupSequenceCounting, tipPickupChannelVariable,
		                           tipPickupChannelUse, errorHandling, CustomStepID::default, userResponseTime);

		return(rc);
	}


	function StepTipEject_cer(
		device& ML_STAR,
		variable tipEjectUseDefaultWaste,
		sequence& tipEjectSequence,
		variable tipEjectSequenceCounting,
		variable& tipEjectChannelVariable,
		variable tipEjectChannelUse,
		variable errorHandling,
      variable customStepID,
		variable userResponseTime)
	{
		variable rc[];

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamVariable(stepName, "tipEjectUseDefaultWaste", tipEjectUseDefaultWaste);
			DEBUG::TraceStepParamSequence(stepName, "tipEjectSequence", tipEjectSequence);
			DEBUG::TraceStepParamVariable(stepName, "tipEjectSequenceCounting", tipEjectSequenceCounting);
			DEBUG::TraceStepParamVariable(stepName, "tipEjectChannelVariable", tipEjectChannelVariable);
			DEBUG::TraceStepParamVariable(stepName, "tipEjectChannelUse", tipEjectChannelUse);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
         DEBUG::TraceStepParamVariable(stepName, "customStepID", customStepID);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif

		if (ErrorHandling::abort_ == errorHandling)
			rc = ML_STAR._541143FC_7FA2_11D3_AD85_0004ACB1DCB2( "99b24a5e_7d7f_4ca4_b6bfad1877a91483" ); // TipEject
		if (ErrorHandling::cancel == errorHandling)
			rc = ML_STAR._541143FC_7FA2_11D3_AD85_0004ACB1DCB2( "28b3dcff_ece1_4cac_a9436b503c220974" ); // TipEject
		if (ErrorHandling::continue == errorHandling)
			rc = ML_STAR._541143FC_7FA2_11D3_AD85_0004ACB1DCB2( "204673c6_2795_4fad_b1909e591f978779" ); // TipEject
      if (ErrorHandling::custom == errorHandling)
      {
         TraceCustomStep("Tip Eject", customStepID);

         // call sub-method library function
         SMARTSTEPCUSTOMERRORHANDLING::TipEject(ML_STAR, customStepID, tipEjectUseDefaultWaste, tipEjectSequence,
            tipEjectSequenceCounting, tipEjectChannelVariable, tipEjectChannelUse, userResponseTime, rc);
      }

		return(rc);
	}


	function StepTipEject(
		device& ML_STAR,
		variable tipEjectUseDefaultWaste,
		sequence& tipEjectSequence,
		variable tipEjectSequenceCounting,
		variable& tipEjectChannelVariable,
		variable tipEjectChannelUse,
		variable errorHandling,
		variable userResponseTime)
	{
		variable rc[];

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamVariable(stepName, "tipEjectUseDefaultWaste", tipEjectUseDefaultWaste);
			DEBUG::TraceStepParamSequence(stepName, "tipEjectSequence", tipEjectSequence);
			DEBUG::TraceStepParamVariable(stepName, "tipEjectSequenceCounting", tipEjectSequenceCounting);
			DEBUG::TraceStepParamVariable(stepName, "tipEjectChannelVariable", tipEjectChannelVariable);
			DEBUG::TraceStepParamVariable(stepName, "tipEjectChannelUse", tipEjectChannelUse);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif

      // 2016-08-08/ubernhard: Forward to StepTipEject_cer only
      rc = StepTipEject_cer(ML_STAR, tipEjectUseDefaultWaste, tipEjectSequence, tipEjectSequenceCounting, tipEjectChannelVariable, 
                              tipEjectChannelUse, errorHandling, CustomStepID::default, userResponseTime);

		return(rc);
	}


	static function StepAspirateEx_cer(
		device& ML_STAR,
		sequence& aspirateSequence,
		variable aspirateSequenceCounting,
		variable& aspirateVolumes[],
		variable aspirateMode,
		variable aspirateCLLDSensitivity,
		variable aspiratePLLDSensitivity,
		variable aspirateSubmergeDepth,
		variable aspirateFluidHeight,
		variable aspirateMaxHeightDiff,
		variable& aspirateChannelVariable,
		variable aspirateChannelUse,
		variable aspirateLiquidFollowing,
		variable aspiratePrerinsingMixCycles,
		variable aspiratePrerinsingMixPosition,
		variable aspiratePrerinsingMixVolume,
		variable& aspirateUserDefinedLiquidClass,
		variable errorHandling,
      variable customStepID,
		variable userResponseTime)
	{
		variable rc[];
		variable size;
		variable aspirateVolume1(0);
		variable aspirateVolume2(0);
		variable aspirateVolume3(0);
		variable aspirateVolume4(0);
		variable aspirateVolume5(0);
		variable aspirateVolume6(0);
		variable aspirateVolume7(0);
		variable aspirateVolume8(0);
		variable aspirateVolume9(0);
		variable aspirateVolume10(0);
		variable aspirateVolume11(0);
		variable aspirateVolume12(0);
		variable aspirateVolume13(0);
		variable aspirateVolume14(0);
		variable aspirateVolume15(0);
		variable aspirateVolume16(0);

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamSequence(stepName, "aspirateSequence", aspirateSequence);
			DEBUG::TraceStepParamVariable(stepName, "aspirateSequenceCounting", aspirateSequenceCounting);
			DEBUG::TraceStepParamVariableArray(stepName, "aspirateVolumes", aspirateVolumes);
			DEBUG::TraceStepParamVariable(stepName, "aspirateMode", aspirateMode);
			DEBUG::TraceStepParamVariable(stepName, "aspirateCLLDSensitivity", aspirateCLLDSensitivity);
			DEBUG::TraceStepParamVariable(stepName, "aspiratePLLDSensitivity", aspiratePLLDSensitivity);
			DEBUG::TraceStepParamVariable(stepName, "aspirateSubmergeDepth", aspirateSubmergeDepth);
			DEBUG::TraceStepParamVariable(stepName, "aspirateFluidHeight", aspirateFluidHeight);
			DEBUG::TraceStepParamVariable(stepName, "aspirateMaxHeightDiff", aspirateMaxHeightDiff);
			DEBUG::TraceStepParamVariable(stepName, "aspirateChannelVariable", aspirateChannelVariable);
			DEBUG::TraceStepParamVariable(stepName, "aspirateChannelUse", aspirateChannelUse);
			DEBUG::TraceStepParamVariable(stepName, "aspirateLiquidFollowing", aspirateLiquidFollowing);
			DEBUG::TraceStepParamVariable(stepName, "aspiratePrerinsingMixCycles", aspiratePrerinsingMixCycles);
			DEBUG::TraceStepParamVariable(stepName, "aspiratePrerinsingMixPosition", aspiratePrerinsingMixPosition);
			DEBUG::TraceStepParamVariable(stepName, "aspiratePrerinsingMixVolume", aspiratePrerinsingMixVolume);
			DEBUG::TraceStepParamVariable(stepName, "aspirateUserDefinedLiquidClass", aspirateUserDefinedLiquidClass);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
         DEBUG::TraceStepParamVariable(stepName, "customStepID", customStepID);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif

		size = aspirateVolumes.GetSize();
		if (0 < size)
			aspirateVolume1 = aspirateVolumes.GetAt(0);
		if (1 < size)
			aspirateVolume2 = aspirateVolumes.GetAt(1);
		if (2 < size)
			aspirateVolume3 = aspirateVolumes.GetAt(2);
		if (3 < size)
			aspirateVolume4 = aspirateVolumes.GetAt(3);
		if (4 < size)
			aspirateVolume5 = aspirateVolumes.GetAt(4);
		if (5 < size)
			aspirateVolume6 = aspirateVolumes.GetAt(5);
		if (6 < size)
			aspirateVolume7 = aspirateVolumes.GetAt(6);
		if (7 < size)
			aspirateVolume8 = aspirateVolumes.GetAt(7);
		if (8 < size)
			aspirateVolume9 = aspirateVolumes.GetAt(8);
		if (9 < size)
			aspirateVolume10 = aspirateVolumes.GetAt(9);
		if (10 < size)
			aspirateVolume11 = aspirateVolumes.GetAt(10);
		if (11 < size)
			aspirateVolume12 = aspirateVolumes.GetAt(11);
		if (12 < size)
			aspirateVolume13 = aspirateVolumes.GetAt(12);
		if (13 < size)
			aspirateVolume14 = aspirateVolumes.GetAt(13);
		if (14 < size)
			aspirateVolume15 = aspirateVolumes.GetAt(14);
		if (15 < size)
			aspirateVolume16 = aspirateVolumes.GetAt(15);

		if (ErrorHandling::abort_ == errorHandling)
			rc = ML_STAR._541143F5_7FA2_11D3_AD85_0004ACB1DCB2( "bd01f18c_bc3e_4f57_ac66536897955dae" ); // Aspirate
		if (ErrorHandling::cancel == errorHandling)
			rc = ML_STAR._541143F5_7FA2_11D3_AD85_0004ACB1DCB2( "8551166e_22f5_4de4_a30031089fc16019" ); // Aspirate
		if (ErrorHandling::continue == errorHandling)
			rc = ML_STAR._541143F5_7FA2_11D3_AD85_0004ACB1DCB2( "ac8a2ef9_0c12_4803_ba63768925292445" ); // Aspirate
      if (ErrorHandling::custom == errorHandling)
      {
         TraceCustomStep("Aspirate", customStepID);

         aspirateVolumes.SetSize(16);

         aspirateVolumes.SetAt( 0, aspirateVolume1);
         aspirateVolumes.SetAt( 1, aspirateVolume2);
         aspirateVolumes.SetAt( 2, aspirateVolume3);
         aspirateVolumes.SetAt( 3, aspirateVolume4);
         aspirateVolumes.SetAt( 4, aspirateVolume5);
         aspirateVolumes.SetAt( 5, aspirateVolume6);
         aspirateVolumes.SetAt( 6, aspirateVolume7);
         aspirateVolumes.SetAt( 7, aspirateVolume8);
         aspirateVolumes.SetAt( 8, aspirateVolume9);
         aspirateVolumes.SetAt( 9, aspirateVolume10);
         aspirateVolumes.SetAt(10, aspirateVolume11);
         aspirateVolumes.SetAt(11, aspirateVolume12);
         aspirateVolumes.SetAt(12, aspirateVolume13);
         aspirateVolumes.SetAt(13, aspirateVolume14);
         aspirateVolumes.SetAt(14, aspirateVolume15);
         aspirateVolumes.SetAt(15, aspirateVolume16);

         // call sub-method library function
         SMARTSTEPCUSTOMERRORHANDLING::Aspirate(ML_STAR, customStepID, aspirateSequence, aspirateSequenceCounting,
            aspirateChannelVariable, aspirateChannelUse, aspirateMode, aspirateVolumes, aspirateUserDefinedLiquidClass,
            aspirateCLLDSensitivity, aspirateSubmergeDepth, aspiratePLLDSensitivity, aspirateMaxHeightDiff, aspirateFluidHeight,
            aspirateLiquidFollowing, aspiratePrerinsingMixCycles, aspiratePrerinsingMixPosition, aspiratePrerinsingMixVolume, userResponseTime, rc);
      }

		return(rc);
	}


	static function StepAspirateEx(
		device& ML_STAR,
		sequence& aspirateSequence,
		variable aspirateSequenceCounting,
		variable& aspirateVolumes[],
		variable aspirateMode,
		variable aspirateCLLDSensitivity,
		variable aspiratePLLDSensitivity,
		variable aspirateSubmergeDepth,
		variable aspirateFluidHeight,
		variable aspirateMaxHeightDiff,
		variable& aspirateChannelVariable,
		variable aspirateChannelUse,
		variable aspirateLiquidFollowing,
		variable aspiratePrerinsingMixCycles,
		variable aspiratePrerinsingMixPosition,
		variable aspiratePrerinsingMixVolume,
		variable& aspirateUserDefinedLiquidClass,
		variable errorHandling,
		variable userResponseTime)
	{
		variable rc[];

      // 2016-08-08/ubernhard: Forward to StepAspirateEx_cer only
      rc = StepAspirateEx_cer(ML_STAR, aspirateSequence, aspirateSequenceCounting, aspirateVolumes, aspirateMode, aspirateCLLDSensitivity,
		                        aspiratePLLDSensitivity, aspirateSubmergeDepth, aspirateFluidHeight, aspirateMaxHeightDiff, aspirateChannelVariable,
		                        aspirateChannelUse, aspirateLiquidFollowing, aspiratePrerinsingMixCycles, aspiratePrerinsingMixPosition,
		                        aspiratePrerinsingMixVolume, aspirateUserDefinedLiquidClass, errorHandling, CustomStepID::default, userResponseTime);

		return(rc);
	}


   static function StepAspirate_cer(
		device& ML_STAR,
		sequence& aspirateSequence,
		variable aspirateSequenceCounting,
		variable aspirateVolume,
		variable aspirateMode,
		variable aspirateCLLDSensitivity,
		variable aspiratePLLDSensitivity,
		variable aspirateSubmergeDepth,
		variable aspirateFluidHeight,
		variable aspirateMaxHeightDiff,
		variable& aspirateChannelVariable,
		variable aspirateChannelUse,
		variable aspirateLiquidFollowing,
		variable aspiratePrerinsingMixCycles,
		variable aspiratePrerinsingMixPosition,
		variable aspiratePrerinsingMixVolume,
		variable& aspirateUserDefinedLiquidClass,
		variable errorHandling,
      variable customStepID,
		variable userResponseTime)
	{
		variable size;
		variable index;
		variable aspirateVolumes[];
		string aspirateChannelVariableCopy;

		aspirateChannelVariableCopy = aspirateChannelVariable;
		size = aspirateChannelVariableCopy.GetLength();
		for (index = 0; index < size; index++)
		{
			aspirateVolumes.AddAsLast(aspirateVolume);
		}
		return(StepAspirateEx_cer(	ML_STAR,
										aspirateSequence,
										aspirateSequenceCounting,
										aspirateVolumes,
										aspirateMode,
										aspirateCLLDSensitivity,
										aspiratePLLDSensitivity,
										aspirateSubmergeDepth,
										aspirateFluidHeight,
										aspirateMaxHeightDiff,
										aspirateChannelVariable,
										aspirateChannelUse,
										aspirateLiquidFollowing,
										aspiratePrerinsingMixCycles,
										aspiratePrerinsingMixPosition,
										aspiratePrerinsingMixVolume,
										aspirateUserDefinedLiquidClass,
										errorHandling,
                              customStepID,
										userResponseTime));
	}

	static function StepAspirate(
		device& ML_STAR,
		sequence& aspirateSequence,
		variable aspirateSequenceCounting,
		variable aspirateVolume,
		variable aspirateMode,
		variable aspirateCLLDSensitivity,
		variable aspiratePLLDSensitivity,
		variable aspirateSubmergeDepth,
		variable aspirateFluidHeight,
		variable aspirateMaxHeightDiff,
		variable& aspirateChannelVariable,
		variable aspirateChannelUse,
		variable aspirateLiquidFollowing,
		variable aspiratePrerinsingMixCycles,
		variable aspiratePrerinsingMixPosition,
		variable aspiratePrerinsingMixVolume,
		variable& aspirateUserDefinedLiquidClass,
		variable errorHandling,
		variable userResponseTime)
	{
		variable size;
		variable index;
		variable aspirateVolumes[];
		string aspirateChannelVariableCopy;

		aspirateChannelVariableCopy = aspirateChannelVariable;
		size = aspirateChannelVariableCopy.GetLength();
		for (index = 0; index < size; index++)
		{
			aspirateVolumes.AddAsLast(aspirateVolume);
		}
		return(StepAspirateEx_cer(	ML_STAR,
										aspirateSequence,
										aspirateSequenceCounting,
										aspirateVolumes,
										aspirateMode,
										aspirateCLLDSensitivity,
										aspiratePLLDSensitivity,
										aspirateSubmergeDepth,
										aspirateFluidHeight,
										aspirateMaxHeightDiff,
										aspirateChannelVariable,
										aspirateChannelUse,
										aspirateLiquidFollowing,
										aspiratePrerinsingMixCycles,
										aspiratePrerinsingMixPosition,
										aspiratePrerinsingMixVolume,
										aspirateUserDefinedLiquidClass,
										errorHandling,
                              CustomStepID::default,
										userResponseTime));
	}

	function StepDispenseEx_cer(
		device& ML_STAR,
		sequence& dispenseSequence,
		variable dispenseSequenceCounting,
		variable& dispenseVolumes[],
		variable dispenseMode,
		variable dispenseCLLDSensitivity,
		variable dispenseSubmergeDepth,
		variable dispenseFluidHeight,
		variable& dispenseChannelVariable,
		variable dispenseChannelUse,
		variable dispenseLiquidFollowing,
		variable dispensePrerinsingMixCycles,
		variable dispensePrerinsingMixPosition,
		variable dispensePrerinsingMixVolume,
		variable& dispenseUserDefinedLiquidClass,
		variable errorHandling,
      variable customStepID,
      variable dispenseType,
		variable userResponseTime)
	{
		variable rc[];
		variable size;
		variable dispenseVolume1(0);
		variable dispenseVolume2(0);
		variable dispenseVolume3(0);
		variable dispenseVolume4(0);
		variable dispenseVolume5(0);
		variable dispenseVolume6(0);
		variable dispenseVolume7(0);
		variable dispenseVolume8(0);
		variable dispenseVolume9(0);
		variable dispenseVolume10(0);
		variable dispenseVolume11(0);
		variable dispenseVolume12(0);
		variable dispenseVolume13(0);
		variable dispenseVolume14(0);
		variable dispenseVolume15(0);
		variable dispenseVolume16(0);

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamSequence(stepName, "dispenseSequence", dispenseSequence);
			DEBUG::TraceStepParamVariable(stepName, "dispenseSequenceCounting", dispenseSequenceCounting);
			DEBUG::TraceStepParamVariableArray(stepName, "dispenseVolumes", dispenseVolumes);
			DEBUG::TraceStepParamVariable(stepName, "dispenseMode", dispenseMode);
			DEBUG::TraceStepParamVariable(stepName, "dispenseCLLDSensitivity", dispenseCLLDSensitivity);
			DEBUG::TraceStepParamVariable(stepName, "dispenseSubmergeDepth", dispenseSubmergeDepth);
			DEBUG::TraceStepParamVariable(stepName, "dispenseFluidHeight", dispenseFluidHeight);
			DEBUG::TraceStepParamVariable(stepName, "dispenseChannelVariable", dispenseChannelVariable);
			DEBUG::TraceStepParamVariable(stepName, "dispenseChannelUse", dispenseChannelUse);
			DEBUG::TraceStepParamVariable(stepName, "dispenseLiquidFollowing", dispenseLiquidFollowing);
			DEBUG::TraceStepParamVariable(stepName, "dispensePrerinsingMixCycles", dispensePrerinsingMixCycles);
			DEBUG::TraceStepParamVariable(stepName, "dispensePrerinsingMixPosition", dispensePrerinsingMixPosition);
			DEBUG::TraceStepParamVariable(stepName, "dispensePrerinsingMixVolume", dispensePrerinsingMixVolume);
			DEBUG::TraceStepParamVariable(stepName, "dispenseUserDefinedLiquidClass", dispenseUserDefinedLiquidClass);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
         DEBUG::TraceStepParamVariable(stepName, "customStepID", customStepID);
         DEBUG::TraceStepParamVariable(stepName, "dispenseType", dispenseType);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif

		size = dispenseVolumes.GetSize();
		if (0 < size)
			dispenseVolume1 = dispenseVolumes.GetAt(0);
		if (1 < size)
			dispenseVolume2 = dispenseVolumes.GetAt(1);
		if (2 < size)
			dispenseVolume3 = dispenseVolumes.GetAt(2);
		if (3 < size)
			dispenseVolume4 = dispenseVolumes.GetAt(3);
		if (4 < size)
			dispenseVolume5 = dispenseVolumes.GetAt(4);
		if (5 < size)
			dispenseVolume6 = dispenseVolumes.GetAt(5);
		if (6 < size)
			dispenseVolume7 = dispenseVolumes.GetAt(6);
		if (7 < size)
			dispenseVolume8 = dispenseVolumes.GetAt(7);
		if (8 < size)
			dispenseVolume9 = dispenseVolumes.GetAt(8);
		if (9 < size)
			dispenseVolume10 = dispenseVolumes.GetAt(9);
		if (10 < size)
			dispenseVolume11 = dispenseVolumes.GetAt(10);
		if (11 < size)
			dispenseVolume12 = dispenseVolumes.GetAt(11);
		if (12 < size)
			dispenseVolume13 = dispenseVolumes.GetAt(12);
		if (13 < size)
			dispenseVolume14 = dispenseVolumes.GetAt(13);
		if (14 < size)
			dispenseVolume15 = dispenseVolumes.GetAt(14);
		if (15 < size)
			dispenseVolume16 = dispenseVolumes.GetAt(15);

		if (ErrorHandling::abort_ == errorHandling)
			rc = ML_STAR._541143F8_7FA2_11D3_AD85_0004ACB1DCB2( "2846b0ac_5dde_4a9d_9e87f8604e5587a6" ); // Dispense
		if (ErrorHandling::cancel == errorHandling)
			rc = ML_STAR._541143F8_7FA2_11D3_AD85_0004ACB1DCB2( "00e401c9_0cd8_4f80_95bc3825df158925" ); // Dispense
		if (ErrorHandling::continue == errorHandling)
			rc = ML_STAR._541143F8_7FA2_11D3_AD85_0004ACB1DCB2( "e23effa6_2e01_47a5_bee949c9095c27ac" ); // Dispense
      if (ErrorHandling::custom == errorHandling)
      {
         dispenseVolumes.SetSize(16);

         dispenseVolumes.SetAt( 0, dispenseVolume1);
         dispenseVolumes.SetAt( 1, dispenseVolume2);
         dispenseVolumes.SetAt( 2, dispenseVolume3);
         dispenseVolumes.SetAt( 3, dispenseVolume4);
         dispenseVolumes.SetAt( 4, dispenseVolume5);
         dispenseVolumes.SetAt( 5, dispenseVolume6);
         dispenseVolumes.SetAt( 6, dispenseVolume7);
         dispenseVolumes.SetAt( 7, dispenseVolume8);
         dispenseVolumes.SetAt( 8, dispenseVolume9);
         dispenseVolumes.SetAt( 9, dispenseVolume10);
         dispenseVolumes.SetAt(10, dispenseVolume11);
         dispenseVolumes.SetAt(11, dispenseVolume12);
         dispenseVolumes.SetAt(12, dispenseVolume13);
         dispenseVolumes.SetAt(13, dispenseVolume14);
         dispenseVolumes.SetAt(14, dispenseVolume15);
         dispenseVolumes.SetAt(15, dispenseVolume16);

         if(DispenseType::regularDispense == dispenseType)
         {
            TraceCustomStep("Dispense", customStepID);

            // call sub-method library function
            SMARTSTEPCUSTOMERRORHANDLING::Dispense(ML_STAR, customStepID, dispenseSequence, dispenseSequenceCounting,
               dispenseChannelVariable, dispenseChannelUse, dispenseMode, dispenseVolumes, dispenseUserDefinedLiquidClass,
               dispenseCLLDSensitivity, dispenseSubmergeDepth, dispenseFluidHeight, dispenseLiquidFollowing,
               dispensePrerinsingMixCycles, dispensePrerinsingMixPosition, dispensePrerinsingMixVolume, userResponseTime, rc);
         }
         if(DispenseType::preDispense == dispenseType)
         {
            TraceCustomStep("Pre-Dispense", customStepID);

            // call sub-method library function
            SMARTSTEPCUSTOMERRORHANDLING::PreDispense(ML_STAR, customStepID, dispenseSequence, dispenseSequenceCounting,
               dispenseChannelVariable, dispenseChannelUse, dispenseMode, dispenseVolumes, dispenseUserDefinedLiquidClass,
               dispenseCLLDSensitivity, dispenseSubmergeDepth, dispenseFluidHeight, dispenseLiquidFollowing,
               dispensePrerinsingMixCycles, dispensePrerinsingMixPosition, dispensePrerinsingMixVolume, userResponseTime, rc);
         }
         if(DispenseType::postDispense == dispenseType)
         {
            TraceCustomStep("Post-Dispense", customStepID);

            // call sub-method library function
            SMARTSTEPCUSTOMERRORHANDLING::PostDispense(ML_STAR, customStepID, dispenseSequence, dispenseSequenceCounting,
               dispenseChannelVariable, dispenseChannelUse, dispenseMode, dispenseVolumes, dispenseUserDefinedLiquidClass,
               dispenseCLLDSensitivity, dispenseSubmergeDepth, dispenseFluidHeight, dispenseLiquidFollowing,
               dispensePrerinsingMixCycles, dispensePrerinsingMixPosition, dispensePrerinsingMixVolume, userResponseTime, rc);
         }
      }
		
      return(rc);
	}

	function StepDispenseEx(
		device& ML_STAR,
		sequence& dispenseSequence,
		variable dispenseSequenceCounting,
		variable& dispenseVolumes[],
		variable dispenseMode,
		variable dispenseCLLDSensitivity,
		variable dispenseSubmergeDepth,
		variable dispenseFluidHeight,
		variable& dispenseChannelVariable,
		variable dispenseChannelUse,
		variable dispenseLiquidFollowing,
		variable dispensePrerinsingMixCycles,
		variable dispensePrerinsingMixPosition,
		variable dispensePrerinsingMixVolume,
		variable& dispenseUserDefinedLiquidClass,
		variable errorHandling,
		variable userResponseTime)
	{
		variable rc[];

      // 2016-08-08/ubernhard: Forward to StepDispenseEx_cer only
		return(StepDispenseEx_cer(	ML_STAR,
										dispenseSequence,
										dispenseSequenceCounting,
										dispenseVolumes,
										dispenseMode,
										dispenseCLLDSensitivity,
										dispenseSubmergeDepth,
										dispenseFluidHeight,
										dispenseChannelVariable,
										dispenseChannelUse,
										dispenseLiquidFollowing,
										dispensePrerinsingMixCycles,
										dispensePrerinsingMixPosition,
										dispensePrerinsingMixVolume,
										dispenseUserDefinedLiquidClass,
										errorHandling,
                              CustomStepID::default,
                              DispenseType::regularDispense,
										userResponseTime));

      return(rc);
	}


   function StepDispense_cer(
		device& ML_STAR,
		sequence& dispenseSequence,
		variable dispenseSequenceCounting,
		variable dispenseVolume,
		variable dispenseMode,
		variable dispenseCLLDSensitivity,
		variable dispenseSubmergeDepth,
		variable dispenseFluidHeight,
		variable& dispenseChannelVariable,
		variable dispenseChannelUse,
		variable dispenseLiquidFollowing,
		variable dispensePrerinsingMixCycles,
		variable dispensePrerinsingMixPosition,
		variable dispensePrerinsingMixVolume,
		variable& dispenseUserDefinedLiquidClass,
		variable errorHandling,
      variable customStepID,
      variable dispenseType,
		variable userResponseTime)
	{
		variable size;
		variable index;
		variable dispenseVolumes[];
		string dispenseChannelVariableCopy;

		dispenseChannelVariableCopy = dispenseChannelVariable;
		size = dispenseChannelVariableCopy.GetLength();
		for (index = 0; index < size; index++)
		{
			dispenseVolumes.AddAsLast(dispenseVolume);
		}
		return(StepDispenseEx_cer(	ML_STAR,
										dispenseSequence,
										dispenseSequenceCounting,
										dispenseVolumes,
										dispenseMode,
										dispenseCLLDSensitivity,
										dispenseSubmergeDepth,
										dispenseFluidHeight,
										dispenseChannelVariable,
										dispenseChannelUse,
										dispenseLiquidFollowing,
										dispensePrerinsingMixCycles,
										dispensePrerinsingMixPosition,
										dispensePrerinsingMixVolume,
										dispenseUserDefinedLiquidClass,
										errorHandling,
                              customStepID,
                              dispenseType,
										userResponseTime));
	}

	function StepDispense(
		device& ML_STAR,
		sequence& dispenseSequence,
		variable dispenseSequenceCounting,
		variable dispenseVolume,
		variable dispenseMode,
		variable dispenseCLLDSensitivity,
		variable dispenseSubmergeDepth,
		variable dispenseFluidHeight,
		variable& dispenseChannelVariable,
		variable dispenseChannelUse,
		variable dispenseLiquidFollowing,
		variable dispensePrerinsingMixCycles,
		variable dispensePrerinsingMixPosition,
		variable dispensePrerinsingMixVolume,
		variable& dispenseUserDefinedLiquidClass,
		variable errorHandling,
		variable userResponseTime)
	{
		variable size;
		variable index;
		variable dispenseVolumes[];
		string dispenseChannelVariableCopy;

		dispenseChannelVariableCopy = dispenseChannelVariable;
		size = dispenseChannelVariableCopy.GetLength();
		for (index = 0; index < size; index++)
		{
			dispenseVolumes.AddAsLast(dispenseVolume);
		}
		return(StepDispenseEx_cer(	ML_STAR,
										dispenseSequence,
										dispenseSequenceCounting,
										dispenseVolumes,
										dispenseMode,
										dispenseCLLDSensitivity,
										dispenseSubmergeDepth,
										dispenseFluidHeight,
										dispenseChannelVariable,
										dispenseChannelUse,
										dispenseLiquidFollowing,
										dispensePrerinsingMixCycles,
										dispensePrerinsingMixPosition,
										dispensePrerinsingMixVolume,
										dispenseUserDefinedLiquidClass,
										errorHandling,
                              CustomStepID::default,
                              DispenseType::regularDispense,
										userResponseTime));
	}

	function StepLoadCarrierEx_cer(
		device& ML_STAR,
		variable& loadCarrier,
		variable loadCarrierBarcodeFileName,
		variable barcodeReadPositions,
		variable recoveryOptionContinue,
		variable recoveryOptionExclude,
		variable recoveryOptionDefault,
		variable errorHandling,
      variable customStepID,
		variable userResponseTime)
	{
		variable rc[];

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamVariable(stepName, "loadCarrier", loadCarrier);
			DEBUG::TraceStepParamVariable(stepName, "loadCarrierBarcodeFileName", loadCarrierBarcodeFileName);
			DEBUG::TraceStepParamVariable(stepName, "barcodeReadPositions", barcodeReadPositions);
			DEBUG::TraceStepParamVariable(stepName, "recoveryOptionContinue", recoveryOptionContinue);
			DEBUG::TraceStepParamVariable(stepName, "recoveryOptionExclude", recoveryOptionExclude);
			DEBUG::TraceStepParamVariable(stepName, "recoveryOptionDefault", recoveryOptionDefault);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
         DEBUG::TraceStepParamVariable(stepName, "customStepID", customStepID);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif

		if (ErrorHandling::abort_ == errorHandling)
			rc = ML_STAR._54114402_7FA2_11D3_AD85_0004ACB1DCB2( "51fa936b_e34c_4bd6_9d7138bfa9130fd4" ); // LoadCarrier
		if (ErrorHandling::cancel == errorHandling)
			rc = ML_STAR._54114402_7FA2_11D3_AD85_0004ACB1DCB2( "40a190e8_8836_4b88_a25dc7672ab91bcd" ); // LoadCarrier
		if (ErrorHandling::continue == errorHandling)
		{
			if (1 == recoveryOptionContinue && 	// visible
				 1 == recoveryOptionExclude &&  	// visible
				 1 == recoveryOptionDefault)		// =exclude
			{
				rc = ML_STAR._54114402_7FA2_11D3_AD85_0004ACB1DCB2( "333c9a62_9cb5_4ad4_961d4cfe30b03222" ); // LoadCarrier
				return(rc);
			}
			if (1 == recoveryOptionContinue && 	// visible 
				 1 == recoveryOptionExclude && 	// visible 
				 0 == recoveryOptionDefault)		// =continue
			{
				rc = ML_STAR._54114402_7FA2_11D3_AD85_0004ACB1DCB2( "122a5c91_bfdd_453b_9f3f34f761651253" ); // LoadCarrier
				return(rc);
			}
			if (1 == recoveryOptionContinue &&  // visible
				 0 == recoveryOptionExclude &&  	// hidden
				 0 == recoveryOptionDefault)		// =continue
			{
				rc = ML_STAR._54114402_7FA2_11D3_AD85_0004ACB1DCB2( "7c9427b6_a944_4858_819a05b6cd9c37c2" ); // LoadCarrier
				return(rc);
			}
			if (0 == recoveryOptionContinue &&  // hidden
				 1 == recoveryOptionExclude &&  	// visible
				 1 == recoveryOptionDefault)		// =exclude
			{
				rc = ML_STAR._54114402_7FA2_11D3_AD85_0004ACB1DCB2( "aea4e3f3_64ce_47e4_8d2891ee2b0545f7" ); // LoadCarrier
				return(rc);
			}
		}
      if (ErrorHandling::custom == errorHandling)
      {
         TraceCustomStep("Load Carrier", customStepID);

         // call sub-method library function
         SMARTSTEPCUSTOMERRORHANDLING::LoadCarrier(ML_STAR, customStepID, loadCarrier, loadCarrierBarcodeFileName, barcodeReadPositions, userResponseTime, rc);
      }

		return(rc);
	}

	function StepLoadCarrierEx(
		device& ML_STAR,
		variable& loadCarrier,
		variable loadCarrierBarcodeFileName,
		variable barcodeReadPositions,
		variable recoveryOptionContinue,
		variable recoveryOptionExclude,
		variable recoveryOptionDefault,
		variable errorHandling,
		variable userResponseTime)
	{
		variable rc[];

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamVariable(stepName, "loadCarrier", loadCarrier);
			DEBUG::TraceStepParamVariable(stepName, "loadCarrierBarcodeFileName", loadCarrierBarcodeFileName);
			DEBUG::TraceStepParamVariable(stepName, "barcodeReadPositions", barcodeReadPositions);
			DEBUG::TraceStepParamVariable(stepName, "recoveryOptionContinue", recoveryOptionContinue);
			DEBUG::TraceStepParamVariable(stepName, "recoveryOptionExclude", recoveryOptionExclude);
			DEBUG::TraceStepParamVariable(stepName, "recoveryOptionDefault", recoveryOptionDefault);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif

      // 2016-08-08/ubernhard: Forward to StepLoadCarrierEx_cer only
      rc = StepLoadCarrierEx_cer(ML_STAR, loadCarrier, loadCarrierBarcodeFileName, barcodeReadPositions, recoveryOptionContinue,
		                           recoveryOptionExclude, recoveryOptionDefault, errorHandling, CustomStepID::default, userResponseTime);

		return(rc);
	}


	// Load Carrier step extension for special use with Load And Match
	function StepLoadCarrierEx2_cer(
		device& ML_STAR,
		variable& loadCarrier,
		variable loadCarrierBarcodeFileName,
		variable barcodeReadPositions,
		variable recoveryOptionContinue,
		variable recoveryOptionExclude,
		variable recoveryOptionDefault,
		variable errorHandling,
      variable customStepID,
		variable userResponseTime)
	{
		variable rc[];

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamVariable(stepName, "loadCarrier", loadCarrier);
			DEBUG::TraceStepParamVariable(stepName, "loadCarrierBarcodeFileName", loadCarrierBarcodeFileName);
			DEBUG::TraceStepParamVariable(stepName, "barcodeReadPositions", barcodeReadPositions);
			DEBUG::TraceStepParamVariable(stepName, "recoveryOptionContinue", recoveryOptionContinue);
			DEBUG::TraceStepParamVariable(stepName, "recoveryOptionExclude", recoveryOptionExclude);
			DEBUG::TraceStepParamVariable(stepName, "recoveryOptionDefault", recoveryOptionDefault);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
         DEBUG::TraceStepParamVariable(stepName, "customStepID", customStepID);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif

		if (ErrorHandling::abort_ == errorHandling)
			rc = ML_STAR._54114402_7FA2_11D3_AD85_0004ACB1DCB2( "4249db47_36e7_47b7_88fc7b4f89159bbe" ); // LoadCarrier
		if (ErrorHandling::cancel == errorHandling)
			rc = ML_STAR._54114402_7FA2_11D3_AD85_0004ACB1DCB2( "b08179f5_df3c_4acf_a05724bb17a18712" ); // LoadCarrier
		if (ErrorHandling::continue == errorHandling)
		{
			// Special error settings in StepLoadCarrierEx2
			// Error "No Labware Error" is recovered with 'exclude' immediately (timeout=0) and 'continue' is hidden.

			if (1 == recoveryOptionContinue && 	// visible 
				 1 == recoveryOptionExclude && 	// visible 
				 1 == recoveryOptionDefault)		// =exclude
			{
				rc = ML_STAR._54114402_7FA2_11D3_AD85_0004ACB1DCB2( "b0254f02_0e42_4d7d_9f07e3edceac61e1" ); // LoadCarrier
				return(rc);
			}
			if (1 == recoveryOptionContinue && 	// visible 
				 1 == recoveryOptionExclude && 	// visible 
				 0 == recoveryOptionDefault)		// =continue
			{
				rc = ML_STAR._54114402_7FA2_11D3_AD85_0004ACB1DCB2( "2fe8a1f8_4d65_4edb_8860b62e24440d2e" ); // LoadCarrier
				return(rc);
			}
			if (1 == recoveryOptionContinue && 	// visible 
				 0 == recoveryOptionExclude && 	// hidden  
				 0 == recoveryOptionDefault)		// =continue
			{
				rc = ML_STAR._54114402_7FA2_11D3_AD85_0004ACB1DCB2( "861d419c_ab6f_4d82_9e40ae1014b5e438" ); // LoadCarrier
				return(rc);
			}
			if (0 == recoveryOptionContinue && 	// hidden 
				 1 == recoveryOptionExclude && 	// visible 
				 1 == recoveryOptionDefault)		// =exclude
			{
				rc = ML_STAR._54114402_7FA2_11D3_AD85_0004ACB1DCB2( "4684ef2c_c114_4941_9e2766dfd5b4d9a4" ); // LoadCarrier
				return(rc);
			}
		}
      if (ErrorHandling::custom == errorHandling)
      {
         TraceCustomStep("Load Carrier", customStepID);

         // call sub-method library function
         SMARTSTEPCUSTOMERRORHANDLING::LoadCarrier(ML_STAR, customStepID, loadCarrier, loadCarrierBarcodeFileName, barcodeReadPositions, userResponseTime, rc);
      }

		return(rc);
	}


	// Load Carrier step extension for special use with Load And Match
	function StepLoadCarrierEx2(
		device& ML_STAR,
		variable& loadCarrier,
		variable loadCarrierBarcodeFileName,
		variable barcodeReadPositions,
		variable recoveryOptionContinue,
		variable recoveryOptionExclude,
		variable recoveryOptionDefault,
		variable errorHandling,
		variable userResponseTime)
	{
		variable rc[];

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamVariable(stepName, "loadCarrier", loadCarrier);
			DEBUG::TraceStepParamVariable(stepName, "loadCarrierBarcodeFileName", loadCarrierBarcodeFileName);
			DEBUG::TraceStepParamVariable(stepName, "barcodeReadPositions", barcodeReadPositions);
			DEBUG::TraceStepParamVariable(stepName, "recoveryOptionContinue", recoveryOptionContinue);
			DEBUG::TraceStepParamVariable(stepName, "recoveryOptionExclude", recoveryOptionExclude);
			DEBUG::TraceStepParamVariable(stepName, "recoveryOptionDefault", recoveryOptionDefault);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif

      // 2016-08-08/ubernhard: Forward to StepLoadCarrierEx2_cer only
      rc = 	StepLoadCarrierEx2_cer(ML_STAR, loadCarrier, loadCarrierBarcodeFileName, barcodeReadPositions, recoveryOptionContinue,
		                              recoveryOptionExclude, recoveryOptionDefault, errorHandling, CustomStepID::default, userResponseTime);

		return(rc);
	}


	function StepLoadCarrier(
		device& ML_STAR,
		variable& loadCarrier,
		variable loadCarrierBarcodeFileName,
		variable errorHandling,
		variable userResponseTime)
	{
		variable barcodeReadPositions("?");						// load carrier barcode read positions
		variable recoveryOptionContinue(hslTrue);				// visibility of recovery option Continue (0 = invisible, 1 = visible)
		variable recoveryOptionExclude(hslTrue);				// visibility of recovery option Continue (0 = invisible, 1 = visible)
		variable recoveryOptionDefault(0);						// default of recovery options Continue and Exclude (0 = Continue, 1 = Exclude) 

		return(StepLoadCarrierEx(	ML_STAR,
											loadCarrier,
											loadCarrierBarcodeFileName,
											barcodeReadPositions,
											recoveryOptionContinue,
											recoveryOptionExclude,
											recoveryOptionDefault,
											errorHandling,
											userResponseTime));
	}

	function StepUnloadCarrier_cer(
		device& ML_STAR,
		variable& unloadCarrier,
		variable errorHandling,
      variable customStepID,
		variable userResponseTime)
	{
		variable rc[];

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamVariable(stepName, "unloadCarrier", unloadCarrier);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
         DEBUG::TraceStepParamVariable(stepName, "customStepID", customStepID);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif

		if (ErrorHandling::abort_ == errorHandling)
			rc = ML_STAR._54114400_7FA2_11D3_AD85_0004ACB1DCB2( "7c957da4_e37b_4567_8b421aaeb8da4b99" ); // UnloadCarrier
		if (ErrorHandling::cancel == errorHandling)
			rc = ML_STAR._54114400_7FA2_11D3_AD85_0004ACB1DCB2( "109856e6_ecea_491c_94f89013d28128cf" ); // UnloadCarrier
		if (ErrorHandling::continue == errorHandling)
			rc = ML_STAR._54114400_7FA2_11D3_AD85_0004ACB1DCB2( "942fdf58_55c4_469c_8d20cc89a906c119" ); // UnloadCarrier
      if (ErrorHandling::custom == errorHandling)
      {
         TraceCustomStep("Unload Carrier", customStepID);
         
         // call sub-method library function
         SMARTSTEPCUSTOMERRORHANDLING::UnloadCarrier(ML_STAR, customStepID, unloadCarrier, userResponseTime, rc);
      }

		return(rc);
	}

	function StepUnloadCarrier(
		device& ML_STAR,
		variable& unloadCarrier,
		variable errorHandling,
		variable userResponseTime)
	{
		variable rc[];

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamVariable(stepName, "unloadCarrier", unloadCarrier);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif
   
      // 2016-08-08/ubernhard: Forward to StepUnloadCarrier_cer only
      rc = StepUnloadCarrier_cer(ML_STAR, unloadCarrier, errorHandling, CustomStepID::default, userResponseTime);

		return(rc);
	}

	function StepCalibrate1536Plate_cer(
		device& ML_STAR,
		variable& calibrateCarrier,
		variable calibrateCarrierChannel,
		variable errorHandling,
      variable customStepID,
		variable userResponseTime)
	{
		variable rc[];

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamVariable(stepName, "calibrateCarrier", calibrateCarrier);
			DEBUG::TraceStepParamVariable(stepName, "calibrateCarrierChannel", calibrateCarrierChannel);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
         DEBUG::TraceStepParamVariable(stepName, "customStepID", customStepID);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif

		if (ErrorHandling::abort_ == errorHandling)
			rc = ML_STAR._81DA4251_3BA9_11d4_AE21_0004ACB1DCB2( "b58fc08f_3e8a_4f01_8f612ec59f871425" ); // Calibrate1536Plate
		if (ErrorHandling::cancel == errorHandling)
			rc = ML_STAR._81DA4251_3BA9_11d4_AE21_0004ACB1DCB2( "c2a4a543_b657_4484_824b2e35b4386662" ); // Calibrate1536Plate
		if (ErrorHandling::continue == errorHandling)
			rc = ML_STAR._81DA4251_3BA9_11d4_AE21_0004ACB1DCB2( "b8732fdf_840a_47d8_9aa1ca8edf6a313c" ); // Calibrate1536Plate
      if (ErrorHandling::custom == errorHandling)
      {
         TraceCustomStep("Calibrate Carrier", customStepID);

         // call sub-method library function
         SMARTSTEPCUSTOMERRORHANDLING::Calibrate1536Plate(ML_STAR, customStepID, calibrateCarrier, calibrateCarrierChannel, userResponseTime, rc);
      }

		return(rc);
	}

	function StepCalibrate1536Plate(
		device& ML_STAR,
		variable& calibrateCarrier,
		variable calibrateCarrierChannel,
		variable errorHandling,
		variable userResponseTime)
	{
		variable rc[];

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamVariable(stepName, "calibrateCarrier", calibrateCarrier);
			DEBUG::TraceStepParamVariable(stepName, "calibrateCarrierChannel", calibrateCarrierChannel);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif

      // 2016-08-08/ubernhard: Forward to StepCalibrate1536Plate_cer only
      rc =  StepCalibrate1536Plate_cer(ML_STAR, calibrateCarrier, calibrateCarrierChannel, errorHandling,
                                       CustomStepID::default, userResponseTime);

		return(rc);
	}

	function StepWaitNeedleWashed_cer(
		device& ML_STAR,
		variable& washStation,
		variable errorHandling,
      variable customStepID,
		variable userResponseTime)
	{
		variable rc[];

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamVariable(stepName, "washStation", washStation);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
         DEBUG::TraceStepParamVariable(stepName, "customStepID", customStepID);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif

		if (ErrorHandling::abort_ == errorHandling)
			rc = ML_STAR._BCAAD4F5_0BD2_4d9c_8243_70DD893496CB( "5bef4e69_24df_4657_ba12c8d89d5a63da" ); // WaitNeedleWashed
		if (ErrorHandling::cancel == errorHandling)
			rc = ML_STAR._BCAAD4F5_0BD2_4d9c_8243_70DD893496CB( "7b76554d_f9f1_439d_82cfae27e7de15e9" ); // WaitNeedleWashed
		if (ErrorHandling::continue == errorHandling)
			rc = ML_STAR._BCAAD4F5_0BD2_4d9c_8243_70DD893496CB( "1f205970_6cc7_42f4_ad59587bc0995713" ); // WaitNeedleWashed
      if (ErrorHandling::custom == errorHandling)
      {
         TraceCustomStep("Wait Needle Wash", customStepID);
         
         // call sub-method library function
         SMARTSTEPCUSTOMERRORHANDLING::WaitNeedleWash(ML_STAR, customStepID, washStation, userResponseTime, rc);
      }

		return(rc);
	}

	function StepWaitNeedleWashed(
		device& ML_STAR,
		variable& washStation,
		variable errorHandling,
		variable userResponseTime)
	{
		variable rc[];

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamVariable(stepName, "washStation", washStation);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif

      // 2016-08-08/ubernhard: Forward to StepWaitNeedleWashed_cer only
      rc =  StepWaitNeedleWashed_cer(ML_STAR, washStation, errorHandling, CustomStepID::default, userResponseTime);

		return(rc);
	}

	function StepStartNeedleWash_cer(
		device& ML_STAR,
		variable& washStation,
		variable rinseTime1,
		variable soakTime1,
		variable flowRate1,
		variable rinseTime2,
		variable soakTime2,
		variable flowRate2,
		variable drainingTime,
		variable startWashLiquid,
		variable errorHandling,
      variable customStepID,
		variable userResponseTime)
	{
		variable rc[];

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamVariable(stepName, "washStation", washStation);
			DEBUG::TraceStepParamVariable(stepName, "rinseTime1", rinseTime1);
			DEBUG::TraceStepParamVariable(stepName, "soakTime1", soakTime1);
			DEBUG::TraceStepParamVariable(stepName, "flowRate1", flowRate1);
			DEBUG::TraceStepParamVariable(stepName, "rinseTime2", rinseTime2);
			DEBUG::TraceStepParamVariable(stepName, "soakTime2", soakTime2);
			DEBUG::TraceStepParamVariable(stepName, "flowRate2", flowRate2);
			DEBUG::TraceStepParamVariable(stepName, "drainingTime", drainingTime);
			DEBUG::TraceStepParamVariable(stepName, "startWashLiquid", startWashLiquid);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
         DEBUG::TraceStepParamVariable(stepName, "customStepID", customStepID);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif

		if (ErrorHandling::abort_ == errorHandling)
			rc = ML_STAR._C3B1B9A6_5B2F_4069_B9CB_68A675EC480D( "09b85c79_1970_4ffd_9967c2970b7cfe50" ); // StartNeedleWash
		if (ErrorHandling::cancel == errorHandling)
			rc = ML_STAR._C3B1B9A6_5B2F_4069_B9CB_68A675EC480D( "50f13c0d_d4c5_45d2_a4cf9de7e1f22b73" ); // StartNeedleWash
		if (ErrorHandling::continue == errorHandling)
			rc = ML_STAR._C3B1B9A6_5B2F_4069_B9CB_68A675EC480D( "215ff88b_bcab_43fc_adad659b825c2ef3" ); // StartNeedleWash
      if (ErrorHandling::custom == errorHandling)
      {
         TraceCustomStep("Start Needle Wash", customStepID);

         // call sub-method library function
         SMARTSTEPCUSTOMERRORHANDLING::StartNeedleWash(ML_STAR, customStepID, washStation, rinseTime1, soakTime1, flowRate1,
            rinseTime2, soakTime2, flowRate2, drainingTime, startWashLiquid, userResponseTime, rc);
      }

		return(rc);
	}

	function StepStartNeedleWash(
		device& ML_STAR,
		variable& washStation,
		variable rinseTime1,
		variable soakTime1,
		variable flowRate1,
		variable rinseTime2,
		variable soakTime2,
		variable flowRate2,
		variable drainingTime,
		variable startWashLiquid,
		variable errorHandling,
		variable userResponseTime)
	{
		variable rc[];

		#ifdef _DEBUG_STEPPARAMS
		{
			variable stepName;
			stepName = GetFunctionName();
			DEBUG::TraceStepParamDevice(stepName, "device", ML_STAR);
			DEBUG::TraceStepParamVariable(stepName, "washStation", washStation);
			DEBUG::TraceStepParamVariable(stepName, "rinseTime1", rinseTime1);
			DEBUG::TraceStepParamVariable(stepName, "soakTime1", soakTime1);
			DEBUG::TraceStepParamVariable(stepName, "flowRate1", flowRate1);
			DEBUG::TraceStepParamVariable(stepName, "rinseTime2", rinseTime2);
			DEBUG::TraceStepParamVariable(stepName, "soakTime2", soakTime2);
			DEBUG::TraceStepParamVariable(stepName, "flowRate2", flowRate2);
			DEBUG::TraceStepParamVariable(stepName, "drainingTime", drainingTime);
			DEBUG::TraceStepParamVariable(stepName, "startWashLiquid", startWashLiquid);
			DEBUG::TraceStepParamVariable(stepName, "errorHandling", errorHandling);
			DEBUG::TraceStepParamVariable(stepName, "userResponseTime", userResponseTime);
		}
		#endif

      // 2016-08-08/ubernhard: Forward to StepStartNeedleWash_cer only
      rc =  StepStartNeedleWash_cer(ML_STAR, washStation, rinseTime1, soakTime1, flowRate1,
   	                                 rinseTime2, soakTime2, flowRate2, drainingTime, startWashLiquid,
		                                 errorHandling, CustomStepID::default, userResponseTime);

		return(rc);
	}

	function StepFirmwareCommand(
		device& ML_STAR,
		variable& commandString,
		variable& parameterString,
		variable& returnValues[]) void
	{
		returnValues.SetSize(0);
		returnValues = ML_STAR._1FB5DA01_3ACB_11d4_AE1F_0004ACB1DCB2( "3b96af1f_dd44_4c8c_8eb9fa4e2c9963e6" ); // FirmwareCommand
	}
}
#endif
#endif
// $$author=wbarmettler$$valid=1$$time=2017-03-14 13:14$$checksum=d4e8f906$$length=090$$