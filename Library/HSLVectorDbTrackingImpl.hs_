// This is a part of the Vector Database Tracking Library.
// Copyright (C) by HAMILTON Bonaduz AG, CH-7402 Bonaduz.
// All rights reserved.
//
// Modification History
// 2006-05-11  bandenmatten : Initial file creation.
// 2006-06-20  bandenmatten : Added function GetDeckID2.
// 2006-09-15  bandenmatten : Renamed LabwareID to ElementID (labwareID to elementID).
// 2006-09-20  bandenmatten : Added static function TrackingEnabled().
// 2006-10-03  ubernhard	 : - Splitted interface function into new defined namespaces
//										- Added several new functions
// 2006-11-24  bandenmatten : Function InitTrackingLibrary() initialized some constants that have not been declared as global once only, 
//										so that they didn't have the expected value when they have been reset to their original value for 
//										the second and following tasks. Fixed this bug (//>> 20061124).
// 2006-05-23  mhosang      : added new functions
//                            - IsLabwareLoadedByLabwareIdPositionId()
//									   - IsBarcodeLoadedEx()
// 2006-05-24  mhosang      : switched the global tracking object vectorDb_TrackingObj to interface IHxVectorDbTracking2
// 2007-08-17  ubernhard	 : added new function
//                            - StartExperimentTrackingByElementIDs()
// 2007-09-27  ubernhard	 : added new functions
//                            - AddExperimentSourceLabware(), GetExperimentSourceLabwareEx(),
//										  CheckBarcode(), CheckBarcodeEx() and LoadLabware()
// 2007-10-17  mhosang      : replaced functions CheckBarcode() & CheckBarcodeEx() with function
//                            CheckBarcodeByLabwareIdPositionId()
// 2010-06-07  mhosang      : fixed function CustomAction()
//                            parameter actionState has not been used when filling the ActionPars
//


#ifndef __HSLVectorDbTrackingImpl_hs___
#define __HSLVectorDbTrackingImpl_hs___	1

// ----------------------------------------------------------------------------------------------------
// Includes
// ----------------------------------------------------------------------------------------------------

#ifndef __HSLStrLib_hsl__
	#include "HSLStrLib.hsl"
#endif

#ifndef __HSLUtilLib_hsl__
	#include "HSLUtilLib.hsl"
#endif

#ifndef __HSLUtilLib2_hsl__
	#include "HSLUtilLib2.hsl"
#endif

#ifndef __HSLUtilLib2Def_hs___
	#include "HSLUtilLib2Def.hs_"
#endif

#ifndef  __HSLSynLib_hsl__
	#include "HSLSynLib.hsl"
#endif

#include "HSLVectorDb.hs_"
#include "HSLVectorDbTrackingDefs.hs_"

// Implementation of the Vector Database Tracking Library

// --------------------------------------------------------------------------------------
// Debugging
// --------------------------------------------------------------------------------------

//#define DEBUG_VECTOR_DB_FUNC			1											// Debug function start-end
//#define DEBUG_VECTOR_DB_PARAM			1											// Debug function params
//#define DEBUG_VECTOR_DB_CORE			1											// Debug function core

// ----------------------------------------------------------------------------------------------------
// Traceing
// ----------------------------------------------------------------------------------------------------

namespace VdbTraceStatus
{
	static const variable start(1);								// Action status for formated trace
	static const variable complete(2);							// Action status for formated trace
	static const variable error_(3);								// Action status for formated trace
	static const variable progress(4);							// Action status for formated trace
	static const variable completeWithError(5);				// Action status for formated trace
}

// ----------------------------------------------------------------------------------------------------
// Data 
// ----------------------------------------------------------------------------------------------------

static global object vectorDb_TrackingObj;									// Tracking object (= IHxVectorDbTracking2)
static global object vectorDb_TrackingScriptControl;						// Script Control, used to evaluate VBScript expressions
static global variable vectorDb_TrackingCS(0);								// Critical section
static global variable vectorDb_TrackingEnabled(hslFalse);				// True if Tracking is enabled

// ----------------------------------------------------------------------------------------------------
// Constants
// ----------------------------------------------------------------------------------------------------

namespace VdbTrackingConstants
{
	static const variable crlf("\013\010");																			// Carriage return linefeed combination
	static const variable helpFileShortName("HSLVectorDbTracking");											// Help file short name
	static const variable helpFileExtension(".chm");																// Help file extension
	static const variable traceSource("SYSTEM");																		// Trace source
	static const variable templateDefaultName("default");															// template default name
	static const variable backslash("\\");
	
	// VectorDb_Deck
	static const variable traceActionGetDeckID("HSLVectorDbTracking > Deck::GetDeckID");
	static const variable traceActionGetDeckID2("HSLVectorDbTracking > Deck::GetDeckID2");

	// VectorDb_Run
	static const variable traceActionGetRunID("HSLVectorDbTracking > Run::GetRunID");
	static const variable traceActionGetRuns("HSLVectorDbTracking > Run::GetRuns");

	// VectorDb_Labware
	static const variable traceActionGetAllLabwareOnDeck("HSLVectorDbTracking > Labware::GetAllLabwareOnDeck");
	static const variable traceActionLoadLabware("HSLVectorDbTracking > Labware::LoadLabware");
	static const variable traceActionIsLabwareLoaded("HSLVectorDbTracking > Labware::IsLabwareLoaded");
	static const variable traceActionIsLabwareLoadedByLabwareId("HSLVectorDbTracking > Labware::IsLabwareLoadedByLabwareId");
	static const variable traceActionIsLabwareLoadedByLabwareIdPositionId("HSLVectorDbTracking > Labware::IsLabwareLoadedByLabwareIdPositionId");
	static const variable traceActionIsBarcodeLoaded("HSLVectorDbTracking > Labware::IsBarcodeLoaded");
	static const variable traceActionIsBarcodeLoadedEx("HSLVectorDbTracking > Labware::IsBarcodeLoadedEx");
	static const variable traceActionCheckBarcodeByLabwareIdPositionId("HSLVectorDbTracking > Labware::CheckBarcodeByLabwareIdPositionId");
	static const variable traceActionGetElementID("HSLVectorDbTracking > Labware::GetElementID");
	static const variable traceActionGetElementIDByDeckIDLabwareId("HSLVectorDbTracking > Labware::GetElementIDByDeckIDLabwareId");
	static const variable traceActionGetLabwareLoadingTime("HSLVectorDbTracking > Labware::GetLabwareLoadingTime");
	static const variable traceActionGetLabwareLoadingTimeByElementID("HSLVectorDbTracking > Labware::GetLabwareLoadingTimeByElementID");
	static const variable traceActionAssignLabwareToJob("HSLVectorDbTracking > Labware::VdbUtil::AssignLabwareToJob");
	static const variable traceActionAssignLoadedLabwareToJobs("HSLVectorDbTracking > Labware::AssignLoadedLabwareToJobs");
	static const variable traceActionGetLabware("HSLVectorDbTracking > Labware::GetLabware");
	static const variable traceActionGetLabwareByElementID("HSLVectorDbTracking > Labware::GetLabwareByElementID");
	static const variable traceActionGetLabwareBarcode("HSLVectorDbTracking > Labware::GetLabwareBarcode");
	static const variable traceActionGetLabwareBarcodeByElementID("HSLVectorDbTracking > Labware::GetLabwareBarcodeByElementID");
	static const variable traceActionGetLabwareVolume("HSLVectorDbTracking > Labware::GetLabwareVolume");
	static const variable traceActionGetLabwareVolumeByElementID("HSLVectorDbTracking > Labware::GetLabwareVolumeByElementID");
	static const variable traceActionGetAllChildLabware("HSLVectorDbTracking > Labware::GetAllChildLabware");
	static const variable traceActionGetLabwareOfLastLoadAction("HSLVectorDbTracking > Labware::GetLabwareOfLastLoadAction");
	static const variable traceActionGetElementIDByCurrentPositionOfSequence("HSLVectorDbTracking > Labware::GetElementIDByCurrentPositionOfSequence");	
	static const variable traceActionGetLabwareHierarchyByCurrentPositionOfSequence("HSLVectorDbTracking > Labware::GetLabwareHierarchyByCurrentPositionOfSequence");	
	static const variable traceActionGetElementIDsOfSequencePositions("HSLVectorDbTracking > Labware::GetElementIDsOfSequencePositions");	
	static const variable traceActionGetLabwareAccessName("HSLVectorDbTracking > Labware::GetLabwareAccessName");	
	static const variable traceActionCreateSequenceForRacks("HSLVectorDbTracking > Labware::CreateSequenceForRacks");
	static const variable traceActionGetLabwareOfRun("HSLVectorDbTracking > Labware::GetLabwareOfRun");
	static const variable traceActionReloadLabware("HSLVectorDbTracking > Labware::ReloadLabware");
	static const variable traceActionAddLabwareAdditionalData("HSLVectorDbTracking > Labware::AddLabwareAdditionalData");
	static const variable traceActionGetLabwareAdditionalData("HSLVectorDbTracking > Labware::GetLabwareAdditionalData");
	static const variable traceActionGetLabwareAdditionalDataByKey("HSLVectorDbTracking > Labware::GetLabwareAdditionalDataByKey");
	static const variable traceActionDeleteLabwareAdditionalData("HSLVectorDbTracking > Labware::DeleteLabwareAdditionalData");

	// VectorDb_LabwareType
	static const variable traceActionCreateSequenceForLabwareTypes("HSLVectorDbTracking > LabwareType::CreateSequenceForLabwareTypes");
	static const variable traceActionSetLabwareType("HSLVectorDbTracking > LabwareType::SetLabwareType");
	static const variable traceActionSetLabwareTypeByElementID("HSLVectorDbTracking > LabwareType::SetLabwareTypeByElementID");
	static const variable traceActionSetLabwareTypeID("HSLVectorDbTracking > LabwareType::SetLabwareTypeID");
	static const variable traceActionSetLabwareTypeIDByElementID("HSLVectorDbTracking > LabwareType::SetLabwareTypeIDByElementID");
	static const variable traceActionGetLabwareTypeID("HSLVectorDbTracking > LabwareType::GetLabwareTypeID");
	static const variable traceActionGetLabwareTypeIDByElementID("HSLVectorDbTracking > LabwareType::GetLabwareTypeIDByElementID");
	static const variable traceActionGetLabwareTypeIDByTypeName("HSLVectorDbTracking > LabwareType::GetLabwareTypeIDByTypeName");
	static const variable traceActionGetLabwareMainTypeIDByTypeName("HSLVectorDbTracking > LabwareType::GetLabwareMainTypeIDByTypeName");
	static const variable traceActionGetLabwareMainTypes("HSLVectorDbTracking > LabwareType::GetLabwareMainTypes");
	static const variable traceActionGetLabwareTypesOfMainType("HSLVectorDbTracking > LabwareType::GetLabwareTypesOfMainType");
	static const variable traceActionGetLabwareTypesOfMainTypeByMainTypeID("HSLVectorDbTracking > LabwareType::CreateSequenceForLabwareTypes");
	static const variable traceActionDeleteLabwareMainType("HSLVectorDbTracking > LabwareType::DeleteLabwareMainType");
	static const variable traceActionDeleteLabwareMainTypeByMainTypeID("HSLVectorDbTracking > LabwareType::DeleteLabwareMainTypeByMainTypeID");
	static const variable traceActionDeleteLabwareType("HSLVectorDbTracking > LabwareType::DeleteLabwareType");
	static const variable traceActionDeleteLabwareTypeByTypeID("HSLVectorDbTracking > LabwareType::DeleteLabwareTypeByTypeID");
	static const variable traceActionGetLoadedLabwareByLabwareTypeID("HSLVectorDbTracking > LabwareType::GetLoadedLabwareByLabwareTypeID");
	static const variable traceActionGetLoadedChildrenLabwareByLabwareTypeID("HSLVectorDbTracking > LabwareType::GetLoadedChildrenLabwareByLabwareTypeID");

	// VectorDb_Experiment
	static const variable traceActionStartExperimentTracking("HSLVectorDbTracking > Experiment::StartExperimentTracking");
	static const variable traceActionStartExperimentTrackingByElementID("HSLVectorDbTracking > Experiment::StartExperimentTrackingByElementID");
	static const variable traceActionStartExperimentTrackingByElementIDs("HSLVectorDbTracking > Experiment::StartExperimentTrackingByElementIDs");
	static const variable traceActionGetAllExperiments("HSLVectorDbTracking > Experiment::GetAllExperiments");
	static const variable traceActionGetExperimentSourceLabware("HSLVectorDbTracking > Experiment::GetExperimentSourceLabware");
	static const variable traceActionGetExperimentSourceLabwareEx("HSLVectorDbTracking > Experiment::GetExperimentSourceLabwareEx");
	static const variable traceActionGetAllExperimentLabware("HSLVectorDbTracking > Experiment::GetAllExperimentLabware");
	static const variable traceActionGetExperiment("HSLVectorDbTracking > Experiment::GetExperiment");
	static const variable traceActionAddExperimentLabware("HSLVectorDbTracking > Experiment::AddExperimentLabware");
	static const variable traceActionAddExperimentSourceLabware("HSLVectorDbTracking > Experiment::AddExperimentSourceLabware");
	static const variable traceActionDeleteExperiment("HSLVectorDbTracking > Experiment::DeleteExperiment");
	static const variable traceActionRemoveExperimentLabware("HSLVectorDbTracking > Experiment::RemoveExperimentLabware");

	// VectorDb_TrackAction
	static const variable traceActionCustomAction("HSLVectorDbTracking > TrackAction::CustomAction");
	static const variable traceActionAddActionAdditionalData("HSLVectorDbTracking > TrackAction::AddActionAdditionalData");
	static const variable traceActionGetActionAdditionalData("HSLVectorDbTracking > TrackAction::GetActionAdditionalData");
	static const variable traceActionGetActionAdditionalDataByKey("HSLVectorDbTracking > TrackAction::GetActionAdditionalDataByKey");
	static const variable traceActionDeleteActionAdditionalData("HSLVectorDbTracking > TrackAction::DeleteActionAdditionalData");
}

// ----------------------------------------------------------------------------------------------------
// Translated strings
// ----------------------------------------------------------------------------------------------------

namespace VdbTrackingTrStr
{
}

// ----------------------------------------------------------------------------------------------------
// Error handling
// ----------------------------------------------------------------------------------------------------

namespace VdbTrackingError
{
	static const variable majorID(0x61);						// Major error id

	namespace MinorID													// Minor error ids
	{
		static const variable generalRuntimeError(0x0B);
		//static const variable ....(0x1F)
	}

	namespace ErrorCode												// Error codes
	{
		static const variable unexpected                   (0x0001);
		static const variable invalidParameter        		(0x0002);
		static const variable trackingDisabled					(0x0003);
		static const variable emptySequence						(0x0004);
		static const variable unknownLabwareId					(0x0005);
		static const variable unknownPositionId				(0x0006);
		//static const variable ....(0xFFFF)					// If a new ErrorCode is added, function VdbTrackingError::MakeErrorDescription() has to be updated
	}

	namespace TrStr													// Translated error strings
	{
		static const variable unexpected							(Translate("Unexpected error."));
		static const variable invalidParameter					(Translate("The parameter is invalid:"));
		static const variable trackingDisabled					(Translate("The Vector Database sample tracking is disabled."));
		static const variable emptySequence						(Translate("The given sequence has no more position left."));
		static const variable unknownLabwareId					(Translate("The Labware identifier '%s1' is unknown on instrument '%s2'."));
		static const variable unknownPositionId				(Translate("The Position identifier '%s1' for labware '%s2' is unknown."));
		static const variable noErrorTextAvailable			(Translate("No error description available."));
	}

	// ----------------------------------------------------------------------------------------------------
	// Error functions
	// ----------------------------------------------------------------------------------------------------

	static function MakeErrorDescription(
		variable errorCode,
		variable& additionalDescription) variable
	{
		variable description("");
		variable errorNumber(0);

		if (ErrorCode::unexpected == errorCode)
			description = TrStr::unexpected;
		else if (ErrorCode::invalidParameter == errorCode)
			description = TrStr::invalidParameter;
		else if (ErrorCode::trackingDisabled == errorCode)
			description = TrStr::trackingDisabled;
		else if (ErrorCode::emptySequence == errorCode)
			description = TrStr::emptySequence;
		else if (ErrorCode::unknownLabwareId == errorCode)
			description = TrStr::unknownLabwareId;
		else if (ErrorCode::unknownPositionId == errorCode)
			description = TrStr::unknownPositionId;
		//...
		//... 
		//...
		//...
		else
		{
			description = TrStr::noErrorTextAvailable;
		}

		// Generate the full description
		if (additionalDescription != "")
		{
			description = description + "\n\n" + additionalDescription;
		}
		return(description);
	}
}

namespace VdbUtil
{
	// ----------------------------------------------------------------------------------------------------
	// Utility functions
	// ----------------------------------------------------------------------------------------------------

	static function GetTrackingHelpFileName() variable	// Builds the library help file name
	{
		return(VdbTrackingConstants::helpFileShortName + GetLanguage() + VdbTrackingConstants::helpFileExtension);
	}

	static global function VectorDb_InitTrackingCS() void
	{
		if (0 == vectorDb_TrackingCS)
		{
			vectorDb_TrackingCS = SynInitializeCriticalSection();
			if (0 == vectorDb_TrackingCS)
			{
				Util2::Error::RaiseRuntimeError(VdbTrackingError::majorID, VdbTrackingError::MinorID::generalRuntimeError, VdbTrackingError::ErrorCode::unexpected,
												VdbTrackingError::MakeErrorDescription(VdbTrackingError::ErrorCode::unexpected, ""), 
												GetTrackingHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
			}

			#ifdef DEBUG_VECTOR_DB_CORE
			FormatTrace("DEBUG", GetFunctionName(), VdbTraceStatus::progress, "Initialized critical section object, id = ", vectorDb_TrackingCS);
			#endif
		}
	}

	static function InitTrackingLibrary() void			// Library initialization function
	{
		// Initialize critical section object 
		VectorDb_InitTrackingCS();

		// Activate error handler
		onerror goto Unexpected;

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		if (vectorDb_TrackingObj.IsNull())
		{
			object tmpTrackerObject;
			// Get Tracking object (= IHxVectorDbTracking2)
			tmpTrackerObject = GetVectorDbTrackerObject(); // returns IHxVectorDbTracking interface
			tmpTrackerObject.GetObject("IHxVectorDbTracking2", vectorDb_TrackingObj); // switch to IHxVectorDbTracking2 interface
			tmpTrackerObject.ReleaseObject(); // release the temporary object

			#ifdef DEBUG_VECTOR_DB_CORE
			FormatTrace("DEBUG", GetFunctionName(), VdbTraceStatus::progress, "Created Tracking object, id = ", vectorDb_TrackingObj);
			#endif

			// check if Tracking is enabled
			vectorDb_TrackingEnabled = vectorDb_TrackingObj.Enabled();

			#ifdef DEBUG_VECTOR_DB_CORE
			FormatTrace("DEBUG", GetFunctionName(), VdbTraceStatus::progress, "Vector Database state, State = ", vectorDb_TrackingEnabled);
			#endif
		//>> 20061124
		}
		//<< 20061124

		// Initialize Tracking constants exported via HSLVectorDbTrackingDefs.hs_
		VectorDb_LabwareLevel::Undefined = vectorDb_TrackingObj.HxVectorDbLabwareLevel_Undefined;
		VectorDb_LabwareLevel::Deck = vectorDb_TrackingObj.HxVectorDbLabwareLevel_Deck;
		VectorDb_LabwareLevel::Template = vectorDb_TrackingObj.HxVectorDbLabwareLevel_Template;
		VectorDb_LabwareLevel::Rack = vectorDb_TrackingObj.HxVectorDbLabwareLevel_Rack;
		VectorDb_LabwareLevel::Well = vectorDb_TrackingObj.HxVectorDbLabwareLevel_Well;
		VectorDb_LabwareLevel::TipRack = vectorDb_TrackingObj.HxVectorDbLabwareLevel_TipRack;
		VectorDb_LabwareLevel::TipWell = vectorDb_TrackingObj.HxVectorDbLabwareLevel_TipWell;
		VectorDb_LabwareLevel::WashRack = vectorDb_TrackingObj.HxVectorDbLabwareLevel_WashRack;
		VectorDb_LabwareLevel::WashWell = vectorDb_TrackingObj.HxVectorDbLabwareLevel_WashWell;
		VectorDb_LabwareLevel::WasteRack = vectorDb_TrackingObj.HxVectorDbLabwareLevel_WasteRack;
		VectorDb_LabwareLevel::WasteWell = vectorDb_TrackingObj.HxVectorDbLabwareLevel_WasteWell;
		VectorDb_LabwareLevel::ConnectedContainerRack = vectorDb_TrackingObj.HxVectorDbLabwareLevel_ConnectedContainerRack;
		VectorDb_LabwareLevel::ConnectedContainerWell = vectorDb_TrackingObj.HxVectorDbLabwareLevel_ConnectedContainerWell;			
		VectorDb_LabwareLevel::_AllRacks = vectorDb_TrackingObj.HxVectorDbLabwareLevel__AllRacks;
		VectorDb_LabwareLevel::_AllWells = vectorDb_TrackingObj.HxVectorDbLabwareLevel__AllWells;
		VectorDb_LabwareLevel::_All = vectorDb_TrackingObj.HxVectorDbLabwareLevel__All;

		VectorDb_LabwareState::NoError = vectorDb_TrackingObj.HxVectorDbLabwareState_NoError;
		VectorDb_LabwareState::Error = vectorDb_TrackingObj.HxVectorDbLabwareState_Error;
		VectorDb_LabwareState::Warning = vectorDb_TrackingObj.HxVectorDbLabwareState_Warning;
		VectorDb_LabwareState::NotUsed = vectorDb_TrackingObj.HxVectorDbLabwareState_NotUsed;

		VectorDb_ActionState::NoError = vectorDb_TrackingObj.HxVectorDbActionState_NoError;
		VectorDb_ActionState::Fatal = vectorDb_TrackingObj.HxVectorDbActionState_Fatal;
		VectorDb_ActionState::Error = vectorDb_TrackingObj.HxVectorDbActionState_Error;
		VectorDb_ActionState::Warning = vectorDb_TrackingObj.HxVectorDbActionState_Warning;

		VectorDb_RunState::Undefined = vectorDb_TrackingObj.HxVectorDbRunState_Undefined;
		VectorDb_RunState::Running = vectorDb_TrackingObj.HxVectorDbRunState_Running;
		VectorDb_RunState::Paused = vectorDb_TrackingObj.HxVectorDbRunState_Paused;
		VectorDb_RunState::Aborted = vectorDb_TrackingObj.HxVectorDbRunState_Aborted;
		VectorDb_RunState::Finished = vectorDb_TrackingObj.HxVectorDbRunState_Finished;
		VectorDb_RunState::_Filter_Running = vectorDb_TrackingObj.HxVectorDbRunState__Filter_Running;
		VectorDb_RunState::_Filter_Finished = vectorDb_TrackingObj.HxVectorDbRunState__Filter_Finished;

		VectorDb_ValueType::String = vectorDb_TrackingObj.HxVectorDbValueType_String;
 		VectorDb_ValueType::Integer = vectorDb_TrackingObj.HxVectorDbValueType_Integer;
 		VectorDb_ValueType::Float = vectorDb_TrackingObj.HxVectorDbValueType_Float;

		VectorDb_SequenceSortingCriteria::None = vectorDb_TrackingObj.HxVectorDbSequenceSortingCriteria_None;
		VectorDb_SequenceSortingCriteria::XAscending_YAscending = vectorDb_TrackingObj.HxVectorDbSequenceSortingCriteria_XAscending_YAscending;
		VectorDb_SequenceSortingCriteria::XAscending_YDescending = vectorDb_TrackingObj.HxVectorDbSequenceSortingCriteria_XAscending_YDescending;
		VectorDb_SequenceSortingCriteria::XDescending_YAscending = vectorDb_TrackingObj.HxVectorDbSequenceSortingCriteria_XDescending_YAscending;
		VectorDb_SequenceSortingCriteria::XDescending_YDescending = vectorDb_TrackingObj.HxVectorDbSequenceSortingCriteria_XDescending_YDescending;
		VectorDb_SequenceSortingCriteria::YAscending_XAscending = vectorDb_TrackingObj.HxVectorDbSequenceSortingCriteria_YAscending_XAscending;
		VectorDb_SequenceSortingCriteria::YAscending_XDescending = vectorDb_TrackingObj.HxVectorDbSequenceSortingCriteria_YAscending_XDescending;
		VectorDb_SequenceSortingCriteria::YDescending_XAscending = vectorDb_TrackingObj.HxVectorDbSequenceSortingCriteria_YDescending_XAscending;
		VectorDb_SequenceSortingCriteria::YDescending_XDescending = vectorDb_TrackingObj.HxVectorDbSequenceSortingCriteria_YDescending_XDescending;
		//>> 20061124
		//}
		//<< 20061124

		// Check whether Vector Database is enabled.
		if (!vectorDb_TrackingEnabled)
		{
			Util2::Error::RaiseRuntimeError(VdbTrackingError::majorID,
											VdbTrackingError::MinorID::generalRuntimeError,
											VdbTrackingError::ErrorCode::trackingDisabled,
											VdbTrackingError::MakeErrorDescription(VdbTrackingError::ErrorCode::trackingDisabled, ""), 
											GetTrackingHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
		}

		if (vectorDb_TrackingScriptControl.IsNull())
		{
			// Create Script Control
			vectorDb_TrackingScriptControl.CreateObject("MSScriptControl.ScriptControl");
			vectorDb_TrackingScriptControl.Language = "VBScript";
		}

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return;

		Unexpected:
		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 

	static function FormatDateTime(variable date, variable namedFormat) variable
	{
		variable precision(20);

		return(vectorDb_TrackingScriptControl.Eval("FormatDateTime(" + FStr(date, hslFalse, precision) + ", " + IStr(namedFormat) + ")"));
	}

	static function DumpParsPackage(object& pars) void
	{
		variable i(0);
		variable keys[];
		variable values[];
		object scriptControl;
	
		scriptControl.CreateObject("MSScriptControl.ScriptControl");
		scriptControl.Language = "VBScript";
		scriptControl.AddObject("pars", pars);
		scriptControl.AddCode
		("																			\n\
			Function GetValues()												\n\
				Dim counter			 				 							\n\
				Dim values							 							\n\
				values = pars.GetValues()									\n\
				For counter = 0 To UBound(values)						\n\
					If IsObject(values(counter)) Then					\n\
						values(counter) = TypeName(values(counter))	\n\
					End If														\n\
				Next												 				\n\
				GetValues = values											\n\
			End Function														\n\
		");
		keys = pars.GetKeys();
		values = scriptControl.Eval("GetValues");
		for (i = 0; i < values.GetSize(); i++)
		{
			Trace("keys[", i, "] = ", keys.ElementAt(i), ", values[", i, "] = ", values.ElementAt(i));
		}
	}
}

// ----------------------------------------------------------------------------------------------------
// Interface functions
// ----------------------------------------------------------------------------------------------------

//*****************************************************************************************************************
namespace VectorDb_Deck
//*****************************************************************************************************************
{
	static function GetDeckID(
		variable& instrumentName) variable				// [in]
	{
		variable errorDesc("");								// Error description
		variable deckID(0);									// Deck ID

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetDeckID, VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetDeckID, VdbTraceStatus::progress,
						"instrumentName = ", instrumentName);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetDeckID + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(instrumentName, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
												errorDesc + "instrumentName");

		// Get DeckID
		deckID = vectorDb_TrackingObj.GetDeckID(instrumentName);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetDeckID, VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(deckID);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetDeckID, 
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 

	static function GetDeckID2(
		device& instrument) variable						// [in]
	{
		variable errorDesc("");								// Error description
		variable deckID(0);									// Deck ID

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetDeckID2, VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetDeckID2, VdbTraceStatus::progress,
						"instrument = ", instrument.GetInstrumentName());
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid

		// Get DeckID
		deckID = vectorDb_TrackingObj.GetDeckID(instrument.GetInstrumentName());

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetDeckID2, VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(deckID);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetDeckID2, 
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 
}

//*****************************************************************************************************************
namespace VectorDb_Run
//*****************************************************************************************************************
{
	function GetRunID() variable
	{
		variable runID(0);									// Run ID

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetRunID, VdbTraceStatus::start);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Get run ID
		runID = vectorDb_TrackingObj.GetRunID(GetUniqueRunId());

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetRunID, VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(runID);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetRunID,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 

	function GetRuns(
		variable& runIDs[],									// [in/out] Array to retrieve run ID's (integer)
		variable& methodNames[],							// [in/out] Array to retrieve method names (string)
		variable& runGUIDs[],								// [in/out] Array to retrieve run GUID's (string)
		variable& startTimes[],								// [in/out] Array to retrieve start times (float if namedFormat = VectorDb_DateTimeFormat::Unformatted, otherwise string)
		variable& endTimes[],								// [in/out] Array to retrieve end times (float if namedFormat = VectorDb_DateTimeFormat::Unformatted, otherwise string)
		variable& runStates[],								// [in/out] Array to retrieve run states (integer)
		variable namedFormat) variable					// [in]: Numeric value that indicates the date/time format used (integer, one of VectorDb_DateTimeFormat).
	{
		variable nbrOfRuns(0);
		variable errorDesc("");								// Error description

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetRuns, VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetRuns, VdbTraceStatus::progress,
						"namedFormat = ", namedFormat);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetRuns + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRangeMinMax(namedFormat, hslInteger, VectorDb_DateTimeFormat::Unformatted, 
														VectorDb_DateTimeFormat::ShortTime, errorDesc + "namedFormat");

		// Get run ID
		nbrOfRuns = vectorDb_TrackingObj.GetRuns(runIDs, methodNames, runGUIDs, startTimes, endTimes, runStates);

		if (VectorDb_DateTimeFormat::Unformatted != namedFormat)
		{
			variable index;
			variable formattedDateTime;
			
			for(index = 0; index < startTimes.GetSize(); index++)
			{
				formattedDateTime = VdbUtil::FormatDateTime(startTimes.GetAt(index), namedFormat);
				startTimes.SetAt(index, formattedDateTime);
				formattedDateTime = VdbUtil::FormatDateTime(endTimes.GetAt(index), namedFormat);
				endTimes.SetAt(index, formattedDateTime);
			}
		}

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetRuns, VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(nbrOfRuns);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetRuns,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}
}

//*****************************************************************************************************************
namespace VectorDb_Labware
//*****************************************************************************************************************
{
	static function GetAllLabwareOnDeck(
		variable deckID,										// [in]
		variable labwareLevel,								// [in]
		variable& elementIDs[],								// [in/out]
		variable& parentElementIDs[],						// [in/out]
		variable& labwareLevels[],							// [in/out]
		variable& labwareNames[],							// [in/out]
		variable& labwareBarcodes[]) variable			// [in/out]
	{
		variable errorDesc("");								// Error description
		variable numberOfLabware(0);						// Number of labware

		variable _elementIDs[];
		variable _parentElementIDs[];
		variable _labwareLevels[];
		variable _labwareNames[];
		variable _barcodes[];

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetAllLabwareOnDeck, VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetAllLabwareOnDeck, 
						VdbTraceStatus::progress, "deckID = ", deckID);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetAllLabwareOnDeck,
						VdbTraceStatus::progress, "labwareLevel = ", labwareLevel);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetAllLabwareOnDeck + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(deckID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
							errorDesc + "deckID");
		Util2::CheckValueTypeAndRangeMinMax(labwareLevel, hslInteger, 
							VectorDb_LabwareLevel::Undefined, VectorDb_LabwareLevel::_All, errorDesc + "labwareLevel");
		
		// Get all labware on deck
		numberOfLabware = vectorDb_TrackingObj.GetAllLabwareOnDeck_OutParams( 
												deckID, _elementIDs, _parentElementIDs, _labwareLevels, _labwareNames, _barcodes );

		elementIDs.SetSize(0);
		parentElementIDs.SetSize(0);
		labwareLevels.SetSize(0);
		labwareNames.SetSize(0);
		labwareBarcodes.SetSize(0);

		if(numberOfLabware > 0) 
		{
			if( labwareLevel == VectorDb_LabwareLevel::_All )
			{
				elementIDs = _elementIDs;
				parentElementIDs = _parentElementIDs;
				labwareLevels = _labwareLevels;
				labwareNames = _labwareNames;
				labwareBarcodes = _barcodes;
			}
			else
			{
				variable index(0);
		
				// filter labware depending given parent Level	
				for( index = 0; index < _parentElementIDs.GetSize(); index++ )
				{
					// find level
					if( _labwareLevels.GetAt(index) == labwareLevel ) //(labwareLevel & _labwareLevels.GetAt(index)) )
					{
						elementIDs.AddAsLast( _elementIDs.GetAt(index) );
						parentElementIDs.AddAsLast( _parentElementIDs.GetAt(index) );
						labwareLevels.AddAsLast( _labwareLevels.GetAt(index) );
						labwareNames.AddAsLast( _labwareNames.GetAt(index) );
						labwareBarcodes.AddAsLast( _barcodes.GetAt(index) );
					}
				}
			}
		}

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetAllLabwareOnDeck,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return
		return(elementIDs.GetSize());

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetAllLabwareOnDeck,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function LoadLabware(
		device& instrument,									// [in]: used instrument (device)
		variable& labwareId,									// [in]: Labware id (string)
		variable& positionId) variable					// [in]: Position id (string)
	{
		variable errorDesc("");								// Error description
		variable labwareAccessName;

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionLoadLabware, VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionLoadLabware, VdbTraceStatus::progress,	
						"instrument = ", instrument.GetInstrumentName());
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionLoadLabware, VdbTraceStatus::progress,	
						"labwareId = ", labwareId);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionLoadLabware, VdbTraceStatus::progress,	
						"positionId = ", positionId);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionLoadLabware + VdbTrackingConstants::crlf;

		Util2::CheckValueTypeAndRange(labwareId, hslString, Util2::ValueCheck::RangeStringNotEmpty,
												errorDesc + "labwareId");
		Util2::CheckValueType(positionId, hslString, errorDesc + "positionId");
		
		// build labware access name
		if( instrument.GetDeckLayoutFileName() != "" )
		{
			variable templateNames[], labwareNames[];
			variable instrumentName;
			variable index, size;
			variable labware_id_Carrier;

			instrumentName = instrument.GetInstrumentName( );	// Get Instrument name

			// Search Template name depending on the labwareId
			instrument.GetTemplateLabwareNames(templateNames, labwareNames);
			size = labwareNames.GetSize();
			for (index = 0; index < size; index ++)
				if (labwareNames.GetAt(index) == labwareId)
					break;

		   // If LabwareName exist
			if (index < size)
			{
				// check if positionId is spelled correctly
				if(positionId != "")
				{
					sequence dummySeq;
					onerror goto WrongSpelledPositionId;
					dummySeq.Add(labwareId, positionId, instrument);
					onerror goto Unexpected;
				}

			   labware_id_Carrier = templateNames[index];	// Assign Template Name
	   
				if (labware_id_Carrier == VdbTrackingConstants::templateDefaultName)			// If a plate is not on a carrier
				{
		         labwareAccessName = instrumentName + VdbTrackingConstants::backslash + labwareId;
				}
		      else
				{
			      labwareAccessName = instrumentName + VdbTrackingConstants::backslash + labware_id_Carrier + VdbTrackingConstants::backslash + labwareId;
				}

				if(positionId != "")
					labwareAccessName = labwareAccessName + VdbTrackingConstants::backslash + positionId;
			}
			else
			{
				// labware with given Id not found within decklayout
				variable traceInfo;

				// Unlock critical section
				if (0 != vectorDb_TrackingCS)
					SynLeaveCriticalSection(vectorDb_TrackingCS);

				traceInfo = VdbTrackingError::TrStr::unknownLabwareId;
				StrReplace(traceInfo, "%s1", labwareId);
				StrReplace(traceInfo, "%s2", instrument.GetInstrumentName());
				
				Util2::Error::RaiseRuntimeError(VdbTrackingError::majorID, VdbTrackingError::MinorID::generalRuntimeError, VdbTrackingError::ErrorCode::unknownLabwareId,
														  traceInfo, VdbUtil::GetTrackingHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
			}
		}
		else
		{
			// device without decklayout...
			labwareAccessName = instrument.GetInstrumentName() + VdbTrackingConstants::backslash + labwareId;
		}

		// block HxVectorDB Tracking
		{
			object actionLoad;
			actionLoad.CreateObject("HXPARAMSLib.HxPars");
			
			actionLoad.Add(1, vectorDb_TrackingObj.HxVectorDbParsKey_ActionPars_ActionCount);

			actionLoad.Add(labwareAccessName,
								vectorDb_TrackingObj.HxVectorDbParsKey_ActionPars_Actions,
								1,
								vectorDb_TrackingObj.HxVectorDbParsKey_ActionPars_Target);

			actionLoad.Add(positionId,
								vectorDb_TrackingObj.HxVectorDbParsKey_ActionPars_Actions,
								1,
								vectorDb_TrackingObj.HxVectorDbParsKey_ActionPars_TargetChildren);

			actionLoad.Add(vectorDb_TrackingObj.HxVectorDbLabwareHandling_IfNotExists_Create,
								vectorDb_TrackingObj.HxVectorDbParsKey_ActionPars_Actions,
								1,
								vectorDb_TrackingObj.HxVectorDbParsKey_ActionPars_TargetLabwareHandling);

			actionLoad.Add(vectorDb_TrackingObj.HxVectorDbActionState_NoError,
								vectorDb_TrackingObj.HxVectorDbParsKey_ActionPars_Actions,
								1,
								vectorDb_TrackingObj.HxVectorDbParsKey_ActionPars_ActionState);
			
			actionLoad.Add(hslFalse,
								vectorDb_TrackingObj.HxVectorDbParsKey_ActionPars_Actions,
								1,
								vectorDb_TrackingObj.HxVectorDbParsKey_ActionPars_ErrorAvailable);
			
			vectorDb_TrackingObj.TrackAction_Load(actionLoad);
		}

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionLoadLabware, VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return status
		return(hslTrue);

		WrongSpelledPositionId:
		{
			variable traceInfo;

			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// unknown position ID
			traceInfo = VdbTrackingError::TrStr::unknownPositionId;
			StrReplace(traceInfo, "%s1", positionId);
			StrReplace(traceInfo, "%s2", labwareId);
			
			Util2::Error::RaiseRuntimeError(VdbTrackingError::majorID, VdbTrackingError::MinorID::generalRuntimeError, VdbTrackingError::ErrorCode::unknownPositionId,
													  traceInfo, VdbUtil::GetTrackingHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
		}

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionLoadLabware,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	static function IsLabwareLoaded(
   	variable& labwareAccessName) variable			// [in]
	{
		variable errorDesc("");								// Error description
		variable elementID(0);								// Labware ID

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionIsLabwareLoaded, VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionIsLabwareLoaded, VdbTraceStatus::progress,	
						"labwareAccessName = ", labwareAccessName);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionIsLabwareLoaded + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(labwareAccessName, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
												errorDesc + "labwareAccessName");

		// Check whether given labware is loaded
		elementID = vectorDb_TrackingObj.IsLabwareLoaded(labwareAccessName);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionIsLabwareLoaded, VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return status
		return(elementID);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionIsLabwareLoaded,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function IsLabwareLoadedByLabwareId(
		variable deckID,										// [in]: Deck ID (integer)
		variable& labwareId)									// [in]: Labware id (string)
	{
		variable errorDesc("");								// Error description
		variable elementID(0);								// Database element ID

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionIsLabwareLoadedByLabwareId,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionIsLabwareLoadedByLabwareId,
						VdbTraceStatus::progress, "deckID = ", deckID);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionIsLabwareLoadedByLabwareId,
						VdbTraceStatus::progress, "labwareId = ", labwareId);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionIsLabwareLoadedByLabwareId + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(deckID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "deckID");
		Util2::CheckValueTypeAndRange(labwareId, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
												errorDesc + "labwareId");

		// Check whether given labware is loaded (empty string set for position ID)
		elementID = vectorDb_TrackingObj.IsLabwareLoadedByLabwareIdPositionId(deckID, labwareId, "");

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionIsLabwareLoadedByLabwareId,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return status
		return(elementID);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionIsLabwareLoadedByLabwareId,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function IsLabwareLoadedByLabwareIdPositionId(
		variable deckID,										// [in]: Deck ID (integer)
		variable& labwareId,									// [in]: Labware id (string)
		variable& positionId)								// [in]: Position Id (string)
	{
		variable errorDesc("");								// Error description
		variable elementID(0);								// Database element ID

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionIsLabwareLoadedByLabwareIdPositionId,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionIsLabwareLoadedByLabwareIdPositionId,
						VdbTraceStatus::progress, "deckID = ", deckID);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionIsLabwareLoadedByLabwareIdPositionId,
						VdbTraceStatus::progress, "labwareId = ", labwareId);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionIsLabwareLoadedByLabwareIdPositionId,
                  VdbTraceStatus::progress, "positionId = ", positionId);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionIsLabwareLoadedByLabwareIdPositionId + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(deckID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "deckID");
		Util2::CheckValueTypeAndRange(labwareId, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
												errorDesc + "labwareId");
		Util2::CheckValueType(positionId, Util2::ValueType::String, errorDesc + "positionId");

		// Check whether given labware is loaded
		elementID = vectorDb_TrackingObj.IsLabwareLoadedByLabwareIdPositionId(deckID, labwareId, positionId);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionIsLabwareLoadedByLabwareIdPositionId,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return status
		return(elementID);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionIsLabwareLoadedByLabwareIdPositionId,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	static function IsBarcodeLoaded(
		variable deckID,										// [in]
		variable& barcode) variable						// [in]
	{
		variable errorDesc("");								// Error description
		variable elementID(0);								// Labware ID

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionIsBarcodeLoaded, VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionIsBarcodeLoaded, VdbTraceStatus::progress,	
						"deckID = ", deckID);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionIsBarcodeLoaded, VdbTraceStatus::progress,	
						"barcode = ", barcode);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionIsBarcodeLoaded + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(deckID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "deckID");
		Util2::CheckValueTypeAndRange(barcode, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
												errorDesc + "barcode");

		// Check whether given labware is loaded
		elementID = vectorDb_TrackingObj.IsBarcodeLoaded(deckID, barcode);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionIsBarcodeLoaded, VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return status
		return(elementID);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionIsBarcodeLoaded, VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	static function IsBarcodeLoadedEx(
		variable deckID,										// [in]
		variable& barcode) variable[]						// [in]
	{
		variable errorDesc("");								// Error description
		variable elementIDs[];								// Array with Element IDs

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionIsBarcodeLoadedEx, VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionIsBarcodeLoadedEx, VdbTraceStatus::progress,	
						"deckID = ", deckID);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionIsBarcodeLoadedEx, VdbTraceStatus::progress,	
						"barcode = ", barcode);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionIsBarcodeLoaded + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(deckID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "deckID");
		Util2::CheckValueTypeAndRange(barcode, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
												errorDesc + "barcode");

		// Check whether given labware is loaded
		elementIDs = vectorDb_TrackingObj.IsBarcodeLoadedEx(deckID, barcode);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionIsBarcodeLoadedEx, VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return status
		return(elementIDs);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionIsBarcodeLoadedEx, VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function CheckBarcodeByLabwareIdPositionId(
		variable& barcode,									// [in]: Barcode to be checked (string)
		device& instrument,  					         // [in]: used instrument (device)
      variable& labwareId,                         // [in]: Labware id (string)
      variable& positionId) variable               // [in]: Position id (string)
	{
		variable errorDesc("");								// Error description
		variable uniqueBarcodeCheckResult;
      variable deckID(0);

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionCheckBarcodeByLabwareIdPositionId, VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionCheckBarcodeByLabwareIdPositionId, VdbTraceStatus::progress,	
						"barcode = ", barcode);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionCheckBarcodeByLabwareIdPositionId, VdbTraceStatus::progress,	
						"instrument = ", instrument.GetInstrumentName());
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionCheckBarcodeByLabwareIdPositionId, VdbTraceStatus::progress,	
						"labwareId = ", labwareId);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionCheckBarcodeByLabwareIdPositionId, VdbTraceStatus::progress,	
						"positionId = ", positionId);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionCheckBarcodeByLabwareIdPositionId + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(barcode, hslString, Util2::ValueCheck::RangeStringNotEmpty,
												errorDesc + "barcode");
		Util2::CheckValueTypeAndRange(labwareId, hslString, Util2::ValueCheck::RangeStringNotEmpty,
												errorDesc + "labwareId");
		Util2::CheckValueTypeAndRange(positionId, hslString, Util2::ValueCheck::RangeStringEmpty,
												errorDesc + "positionId");

		// Get DeckID
		deckID = vectorDb_TrackingObj.GetDeckID(instrument.GetInstrumentName());

		// Check whether given labware is loaded
		uniqueBarcodeCheckResult = vectorDb_TrackingObj.CheckBarcodeByLabwareIdPositionId(barcode, deckID, labwareId, positionId);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionCheckBarcodeByLabwareIdPositionId, VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return status
		return(uniqueBarcodeCheckResult);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionCheckBarcodeByLabwareIdPositionId, VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	static function GetElementID(
   	variable& labwareAccessName) variable			// [in]
	{
		variable errorDesc("");								// Error description
		variable elementID(0);								// Labware ID

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetElementID, VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetElementID, VdbTraceStatus::progress,	
						"labwareAccessName = ", labwareAccessName);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetElementID + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(labwareAccessName, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
												errorDesc + "labwareAccessName");

		// Get ElementID
		elementID = vectorDb_TrackingObj.GetElementID(labwareAccessName);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetElementID, VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return status
		return(elementID);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetElementID,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 

	static function GetElementIDByDeckIDLabwareId(
		variable deckID,										// [in]
		variable& labwareId) variable						// [in]
	{
		variable errorDesc("");								// Error description
		variable elementID(0);								// Labware ID

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetElementIDByDeckIDLabwareId,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetElementIDByDeckIDLabwareId,
						VdbTraceStatus::progress, "deckID = ", deckID);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetElementIDByDeckIDLabwareId,
						VdbTraceStatus::progress, "labwareId = ", labwareId);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetElementIDByDeckIDLabwareId + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(deckID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "deckID");
		Util2::CheckValueTypeAndRange(labwareId, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
												errorDesc + "labwareId");

		// Get ElementID
		elementID = vectorDb_TrackingObj.GetElementIDByDeckIDLabwareName(deckID,labwareId);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetElementIDByDeckIDLabwareId,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return status
		return(elementID);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetElementIDByDeckIDLabwareId,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 

	static function GetLabwareLoadingTime(
   	variable& labwareAccessName,						// [in]
   	variable namedFormat) variable					// [in]
	{
		variable errorDesc("");								// Error description
		variable labwareLoadingTime(0);					// Labware loading time

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareLoadingTime,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareLoadingTime,
						VdbTraceStatus::progress, "labwareAccessName = ", labwareAccessName);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareLoadingTime,
						VdbTraceStatus::progress, "namedFormat = ", namedFormat);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetLabwareLoadingTime + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(labwareAccessName, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
												errorDesc + "labwareAccessName");
		Util2::CheckValueTypeAndRangeMinMax(namedFormat, hslInteger, VectorDb_DateTimeFormat::Unformatted,
														VectorDb_DateTimeFormat::ShortTime, errorDesc + "namedFormat");

		// Get labware loading time
		labwareLoadingTime = vectorDb_TrackingObj.GetLabwareLoadingTime(labwareAccessName);
		if (VectorDb_DateTimeFormat::Unformatted != namedFormat)
		{
			labwareLoadingTime = VdbUtil::FormatDateTime(labwareLoadingTime, namedFormat);
		}

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareLoadingTime,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return status
		return(labwareLoadingTime);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareLoadingTime,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 

	static function GetLabwareLoadingTimeByElementID(
		variable deckID,										// [in]
		variable elementID,									// [in]
   	variable namedFormat) variable					// [in]
	{
		variable errorDesc("");								// Error description
		variable labwareLoadingTime(0);					// Labware loading time

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareLoadingTimeByElementID,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareLoadingTimeByElementID,
						VdbTraceStatus::progress, "deckID = ", deckID);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareLoadingTimeByElementID,
						VdbTraceStatus::progress, "elementID = ", elementID);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareLoadingTimeByElementID,
						VdbTraceStatus::progress, "namedFormat = ", namedFormat);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetLabwareLoadingTimeByElementID + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(deckID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "deckID");
		Util2::CheckValueTypeAndRange(elementID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "elementID");
		Util2::CheckValueTypeAndRangeMinMax(namedFormat, hslInteger, VectorDb_DateTimeFormat::Unformatted, 
														VectorDb_DateTimeFormat::ShortTime, errorDesc + "namedFormat");

		// Get labware loading time
		labwareLoadingTime = vectorDb_TrackingObj.GetLabwareLoadingTimeByElementID(deckID, elementID);
		if (VectorDb_DateTimeFormat::Unformatted != namedFormat)
		{
			labwareLoadingTime = VdbUtil::FormatDateTime(labwareLoadingTime, namedFormat);
		}

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareLoadingTimeByElementID,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return status
		return(labwareLoadingTime);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareLoadingTimeByElementID,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 

	static  function AssignLabwareToJob(
		variable jobID, 
		variable sourceElementID, 
		variable targetElementID) variable
	{
		variable errorDesc("");								// Error description

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionAssignLabwareToJob, VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionAssignLabwareToJob,
						VdbTraceStatus::progress, "jobID = ", jobID);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionAssignLabwareToJob,
						VdbTraceStatus::progress, "sourceElementID = ", sourceElementID);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionAssignLabwareToJob,
						VdbTraceStatus::progress, "targetElementID = ", targetElementID);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionAssignLabwareToJob + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(jobID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "jobID");
		Util2::CheckValueTypeAndRange(sourceElementID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "sourceElementID");
		Util2::CheckValueTypeAndRange(targetElementID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "targetElementID");

		// Assign labware to job
		vectorDb_TrackingObj.AssignLabwareToJob(jobID,sourceElementID,targetElementID);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionAssignLabwareToJob,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return status
		return(hslTrue);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionAssignLabwareToJob,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 

	function AssignLoadedLabwareToJobs(
		variable deckID) variable
	{
		variable errorDesc("");							// Error description
		variable numberOfAffectedRecords(0);						// Number of jobs

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionAssignLoadedLabwareToJobs,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionAssignLoadedLabwareToJobs,
						VdbTraceStatus::progress, "deckID = ", deckID);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionAssignLoadedLabwareToJobs + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(deckID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "deckID");

		// Assign jobs to corresponding labware
		numberOfAffectedRecords = vectorDb_TrackingObj.AssignLoadedLabwareToJobs(deckID);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionAssignLoadedLabwareToJobs,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(numberOfAffectedRecords);

		Unexpected:
		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionAssignLoadedLabwareToJobs,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 

	static function GetLabware(
		variable& labwareAccessName,						// [in]
		variable& deckID,										// [out]
		variable& parentElementID,							// [out]
		variable& elementID,									// [out]
		variable& labwareName,								// [out]
		variable& labwareLevel,								// [out]
		variable& barcode,									// [out]
		variable& volume,										// [out]
		variable& labwareState,								// [out]
		variable& userLabwareState,						// [out]
		variable& deckCoordinateX,							// [out]
		variable& deckCoordinateY,							// [out]
		variable& deckCoordinateZ,							// [out]
		variable& userLabwareTypeID) variable			// [out]
	{
		variable errorDesc("");								// Error description
		object resultPars;									// Result pars package

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabware, VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabware, VdbTraceStatus::progress, 
						"labwareAccessName = ", labwareAccessName);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetLabware + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(labwareAccessName, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
												errorDesc + "labwareAccessName");

		// Init output params
		deckID = 0;
		parentElementID = 0;
		elementID = 0;
		labwareName = "";
		labwareLevel = VectorDb_LabwareLevel::Undefined;
		barcode = "";
		volume = 0.0;
		labwareState = VectorDb_LabwareState::NoError;
		userLabwareState = 0;
		deckCoordinateX = 0.0;
		deckCoordinateY = 0.0;
		deckCoordinateZ = 0.0;
		userLabwareTypeID = 0;

		// Get labware details
		vectorDb_TrackingObj.GetLabware_OutParams(labwareAccessName,
																elementID,parentElementID,deckID,labwareName,labwareLevel,
																barcode,volume,labwareState,userLabwareState,
																deckCoordinateX,deckCoordinateY,deckCoordinateZ,userLabwareTypeID);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabware, VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return status
		return(hslTrue);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabware,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 

	static function GetLabwareByElementID(
		variable elementID,									// [in]
		variable& deckID,										// [out]
		variable& parentElementID,							// [out]
		variable& labwareName,								// [out]
		variable& labwareLevel,								// [out]
		variable& barcode,									// [out]
		variable& volume,										// [out]
		variable& labwareState,								// [out]
		variable& userLabwareState,						// [out]
		variable& deckCoordinateX,							// [out]
		variable& deckCoordinateY,							// [out]
		variable& deckCoordinateZ,							// [out]
		variable& userLabwareTypeID) variable			// [out]
	{
		variable errorDesc("");								// Error description
		object resultPars;									// Result pars package

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareByElementID,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareByElementID,
						VdbTraceStatus::progress, "elementID = ", elementID);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetLabwareByElementID + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(elementID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "elementID");

		// Init output params
		deckID = 0;
		parentElementID = 0;
		labwareName = "";
		labwareLevel = VectorDb_LabwareLevel::Undefined;
		barcode = "";
		volume = 0.0;
		labwareState = VectorDb_LabwareState::NoError;
		userLabwareState = 0;
		deckCoordinateX = 0.0;
		deckCoordinateY = 0.0;
		deckCoordinateZ = 0.0;
		userLabwareTypeID = 0;

		// Get labware details
		vectorDb_TrackingObj.GetLabwareByElementID_OutParams(elementID,
																				parentElementID,deckID,labwareName,labwareLevel,
																				barcode,volume,labwareState,userLabwareState,
																				deckCoordinateX,deckCoordinateY,deckCoordinateZ,userLabwareTypeID);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareByElementID,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return status
		return(hslTrue);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareByElementID,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 

	function GetLabwareBarcode(
		variable& labwareAccessName) variable			// [in]
	{
		variable errorDesc("");								// Error description
		variable labwareBarcode("");						// Labware barcode

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareBarcode, VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareBarcode,
						VdbTraceStatus::progress, "labwareAccessName = ", labwareAccessName);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetLabwareBarcode + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(labwareAccessName, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
												errorDesc + "labwareAccessName");

		// Get labware barcode
		labwareBarcode = vectorDb_TrackingObj.GetLabwareBarcode(labwareAccessName);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareBarcode,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return status
		return(labwareBarcode);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareBarcode,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 

	function GetLabwareBarcodeByElementID(
		variable elementID) variable						// [in]
	{
		variable errorDesc("");								// Error description
		variable labwareBarcode("");						// Labware barcode

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareBarcodeByElementID,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareBarcodeByElementID,
						VdbTraceStatus::progress, "elementID = ", elementID);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetLabwareBarcodeByElementID + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(elementID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "elementID");

		// Get labware barcode
		labwareBarcode = vectorDb_TrackingObj.GetLabwareBarcodeByElementID(elementID);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareBarcodeByElementID,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return status
		return(labwareBarcode);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareBarcodeByElementID,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 

	function GetLabwareVolume(
		variable& labwareAccessName) variable			// [in]
	{
		variable errorDesc("");								// Error description
		variable labwareVolume("");						// Labware volume

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareVolume, VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareVolume, VdbTraceStatus::progress,	
						"labwareAccessName = ", labwareAccessName);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetLabwareVolume + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(labwareAccessName, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
												errorDesc + "labwareAccessName");

		// Get labware volume
		labwareVolume = vectorDb_TrackingObj.GetLabwareVolume(labwareAccessName);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareVolume, VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return status
		return(labwareVolume);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareVolume,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 

	function GetLabwareVolumeByElementID(
		variable elementID) variable						// [in]
	{
		variable errorDesc("");								// Error description
		variable labwareVolume("");						// Labware volume

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareVolumeByElementID,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareVolumeByElementID,
						VdbTraceStatus::progress, "elementID = ", elementID);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetLabwareVolumeByElementID + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(elementID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "elementID");

		// Get labware volume
		labwareVolume = vectorDb_TrackingObj.GetLabwareVolumeByElementID(elementID);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareVolumeByElementID,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return status
		return(labwareVolume);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareVolumeByElementID,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function GetAllChildLabware(
		variable elementID) variable []					// [in]: Element ID (integer)
	{
		variable arrChildElementIDs[];
		variable errorDesc("");								// Error description

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetAllChildLabware, VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetAllChildLabware, VdbTraceStatus::progress,
						"elementID = ", elementID);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetAllChildLabware + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(elementID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "elementID");

		// Get child labware
		arrChildElementIDs = vectorDb_TrackingObj.GetAllChildLabware(elementID);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetAllChildLabware, VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(arrChildElementIDs);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetAllChildLabware,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}	
	}

	function GetLabwareOfLastLoadAction(
		variable& elementIDs[],								// [in/out] Array to retrieve element ID's (integer)
		variable& parentElementIDs[],						// [in/out] Array to retrieve parent element ID's (integer)
		variable& initialLabwareAccessNames[],			// [in/out] Array to retrieve initial labware access names (string)
		variable& labwareNames[],							// [in/out] Array to retrieve labware names (string)
		variable& labwareLevels[],							// [in/out] Array to retrieve labware levels (integer)
		variable& barcodes[]) variable					// [in/out] Array to retrieve barcodes (string)
	{
		variable nbrOfElementIDs(-1);
		variable errorDesc("");								// Error description

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareOfLastLoadAction,
						VdbTraceStatus::start);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Get labware of last load action
		nbrOfElementIDs = vectorDb_TrackingObj.GetLabwareOfLastLoadAction(
										elementIDs, parentElementIDs, initialLabwareAccessNames, labwareNames, labwareLevels, barcodes);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareOfLastLoadAction,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(nbrOfElementIDs);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareOfLastLoadAction,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}	
	}

	function GetElementIDByCurrentPositionOfSequence(
		variable deckID,										// [in]: Deck ID (integer)
		sequence& Sequence) variable 						// [in]: Sequence of interest
	{
		variable errorDesc("");								// Error description
		variable elementID(0);
		variable backupCurrentSeqPos(-1);

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetElementIDByCurrentPositionOfSequence,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetElementIDByCurrentPositionOfSequence,
						VdbTraceStatus::progress, "deckID = ", deckID);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetElementIDByCurrentPositionOfSequence,
						VdbTraceStatus::progress, "Sequence = ", Sequence.GetName());
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetElementIDByCurrentPositionOfSequence + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(deckID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "deckID");
		// backup and check current sequence position
		backupCurrentSeqPos = Sequence.GetCurrentPosition();
		if( backupCurrentSeqPos < 1 )
		{
			// throw an error
			Util2::Error::RaiseRuntimeError(VdbTrackingError::majorID, VdbTrackingError::MinorID::generalRuntimeError,
													VdbTrackingError::ErrorCode::emptySequence,
													VdbTrackingError::MakeErrorDescription(
													VdbTrackingError::ErrorCode::invalidParameter, errorDesc + "Sequence"), 
													VdbUtil::GetTrackingHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
		}

		// Get Element ID 
		elementID = vectorDb_TrackingObj.GetElementIDByCurrentPositionOfSequence(deckID, Sequence);

		// restore current sequence Position
		Sequence.SetCurrentPosition(backupCurrentSeqPos);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetElementIDByCurrentPositionOfSequence,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(elementID);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetElementIDByCurrentPositionOfSequence,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function GetLabwareHierarchyByCurrentPositionOfSequence(
		variable deckID,										// [in]: Deck ID (integer)
		sequence& Sequence,			 						// [in]: Sequence of interest
		variable& templateID,								// [out]: Template ID (integer)
		variable& rackID) variable							// [out]: Rack ID (integer)
	{
		variable errorDesc("");								// Error description
		variable elementIDofWell(0);
		variable backupCurrentSeqPos(-1);

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareHierarchyByCurrentPositionOfSequence,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareHierarchyByCurrentPositionOfSequence,
						VdbTraceStatus::progress, "deckID = ", deckID);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareHierarchyByCurrentPositionOfSequence,
						VdbTraceStatus::progress, "Sequence = ", Sequence.GetName());
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetLabwareHierarchyByCurrentPositionOfSequence + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(deckID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "deckID");
		// backup and check current sequence position
		backupCurrentSeqPos = Sequence.GetCurrentPosition();
		if( backupCurrentSeqPos < 1 )
		{
			// throw an error
			Util2::Error::RaiseRuntimeError(VdbTrackingError::majorID, VdbTrackingError::MinorID::generalRuntimeError,
													VdbTrackingError::ErrorCode::emptySequence,
													VdbTrackingError::MakeErrorDescription(
													VdbTrackingError::ErrorCode::invalidParameter, errorDesc + "Sequence"), 
													VdbUtil::GetTrackingHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
		}

		elementIDofWell = vectorDb_TrackingObj.GetLabwareHierarchyByCurrentPositionOfSequence(deckID, Sequence, templateID, rackID);

		// restore current sequence Position
		Sequence.SetCurrentPosition(backupCurrentSeqPos);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareHierarchyByCurrentPositionOfSequence,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(elementIDofWell);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareHierarchyByCurrentPositionOfSequence,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function GetElementIDsOfSequencePositions(
		variable deckID,										// [in]: Deck ID (integer)
		sequence& Sequences[]) variable []				// [in]: Sequence(s) of interest
	{
		variable errorDesc("");								// Error description
		variable elementIDs[];
		variable index(0);

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetElementIDsOfSequencePositions,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetElementIDsOfSequencePositions,
						VdbTraceStatus::progress, "deckID = ", deckID);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetElementIDsOfSequencePositions,
						VdbTraceStatus::progress, "Sequences[] (size) = ", Sequences.GetSize());
		for(index = 0; index < Sequences.GetSize(); index++)
		{
			sequence s;
			s = Sequences.ElementAt(index);
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetElementIDsOfSequencePositions,
							VdbTraceStatus::progress, "Sequences[" + IStr(index) + "] = ", s.GetName());
		}
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetElementIDsOfSequencePositions + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(deckID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "deckID");

		// check current sequence position
		for(index = 0; index < Sequences.GetSize(); index++)
		{
			sequence seq;
			seq = Sequences.GetAt(index);

			if( seq.GetCurrentPosition() < 1 )
			{
				// throw an error
				Util2::Error::RaiseRuntimeError(VdbTrackingError::majorID, VdbTrackingError::MinorID::generalRuntimeError,
														VdbTrackingError::ErrorCode::emptySequence,
														VdbTrackingError::MakeErrorDescription(
														VdbTrackingError::ErrorCode::invalidParameter, errorDesc + "Sequences"), 
														VdbUtil::GetTrackingHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
			}
		}

		// Get Element IDs 
		elementIDs = vectorDb_TrackingObj.GetElementIDsOfSequencePositions(deckID, Sequences);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetElementIDsOfSequencePositions,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(elementIDs);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetElementIDsOfSequencePositions,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}	
	}

	function GetLabwareAccessName(
		variable& elementID) variable						// [in]: Element ID (integer)
	{
		variable errorDesc("");								// Error description
		variable labwareAccessName("");

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareAccessName, VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareAccessName,
						VdbTraceStatus::progress, "elementID = ", elementID);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetLabwareAccessName + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(elementID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "elementID");

		// Get labware barcode
		labwareAccessName = vectorDb_TrackingObj.GetLabwareAccessName(elementID);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareAccessName, 
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(labwareAccessName);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareAccessName,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function CreateSequenceForRacks(
		variable deckID,										// [in]: Deck ID (integer)
		variable& rackElementIDs[], 						// [in]: Array with rack element ID's (integer)
		variable rackSortingCritera,						// [in]: Rack sorting criteria (integer)
		variable wellSortingCriteria,						// [in]: Well sorting criteria (integer)
		sequence& Sequence) variable						// [out]: Sequence object
	{
		variable errorDesc("");								// Error description
		variable i;

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionCreateSequenceForRacks,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionCreateSequenceForRacks,
						VdbTraceStatus::progress, "deckID = ", deckID);
		for(i = 0; i < rackElementIDs.GetSize(); i++)
		{
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionCreateSequenceForRacks,
							VdbTraceStatus::progress, "rackElementIDs[" + IStr(i) +"] = ", rackElementIDs.ElementAt(i));
		}
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionCreateSequenceForRacks,
						VdbTraceStatus::progress, "rackSortingCritera = ", rackSortingCritera);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionCreateSequenceForRacks,
						VdbTraceStatus::progress, "wellSortingCriteria = ", wellSortingCriteria);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionCreateSequenceForRacks + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(deckID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "deckID");
		for(i = 0; i < rackElementIDs.GetSize(); i++)
		{
			Util2::CheckValueTypeAndRange(rackElementIDs.ElementAt(i), hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero,
													errorDesc + "rackElementIDs[" + IStr(i) + "]");
		}
		Util2::CheckValueTypeAndRangeMinMax(rackSortingCritera, hslInteger, VectorDb_SequenceSortingCriteria::None, 
														VectorDb_SequenceSortingCriteria::YDescending_XDescending,
														errorDesc + "rackSortingCritera");
		Util2::CheckValueTypeAndRangeMinMax(wellSortingCriteria, hslInteger, VectorDb_SequenceSortingCriteria::None, 
														VectorDb_SequenceSortingCriteria::YDescending_XDescending,
														errorDesc + "wellSortingCriteria");

		vectorDb_TrackingObj.CreateSequenceForRacks(
										deckID, rackElementIDs, rackSortingCritera, wellSortingCriteria, Sequence.GetSequenceObject());

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionCreateSequenceForRacks,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(hslTrue);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionCreateSequenceForRacks,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function GetLabwareOfRun(
		variable runID,										// [in] The run ID (integer)
		variable labwareLevel,								// [in] The level of interesting labware (integer, one of VectorDb_LabwareLevel)
		variable& elementIDs[],								// [in/out] Array to retrieve element ID's (integer)
		variable& initialParentElementIDs[],			// [in/out] Array to retrieve initial parent element ID's (integer)
		variable& initialLabwareAccessNames[],			// [in/out] Array to retrieve initial labware access names (string)
		variable& initialLabwareNames[],					// [in/out] Array to retrieve initial labware names (string)
		variable& barcodes[],								// [in/out] Array to retrieve barcodes (string)
		variable& labwareLevels[],							// [in/out] Array to retrieve labware levels (integer, one of VectorDb_LabwareLevel)
		variable& labwareStates[],							// [in/out] Array to retrieve labware states (integer, one of VectorDb_LabwareState)
		variable& loadingTimes[],							// [in/out] Array to retrieve loading times (float if namedFormat = VectorDb_DateTimeFormat::Unformatted, otherwise string)
		variable namedFormat) variable					// [in]: Numeric value that indicates the date/time format used (integer, one of VectorDb_DateTimeFormat).
	{
		variable nbrOfLabware(0);
		variable errorDesc("");								// Error description

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareOfRun, VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareOfRun,
						VdbTraceStatus::progress, "runID = ", runID);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareOfRun,
						VdbTraceStatus::progress, "labwareLevel = ", labwareLevel);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareOfRun,
						VdbTraceStatus::progress, "namedFormat = ", namedFormat);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetLabwareOfRun + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(runID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "runID");
		Util2::CheckValueTypeAndRangeMinMax(labwareLevel, hslInteger, VectorDb_LabwareLevel::Undefined, 
														VectorDb_LabwareLevel::_All, errorDesc + "labwareLevel");
		Util2::CheckValueTypeAndRangeMinMax(namedFormat, hslInteger, VectorDb_DateTimeFormat::Unformatted, 
														VectorDb_DateTimeFormat::ShortTime, errorDesc + "namedFormat");

		nbrOfLabware = vectorDb_TrackingObj.GetLabwareOfRun(runID,
																			 labwareLevel,
																			 elementIDs,
																			 initialParentElementIDs,
																			 initialLabwareAccessNames,
																			 initialLabwareNames,
																			 barcodes,
																			 labwareLevels,
																			 labwareStates,
																			 loadingTimes);

		if (VectorDb_DateTimeFormat::Unformatted != namedFormat)
		{
			variable index;
			variable formattedDateTime;
			
			for(index = 0; index < loadingTimes.GetSize(); index++)
			{
				formattedDateTime = VdbUtil::FormatDateTime(loadingTimes.GetAt(index), namedFormat);
				loadingTimes.SetAt(index, formattedDateTime);
			}
		}

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareOfRun, VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(nbrOfLabware);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareOfRun,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function ReloadLabware(
		variable currentRunElementID,						// [in] The element ID of current run (integer)
		variable previousRunElementID) variable		// [in] The element ID of previous run (integer)
	{
		variable errorDesc("");								// Error description

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionReloadLabware, VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionReloadLabware,
						VdbTraceStatus::progress, "currentRunElementID = ", currentRunElementID);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionReloadLabware,
						VdbTraceStatus::progress, "previousRunElementID = ", previousRunElementID);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionReloadLabware + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(currentRunElementID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
								errorDesc + "currentRunElementID");
		Util2::CheckValueTypeAndRange(previousRunElementID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
								errorDesc + "previousRunElementID");

		vectorDb_TrackingObj.ReloadLabware(currentRunElementID, previousRunElementID);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionReloadLabware, VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return status
		return(hslTrue);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionReloadLabware,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function AddLabwareAdditionalData(
		variable elementID, 									// [in] The element ID (integer)
		variable additionalDataKey,						// [in] Additional data key (string)
		variable additionalDataValue) variable			// [in] Additional data value (integer, float or string)
	{
		variable errorDesc("");								// Error description
		variable additionalDataValueType(-1);
		variable additionalDataKeys[];
		variable additionalDataValues[];
		variable additionalDataTypes[];

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionAddLabwareAdditionalData,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionAddLabwareAdditionalData,
						VdbTraceStatus::progress, "elementID = ", elementID);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionAddLabwareAdditionalData,
						VdbTraceStatus::progress, "additionalDataKey = ", additionalDataKey);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionAddLabwareAdditionalData,
						VdbTraceStatus::progress, "additionalDataValue = ", additionalDataValue);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionAddLabwareAdditionalData + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(elementID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "elementID");
		Util2::CheckValueTypeAndRange(additionalDataKey, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
												errorDesc + "additionalDataKey");

		// additionalDataValue may be any hsl Type (string, float ot integer)
		if( Util::IsString(additionalDataValue) )
		{
			additionalDataValueType = VectorDb_ValueType::String;
		}
		else
		if( Util::IsFloat(additionalDataValue) )
		{
			additionalDataValueType = VectorDb_ValueType::Float;
		}
		else
		if( Util::IsInteger(additionalDataValue) )
		{
			additionalDataValueType = VectorDb_ValueType::Integer;
		}
		else
		{
			// throw an error
			Util2::Error::RaiseRuntimeError(VdbTrackingError::majorID, VdbTrackingError::MinorID::generalRuntimeError,
													VdbTrackingError::ErrorCode::invalidParameter,
													VdbTrackingError::MakeErrorDescription(
													VdbTrackingError::ErrorCode::invalidParameter, errorDesc + "additionalDataValue"),
													VdbUtil::GetTrackingHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
		}

		// fill up arrays
		additionalDataKeys.AddAsLast(additionalDataKey);
		additionalDataValues.AddAsLast(additionalDataValue);
		additionalDataTypes.AddAsLast(additionalDataValueType);

		vectorDb_TrackingObj.AddLabwareAdditionalData(elementID, additionalDataKeys, additionalDataTypes, additionalDataValues);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionAddLabwareAdditionalData,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return status
		return(hslTrue);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionAddLabwareAdditionalData,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function GetLabwareAdditionalData(
		variable elementID,									// [in] The element ID (integer)
		variable additionalDataIDs[],						// [in/out] Array to retrieve additional data ID's (integer)
		variable additionalDataKeys[],					// [in/out] Array to retrieve additional data keys (string)
		variable additionalDataTypes[],					// [in/out] Array to retrieve additional data types (integer)
		variable additionalDataValues[]) variable		// [in/out] Array to retrieve additional data values (integer, float or string)
	{
		variable nbrOfAdditionalData(0);
	
		variable errorDesc("");								// Error description

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareAdditionalData,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareAdditionalData,
						VdbTraceStatus::progress, "elementID = ", elementID);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetLabwareAdditionalData + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(elementID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
								errorDesc + "elementID");

		nbrOfAdditionalData = vectorDb_TrackingObj.GetLabwareAdditionalData(
												elementID, additionalDataIDs, additionalDataKeys, additionalDataTypes, additionalDataValues);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareAdditionalData,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(nbrOfAdditionalData);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareAdditionalData,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function GetLabwareAdditionalDataByKey(
		variable elementID,									// [in] The element ID (integer)
		variable additionalDataKey, 						// [in] Additional data key (string)
		variable& additionalDataID,   					// [out] Additional data ID (integer)
		variable& additionalDataType, 					// [out] Additional data type (integer, one of VectorDb_ValueType)
		variable& additionalDataValue) variable		// [out] Additional data value (integer, float or string)
	{
		variable errorDesc("");								// Error description

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareAdditionalDataByKey,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareAdditionalDataByKey,
						VdbTraceStatus::progress, "elementID = ", elementID);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareAdditionalDataByKey,
						VdbTraceStatus::progress, "additionalDataKey = ", additionalDataKey);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetLabwareAdditionalDataByKey + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(elementID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "elementID");
		Util2::CheckValueTypeAndRange(additionalDataKey, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
												errorDesc + "additionalDataKey");

		vectorDb_TrackingObj.GetLabwareAdditionalDataByKey(
										elementID, additionalDataKey, additionalDataID, additionalDataType, additionalDataValue);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareAdditionalDataByKey,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return status
		return(hslTrue);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareAdditionalDataByKey,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function DeleteLabwareAdditionalData(
		variable elementID,									// [in] The element ID (integer)
		variable additionalDataKey) variable			// [in] Additional data key (string)
	{
	
		variable nbrOfAffectedRows(0);
		variable errorDesc("");								// Error description
		variable additionalDataKeys[];

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionDeleteLabwareAdditionalData,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionDeleteLabwareAdditionalData,
						VdbTraceStatus::progress, "elementID = ", elementID);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionDeleteLabwareAdditionalData,
						VdbTraceStatus::progress, "additionalDataKey = ", additionalDataKey);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionDeleteLabwareAdditionalData + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(elementID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "elementID");
		Util2::CheckValueTypeAndRange(additionalDataKey, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
												errorDesc + "additionalDataKey");

		// fill up array
		additionalDataKeys.AddAsLast(additionalDataKey);

		nbrOfAffectedRows = vectorDb_TrackingObj.DeleteLabwareAdditionalData(elementID, additionalDataKeys);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionDeleteLabwareAdditionalData,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(nbrOfAffectedRows);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionDeleteLabwareAdditionalData,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}
}

//*****************************************************************************************************************
namespace VectorDb_Misc
//*****************************************************************************************************************
{	
	static function TrackingEnabled() variable
	{
		variable trackingEnabled(hslFalse);

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		//FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionTrackingEnabled, VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		// Nothing to dump
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		// Nothing to check

		// Get Tracking enabled flag
		trackingEnabled = vectorDb_TrackingObj.Enabled();

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		//FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionTrackingEnabled, VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return status
		return(trackingEnabled);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			//FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionTrackingEnabled, VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}
}

//*****************************************************************************************************************
namespace VectorDb_Experiment
//*****************************************************************************************************************
{	
	function StartExperimentTracking(
		variable& name,									// [in]: Experiment name (string)
		variable& description,							// [in]: Experiment description (string)
		variable& sourceAccessName) variable		// [in]: Labware access name, e.g. ML_STAR\TemplateA\Rack1\1 (string)
	{
		variable errorDesc("");								// Error description
		variable experimentID(-1);							// ID of started experiment

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionStartExperimentTracking,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionStartExperimentTrackingByElementID,
						VdbTraceStatus::progress, "name = ", name);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionStartExperimentTrackingByElementID,
						VdbTraceStatus::progress, "description = ", description);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionStartExperimentTrackingByElementID,
						VdbTraceStatus::progress, "sourceAccessName = ", sourceAccessName);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionStartExperimentTracking + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(name, hslString, Util2::ValueCheck::RangeStringNotEmpty, errorDesc + "name");
		Util2::CheckValueType(description, hslString, errorDesc + "description");
		Util2::CheckValueType(sourceAccessName, hslString, errorDesc + "sourceAccessName");

		// Start Experiment Tracking
		experimentID = vectorDb_TrackingObj.StartExperimentTracking(name, description, sourceAccessName);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionStartExperimentTracking,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return status
		return(experimentID);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionStartExperimentTracking,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 

	function StartExperimentTrackingByElementID(
		variable& name,									// [in]: Experiment name (string)
		variable& description,							// [in]: Experiment description (string)
		variable sourceElementID) variable 			// [in]: Element ID of source element (integer)
	{
		variable errorDesc("");							// Error description
		variable experimentID(-1);						// ID of started experiment

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionStartExperimentTrackingByElementID,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionStartExperimentTrackingByElementID,
						VdbTraceStatus::progress, "name = ", name);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionStartExperimentTrackingByElementID,
						VdbTraceStatus::progress, "description = ", description);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionStartExperimentTrackingByElementID,
						VdbTraceStatus::progress, "sourceElementID = ", sourceElementID);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionStartExperimentTrackingByElementID + VdbTrackingConstants::crlf;
		Util2::CheckValueType(name, hslString, errorDesc + "name");
		Util2::CheckValueType(description, hslString, errorDesc + "description");
		Util2::CheckValueTypeAndRange(sourceElementID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "sourceElementID");

		// Start Experiment Tracking
		experimentID = vectorDb_TrackingObj.StartExperimentTrackingByElementID(name, description, sourceElementID);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionStartExperimentTrackingByElementID,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return status
		return(experimentID);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionStartExperimentTrackingByElementID,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function StartExperimentTrackingByElementIDs(
		variable& name,									// [in]: Experiment name (string)
		variable& description,							// [in]: Experiment description (string)
		variable& sourceElementIDs[]) variable 	// [in]: Array containing the element IDs (integer)
	{
		variable errorDesc("");							// Error description
		variable experimentID(-1);						// ID of started experiment
		variable nIndex(0);

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionStartExperimentTrackingByElementIDs,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionStartExperimentTrackingByElementIDs,
						VdbTraceStatus::progress, "name = ", name);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionStartExperimentTrackingByElementIDs,
						VdbTraceStatus::progress, "description = ", description);
		nIndex = 0;
		while(nIndex < sourceElementIDs.GetSize())
		{
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionStartExperimentTrackingByElementIDs,
							VdbTraceStatus::progress, "sourceElementID at index [" + IStr(nIndex) + "]:",
							sourceElementIDs.ElementAt(nIndex));
			nIndex++;
		}
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionStartExperimentTrackingByElementIDs + VdbTrackingConstants::crlf;
		Util2::CheckValueType(name, hslString, errorDesc + "name");
		Util2::CheckValueType(description, hslString, errorDesc + "description");
		
		nIndex = 0;
		while(nIndex < sourceElementIDs.GetSize())
		{
			Util2::CheckValueTypeAndRange(sourceElementIDs.ElementAt(nIndex), hslInteger,
													Util2::ValueCheck::RangeNumberGreaterThanZero,
													errorDesc + "sourceElementIDs[" + IStr(nIndex) + "]");
			nIndex++;
		}

		// Start Experiment Tracking
		experimentID = vectorDb_TrackingObj.StartExperimentTrackingByElementIDs(name, description, sourceElementIDs);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionStartExperimentTrackingByElementIDs,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return status
		return(experimentID);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionStartExperimentTrackingByElementIDs,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function GetAllExperiments(
		variable& experimentIDs[],						// [in/out]: Array to retrieve the experiment ID's (integer)
		variable& names[],								// [in/out]: Array to retrieve the experiment names (string)
		variable& descriptions[],						// [in/out]: Array to retrieve the experiment descriptions (string)
		variable& experimentTimes[],					// [in/out]: Array to retrieve the experiment date/times (float if namedFormat = VectorDb_DateTimeFormat::Unformatted, otherwise string)
		variable namedFormat) variable				// [in]: Numeric value that indicates the date/time format used (integer, one of VectorDb_DateTimeFormat).
	{
		variable errorDesc("");								// Error description
		variable nbrOfExperiments(-1);
	
		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetAllExperiments, VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetAllExperiments,
						VdbTraceStatus::progress,	"namedFormat = ", namedFormat);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetAllExperiments + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRangeMinMax(namedFormat, hslInteger, VectorDb_DateTimeFormat::Unformatted, 
														VectorDb_DateTimeFormat::ShortTime, errorDesc + "namedFormat");

		nbrOfExperiments = vectorDb_TrackingObj.GetAllExperiments(experimentIDs, names, descriptions, experimentTimes);

		if (VectorDb_DateTimeFormat::Unformatted != namedFormat)
		{
			variable tempExperimentTime("");
			variable index(0);

			for( index; index < experimentTimes.GetSize(); index++ )
			{
				tempExperimentTime = experimentTimes.GetAt( index );
				tempExperimentTime = VdbUtil::FormatDateTime( tempExperimentTime, namedFormat ); 
				experimentTimes.SetAt( index, tempExperimentTime );
			}
		}

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetAllExperiments, VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return status
		return(nbrOfExperiments);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetAllExperiments,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 

	function GetExperimentSourceLabware(
		variable experimentID) variable				// [in]: Experiment ID (integer)
	{
		variable errorDesc("");								// Error description
		variable elementID(0);								// Element ID of source labware

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetExperimentSourceLabware,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetExperimentSourceLabware,
						VdbTraceStatus::progress, "experimentID = ", experimentID);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetExperimentSourceLabware + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(experimentID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "experimentID");

		elementID = vectorDb_TrackingObj.GetExperimentSourceLabware( experimentID );

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetExperimentSourceLabware,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return status
		return(elementID);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetExperimentSourceLabware,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function GetExperimentSourceLabwareEx(
		variable experimentID) variable[]			// [in]: Experiment ID (integer)
	{
		variable errorDesc("");							// Error description
		variable elementIDs[];							// Element ID's of source labware

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetExperimentSourceLabwareEx,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetExperimentSourceLabwareEx,
						VdbTraceStatus::progress, "experimentID = ", experimentID);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetExperimentSourceLabwareEx + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(experimentID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "experimentID");

		elementIDs = vectorDb_TrackingObj.GetExperimentSourceLabwareEx( experimentID );

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetExperimentSourceLabwareEx,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return source experiment element ID's
		return(elementIDs);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetExperimentSourceLabwareEx,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}		
	}
	
	function GetAllExperimentLabware(
		variable experimentID,							// [in]: Experiment ID (integer)
		variable& elementIDs[]) variable				// [in/out]: Array to retrieve element ID's (integer)
	{
		variable errorDesc("");								// Error description
		variable nbrElementIDs(-1);

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetAllExperimentLabware,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetAllExperimentLabware,
						VdbTraceStatus::progress, "experimentID = ", experimentID);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetAllExperimentLabware + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(experimentID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "experimentID");

		nbrElementIDs = vectorDb_TrackingObj.GetAllExperimentLabware( experimentID, elementIDs );

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetAllExperimentLabware,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return status
		return(nbrElementIDs);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetAllExperimentLabware,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 

	function GetExperiment(
		variable experimentID,							// [in]: Experiment ID (integer)
		variable& name,									// [out]: Experiment name (string)
		variable& description,							//	[out]: Experiment descrioption (string)
		variable& experimentTime,						// [out]: Experiment date/time (float if namedFormat = VectorDb_DateTimeFormat::Unformatted, otherwise string)
   	variable namedFormat) variable				// [in]: Numeric value that indicates the date/time format used (integer, one of VectorDb_DateTimeFormat).
	{
		variable errorDesc("");								// Error description
	
		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetExperiment, VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetExperiment,
						VdbTraceStatus::progress,	"experimentID = ", experimentID);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetExperiment,
						VdbTraceStatus::progress,	"namedFormat = ", namedFormat);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetExperiment + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(experimentID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "experimentID");
		Util2::CheckValueTypeAndRangeMinMax(namedFormat, hslInteger, VectorDb_DateTimeFormat::Unformatted,
														VectorDb_DateTimeFormat::ShortTime, errorDesc + "namedFormat");

		vectorDb_TrackingObj.GetExperiment(experimentID, name, description, experimentTime);

		if (VectorDb_DateTimeFormat::Unformatted != namedFormat)
		{
			experimentTime = VdbUtil::FormatDateTime( experimentTime, namedFormat ); 
		}

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetExperiment, VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return status
		return(hslTrue);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetExperiment,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 

	function AddExperimentLabware(
		variable experimentID,							// [in]: Experiment ID (integer)
		variable elementID) variable					// [in]: Element ID (integer)
	{
		variable errorDesc("");								// Error description
	
		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionAddExperimentLabware, VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionAddExperimentLabware,
						VdbTraceStatus::progress,	"experimentID = ", experimentID);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionAddExperimentLabware,
						VdbTraceStatus::progress,	"elementID = ", elementID);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionAddExperimentLabware + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(experimentID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "experimentID");
		Util2::CheckValueTypeAndRange(elementID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "elementID");

		vectorDb_TrackingObj.AddExperimentLabware(experimentID, elementID);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionAddExperimentLabware,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return status
		return(hslTrue);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionAddExperimentLabware,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function AddExperimentSourceLabware(
		variable experimentID,							// [in]: Experiment ID (integer)
		variable sourceElementID) variable			// [in]: Element ID of source (integer)
	{
		variable errorDesc("");								// Error description
	
		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionAddExperimentSourceLabware, VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionAddExperimentSourceLabware,
						VdbTraceStatus::progress,	"experimentID = ", experimentID);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionAddExperimentSourceLabware,
						VdbTraceStatus::progress,	"sourceElementID = ", sourceElementID);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionAddExperimentSourceLabware + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(experimentID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "experimentID");
		Util2::CheckValueTypeAndRange(sourceElementID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "sourceElementID");

		vectorDb_TrackingObj.AddExperimentSourceLabware(experimentID, sourceElementID);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionAddExperimentSourceLabware,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return status
		return(hslTrue);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionAddExperimentSourceLabware,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function DeleteExperiment(
		variable experimentID) variable				// [in]: Experiment ID (integer)
	{
		variable affectedRows(0);
		variable errorDesc("");								// Error description
	
		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionDeleteExperiment, VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionDeleteExperiment,
						VdbTraceStatus::progress,	"experimentID = ", experimentID);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionDeleteExperiment + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(experimentID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "experimentID");
		
		affectedRows = vectorDb_TrackingObj.DeleteExperiment(experimentID);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionDeleteExperiment, VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(affectedRows);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionDeleteExperiment,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}	
	}

	function RemoveExperimentLabware(
		variable experimentID,							// [in]: Experiment ID (integer)
		variable elementID) variable					// [in]: Element ID (integer)
	{
		variable affectedRows(0);
		variable errorDesc("");								// Error description
	
		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionRemoveExperimentLabware,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionRemoveExperimentLabware,
						VdbTraceStatus::progress,	"experimentID = ", experimentID);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionRemoveExperimentLabware,
						VdbTraceStatus::progress,	"elementID = ", elementID);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionRemoveExperimentLabware + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(experimentID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "experimentID");
		Util2::CheckValueTypeAndRange(elementID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "elementID");

		// Get labware loading time
		affectedRows = vectorDb_TrackingObj.RemoveExperimentLabware(experimentID, elementID);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionRemoveExperimentLabware,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(affectedRows);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionRemoveExperimentLabware,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}
}

//*****************************************************************************************************************
namespace VectorDb_TrackAction
//*****************************************************************************************************************
{
	function CustomAction(
		variable& labwareAccessName, 					// [in]: Labware access name, e.g. ML_STAR\TemplateA\Rack1\1 (string)
		variable actionState,							// [in]: Action state (integer)
		variable additionalData_Key,					// [in]: Additional key (string)
		variable additionalData_Value) variable	// [in]: Additional value (string, float or integer)
	{
		variable errorDesc("");								// Error description
		variable additionalData_ValueType(-1);			// Type of additional Data
		object actionCustomAction;
		variable actionIDs[];
	
		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionCustomAction, VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionCustomAction,
						VdbTraceStatus::progress,	"labwareAccessName = ", labwareAccessName);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionCustomAction,
						VdbTraceStatus::progress,	"actionState = ", actionState);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionCustomAction,
						VdbTraceStatus::progress,	"additionalData_Key = ", additionalData_Key);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionCustomAction,
						VdbTraceStatus::progress,	"additionalData_Value = ", additionalData_Value);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionCustomAction + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(labwareAccessName, hslString, Util2::ValueCheck::RangeStringNotEmpty,
												errorDesc + "labwareAccessName");
		Util2::CheckValueTypeAndRangeMinMax(actionState, hslInteger, VectorDb_ActionState::NoError, VectorDb_ActionState::Warning,
														errorDesc + "actionState");
		Util2::CheckValueTypeAndRange(additionalData_Key, hslString, Util2::ValueCheck::RangeStringNotEmpty,
												errorDesc + "additionalData_Key");
		// additionalData_Value may be any hsl Type (string, float ot integer)
		if( Util::IsString(additionalData_Value) )
		{
			additionalData_ValueType = VectorDb_ValueType::String;
		}
		else
		if( Util::IsFloat(additionalData_Value) )
		{
			additionalData_ValueType = VectorDb_ValueType::Float;
		}
		else
		if( Util::IsInteger(additionalData_Value) )
		{
			additionalData_ValueType = VectorDb_ValueType::Integer;
		}
		else
		{
			// throw an error
			Util2::Error::RaiseRuntimeError(VdbTrackingError::majorID, VdbTrackingError::MinorID::generalRuntimeError,
													VdbTrackingError::ErrorCode::invalidParameter,
													VdbTrackingError::MakeErrorDescription(VdbTrackingError::ErrorCode::invalidParameter,
																										errorDesc + "additionalData_Value"),
													VdbUtil::GetTrackingHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
		}

		actionCustomAction.CreateObject("HXPARAMSLib.HxPars");
		actionCustomAction.Add(	1, vectorDb_TrackingObj.HxVectorDbParsKey_ActionPars_ActionCount);
		actionCustomAction.Add(	labwareAccessName,
										vectorDb_TrackingObj.HxVectorDbParsKey_ActionPars_Actions,
										1,
										vectorDb_TrackingObj.HxVectorDbParsKey_ActionPars_Target);
		actionCustomAction.Add(	vectorDb_TrackingObj.HxVectorDbLabwareHandling_IfNotExists_Error,
										vectorDb_TrackingObj.HxVectorDbParsKey_ActionPars_Actions,
										1,
										vectorDb_TrackingObj.HxVectorDbParsKey_ActionPars_TargetLabwareHandling);
		actionCustomAction.Add(	additionalData_ValueType,
										vectorDb_TrackingObj.HxVectorDbParsKey_ActionPars_Actions,
										1,
										vectorDb_TrackingObj.HxVectorDbParsKey_ActionPars_AdditionalData,
										additionalData_Key,
										vectorDb_TrackingObj.HxVectorDbParsKey_AdditionalData_ValueType);
		actionCustomAction.Add( additionalData_Value,
										vectorDb_TrackingObj.HxVectorDbParsKey_ActionPars_Actions,
										1,
										vectorDb_TrackingObj.HxVectorDbParsKey_ActionPars_AdditionalData,
										additionalData_Key,
										vectorDb_TrackingObj.HxVectorDbParsKey_AdditionalData_Value);
		actionCustomAction.Add(	actionState,
										vectorDb_TrackingObj.HxVectorDbParsKey_ActionPars_Actions,
										1,
										vectorDb_TrackingObj.HxVectorDbParsKey_ActionPars_ActionState);
		actionCustomAction.Add(	hslFalse, 
										vectorDb_TrackingObj.HxVectorDbParsKey_ActionPars_Actions,
										1,
										vectorDb_TrackingObj.HxVectorDbParsKey_ActionPars_ErrorAvailable);
		
		// track Custom Action
		actionIDs = vectorDb_TrackingObj.TrackAction_CustomAction(actionCustomAction);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionCustomAction, VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		// Return status
		return(actionIDs.GetAt(0));

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionCustomAction,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}
}

//*****************************************************************************************************************
namespace VectorDb_LabwareType
//*****************************************************************************************************************
{
	static function CreateSequenceForLabwareTypes(
		variable deckID,										// [in]: Deck ID (integer)
		variable& rackLabwareTypeIDs[], 					// [in]: Array with rack labware type ID's (integer)
		variable& wellLabwareTypeIDs[], 					// [in]: Array with well labware type ID's (integer)
		variable rackSortingCritera,						// [in]: Rack sorting criteria (integer)
		variable wellSortingCriteria,						// [in]: Well sorting criteria (integer)
		sequence& Sequence) variable						// [out]: Sequence object
	{
		variable errorDesc("");								// Error description

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionCreateSequenceForLabwareTypes,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionCreateSequenceForLabwareTypes,
						VdbTraceStatus::progress, "deckID = ", deckID);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionCreateSequenceForLabwareTypes,
						VdbTraceStatus::progress, "rackSortingCritera = ", rackSortingCritera);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionCreateSequenceForLabwareTypes,
						VdbTraceStatus::progress, "wellSortingCriteria = ", wellSortingCriteria);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionCreateSequenceForLabwareTypes + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(deckID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "deckID");
		Util2::CheckValueTypeAndRangeMinMax(rackSortingCritera, hslInteger, VectorDb_SequenceSortingCriteria::None, 
														VectorDb_SequenceSortingCriteria::YDescending_XDescending,
														errorDesc + "rackSortingCritera");
		Util2::CheckValueTypeAndRangeMinMax(wellSortingCriteria, hslInteger, VectorDb_SequenceSortingCriteria::None, 
														VectorDb_SequenceSortingCriteria::YDescending_XDescending,
														errorDesc + "wellSortingCriteria");

		vectorDb_TrackingObj.CreateSequenceForLabwareTypes(deckID, rackLabwareTypeIDs, wellLabwareTypeIDs, rackSortingCritera,
																			wellSortingCriteria, Sequence.GetSequenceObject());

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionCreateSequenceForLabwareTypes,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(hslTrue);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionCreateSequenceForLabwareTypes,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}	
	}

	function SetLabwareType(
		variable& mainTypeName,								// [in]: Main type name (string)
		variable& typeName, 									// [in]: Type name (string)
		variable& accessName) variable					// [in]: Labware access name, e.g. ML_STAR\TemplateA\Rack1\1 (string)
	{
		variable labwareTypeID(0);
		variable errorDesc("");								// Error description

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionSetLabwareType, VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionSetLabwareType,
						VdbTraceStatus::progress, "mainTypeName = ", mainTypeName);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionSetLabwareType,
						VdbTraceStatus::progress, "typeName = ", typeName);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionSetLabwareType,
						VdbTraceStatus::progress, "accessName = ", accessName);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionSetLabwareType + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(mainTypeName, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
												errorDesc + "mainTypeName");
		Util2::CheckValueTypeAndRange(typeName, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
												errorDesc + "typeName");
		Util2::CheckValueTypeAndRange(accessName, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
												errorDesc + "accessName");

		labwareTypeID = vectorDb_TrackingObj.SetLabwareType(mainTypeName, typeName, accessName);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionSetLabwareType, VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(labwareTypeID);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionSetLabwareType,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function SetLabwareTypeByElementID(
		variable& mainTypeName,								// [in]: Main type name (string)
		variable& typeName, 									// [in]: Type name (string)
		variable elementID) variable						// [in]: Element ID (integer)
	{
		variable labwareTypeID(0);
		variable errorDesc("");								// Error description

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionSetLabwareTypeByElementID,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionSetLabwareTypeByElementID,
						VdbTraceStatus::progress, "mainTypeName = ", mainTypeName);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionSetLabwareTypeByElementID,
						VdbTraceStatus::progress, "typeName = ", typeName);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionSetLabwareTypeByElementID,
						VdbTraceStatus::progress, "elementID = ", elementID);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionSetLabwareType + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(mainTypeName, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
												errorDesc + "mainTypeName");
		Util2::CheckValueTypeAndRange(typeName, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
												errorDesc + "typeName");
		Util2::CheckValueTypeAndRange(elementID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "elementID");

		labwareTypeID = vectorDb_TrackingObj.SetLabwareTypeByElementID(mainTypeName, typeName, elementID);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionSetLabwareTypeByElementID,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(labwareTypeID);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionSetLabwareTypeByElementID,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function SetLabwareTypeID(
		variable labwareTypeID,								// [in]: Labware type ID (integer)
		variable& accessName) variable					// [in]: Labware access name, e.g. ML_STAR\TemplateA\Rack1\1 (string)
	{
		variable errorDesc("");								// Error description

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionSetLabwareTypeID,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionSetLabwareTypeID,
						VdbTraceStatus::progress, "labwareTypeID = ", labwareTypeID);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionSetLabwareTypeID,
						VdbTraceStatus::progress, "accessName = ", accessName);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionSetLabwareTypeID + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(labwareTypeID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "labwareTypeID");
		Util2::CheckValueTypeAndRange(accessName, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
												errorDesc + "accessName");

		vectorDb_TrackingObj.SetLabwareTypeID(labwareTypeID, accessName);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionSetLabwareTypeID,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(hslTrue);
		
		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionSetLabwareTypeID,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function SetLabwareTypeIDByElementID(
		variable labwareTypeID,								// [in]: Labware type ID (integer)
		variable elementID) variable						// [in]: Element ID (integer)
	{
		variable errorDesc("");								// Error description

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionSetLabwareTypeIDByElementID,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionSetLabwareTypeIDByElementID,
						VdbTraceStatus::progress, "labwareTypeID = ", labwareTypeID);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionSetLabwareTypeIDByElementID,
						VdbTraceStatus::progress, "elementID = ", elementID);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionSetLabwareTypeIDByElementID + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(labwareTypeID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "labwareTypeID");
		Util2::CheckValueTypeAndRange(elementID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "elementID");

		vectorDb_TrackingObj.SetLabwareTypeIDByElementID(labwareTypeID, elementID);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionSetLabwareTypeIDByElementID,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(hslTrue);
		
		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionSetLabwareTypeIDByElementID,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function GetLabwareTypeID(
		variable& accessName) variable					// [in]: Labware access name, e.g. ML_STAR\TemplateA\Rack1\1 (string)
	{
		variable labwareTypeID(0);
		variable errorDesc("");								// Error description

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareTypeID,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareTypeID,
						VdbTraceStatus::progress, "accessName = ", accessName);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetLabwareTypeID + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(accessName, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
												errorDesc + "accessName");

		labwareTypeID = vectorDb_TrackingObj.GetLabwareTypeID(accessName);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareTypeID,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(labwareTypeID);
		
		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareTypeID,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function GetLabwareTypeIDByElementID(
		variable elementID) variable						// [in]: Element ID (integer)
	{
		variable labwareTypeID(0);
		variable errorDesc("");								// Error description

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareTypeIDByElementID,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareTypeIDByElementID,
						VdbTraceStatus::progress, "elementID = ", elementID);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetLabwareTypeIDByElementID + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(elementID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "elementID");

		labwareTypeID = vectorDb_TrackingObj.GetLabwareTypeIDByElementID(elementID);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareTypeIDByElementID,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(labwareTypeID);
		
		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareTypeIDByElementID,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function GetLabwareTypeIDByTypeName(
		variable& mainTypeName,								// [in]: Main type name (string)
		variable& typeName, 									// [in]: Type name (string)
		variable createIfNotExist) variable				// [in]: Flag, indicates whether the labware type has to be created if not exist (integer)
	{
		variable labwareTypeID(0);
		variable errorDesc("");								// Error description

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareTypeIDByTypeName,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareTypeIDByTypeName,
						VdbTraceStatus::progress, "mainTypeName = ", mainTypeName);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareTypeIDByTypeName,
						VdbTraceStatus::progress, "typeName = ", typeName);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareTypeIDByTypeName,
						VdbTraceStatus::progress, "createIfNotExist = ", createIfNotExist);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetLabwareTypeIDByTypeName + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(mainTypeName, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
												errorDesc + "mainTypeName");
		Util2::CheckValueTypeAndRange(typeName, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
												errorDesc + "typeName");
		Util2::CheckValueTypeAndRangeMinMax(createIfNotExist, hslInteger, 0, 1, errorDesc + "createIfNotExist");

		labwareTypeID = vectorDb_TrackingObj.GetLabwareTypeIDByTypeName(mainTypeName, typeName, createIfNotExist);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareTypeIDByTypeName,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(labwareTypeID);
		
		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareTypeIDByTypeName,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function GetLabwareMainTypeIDByTypeName(
		variable& mainTypeName,								// [in]: Main type name (string)
		variable createIfNotExist) variable				// [in]: Flag, indicates whether the labware type has to be created if not exist (integer)
	{
		variable labwareMainTypeID(0);
		variable errorDesc("");								// Error description

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareMainTypeIDByTypeName,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareMainTypeIDByTypeName,
						VdbTraceStatus::progress, "mainTypeName = ", mainTypeName);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareMainTypeIDByTypeName,
						VdbTraceStatus::progress, "createIfNotExist = ", createIfNotExist);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetLabwareMainTypeIDByTypeName + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(mainTypeName, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
												errorDesc + "mainTypeName");
		Util2::CheckValueTypeAndRangeMinMax(createIfNotExist, hslInteger, 0, 1, errorDesc + "createIfNotExist");

		labwareMainTypeID = vectorDb_TrackingObj.GetLabwareMainTypeIDByTypeName(mainTypeName, createIfNotExist);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareMainTypeIDByTypeName,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(labwareMainTypeID);
		
		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareMainTypeIDByTypeName,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function GetLabwareMainTypes(
		variable& mainTypeIDs[],							// [in/out]: Array to retrieve the labware main type ID's (integer)
		variable& mainTypeNames[]) variable				// [in/out]: Array to retrieve the labware main type names (sting)
	{
		variable nbrOfLabwareMainTypes(0);
		variable errorDesc("");								// Error description

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareMainTypes,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		nbrOfLabwareMainTypes = vectorDb_TrackingObj.GetLabwareMainTypes(mainTypeIDs, mainTypeNames);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareMainTypes,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(nbrOfLabwareMainTypes);
		
		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareMainTypes,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function GetLabwareTypesOfMainType(
		variable& mainType,									// [in]: Main type name (string)
		variable& mainTypeIDs[],							// [in/out]: Array to retrieve the labware main type ID's (integer)
		variable& typeNames[]) variable					// [in/out]: Array to retrieve the labware type names (sting)
	{
		variable nbrOfLabwareTypes(0);
		variable errorDesc("");								// Error description

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareTypesOfMainType,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareTypesOfMainType,
						VdbTraceStatus::progress, "mainType = ", mainType);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetLabwareTypesOfMainType + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(mainType, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
												errorDesc + "mainType");

		nbrOfLabwareTypes = vectorDb_TrackingObj.GetLabwareTypesOfMainType(mainType, mainTypeIDs, typeNames);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareTypesOfMainType,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(nbrOfLabwareTypes);
		
		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareTypesOfMainType,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function GetLabwareTypesOfMainTypeByMainTypeID(
		variable mainTypeID,									// [in]: Main type ID (integer)
		variable& mainTypeIDs[],							// [in/out]: Array to retrieve the labware main type ID's (integer)
		variable& typeNames[]) variable					// [in/out]: Array to retrieve the labware type names (sting)
	{
		variable nbrOfLabwareTypes(0);
		variable errorDesc("");								// Error description

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareTypesOfMainTypeByMainTypeID,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareTypesOfMainTypeByMainTypeID,
						VdbTraceStatus::progress, "mainTypeID = ", mainTypeID);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetLabwareTypesOfMainTypeByMainTypeID + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(mainTypeID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "mainTypeID");

		nbrOfLabwareTypes = vectorDb_TrackingObj.GetLabwareTypesOfMainTypeByMainTypeID(mainTypeID, mainTypeIDs, typeNames);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareTypesOfMainTypeByMainTypeID,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(nbrOfLabwareTypes);
		
		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLabwareTypesOfMainTypeByMainTypeID,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function DeleteLabwareMainType(
		variable& mainTypeName) variable					// [in]: Main type name (string)
	{
		variable nbrOfAffectedRows(0);
		variable errorDesc("");								// Error description

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionDeleteLabwareMainType,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionDeleteLabwareMainType,
						VdbTraceStatus::progress, "mainTypeName = ", mainTypeName);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionDeleteLabwareMainType + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(mainTypeName, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
												errorDesc + "mainTypeName");

		nbrOfAffectedRows = vectorDb_TrackingObj.DeleteLabwareMainType(mainTypeName);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionDeleteLabwareMainType,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(nbrOfAffectedRows);
		
		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionDeleteLabwareMainType,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function DeleteLabwareMainTypeByMainTypeID(
		variable mainTypeID) variable						// [in]: Main type ID (integer)
	{
		variable nbrOfAffectedRows(0);
		variable errorDesc("");								// Error description

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionDeleteLabwareMainTypeByMainTypeID,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionDeleteLabwareMainTypeByMainTypeID,
						VdbTraceStatus::progress, "mainTypeID = ", mainTypeID);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionDeleteLabwareMainTypeByMainTypeID + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(mainTypeID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "mainTypeID");

		nbrOfAffectedRows = vectorDb_TrackingObj.DeleteLabwareMainTypeByMainTypeID(mainTypeID);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionDeleteLabwareMainTypeByMainTypeID,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(nbrOfAffectedRows);
		
		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionDeleteLabwareMainTypeByMainTypeID,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function DeleteLabwareType(
		variable& mainTypeName,								// [in]: Main type name (string)
		variable& typeName) variable						// [in]: Type name (string)
	{
		variable nbrOfAffectedRows(0);
		variable errorDesc("");								// Error description

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionDeleteLabwareType,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionDeleteLabwareType,
						VdbTraceStatus::progress, "mainTypeName = ", mainTypeName);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionDeleteLabwareType,
						VdbTraceStatus::progress, "typeName = ", typeName);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionDeleteLabwareType + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(mainTypeName, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
												errorDesc + "mainTypeName");
		Util2::CheckValueTypeAndRange(typeName, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
												errorDesc + "typeName");

		nbrOfAffectedRows = vectorDb_TrackingObj.DeleteLabwareType(mainTypeName, typeName);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionDeleteLabwareType,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(nbrOfAffectedRows);
		
		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionDeleteLabwareType,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function DeleteLabwareTypeByTypeID(
		variable typeID) variable							// [in]: Labware type ID (integer)
	{
		variable nbrOfAffectedRows(0);
		variable errorDesc("");								// Error description

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionDeleteLabwareTypeByTypeID,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionDeleteLabwareTypeByTypeID,
						VdbTraceStatus::progress, "typeID = ", typeID);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionDeleteLabwareTypeByTypeID + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(typeID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "typeID");

		nbrOfAffectedRows = vectorDb_TrackingObj.DeleteLabwareTypeByTypeID(typeID);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionDeleteLabwareTypeByTypeID,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(nbrOfAffectedRows);
		
		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionDeleteLabwareTypeByTypeID,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function GetLoadedLabwareByLabwareTypeID(
		variable deckID, 										// [in]: Deck ID (integer)
		variable labwareLevel,								// [in]: The labware level (integer, one of VectorDb_LabwareLevel)
		variable labwareTypeID, 							// [in]: Labware type ID (integer)
		variable& elementIDs[], 							// [in/out]: Array to retrieve the element ID's of currently loaded labware (integer)
		variable& labwareTypeIDs[]) variable			// [in/out]: Array to retrieve the labware type ID's of currently loaded labware (integer)
	{
		variable nbrOfLabware(0);
		variable errorDesc("");								// Error description

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLoadedLabwareByLabwareTypeID,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLoadedLabwareByLabwareTypeID,
						VdbTraceStatus::progress, "deckID = ", deckID);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLoadedLabwareByLabwareTypeID,
						VdbTraceStatus::progress, "labwareLevel = ", labwareLevel);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLoadedLabwareByLabwareTypeID,
						VdbTraceStatus::progress, "labwareTypeID = ", labwareTypeID);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetLoadedLabwareByLabwareTypeID + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(deckID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "deckID");
		Util2::CheckValueTypeAndRangeMinMax(labwareLevel, hslInteger, VectorDb_LabwareLevel::Undefined, VectorDb_LabwareLevel::_All, 
												errorDesc + "labwareLevel");
		Util2::CheckValueTypeAndRange(labwareTypeID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "labwareTypeID");

		nbrOfLabware = vectorDb_TrackingObj.GetLoadedLabwareByLabwareTypeID(deckID,
																								  labwareLevel,
																								  labwareTypeID,
																								  elementIDs,
																								  labwareTypeIDs);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLoadedLabwareByLabwareTypeID,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(nbrOfLabware);
		
		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLoadedLabwareByLabwareTypeID,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function GetLoadedChildrenLabwareByLabwareTypeID(
		variable deckID, 										// [in]: Deck ID (integer)
		variable parentElementID, 							// [in]: Parent element ID (integer)
		variable labwareTypeID, 							// [in]: Labware type ID (integer)
		variable& elementIDs[], 							// [in/out]: Array to retrieve the element ID's of currently loaded labware (integer)
		variable& labwareTypeIDs[]) variable			// [in/out]: Array to retrieve the labware type ID's of currently loaded labware (integer)
	{
		variable nbrOfChildLabware(0);
		variable errorDesc("");								// Error description

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLoadedChildrenLabwareByLabwareTypeID,
						VdbTraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLoadedChildrenLabwareByLabwareTypeID,
						VdbTraceStatus::progress, "deckID = ", deckID);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLoadedChildrenLabwareByLabwareTypeID,
						VdbTraceStatus::progress, "parentElementID = ", parentElementID);
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLoadedChildrenLabwareByLabwareTypeID,
						VdbTraceStatus::progress, "labwareTypeID = ", labwareTypeID);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		VdbUtil::InitTrackingLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_TrackingCS);

		// Check input params to be valid
		errorDesc = VdbTrackingConstants::traceActionGetLoadedChildrenLabwareByLabwareTypeID + VdbTrackingConstants::crlf;
		Util2::CheckValueTypeAndRange(deckID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "deckID");
		Util2::CheckValueTypeAndRange(parentElementID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "parentElementID");
		Util2::CheckValueTypeAndRange(labwareTypeID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
												errorDesc + "labwareTypeID");

		nbrOfChildLabware = vectorDb_TrackingObj.GetLoadedChildrenLabwareByLabwareTypeID(deckID,
																													parentElementID,
																								 					labwareTypeID,
																													elementIDs,
																													labwareTypeIDs);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLoadedChildrenLabwareByLabwareTypeID,
						VdbTraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_TrackingCS);

		return(nbrOfChildLabware);
		
		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_TrackingCS)
				SynLeaveCriticalSection(vectorDb_TrackingCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(VdbTrackingConstants::traceSource, VdbTrackingConstants::traceActionGetLoadedChildrenLabwareByLabwareTypeID,
							VdbTraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}
}


#endif
// $$author=mhosang$$valid=0$$time=2010-06-07 15:15$$checksum=86b93a0c$$length=086$$