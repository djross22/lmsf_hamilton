// ======================================================================
// This is a part of the HSLHamHeaterCooler Library.
// Copyright (C) by HAMILTON Bonaduz AG, CH-7402 Bonaduz.
// All rights reserved.
// ======================================================================
//
// Modification History
//   
//	2019-25-11  rwilliams >  V1.0 first creation
//
// 2020-16-07  rwilliams >  V1.1 Addition of set verification date command
//
// >>>>> if you change the version update HamHeaterCoolerVersion too <<<<
//
//	**********************************************************************
// This library version supports following hardware:
//		- Hamilton Heater Cooler PN 186280/02
//	**********************************************************************

 
#ifndef __HSLHeaterCoolerLibImpl_hsl__
#define __HSLHeaterCoolerLibImpl_hsl__	1

 
static const variable HamHeaterCoolerVersion("Version: V4.4");
 
// ----------------------------------------------------------------------------------------------------  
// Includes
// ----------------------------------------------------------------------------------------------------

#ifndef __HSLStrLib_hsl__
	#include "HSLStrLib.hsl"
#endif
 
#ifndef __HSLSynLib_hsl__
	#include "HSLSynLib.hsl"
#endif 

#ifndef __HSLMthLib_hsl__
	#include "HSLMthLib.hsl"
#endif


// ----------------------------------------------------------------------------------------------------
// Device (for development only! Comment out for release version.)
// ----------------------------------------------------------------------------------------------------
//device ML_STAR;

// --------------------------------------------------------------------------------------
// Implementation of Hamilton Heater Cooler library 
// --------------------------------------------------------------------------------------
namespace HSLHamHeaterCooler
{
	#ifndef __HSLStringTableLib_hsl__
	#include "HSLStringTableLib.hs_"
	#endif

	// --------------------------------------------------------------------------------------
	// Debugging and Developing (for development only! Comment out for release version.)
	// --------------------------------------------------------------------------------------
	//#define _DEBUG		1		// specifies the debug version of the HSLHamHeaterCooler library

	// --------------------------------------------------------------------------------------
	// Tracing
	// --------------------------------------------------------------------------------------
   namespace TraceStatus
   {
		static const variable cmd_start(1);					// action status for formated trace and step return
		static const variable cmd_complete(2);				// action status for formated trace and step return
		static const variable cmd_error(3);					// action status for formated trace and step return
		static const variable cmd_progress(4);				// action status for formated trace and step return
		static const variable cmd_errComplete(5);			// action status for formated trace and step return
   }

	// --------------------------------------------------------------------------------------
	// Parameter definitions
	// --------------------------------------------------------------------------------------
   namespace ShakingParam
   {
      static const variable directionLeft(0);         // Shaking direction
      static const variable directionRight(1);        // Shaking direction
      static const variable directionDefault(0);      // Shaking direction
      static const variable speedParamLenght(4);      // Length of firmware parameter string
      static const variable accelParamLenght(5);      // Length of firmware parameter string
      static const variable timeParamLenght(5);       // Length of firmware parameter string
      static const variable rampMin(630);             // Accelerator ramp min
      static const variable rampMax(12500);           // Accelerator ramp max
      static const variable rampDefault(1250);        // Accelerator ramp default
      static const variable rpmMin(30);               // min revolutions per minutes RPM (steps per second (48 steps == 1 revolution)
      static const variable rpmMax(2500);             // max revolutions per minutes RPM
      static const variable rpmDefault(1000);         // Revolutions per minutes RPM
		static const variable rmpStepFactor(1.25);		// Factor to calculate RPM to steps (Steps = RPM / rmpStepFactor)
      static const variable shakingTimeMin(0);        // min shaking time
      static const variable shakingTimeMax(30000);    // max shaking time
      static const variable shakeTolMin(0);    			// min shaking tolerance
      static const variable shakeTolMax(100);    		// max shaking tolerance
		
   }

   namespace TemperateParam
   {
      static const variable startTimeOutDefault(1800);// Time before temperature will be checked
      static const variable startTimeOutMin(1);       // Time before temperature will be checked
      static const variable startTimeOutMax(3600);    // Time before temperature will be checked
      static const variable paramLength(4);           // Length of all temperature step parameter
      static const variable tempStateOk(0);           // Temperature was allways in temperature range
      static const variable tempStateOutOfRange(1);   // Temperature was out of temperature range
      static const variable tempStateOutOfSecurity(2);// Temperature was out of security range
      static const variable tempStateTimeOut(3);		// Temperature timeout
      static const variable tempMin(0.0);             // min temperature
      static const variable tempMax(105.0);           // max temperature
      static const variable tempToleranceDefault(2.0);// Tolerance of incubation time
      static const variable tempToleranceMin(0.0);    // Tolerance of incubation time
      static const variable tempToleranceMax(100.0);  // Tolerance of incubation time
      static const variable tempSecurityDefault(6.0); // Security range of incubation temperature (switch off heater if reached)
      static const variable tempSecurityMin(0.0);     // Security range of incubation temperature (switch off heater if reached)
      static const variable tempSecurityMax(100.0);   // Security range of incubation temperature (switch off heater if reached)
      static const variable tempTempRequestLength(13);// Length of temperature response string
      static const variable tempStateRequestLength(4);// Length of temperature state response string
   }

	// --------------------------------------------------------------------------------------
	// Monitoring
	// --------------------------------------------------------------------------------------
   namespace MonitorStatus
   {
		static const variable monitorOK(0);							// no error
		static const variable monitorErrHeating(1);				// heating out of range
		static const variable monitorErrShaking(2);				// shaking out of range
		static const variable monitorErrHeatingAndShaking(3);	// heating and shaking out of range
   }

   namespace MonitorAction
   {
		static const variable monitorActionMin(0);				// min value
		static const variable monitorActionCont(0);				// Continue
		static const variable monitorActionStop(1);				// Stop Heating, shaking and monitoring
		static const variable monitorActionAbort(2);				// Abort run
		static const variable monitorActionMax(2);				// max value
   }

	// --------------------------------------------------------------------------------------
	// Module local constants/variables
	// --------------------------------------------------------------------------------------
   static const variable m_maxHHC(10);                      // node 0..9
   static const variable m_firstStarNode(1);                // node 1 and 2 for ML_Star
   static const variable m_lastStarNode(2);                 // node 1 and 2 for ML_Star
   static const variable m_firstUsbNode(1);                 // node 1 to 8 for USB (0..7)
   static const variable m_lastUsbNode(8);                  // node 1 to 8 for USB (0..7)
   static const variable m_firstDeviceNumber(1);            // generated deviceNumber range
   static const variable m_lastDeviceNumber(m_maxHHC);      // generated deviceNumber range

   static const variable m_usbMsgTimeout(240);              // timeout for comand which are send to USB
   static const variable m_usbInitTimeout(15);              // timeout for init comands which are send to USB
   static const variable m_OFF(0);
   static const variable m_ON(1);
   static const variable m_firmwareCmdLength(2);            // length of firmware command without node (Tx)
   static const variable m_waitTimeOutSecurity(60);         // Security time which will be added oto wait timeout of function waitCooler()
	static const variable m_starSimulateModeKey(18);			// key for read simulate flag of STAR with GetCfgValueWithKey()
	static const variable m_shakingPropertyHeatAndShake(0);	// HHC is usable for heating and shaking
	static const variable m_shakingPropertyOnlyHeat(1);		// HHC is usable for heating only
	static const variable m_shakingPropertyOnlyShake(2);		// HHC is usable for shaking only
	static const variable m_shakingPropertyNothing(3);			// HHC is defined wrong, no shaking and no heating ????

   // special error definition for direct check in step result string
   static const variable m_fwNoError("er00");               // no error
   static const variable m_fwCanError("er10");              // can error
   static const variable m_fwShNotInitError("er51");        // Cooler not initialized
   static const variable m_fwShStepLostError("er52");       // Cooler step lost
   static const variable m_fwPlNotInitError("er56");        // Plate lock not initialized
   static const variable m_fwPlStepLostError("er57");       // Plate lock step lost
   static const variable m_fwTimeoutError("er98");          // Time out during send of a command
   static const variable m_fwIsInitialized("qw1");          // QW answere, initialize = flag == 1
   static const variable m_noStarConnectionError("er03");   // No connection to star

	// definition for USB component
   static variable   m_HHCUsbObjectName("HamHeaterCoolerUSB.USB");   // name of USB component
   // "{BD0DAB87-838B-44c5-A114-1CBA5BE0E45F}", bufferSize(4090), vendorId(2223), productId(32770), serialNumber(00));
   static variable   m_HHCUsbProductNum(32770);             // productId and serialNumber as string 
   static variable   m_HHCUsbSerieNum("00");             	// productId and serialNumber as string 


	// --------------------------------------------------------------------------------------
	// Module globale constants/variables
	// --------------------------------------------------------------------------------------
	static global variable  m_HHCCriticalSection(0);   // critical section object for library synchronization 
   static global object    m_usbHCComObject;            // USB device object 

	// --------------------------------------------------------------------------------------
	// Module local constants/variables which must be locked during set / get
	// --------------------------------------------------------------------------------------
   static variable m_isStringTableInitialized(hslFalse);   			// flag for init string table
	static global variable m_initializedHeaterCoolerLib(hslFalse);				   // initialization state of the HSL HamHeaterCooler library
	static global variable m_isSimulateHeater(hslFalse);                 // flag for simulate mode of heater Cooler
   static global variable m_usbHeaterTrace(hslTrue);							// flag vor trace the send and receive from USB device
	static global variable m_initializedHeaterCooler[](m_maxHHC);        // initialization state of the used device
   //static global variable m_shakingDirection[](m_maxHHC);          Shaking direction left/right (0/1)
   //static global variable m_shakingAccRamp[](m_maxHHC);           // Acceleration ramp (rpm)
   //static global variable m_shakingTimeOut[](m_maxHHC);           // Time out for waiting function after StartTimed 0 = not started
   static global variable m_tempHCStartTimeOut[](m_maxHHC);         // Time to elapse until the time controlling is satrt
   static global variable m_tempHCToleranceRange[](m_maxHHC);       // Tolerance of incubation temperature
   static global variable m_tempHCSecurityRange[](m_maxHHC);        // Security tolerance before the heater is automatic switched off
   //static global variable m_userShakingSpeed[](m_maxHHC);          The given speed from start function
   static global variable m_userHCTemperature[](m_maxHHC);         	// The given temperature from start function

	// device management
	// note: the assigned deviceNumber correspond with the array index (deviceNumber-1 == arrayIndex)
	static global variable m_deviceHCName[](m_maxHHC);					// Name of ML_STAR or "USB" on USB
	static global variable m_nodeHCNumber[](m_maxHHC);					// can node number 1 based
	static global object   m_starHCDeviceObj[](m_maxHHC);				// object of ML_STAR device, for USB use m_usbHCComObject
	static global variable m_isStarHCSimulate[](m_maxHHC);				// ML_STAR is in simulate mode
	static global variable m_HHCSetting[](m_maxHHC);					// 0..2, 0=both, 1=onlyHeat, 2=onlyShake
   static global variable m_selfDiagnostics[](m_maxHHC);          // Self diagnositc flags set to.

	static function saveAndCreateDeviceNumber(variable funcId, variable deviceName,
			object& starObject, variable isStarSimulate,	variable usedNode);
   // m_initializedHeaterCooler value with data access lock
 	static function isSimulate(variable funcId, variable deviceNumber, variable makeTrace );
   // uses node from 0 to 9
   static function isHeaterInitialized(variable deviceNumber); 
   // uses node from 0 to 9
   static function setHeaterInitialized(variable deviceNumber);

	// definitions for Monitoring function
   static const variable m_minSampleInterval(5);
   static const variable m_maxSampleInterval(300);

   // Prepare the globals for the hsl thread.
   static global event	  m_monitorHCStartEvent;
   static global variable m_monitorHCDeviceNumber;
   static global variable m_monitorCoolerMin;
   static global variable m_monitorCoolerMax;
	static global variable m_monitorHeaterCoolerMin;
	static global variable m_monitorHeaterCoolerMax;
   static global variable m_monitorHCSampleInterval;
   static global variable m_monitorHCAction;
   static global event	  m_monitorHCEvent[](m_maxHHC);
   static global variable m_monitorHCResult[](m_maxHHC);

	// --------------------------------------------------------------------------------------
	// Firmware Error Ids
	// --------------------------------------------------------------------------------------
	namespace IDE
	{
		static const variable first(0);						            // guard
		static const variable noError(first);								// No error
      static const variable retErr(first + 1);							// fatalError
      static const variable retNotInitErr(first + 2);					// node not initialized
      static const variable retNotConnectErr(first + 3);				// device not connected
		static const variable canError(first + 4);					   // No communication to CAN node
		static const variable eepromError(first + 5);				   // No communication to EEPROM
		static const variable syntaxCmdError(first + 6);			   // Unknown command
		static const variable syntaxParUnkError(first + 7);			// Unknown parameter.
		static const variable syntaxParRangeError(first + 8);			// Parameter out of range.
		static const variable generalVoltError(first + 9);			   // Voltage outside permitted range
		static const variable generalStopError(first + 10);			// Stop received
		static const variable generalAddrError(first + 11);			// Wrong system address
		static const variable parallelError(first + 12);				// Parallel commands are nor allowed
		static const variable CoolerInitError(first + 13);          // Cooler initialization failt
		static const variable CoolerNotInitError(first + 14);			// Cooler not initialized
		static const variable CoolerStepLossError(first + 15);		// Cooler step loss
		static const variable CoolerStartModeError(first + 16);     // Cooler is not started with timeout
		static const variable plateLockInitError(first + 17);			// Plate lock initialization failt
		static const variable plateLockNotInitError(first + 18);		// Plate lock not initialized
		static const variable plateLockStepLossError(first + 19);	// Plate lock step loss
		static const variable tempNotStartError(first + 20);		   // Temperature controlling not started
		static const variable tempTimeoutError(first + 21);	      // Timeout of temperature supervision
		static const variable tempSuperRangeError(first + 22);		// Temperature out of supervision range
		static const variable tempSecurRangeError(first + 23);	   // Temperature out of security range
		static const variable tempSensorError(first + 24);	         // Temperature out of security range
		static const variable commandSendTimeout(first + 25);	      // Time out occured on command ='%s'
		static const variable unknowFwError(first + 26);	         // Unknow firmware error = '%s'
      // none firmware errors
		static const variable noStringValue(first + 27);	         // Wrong type of parameter; '%s1(%s2)' must be a sting..
		static const variable noIntegerValue(first + 28);	         // Wrong type of parameter; '%s1(%s2)' must be a whole number.
		static const variable noDoubleValue(first + 29);	         // Wrong type of parameter; '%s1(%s2)' must be a whole or decimal number.
      static const variable neededNodeNotAvailable(first + 30);	// Node '%s1' not found, please set it to 0 on parameter '%s2' at position '%s3'.
      static const variable unknownResultFormat(first + 31);      // Unknown format of firmware result string.\r\nExpected: '%s1'.\r\nReceived: '%s2'.
      static const variable wrongParameterLength(first + 32);     // Wrong length of input parameter.\r\nParameter = '%s1' length (%s2).\r\nExpected lenght (%s3).

		static const variable last(first + 32);							// guard
	}


	// --------------------------------------------------------------------------------------
	// String Ids
	// --------------------------------------------------------------------------------------
	namespace IDS
	{
		static const variable first(IDE::last + 1);					   // guard
		static const variable traceSource(first);						   // Text: "SYSTEM", source for formated trace
		static const variable helpFileName(first + 1);		         // Text: "HSLHAMHEATERCoolerLIB%s.CHM", language independend language name
		static const variable sendMessageTitle(first + 2);				// Text: "Send message = "
		static const variable receiveMessageTitle(first + 3);		   // Text: "Received answere = "
		static const variable setSimulate(first + 4);					// Text: "Set simulate mode = "
		static const variable starNode(first + 5);					   // Text: "ML_Star node"
		static const variable usbNode(first + 6);					      // Text: "USB node"
		static const variable noUsbConnection(first + 7);	         // Text: "No connection to USB device."
		static const variable parameterOutOfRange(first + 8);	      // Text: "Parameter out of range; '%s1(%s2)' must be between [%s3..%s4]."
      static const variable neededNodeNotInitialized(first + 9);	// Text: "Node '%s1' not initialized'."
      static const variable setTrace(first + 10);						// Text:	"Set USB trace mode = "
		static const variable firmwareVersion(first + 11);				// Text: "%s1 '%s2' firmware version = "
		static const variable cannotCreateUsbPort(first + 12);	   // Text: "USB communication cannot be created."
      static const variable timeoutDuringWaitCooler(first + 13);  // Text: "Time out during wait for end shaking. Shaking will be stop."
      static const variable progressSendTo(first + 14);           // Text: "Send command to %s1 ( %s2 )."
      static const variable startTimeout(first + 15);             // Text: "Start time out = "
      static const variable toleranceRange(first + 16);           // Text: "Temperature range = "
      static const variable securityRange(first + 17);            // Text: "Security range = "
      static const variable shakingDirection(first + 18);         // Text: "Shaking direction = "
      static const variable shakingSpeed(first + 19);             // Text: "Shaking speed = "
      static const variable shakingAccRamp(first + 20);           // Text: "Shaking acceleration ramp = "
      static const variable sendToStar(first + 21);               // Text: "HSLHamHeaterCoolerLib::SendToStar"
      static const variable sendToUsb(first + 22);                // Text: "HSLHamHeaterCoolerLib::SendToUsb"
      static const variable invalidStarDevice(first + 23);      	// Text: "Parameter 'starDevice' contains an invalid object."
      static const variable invalidDeviceNumber(first + 24);      // Text: "Parameter 'deviceNumber' contains an invalid value! \r\nMust be created with function Connect() or CreateUsbDevice()"
      static const variable maxHHCReached(first + 25);      		// Text: "Cannot create the deviceNumber; Maximum count of usable HHC is reached."
      static const variable shakingNotActivated(first + 26);      // Text: "Current HHC module on %s1 '%s2' cannot used as Cooler.");
      static const variable heatingNotActivated(first + 27);      // Text: "Current HHC module on %s1 '%s2' cannot used as heater.");
      static const variable monitoringShakingTitle(first + 28);   // Text: "Current speed (RPM) = ");
      static const variable monitoringTempTitle(first + 29);      // Text: "Current temperature = ");
      static const variable monitoringTempHeatUpTitle(first + 30);// Text:	"Current temperature (heating up mode) = ");
      static const variable monitoringStateTitle(first + 31);		// Text:	"Current monitored state = ");
      static const variable monitoringWarning(first + 32);			// Text:	"Warning: ");
      static const variable monitoringShNotStart(first + 33);		// Text:	"Shaking not started, check of speed limit will be disabled!");
      static const variable monitoringHeNotStart(first + 34);		// Text:	"Heating up not started, check of temperature limit will be disabled!");
      static const variable monitoringAbort(first + 35);				// Text:	"Heating or shaking is out of range; Method will be abort!");

		static const variable last(first + 35);						   // guard
	}

	// --------------------------------------------------------------------------------------
	// Function Ids
	// --------------------------------------------------------------------------------------
	namespace IDF
	{
      // do not change the sort of this list of function and his IDs
		static const variable first(IDS::last + 1);					   // guard
		static const variable Connect(first);		         // Text: "HSLHamHeaterCoolerLib - Connect"
		static const variable CreateUsbDevice(first+1);		         // Text: "HSLHamHeaterCoolerLib - CreateUsbDevice"
		static const variable Terminate(first + 2);				      // Text: "HSLHamHeaterCoolerLib - Terminate"

		static const variable StartCooler(first + 3);				   // Text: "HSLHamHeaterCoolerLib - StartCooler"
		static const variable StopCooler(first + 4);		            // Text: "HSLHamHeaterCoolerLib - StopCooler"
		static const variable StartCoolerTimed(first + 5);		      // Text: "HSLHamHeaterCoolerLib - StartCoolerTimed"
		static const variable WaitForCooler(first + 6);		         // Text: "HSLHamHeaterCoolerLib - WaitForCooler"
		static const variable StartAllCooler(first + 7);		      // Text: "HSLHamHeaterCoolerLib - StartAllCooler"
		static const variable StartAllCoolerTimed(first + 8);		   // Text: "HSLHamHeaterCoolerLib - StartAllCoolerTimed"
		static const variable StopAllCooler(first + 9);		         // Text: "HSLHamHeaterCoolerLib - StopAllCooler"
		static const variable SetCoolerParameter(first + 10);		   // Text: "HSLHamHeaterCoolerLib - SetCoolerParameter"
		static const variable GetCoolerParameter(first + 11);		   // Text: "HSLHamHeaterCoolerLib - GetCoolerParameter"
		static const variable GetCoolerSpeed(first + 12);	   		// Text: "HSLHamHeaterCoolerLib - GetCoolerSpeed"

		static const variable SetTemperatureControl(first + 13);	   // Text: "HSLHamHeaterCoolerLib - SetTemperatureControl"
		static const variable StopTemperatureControl(first + 14);   // Text: "HSLHamHeaterCoolerLib - StopTempCtrl"
		static const variable WaitForTempCtrl(first + 15);		      // Text: "HSLHamHeaterCoolerLib - WaitForTempCtrl"
		static const variable GetTemperature(first + 16);		      // Text: "HSLHamHeaterCoolerLib - GetTemperature"
		static const variable GetTemperatureState(first + 17);		// Text: "HSLHamHeaterCoolerLib - GetTemperatureState"
		static const variable SetTempParameter(first + 18);	      // Text: "HSLHamHeaterCoolerLib - SetTempParameter"
		static const variable GetTempParameter(first + 19);	      // Text: "HSLHamHeaterCoolerLib - GetTempParameter"

		static const variable SetSelfDiagnostic(first + 20);		   // Text: "HSLHamHeaterCoolerLib - SetSelfDiagnostic"
		static const variable GetFirmwareVersion(first + 21);	      // Text: "HSLHamHeaterCoolerLib - GetFirmwareVersion"
		static const variable GetSerialNumber(first + 22);		      // Text: "HSLHamHeaterCoolerLib - GetSerialNumber"
		static const variable BeginMonitoring(first + 23);		      // Text: "HSLHamHeaterCoolerLib - BeginMonitoring"
		static const variable EndMonitoring(first + 24);		      // Text: "HSLHamHeaterCoolerLib - EndMonitoring"

		static const variable SendFirmwareCommand(first + 25);	   // Text: "HSLHamHeaterCoolerLib - SendFirmwareCommand"
		static const variable SetSimulation(first + 26);		      // Text: "HSLHamHeaterCoolerLib - SetSimulation"
		static const variable SetUSBTrace(first + 27);					// Text: "HSLHamHeaterCoolerLib - SetUSBTrace"


		static const variable Monitoring(first + 28);					// Text: "HSLHamHeaterCoolerLib - Monitoring"

		static const variable last(first + 28);						   // guard
	}

	// --------------------------------------------------------------------------------------
	// Exception handling
	// --------------------------------------------------------------------------------------

	namespace Error
	{
		static function Raise(												// raises a runtime error
			variable errorId,													// i: error id, one of IDE
			variable& fileName,												// i: file name
			variable& funcName,												// i: function name
			variable& lineNumber)											// i: line number
		{
			variable description("");
			string hlpFileName;

			// set error description
			if ("" == funcName)
				description = fileName + "(" + lineNumber + ") : " + StringTable::Load(errorId);
			else
				description = fileName + "(" + lineNumber + ") : " + funcName + "()\n" + StringTable::Load(errorId);
			err.SetDescription(description);

			hlpFileName = StringTable::Load(IDS::helpFileName);
			StrReplace(hlpFileName, "%s", GetLanguage());
			// raise error
			err.Raise(errorId, err.GetDescription(), hlpFileName);
		}

		static function RaiseEx(											// raises a runtime error
			variable errorId,													// i: error id, one of IDE
			variable errorDesc,												// i: error description
			variable& fileName,												// i: file name
			variable& funcName,												// i: function name
			variable& lineNumber)											// i: line number
		{
			variable description("");
			string hlpFileName;

			// set error description
			if ("" == funcName)
				description = fileName + "(" + lineNumber + ") : " + errorDesc;
			else
				description = fileName + "(" + lineNumber + ") : " + funcName + "()\n" + errorDesc;
			err.SetDescription(description);

			hlpFileName = StringTable::Load(IDS::helpFileName);
			StrReplace(hlpFileName, "%s", GetLanguage());
			// raise error
			err.Raise(errorId, err.GetDescription(), hlpFileName);
		}

		static function RaiseLast()										// re-throws the last runtime error
		{
			// re-raise error
			err.Raise();
		}
	}

	/****************************************************************************************
	*	
	* Internal helper function declaration
	*
	****************************************************************************************/
	static function initHamHeaterCoolerLib(variable funcId, variable deviceNumber, variable initCooler);
   static function checkStringInput(variable funcId, variable parameterName, variable input);
   static function checkIntegerInput(variable funcId, variable parameterName, variable input);
   static function checkIntegerInputRange(variable funcId, variable parameterName, variable input, variable min, variable max);
   static function checkDoubleInput(variable funcId, variable parameterName, variable input);
   static function checkDoubleInputRange(variable funcId, variable parameterName, variable input, variable min, variable max);
	static function isStarDevice(variable deviceNumber);
	static function getNodeFromDeviceNumber(variable deviceNumber);
	static function checkDeviceNumber(variable funcId, variable deviceNumber);
	static function setHHCSetting(variable funcId, variable deviceNumber, variable& HHCSetting);
	static function hasHeater(variable funcId, variable deviceNumber, variable throw);
	//static function hasCooler(variable funcId, variable deviceNumber, variable throw);
   static function sendMsg(variable deviceNumber, variable command, variable parameter, variable timeOut, variable makeTrace);
   static function sendToUsb(variable deviceNumber, variable command, variable parameter, variable timeOut);
   static function sendToStar(variable deviceNumber, variable cmd, variable param, variable makeTrace);
   static function startTrace(variable funcName) void;
   static function progressTrace(variable funcName, variable progMsgTitle, variable progMsg) void;
   static function errorTrace(variable funcName, variable errMsg) void;
   static function errorCompleteTrace(variable funcName, variable errMsg) void;
   static function endTrace(variable funcName) void;
   static function getSendState(variable funcId, variable deviceNumber, variable isCooler);
   static function isFirmwError(variable funcId, string cmdResult, variable makeTrace);
   static function startPlateLockCmd(variable funcId, variable deviceNumber, variable plateLock);
   static function startShakingCmd(variable funcId, variable deviceNumber, variable command, variable parameter, variable isStart);
   synchronized function monitorHeaterCooler();
	static function wait(variable waitTime);
	static function getCurrentCoolerRPM(variable deviceNumber, variable makeTrace);
	static function getCurrentTemp(variable deviceNumber, variable makeTrace);
	static function pollingForRunningCooler(variable deviceNumber, variable maxPollingTime);
	static function pollingForRunningHeater(variable deviceNumber, variable maxPollingTime);
	static function OnAbortHHCLibrary();

   static function versionTrace() void;
	// this function is used in InitializeLibrary() and uses index 0..10
	static function traceFirmwareVersion(variable funcId, variable deviceNumber);
   static function sendToProgressTrace(variable funcName, variable deviceNumber) void;

   // get the given parameter with filled 0 before value
	static function formatParam(variable param, variable strWidth);
   // returns the given parameter normalized (*10) for firmware command as string
	static function normalizeParam(variable param, variable strWidth);

   function SetSelfDiagnostic(variable deviceNumber, variable onOrOffFlag);  
	/****************************************************************************************
	*	
	* Interface functions
	*
	****************************************************************************************/

   //====================================================================
	//
	// Application function Connect()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Initialize Cooler/heater module on ML_Star device.
   //  Only NOT initialized nodes will be initialize, the function will
   //  check first the initialization state before.
   //....................................................................
   // Parameters:
   //  in : starDevice   : Used STAR device for node T1 and T2 of STAR
   //  in : usedNode     : Node which must be create and initialized. (1 or 2)
	//	 out: deviceNumber : generated device number which must be used in all other functions
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
	function Connect(
		device& starDevice,						// in:  ML_STAR device
		variable usedNode,						// in:  node ID (1 or 2)
		variable& deviceNumber)					// out: generated deviceNumber
	{
      variable funcRc(IDE::noError);
      variable funcId("Connect");
		variable deviceName;
		variable isSimulate(m_ON);
		variable isStarSimulate(hslFalse);
		variable shakingProperty(0);
		object	starObject;

      versionTrace();
      startTrace(funcId);

		// check input parameter
		checkIntegerInputRange(funcId, "usedNode", usedNode, m_firstStarNode, m_lastStarNode);

		onerror goto DeviceError;
		deviceName = starDevice.GetInstrumentName();
		isSimulate = starDevice.GetCfgValueWithKey(m_starSimulateModeKey);
		starObject = starDevice.GetCommandObject();
		onerror goto 0;

		if(starObject.IsNull())
		{
         string msg;
         variable funcName;
			// "Parameter 'starDevice' contains an invalid object."
         msg = StringTable::Load(IDS::invalidStarDevice);
         funcName = StringTable::Load(funcId);

         errorCompleteTrace(funcId, msg);
			Error::RaiseEx(IDE::retErr, msg, GetFileName(), funcName, GetLineNumber());
		}

      if(GetType(isSimulate) == "i")
      {
         if(isSimulate != m_OFF)
            isStarSimulate = hslTrue;
      }

		// initialize the library variables
		funcRc = initHamHeaterCoolerLib(funcId, deviceNumber, m_OFF);
      if(0 < funcRc)
         return (funcRc);

		deviceNumber = saveAndCreateDeviceNumber(funcId, deviceName, starObject, isStarSimulate, usedNode);

		// initialize the Cooler
		funcRc = initHamHeaterCoolerLib(funcId, deviceNumber, m_ON);
      if(0 < funcRc)
         return (funcRc);

      //Set base diagnostic flag
      funcRc = SetSelfDiagnostic(deviceNumber, m_selfDiagnostics[deviceNumber]);
      if(0 < funcRc)
         return(funcRc);

      endTrace(funcId);
		return (funcRc);

		DeviceError:
		{
         string msg;
         variable funcName;
			// "Parameter 'starDevice' contains an invalid object."
         msg = StringTable::Load(IDS::invalidStarDevice);
         funcName = StringTable::Load(funcId);

         errorCompleteTrace(funcId, msg);
			Error::RaiseEx(IDE::retErr, msg, GetFileName(), funcName, GetLineNumber());
		}
	}

   //====================================================================
	//
	// Application function StartTemperatureControl()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Set incubation temperature and wait (if set) until temperature is reached
   //....................................................................
   // Parameters:
   //  deviceNumber :  device number which was generated on CreateXXDevice() 
   //  temperature         :  Incubation temperature
   //  waitForTempReached  :  Flag for waiting until temperature is reached
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function SetTemperatureControl(
      variable deviceNumber,
      variable temperature,
      variable waitForTempReached)
   {
      variable funcRc(IDE::noError);
      variable funcId("SetTemperatureControl");
      variable tempStartTimeOut;
      variable tempToleranceRange;
      variable tempSecurityRange;
      variable command("TA");
      variable parameter("ta%s1tb%s2tc%s3td%s4");
      variable cmdResult;
         
      startTrace(funcId);

		checkDeviceNumber(funcId, deviceNumber);
      //tb 2008-12-03 checkDoubleInputRange(funcId, "temperature", temperature, TemperateParam::tempMin, TemperateParam::tempMax);
      checkDoubleInput(funcId, "temperature", temperature);
      checkIntegerInputRange(funcId, "waitForTempReached", waitForTempReached, m_OFF, m_ON);

      initHamHeaterCoolerLib(funcId, deviceNumber, m_OFF);

		hasHeater(funcId, deviceNumber, 1);

		// activate error handler
		onerror goto Unexpected;

      SynEnterCriticalSection(m_HHCCriticalSection);
      tempStartTimeOut = m_tempHCStartTimeOut.GetAt(deviceNumber-1);
      tempToleranceRange = m_tempHCToleranceRange.GetAt(deviceNumber-1);
      tempSecurityRange = m_tempHCSecurityRange.GetAt(deviceNumber-1);
		m_userHCTemperature[deviceNumber-1] = temperature;
      SynLeaveCriticalSection(m_HHCCriticalSection);

      StrReplace(parameter, "%s1", normalizeParam(temperature, TemperateParam::paramLength));
      StrReplace(parameter, "%s2", formatParam(tempStartTimeOut, TemperateParam::paramLength));
      StrReplace(parameter, "%s3", normalizeParam(tempToleranceRange, TemperateParam::paramLength));
      StrReplace(parameter, "%s4", normalizeParam(tempSecurityRange, TemperateParam::paramLength));

      sendToProgressTrace(funcId, deviceNumber);

      if(isSimulate(funcId, deviceNumber, hslTrue))
         return (IDE::noError);

      // check for initialized and connect
      //funcRc = getSendState(funcId, deviceNumber, hslFalse);
      //if(0 < funcRc)
         //return (funcRc);

      // add 60 seconds to the started heat up time (secure that the heat up time out is reached before the wait time out)
      tempStartTimeOut = tempStartTimeOut + m_waitTimeOutSecurity;
      if(tempStartTimeOut < m_usbMsgTimeout)
         tempStartTimeOut = m_usbMsgTimeout;


      #ifdef _DEBUG
      progressTrace(funcId, "Function timeout = ", IStr(tempStartTimeOut));
      #endif

      // set temperature
      cmdResult = sendMsg(deviceNumber, command, parameter, tempStartTimeOut, hslTrue);

      funcRc = isFirmwError(funcId, cmdResult, hslFalse);

		// command waits until temperature is in controlling mode
      if(waitForTempReached == m_ON && funcRc == IDE::noError)
		{
			pollingForRunningHeater(deviceNumber, tempStartTimeOut-m_waitTimeOutSecurity);

	      // wait for temperature
	      cmdResult = sendMsg(deviceNumber, "TW", "", m_usbMsgTimeout, hslTrue);
		}

      funcRc = isFirmwError(funcId, cmdResult, hslTrue);
      if(0 < funcRc)
         return (funcRc);

      endTrace(funcId);
      return (funcRc);

		Unexpected:
		{
         SynLeaveCriticalSection(m_HHCCriticalSection);
   		Error::RaiseLast();
      }
   }

   //====================================================================
	//
	// Application function StopTemperatureControl()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Set incubation temperature control off
   //....................................................................
   // Parameters:
   //  deviceNumber :  device number which was generated on CreateXXDevice() 
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function StopTemperatureControl(
      variable deviceNumber)
   {
      variable funcRc(IDE::noError);
      variable funcId("StopTemperatureControl");
      variable command("TO");
      variable parameter("");
      variable cmdResult;
         
      startTrace(funcId);

		checkDeviceNumber(funcId, deviceNumber);

      initHamHeaterCoolerLib(funcId, deviceNumber, m_OFF);

		hasHeater(funcId, deviceNumber, 1);

      sendToProgressTrace(funcId, deviceNumber);

      if(isSimulate(funcId, deviceNumber, hslTrue))
         return (IDE::noError);

      // check for initialized and connect
      //funcRc = getSendState(funcId, deviceNumber, hslFalse);
      //if(0 < funcRc)
         //return (funcRc);

      // set temperature
      cmdResult = sendMsg(deviceNumber, command, parameter, m_usbMsgTimeout, hslTrue);

      SynEnterCriticalSection(m_HHCCriticalSection);
   	m_userHCTemperature[deviceNumber-1] = 0;
		SynLeaveCriticalSection(m_HHCCriticalSection);

      funcRc = isFirmwError(funcId, cmdResult, hslTrue);
      if(0 < funcRc)
         return (funcRc);

      endTrace(funcId);
      return (funcRc);
   }
 //====================================================================
	//
	// Application function TurnOnOrOffDisplay()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Turns on or off the display of the selected HHC device
   //....................................................................
   // Parameters:
   //  deviceNumber :  device number which was generated on Connect 
   //  onOrOffFlag: Flag that when 0 states to turn off the display and 1 to enable it.
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function TurnOnOrOffDisplay(
      variable deviceNumber,
      variable onOrOffFlag)
   {
      variable funcRc(IDE::noError);
      variable funcId("TurnOnOrOffDisplay");
      variable command("DE");
      variable parameter("de%s1");
      variable cmdResult;
         
      startTrace(funcId);

		checkDeviceNumber(funcId, deviceNumber);
    checkIntegerInputRange(funcId, "onOrOffFlag", onOrOffFlag, m_OFF, m_ON);

      initHamHeaterCoolerLib(funcId, deviceNumber, m_OFF);

		hasHeater(funcId, deviceNumber, 1);

    StrReplace(parameter, "%s1", IStr(onOrOffFlag));

      sendToProgressTrace(funcId, deviceNumber);

      if(isSimulate(funcId, deviceNumber, hslTrue))
         return (IDE::noError);

      // set display states
      cmdResult = sendMsg(deviceNumber, command, parameter, m_usbMsgTimeout, hslTrue);

      funcRc = isFirmwError(funcId, cmdResult, hslTrue);
      if(0 < funcRc)
         return (funcRc);

      endTrace(funcId);
      return (funcRc);
   }

 //====================================================================
	//
	// Application function Identify()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Turns on and off the display of the selected HHC device displaying
   //  its dip switch addresss
   //....................................................................
   // Parameters:
   //  deviceNumber :  device number which was generated on Connect
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function Identify(
      variable deviceNumber)
   {
      variable funcRc(IDE::noError);
      variable funcId("Identify");
      variable command("IF");
      variable parameter("");
      variable cmdResult;
      timer delayTimer;
         
      startTrace(funcId);

		checkDeviceNumber(funcId, deviceNumber);

      initHamHeaterCoolerLib(funcId, deviceNumber, m_OFF);

      sendToProgressTrace(funcId, deviceNumber);

      if(isSimulate(funcId, deviceNumber, hslTrue))
         return (IDE::noError);

      // identify
      cmdResult = sendMsg(deviceNumber, command, parameter, m_usbMsgTimeout, hslTrue);

      funcRc = isFirmwError(funcId, cmdResult, hslTrue);
      if(0 < funcRc)
         return (funcRc);

      delayTimer.SetTimer(10);
      delayTimer.WaitTimer();

      endTrace(funcId);
      return (funcRc);
   }

//====================================================================
	//
	// Application 
   // SetSelfDiagnostic()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Sets the self diagnostics flag on selected HHC device
   //....................................................................
   // Parameters:
   //  deviceNumber :  device number which was generated on Connect 
   //  onOrOffFlag: Flag that when 0 states to set the diagnostic flag to 
   //  disabled and 1 to enable it.
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function SetSelfDiagnostic(
      variable deviceNumber,
      variable onOrOffFlag)
   {
      variable funcRc(IDE::noError);
      variable funcId("SetSelfDiagnostic");
      variable command("SD");
      variable parameter("sd%s1");
      variable cmdResult;
         
      startTrace(funcId);

		checkDeviceNumber(funcId, deviceNumber);
    //checkIntegerInputRange(funcId, "onOrOffFlag", onOrOffFlag, m_ON, m_OFF);

      initHamHeaterCoolerLib(funcId, deviceNumber, m_OFF);

		hasHeater(funcId, deviceNumber, 1);

    StrReplace(parameter, "%s1", IStr(onOrOffFlag));

      sendToProgressTrace(funcId, deviceNumber);

      if(isSimulate(funcId, deviceNumber, hslTrue))
         return (IDE::noError);

      cmdResult = sendMsg(deviceNumber, command, parameter, m_usbMsgTimeout, hslTrue);

      funcRc = isFirmwError(funcId, cmdResult, hslTrue);
      if(0 < funcRc)
         return (IDE::retErr);

	  m_selfDiagnostics[deviceNumber] = onOrOffFlag;

      endTrace(funcId);
      return (IDE::noError);
   }

//====================================================================
	//
	// Application function GetSelfDiagnostic()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Get self diagnostics flag of current HHC
   //  
   //....................................................................
   // Parameters:
   //  in : deviceNumber 		:  device number which was generated on CreateXXDevice() 
   //  out: diagnosticFlag: Flag that when 0 states to turn off the display and 1 to enable it.
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function GetSelfDiagnostic(
				variable deviceNumber,
				variable& diagnosticFlag)
	{
      variable funcRc(IDE::noError);
      variable funcId("GetSelfDiagnostic");
		string 	answString;
		variable startPos;

      startTrace(funcId);

		checkDeviceNumber(funcId, deviceNumber);
      diagnosticFlag = m_OFF;

      funcRc = initHamHeaterCoolerLib(funcId, deviceNumber, m_OFF);
      if(0 < funcRc)
         return (funcRc);

      sendToProgressTrace(funcId, deviceNumber);

      if(isSimulate(funcId, deviceNumber, hslTrue))
         return (IDE::noError);

		// read the firmware version of current node
		
         diagnosticFlag = m_selfDiagnostics[deviceNumber];    

      endTrace(funcId);
      return (funcRc);
	}

   //====================================================================
	//
	// Application function SetDisplayBrightness()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Turns on or off the display of the selected HHC device
   //....................................................................
   // Parameters:
   //  deviceNumber :  device number which was generated on Connect 
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function SetDisplayBrightness(
      variable deviceNumber,
      variable brightness)
   {
      variable funcRc(IDE::noError);
      variable funcId("SetDisplayBrightness");
      variable command("DB");
      variable parameter("db%s1");
      variable cmdResult;
      variable convertedBrightness;
         
      startTrace(funcId);

		checkDeviceNumber(funcId, deviceNumber);
    checkIntegerInputRange(funcId, "brightness", brightness, 0, 100);

      initHamHeaterCoolerLib(funcId, deviceNumber, m_OFF);

		hasHeater(funcId, deviceNumber, 1);

      convertedBrightness = ((255 * brightness) / 100);

      StrReplace(parameter, "%s1", IStr(convertedBrightness));

      sendToProgressTrace(funcId, deviceNumber);

      if(isSimulate(funcId, deviceNumber, hslTrue))
         return (IDE::noError);

      // set temperature
      cmdResult = sendMsg(deviceNumber, command, parameter, m_usbMsgTimeout, hslTrue);

      funcRc = isFirmwError(funcId, cmdResult, hslTrue);
      if(0 < funcRc)
         return (funcRc);

      endTrace(funcId);
      return (funcRc);
   }

   //====================================================================
	//
	// Application function GetTemperature()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Get the current temperatur
   //....................................................................
   // Parameters:
   //  deviceNumber :  device number which was generated on CreateXXDevice() 
   //  temperature         :  Actual carrier temperature 
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function GetTemperature(
      variable deviceNumber,
      variable& temperature)
   {
      variable funcRc(IDE::noError);
      variable funcId("GetTemperature");

      startTrace(funcId);

      temperature = 0;

		checkDeviceNumber(funcId, deviceNumber);

      initHamHeaterCoolerLib(funcId, deviceNumber, m_OFF);

		hasHeater(funcId, deviceNumber, 1);

      sendToProgressTrace(funcId, deviceNumber);

      if(isSimulate(funcId, deviceNumber, hslTrue))
         return (IDE::noError);

		temperature = getCurrentTemp(deviceNumber, hslTrue);

      endTrace(funcId);
      return (funcRc);
   }

   


   //====================================================================
	//
	// Application function GetFirmwareVersion()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Get firmware version of current HHC
   //  
   //....................................................................
   // Parameters:
   //  in : deviceNumber 		:  device number which was generated on CreateXXDevice() 
   //  out: firmwareVersion   :  firmware version format: "1.0P 1999-03-10"
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function GetFirmwareVersion(
			variable deviceNumber,
			variable& firmwareVersion)
	{
      variable funcRc(IDE::noError);
      variable funcId("GetFirmwareVersion");
		string 	answString;
		variable startPos;
      
      startTrace(funcId);

		checkDeviceNumber(funcId, deviceNumber);
      firmwareVersion = "0.0S 2019-01-01";

      funcRc = initHamHeaterCoolerLib(funcId, deviceNumber, m_OFF);
      if(0 < funcRc)
         return (funcRc);

      sendToProgressTrace(funcId, deviceNumber);

      if(isSimulate(funcId, deviceNumber, hslTrue))
         return (IDE::noError);

		// read the firmware version of current node
		answString = sendMsg(deviceNumber, "RF", "", m_usbInitTimeout, hslTrue);

		startPos = answString.Find("rf");
		if(startPos >= 0)
		{
			firmwareVersion = answString.Right(answString.GetLength()-(startPos+2));
		}

      endTrace(funcId);
      return (funcRc);
	}


   //====================================================================
	//
	// Application function GetSerialNumber()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Get serial number of current HHC
   //  
   //....................................................................
   // Parameters:
   //  in : deviceNumber 		:  device number which was generated on CreateXXDevice() 
   //  out: firmwareVersion   :  firmware serial number format: "####"
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function GetSerialNumber(
				variable deviceNumber,
				variable& serialNumber)
	{
      variable funcRc(IDE::noError);
      variable funcId("GetSerialNumber");
		string 	answString;
		variable startPos;

      startTrace(funcId);

		checkDeviceNumber(funcId, deviceNumber);
      serialNumber = "0000";

      funcRc = initHamHeaterCoolerLib(funcId, deviceNumber, m_OFF);
      if(0 < funcRc)
         return (funcRc);

      sendToProgressTrace(funcId, deviceNumber);

      if(isSimulate(funcId, deviceNumber, hslTrue))
         return (IDE::noError);

		// read the firmware version of current node
		answString = sendMsg(deviceNumber, "QT", "", m_usbInitTimeout, hslTrue);

		// format: er00###/###/######### part number, revision, serial number
		startPos = answString.Find("er00");
		if(startPos >= 0 && answString.GetLength() > startPos+12)
		{
         serialNumber = answString.Mid((startPos+12),9);
		}

      

      endTrace(funcId);
      return (funcRc);
	}

//====================================================================
	//
	// Application function GetVerificationDate()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Get verification date of current HHC
   //  
   //....................................................................
   // Parameters:
   //  in : deviceNumber 		:  device number which was generated on CreateXXDevice() 
   //  out: verificationDate  :  date that the device is last verified
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function GetVerificationDate(
				variable deviceNumber,
				variable& verificationDate)
	{
      variable funcRc(IDE::noError);
      variable funcId("GetVerificationDate");
		string 	answString;
		variable startPos;

      startTrace(funcId);

		checkDeviceNumber(funcId, deviceNumber);
      verificationDate = "0000";

      funcRc = initHamHeaterCoolerLib(funcId, deviceNumber, m_OFF);
      if(0 < funcRc)
         return (funcRc);

      sendToProgressTrace(funcId, deviceNumber);

      if(isSimulate(funcId, deviceNumber, hslTrue))
         return (IDE::noError);

		// read the firmware version of current node
		answString = sendMsg(deviceNumber, "VD", "", m_usbInitTimeout, hslTrue);

		// format: VDidxxxxvdMMDDYYYY
		startPos = answString.Find("vd");

		if(startPos >= 0 && answString.GetLength() > startPos+9)
		{
         verificationDate = answString.Mid((startPos+9),8);
		}     

      endTrace(funcId);
      return (funcRc);
	}

//====================================================================
	//
	// Application function SetVerificationDate()
	//
   //--------------------------------------------------------------------
   // Description:
   //  set verification date of current HHC
   //  
   //....................................................................
   // Parameters:
   //  in : deviceNumber 		:  device number which was generated on CreateXXDevice() 
   //  in: verificationDate   :  date that the device is last verified needs to be a format of MMDDYYYY
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function SetVerificationDate(
				variable deviceNumber,
				variable verificationDate)
	{
      variable funcRc(IDE::noError);
      variable funcId("SetVerificationDate");
		string 	answString;
		variable startPos;

      startTrace(funcId);

		checkDeviceNumber(funcId, deviceNumber);
      
      funcRc = initHamHeaterCoolerLib(funcId, deviceNumber, m_OFF);
      if(0 < funcRc)
         return (funcRc);

      sendToProgressTrace(funcId, deviceNumber);

      if(isSimulate(funcId, deviceNumber, hslTrue))
         return (IDE::noError);

		// set the firmware version of current node
		funcRc = sendMsg(deviceNumber, "VS", "vs" + verificationDate, m_usbInitTimeout, hslTrue); 

      endTrace(funcId);
      return (funcRc);
	}

   //====================================================================
	//
	// Application function SetSimulation()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Set the internal flag m_isSimulateHeater.
   //  If this flag is set, only parameter checks are made on all exported function
   //  
   //....................................................................
   // Parameters:
   //  simulate   :  Flag for set the simulate mode, must be a number 0/1
   //
   // ...................................................................
   // return value:
   //  Raise      :  Wrong parameter 
   //....................................................................
   // Remarks:
   //   
	//====================================================================
 	function SetSimulation(variable simulate) void
	{
      variable funcId("SetSimulation");

      startTrace(funcId);

      checkIntegerInputRange(funcId, "simulate", simulate, m_OFF, m_ON);

  		progressTrace(funcId, IDS::setSimulate, IStr(simulate));

		// activate error handler
		onerror goto Unexpected;

      SynEnterCriticalSection(m_HHCCriticalSection);
      m_isSimulateHeater = hslFalse;
      if(simulate == m_ON)
		   m_isSimulateHeater = hslTrue;
      SynLeaveCriticalSection(m_HHCCriticalSection);

      endTrace(funcId);
      return;

		Unexpected:
		{
         SynLeaveCriticalSection(m_HHCCriticalSection);
   		Error::RaiseLast();
      }
	}


   //====================================================================
	//
	// Application function SendFirmwareCommand()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Send a command to the device
   //  
   //....................................................................
   // Parameters:
   //  deviceNumber :  device number which was generated on CreateXXDevice() 
   //  command				:  Firmware command without node name ( 2 letter )
   //  parameter			:  Parameter dependent of the used command
   // ...................................................................
   // return value:
   //  Raise            :  An exception is throw on wrong parameter or time out 
   //  string           :  Firmware command result data string
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function SendFirmwareCommand(
      variable deviceNumber,
      variable command, variable parameter)
   {
      variable funcRc(IDE::noError);
      variable funcId("SendFirmwareCommand");
      string   cmd;
      string   cmdResult;

      startTrace(funcId);

		checkDeviceNumber(funcId, deviceNumber);
      checkStringInput(funcId, "command", command);
      checkStringInput(funcId, "parameter", parameter);

      // check for two character as command
      cmd = command;
      if(cmd.GetLength() != m_firmwareCmdLength)
      {
         variable funcName;
         string errMsg;

         // "Wrong length of input parameter.\r\nParameter = '%s1' length (%s2).\r\nExpected lenght (%s3)."
         errMsg = StringTable::Load(IDE::wrongParameterLength);
         StrReplace(errMsg, "%s1", "command");
         StrReplace(errMsg, "%s2", IStr(cmd.GetLength()));
         StrReplace(errMsg, "%s3", IStr(m_firmwareCmdLength));

         funcName = StringTable::Load(funcId);

         Error::RaiseEx(IDE::wrongParameterLength, errMsg, GetFileName(), funcName, GetLineNumber());
      }

      funcRc = initHamHeaterCoolerLib(funcId, deviceNumber, m_ON);
      if(0 < funcRc)
         return (funcRc);

      sendToProgressTrace(funcId, deviceNumber);

      if(isSimulate(funcId, deviceNumber, hslTrue))
         return (IDE::noError);

     	// wait for temperature is reached
      cmdResult = sendMsg(deviceNumber, command, parameter, m_usbMsgTimeout, hslTrue);

      endTrace(funcId);
      return (cmdResult);
   }

   


	/****************************************************************************************
	*	
	* Internal helper function declaration
	*
	****************************************************************************************/


	// --------------------------------------------------------------------------------------
	// Library Initialization and data access functions
	// --------------------------------------------------------------------------------------
   static function initStringTable() void
   {
		// activate error handler
		onerror goto Unexpected;

		if(0 == m_HHCCriticalSection)
			m_HHCCriticalSection = SynInitializeCriticalSection();

      SynEnterCriticalSection(m_HHCCriticalSection);
      if(!m_isStringTableInitialized)
      {
			StringTable::Init("HSLHamHeaterCoolerStringTable");
         m_isStringTableInitialized = hslTrue;
      }
      SynLeaveCriticalSection(m_HHCCriticalSection);

      return;

		Unexpected:
		{
         SynLeaveCriticalSection(m_HHCCriticalSection);
   		Error::RaiseLast();
      }
   }

	static function InitializeNode(variable funcId, variable deviceNumber)
	{
      variable funcRc(IDE::noError);
		variable node;
      variable nodeNameId(IDS::starNode);

      // check if the library set to simulate
      if(isSimulate(funcId, deviceNumber, hslFalse))
         return(funcRc);

      // init node if needed      
      if(!isHeaterInitialized(deviceNumber))
      {  
         string answString;
			variable HHCSettings(-1);

			// on usb check connection
			if(!isStarDevice(deviceNumber))
			{            
            return (IDE::retNotConnectErr);
				//nodeNameId = IDS::usbNode;
			}

			// ask for settings
         setHHCSetting(funcId, deviceNumber, HHCSettings);
         if(0 < funcRc)
             return (funcRc);

			// check if shaking activated
			if((HHCSettings != m_shakingPropertyHeatAndShake) && (HHCSettings != m_shakingPropertyOnlyShake))
            return (funcRc);

         // init HHC on nodes if needed
			answString = sendMsg(deviceNumber, "QW", "", m_usbInitTimeout, hslTrue);

			if(isStarDevice(deviceNumber))
			{

            funcRc = isFirmwError(funcId, answString, hslTrue);
            if(0 < funcRc)
                return (funcRc);
			}

			node = getNodeFromDeviceNumber(deviceNumber);
     
         // check for timeout, if timeout, only node 0 is installed without any other CAN nodes
         // if CAN error, this node is not available
         if((answString.Find(m_fwTimeoutError) >= 0) || (answString.Find(m_fwCanError) >= 0))
         {
            // "%s1 '%s2' not available."
            string msg;
            string nodeName;
            variable funcName;
            msg = StringTable::Load(IDE::neededNodeNotAvailable);
            nodeName = StringTable::Load(nodeNameId);
            funcName = StringTable::Load(funcId);


            StrReplace(msg, "%s1", nodeName);
            StrReplace(msg, "%s2", IStr(node));
            errorCompleteTrace(funcId, msg);

            if(answString.Find(m_fwTimeoutError) >= 0)
               Error::RaiseEx(IDE::neededNodeNotAvailable, msg, GetFileName(), funcName, GetLineNumber());
            else
               Error::RaiseEx(IDE::canError, msg, GetFileName(), funcName, GetLineNumber());
         }

			traceFirmwareVersion(funcId, deviceNumber);
			
         if(answString.Find(m_fwIsInitialized) >= 0)
            setHeaterInitialized(deviceNumber);
         else
         {
            answString = sendMsg(deviceNumber, "LI", "", m_usbInitTimeout, hslTrue);
            sendMsg(deviceNumber, "LP", "lp1", m_usbInitTimeout, hslTrue);

            if(answString.Find(m_fwNoError) >= 0)
            {
	            answString = sendMsg(deviceNumber, "SI", "", m_usbInitTimeout, hslTrue);

               if(answString.Find(m_fwNoError) >= 0)
                  setHeaterInitialized(deviceNumber);

               sendMsg(deviceNumber, "LP", "lp0", m_usbInitTimeout, hslTrue);
            }

            funcRc = isFirmwError(funcId, answString, hslTrue);
            if(0 < funcRc)
               return (funcRc);
         }
      }

      return (funcRc);
   }


	static function initHamHeaterCoolerLib(variable funcId, variable deviceNumber, variable initCooler)
	{
      variable funcRc(IDE::noError);
      initStringTable();

		// activate error handler
		onerror goto Unexpected;

      SynEnterCriticalSection(m_HHCCriticalSection);

      if(!m_initializedHeaterCoolerLib)
      {
         variable nodeIndex(0);

			RegisterAbortHandler("HSLHamHeaterCooler::OnAbortHHCLibrary");

		   m_monitorHCDeviceNumber	= m_OFF;
		   m_monitorCoolerMin		= m_OFF;
		   m_monitorCoolerMax		= m_OFF;
		   m_monitorHCSampleInterval	= m_OFF;
		   m_monitorHCAction			= m_OFF;

         for( nodeIndex = 0; nodeIndex < m_maxHHC; nodeIndex++)
         {
            m_initializedHeaterCooler[nodeIndex] = hslFalse;
            //m_shakingDirection[nodeIndex] = ShakingParam::directionDefault;
            //m_shakingAccRamp[nodeIndex] = ShakingParam::rampDefault;
            //m_shakingTimeOut[nodeIndex] = m_OFF;
            m_tempHCStartTimeOut[nodeIndex] = TemperateParam::startTimeOutDefault;
            m_tempHCToleranceRange[nodeIndex] = TemperateParam::tempToleranceDefault;
            m_tempHCSecurityRange[nodeIndex] = TemperateParam::tempSecurityDefault;
				//m_userShakingSpeed[nodeIndex] = m_OFF;
				m_userHCTemperature[nodeIndex] = m_OFF;
				m_deviceHCName[nodeIndex] = "";
				m_isStarHCSimulate[nodeIndex] = hslFalse;
				m_nodeHCNumber[nodeIndex] = m_OFF;
				m_HHCSetting[nodeIndex] = m_OFF;
            m_selfDiagnostics[nodeIndex] = m_ON;
				m_monitorHCResult[nodeIndex] = -1;
         }

         m_initializedHeaterCoolerLib = hslTrue;

		}

      SynLeaveCriticalSection(m_HHCCriticalSection);

      // check for node initialize, this call must be outside of CriticalSection
      if(initCooler > m_OFF)
      {
         funcRc = InitializeNode(funcId, deviceNumber);
      }

      return (funcRc);

		Unexpected:
		{
         SynLeaveCriticalSection(m_HHCCriticalSection);
   		Error::RaiseLast();
      }
	}

   
 	static function isSimulate(variable funcId, variable deviceNumber, variable makeTrace)
	{
      variable retVal(hslFalse);
      variable starSimState(hslFalse);

		// activate error handler
		onerror goto Unexpected;

      SynEnterCriticalSection(m_HHCCriticalSection);
		retVal = m_isSimulateHeater;
      starSimState = m_isStarHCSimulate[deviceNumber-1];
      SynLeaveCriticalSection(m_HHCCriticalSection);

      // if m_isSimulateHeater is set, both devices are simulate
      // if m_isSimulateHeater is not set, check if useMlStar and m_isStarHCSimulate is set

      if(retVal)
      {
         // if simulate, trace the function end
         if(makeTrace)
     		   endTrace(funcId);
         return (retVal);
      }

      if(starSimState)
      {
         // if simulate, trace the function end
         if(makeTrace)
        		endTrace(funcId);
         return (hslTrue);
      }

      // simulation is not set
      return (retVal);

		Unexpected:
		{
         SynLeaveCriticalSection(m_HHCCriticalSection);
         return (retVal);
      }
	}

   // uses node from 1 to 10
   static function isHeaterInitialized(variable deviceNumber)
   {
      variable retVal(hslFalse);

   	// activate error handler
   	onerror goto Unexpected;

      SynEnterCriticalSection(m_HHCCriticalSection);
      retVal = m_initializedHeaterCooler.GetAt(deviceNumber-1);
      SynLeaveCriticalSection(m_HHCCriticalSection);

      return (retVal);

   	Unexpected:
   	{
         SynLeaveCriticalSection(m_HHCCriticalSection);
         return (retVal);
      }
   }

   // uses node from 1 to 10
   static function setHeaterInitialized(variable deviceNumber)
   {
      variable retVal(hslFalse);

   	// activate error handler
   	onerror goto Unexpected;

      SynEnterCriticalSection(m_HHCCriticalSection);
      m_initializedHeaterCooler[deviceNumber-1] = hslTrue;
      SynLeaveCriticalSection(m_HHCCriticalSection);

      return (retVal);

   	Unexpected:
   	{
         SynLeaveCriticalSection(m_HHCCriticalSection);
         return (retVal);
      }
   }



 	// --------------------------------------------------------------------------------------
	// Communication functions
	// --------------------------------------------------------------------------------------
 
 	//====================================================================
	//
	// Internal function getSendState()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Check the connect and initialize state.
   //  Must be call from each interface function which will send a command to the Cooler
	//====================================================================
   static function getSendState(variable funcId, variable deviceNumber, variable isCooler)
   {
      variable node;
      variable nodeTxt;

		node = getNodeFromDeviceNumber(deviceNumber);
      nodeTxt = StringTable::Load(IDS::starNode);


      if(!isStarDevice(deviceNumber))
      {
         return (IDE::retNotConnectErr);
         nodeTxt = StringTable::Load(IDS::usbNode);
      }

      if(!isHeaterInitialized(deviceNumber) && isCooler)
      {
         // "%s1 '%s2' not initialized'."
         variable msg;
         msg = StringTable::Load(IDS::neededNodeNotInitialized);
         StrReplace(msg, "%s1", nodeTxt);
         StrReplace(msg, "%s2", IStr(node));

         errorCompleteTrace(funcId, msg);
         return (IDE::retNotInitErr);
      }

      return (IDE::noError);
   }


	//====================================================================
	//
	// Internal function sendMsg()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Sends a command dependent of device to a star or to the usb.
	//====================================================================
   static function sendMsg(variable deviceNumber, variable command, variable parameter, variable timeOut, variable makeTrace)
	{
      variable receMsg;
		
		if(isStarDevice(deviceNumber))
		{
			receMsg = sendToStar(deviceNumber, command, parameter, makeTrace);
		}
		else
		{
			//error we should never get here
		}

		return (receMsg);

	}


	//====================================================================
	//
	// Internal function sendToStar()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Sends a command to the corresponding device node via ML_STAR component.
	//====================================================================
   static function sendToStar(variable deviceNumber, variable cmd, variable param, variable makeTrace)
   {
		variable stepShowNameKey(-534118376);
		variable globalKey(-534183935);
		variable orderKey(-534183816);
		variable parameterKey(-534183815);
		variable resultDataKey(-534118396);
		variable resultDataPos(4);
		variable node;
		object	starObject;
	   object 	parsIn;
   	object 	parsOut;
      variable command("T");
      variable parameter(param);
		variable result4;
      variable receMsg;
      string   tempMsg;
      string   tempCmd(cmd);
      variable errPos;

      // device node must be 1 or 2 -->> node must not be updated
		node = getNodeFromDeviceNumber(deviceNumber);

		onerror goto objectError;
      SynEnterCriticalSection(m_HHCCriticalSection);
		starObject = m_starHCDeviceObj.GetAt(deviceNumber-1);
      SynLeaveCriticalSection(m_HHCCriticalSection);
		onerror goto 0;

      command = command + IStr(node);
      command = command + cmd;

      if( makeTrace)
      {
         string   sendMsg(command);
         sendMsg = sendMsg + param;
  			progressTrace(IDS::sendToStar, IDS::sendMessageTitle, sendMsg);
      }

      // set the command at first of the receMsg
      receMsg = command;

		// activate error handler
		onerror goto Unexpected;

		// create data pars for the firmwareCommand
	   parsIn.CreateObject("HXPARAMSLib.HxPars", hslFalse);
	   parsOut.CreateObject("HXPARAMSLib.HxPars", hslFalse);

	   parsIn.Add(2, "ParsCommandVersion");
	   parsIn.Add("FirmwareCommand", "StepName");
	   parsIn.Add(457, stepShowNameKey);
	   parsIn.Add(0, "NbrOfErrors");
	   parsIn.Add(command, globalKey, orderKey);
	   parsIn.Add(parameter, globalKey, parameterKey);


		// send command
		starObject.FirmwareCommand(parsIn, parsOut);

	   result4 = parsOut.Item(resultDataKey, resultDataPos);

		parsIn.ReleaseObject();
		parsOut.ReleaseObject();

      receMsg = receMsg + result4;
      tempMsg = receMsg;

      // remove the master error erXX/XX so that the result string is the same than on USB command erXX
      errPos = tempMsg.Find("er");
      if(errPos >= 0)
      {
         if(tempMsg.GetLength() > errPos + 4)
         {
            if(tempMsg.Mid(errPos+4, 1) == "/")
            {
               // the simulator returns er01/00 on a unknown command,
               // in this case, remove the slave error not the master error
               if(tempMsg.GetLength() >= errPos + 7)
               {
                  // check slave error
                  if(tempMsg.Mid(errPos+5, 2) == "00")
                  {
                     // use the master error, so that the return is not null
                     receMsg = tempMsg.Left(errPos+4);
                     receMsg = receMsg + tempMsg.Right(tempMsg.GetLength() - (errPos+7));
                  }
                  else
                  {
                     // use the slave error
                     receMsg = tempMsg.Left(errPos+2);
                     receMsg = receMsg + tempMsg.Right(tempMsg.GetLength() - (errPos+5));
                  }
               }
            }
         }
      }

      // on request of firmware version do not trace the answere.
      // Answere is traced as firmware version in function traceFirmwareVersion()
      if((tempCmd.Find("RF") < 0) && makeTrace)
	  		progressTrace(IDS::sendToStar, IDS::receiveMessageTitle, receMsg);

      return (receMsg);

		Unexpected:
		{
         variable errId( err.GetId( ) );

			parsIn.ReleaseObject();
			parsOut.ReleaseObject();

         // no connection
         if(errId == -1591212031 || errId == -1574764487)
         {
            receMsg = receMsg + "er0";
            receMsg = receMsg + IStr(IDE::retNotConnectErr);
         }
         else
            Error::RaiseLast();
      }

      // on request of firmware version do not trace the answere.
      // Answere is traced as firmware version in function traceFirmwareVersion()
      if((tempCmd.Find("RF") < 0))
	  		progressTrace(IDS::sendToStar, IDS::receiveMessageTitle, receMsg);

      return (receMsg);

		objectError:
		{
         SynLeaveCriticalSection(m_HHCCriticalSection);
   		Error::RaiseLast();
      }
      return (receMsg);
	}

	

	//====================================================================
	//
	// Internal function setHHCSetting()
	//
   //--------------------------------------------------------------------
   // Description:
   // Check the given deviceNumber from a interface function
	//====================================================================
	static function setHHCSetting(variable funcId, variable deviceNumber, variable& HHCSetting)
	{
      string   cmdResult;
      variable funcRc(IDE::noError);

		HHCSetting = 0;
      if(!isSimulate(0, deviceNumber, hslFalse))
		{
			variable startPos(-1);

			// read the HHC settings
			cmdResult = sendMsg(deviceNumber, "QU", "", m_usbMsgTimeout, hslTrue);
			funcRc = isFirmwError(funcId, cmdResult, hslTrue);
         if(0 < funcRc)
            return (funcRc);

      	startPos = cmdResult.Find("au");
	      if(startPos >= 0 && cmdResult.GetLength() >= 25)
	      {
				variable Cooler;
				variable heater;
				// cmdResult auswerten
				// format "TxQUau0 0 0 0 0 0 0 0 0 0"
				Cooler = cmdResult.Mid(startPos+2, 1);
				heater = cmdResult.Mid(startPos+4, 1);
				if(Cooler == "1" && heater == "1")
					HHCSetting = m_shakingPropertyNothing;
				else
				if(Cooler == "1")
					HHCSetting = m_shakingPropertyOnlyHeat;
				else
				if(heater == "1")
					HHCSetting = m_shakingPropertyOnlyShake;
			}
		}

		onerror goto Unexpected;

      SynEnterCriticalSection(m_HHCCriticalSection);
		m_HHCSetting[deviceNumber-1] = HHCSetting;
      SynLeaveCriticalSection(m_HHCCriticalSection);

      return(funcRc);

		Unexpected:
		{
         SynLeaveCriticalSection(m_HHCCriticalSection);
   		Error::RaiseLast();
      }

		return (funcRc);
	}


	//====================================================================
	//
	// Internal function hasHeater()
	//
   //--------------------------------------------------------------------
   // Description:
   // Check if the heater is activated on current HHC
	//====================================================================
	static function hasHeater(variable funcId, variable deviceNumber, variable throw)
	{
		variable HHCSettings(-1);
      variable funcRc(hslFalse);

		onerror goto Unexpected;

      SynEnterCriticalSection(m_HHCCriticalSection);
		HHCSettings = m_HHCSetting.GetAt(deviceNumber-1);
      SynLeaveCriticalSection(m_HHCCriticalSection);

		if((HHCSettings == m_shakingPropertyHeatAndShake) || (HHCSettings == m_shakingPropertyOnlyHeat))
			funcRc = hslTrue;

		if(funcRc == hslFalse && throw == 1)
		{
			// "Current HHC module on %s1 '%s2' cannot used as heater"
	      variable nodeNameId(IDS::starNode);
	      variable node;
         string 	msg;
         string 	nodeName;
         variable funcName;

			node = getNodeFromDeviceNumber(deviceNumber);
			if(!isStarDevice(deviceNumber))
				nodeNameId = IDS::usbNode;

         msg = StringTable::Load(IDS::heatingNotActivated);
         nodeName = StringTable::Load(nodeNameId);
         funcName = StringTable::Load(funcId);

         StrReplace(msg, "%s1", nodeName);
         StrReplace(msg, "%s2", IStr(node));
         errorCompleteTrace(funcId, msg);

         Error::RaiseEx(IDE::retErr, msg, GetFileName(), funcName, GetLineNumber());
		}

      return(funcRc);

		Unexpected:
		{
         SynLeaveCriticalSection(m_HHCCriticalSection);
   		Error::RaiseLast();
      }

		return (funcRc);
	}

	

	// --------------------------------------------------------------------------------------
	// Library traces
	// --------------------------------------------------------------------------------------
	//====================================================================
	//
	// Internal function versionTrace()
	//
   //--------------------------------------------------------------------
   // Description:
   // Traces the start of a exported function
	//====================================================================
   static function versionTrace() void
   {
		variable traceSource;

      initStringTable();

      traceSource = StringTable::Load(IDS::traceSource);	// source for formated trace
      FormatTrace(traceSource, "HSLHamHeaterCoolerLib", TraceStatus::cmd_progress, HamHeaterCoolerVersion);
   }

	//====================================================================
	//
	// Internal function startTrace()
	//
   //--------------------------------------------------------------------
   // Description:
   // Traces the start of a exported function
	//====================================================================
   static function startTrace(variable funcName) void
   {
		variable traceSource;
      variable functionName;

      initStringTable();

      traceSource = StringTable::Load(IDS::traceSource);	// source for formated trace
      if(GetType(funcName) == "i")
         functionName = StringTable::Load(funcName);
      else
         functionName = funcName;

      FormatTrace(traceSource, functionName, TraceStatus::cmd_start);
   }

	//====================================================================
	//
	// Internal function progressTrace()
	//
   //--------------------------------------------------------------------
   // Description:
   // Traces a msg during a exported function is working
	//====================================================================
   static function progressTrace(variable funcName, variable progMsgTitle, variable progMsg) void
   {
		variable traceSource;
      variable functionName;
      variable progressTitle;
      variable progressMsg;

      initStringTable();

      traceSource = StringTable::Load(IDS::traceSource);	// source for formated trace
      if(GetType(funcName) == "i")
         functionName = StringTable::Load(funcName);
      else
         functionName = funcName;

      if(GetType(progMsgTitle) == "i")
         progressTitle = StringTable::Load(progMsgTitle);
      else
         progressTitle = progMsgTitle;

      if(GetType(progMsg) == "i")
         progressMsg = StringTable::Load(progMsg);
      else
         progressMsg = progMsg;

      FormatTrace(traceSource, functionName, TraceStatus::cmd_progress, progressTitle, progressMsg);
   }

	//====================================================================
	//
	// Internal function errorTrace()
	//
   //--------------------------------------------------------------------
   // Description:
   // Traces an error msg during a exported function is working
	//====================================================================
   static function errorTrace(variable funcName, variable errMsg) void
   {
		variable traceSource;
      variable functionName;
      variable errorMsg;

      initStringTable();

      traceSource = StringTable::Load(IDS::traceSource);	// source for formated trace
      if(GetType(funcName) == "i")
         functionName = StringTable::Load(funcName);
      else
         functionName = funcName;

      if(GetType(errMsg) == "i")
         errorMsg = StringTable::Load(errMsg);
      else
         errorMsg = errMsg;

      FormatTrace(traceSource, functionName, TraceStatus::cmd_error, errorMsg);
   }

	//====================================================================
	//
	// Internal function errorCompleteTrace()
	//
   //--------------------------------------------------------------------
   // Description:
   // Traces an error msg on end of an exported function
	//====================================================================
   static function errorCompleteTrace(variable funcName, variable errMsg) void
   {
		variable traceSource;
      variable functionName;
      variable errorMsg;

      initStringTable();

      traceSource = StringTable::Load(IDS::traceSource);	// source for formated trace
      if(GetType(funcName) == "i")
         functionName = StringTable::Load(funcName);
      else
         functionName = funcName;

      if(GetType(errMsg) == "i")
         errorMsg = StringTable::Load(errMsg);
      else
         errorMsg = errMsg;

      FormatTrace(traceSource, functionName, TraceStatus::cmd_errComplete, errorMsg);
   }

	//====================================================================
	//
	// Internal function endTrace()
	//
   //--------------------------------------------------------------------
   // Description:
   // Traces the end of an exported function
	//====================================================================
   static function endTrace(variable funcName) void
   {
		variable traceSource;
      variable functionName;

      initStringTable();

      traceSource = StringTable::Load(IDS::traceSource);	// source for formated trace
      if(GetType(funcName) == "i")
         functionName = StringTable::Load(funcName);
      else
         functionName = funcName;

      FormatTrace(traceSource, functionName, TraceStatus::cmd_complete);
   }

	//====================================================================
	//
	// Internal function traceFirmwareVersion()
	//
   //--------------------------------------------------------------------
   // Description:
   // Traces the firmware version of an used heater Cooler
	//====================================================================
	// this function is used in InitializeLibrary() and uses index 0..10	
	static function traceFirmwareVersion(variable funcId, variable deviceNumber)
	{
      variable nodeNameId(IDS::starNode);
		string 	answString;
		variable startPos(0);
		
		// read the firmware version of current node
		answString = sendMsg(deviceNumber, "RF", "", m_usbInitTimeout, hslTrue);

		if(!isStarDevice(deviceNumber))
			nodeNameId = IDS::usbNode;

		startPos = answString.Find("rf");
		if(startPos >= 0)
		{
			string fwVers;
			string title;
			string nodeName;
			variable node;

			node = getNodeFromDeviceNumber(deviceNumber);

			fwVers = answString.Right(answString.GetLength()-(startPos+2));
			// Text: "%s1 '%s2' firmware version = "
			title = StringTable::Load(IDS::firmwareVersion);
			nodeName = StringTable::Load(nodeNameId);
			
			StrReplace(title, "%s1", nodeName);
			StrReplace(title, "%s2", IStr(node));


			progressTrace(funcId, title, fwVers);
		}
	}

	//====================================================================
	//
	// Internal function sendToProgressTrace()
	//
   //--------------------------------------------------------------------
   // Description:
   // Traces a msg during a exported function is working
	//====================================================================
   static function sendToProgressTrace(
      variable funcName,
      variable deviceNumber)
      void
   {
		variable traceSource;
      variable functionName;
      variable nodeNameId(IDS::starNode);
		string   nodeName;
      variable progressMsg;
      variable node;

      initStringTable();

		node = getNodeFromDeviceNumber(deviceNumber);

		if(!isStarDevice(deviceNumber))
         nodeNameId = IDS::usbNode;

      nodeName = StringTable::Load(nodeNameId);

      traceSource = StringTable::Load(IDS::traceSource);	// source for formated trace
      if(GetType(funcName) == "i")
         functionName = StringTable::Load(funcName);
      else
         functionName = funcName;

      // Text: "Start command to %s1(%s2)."
      progressMsg = StringTable::Load(IDS::progressSendTo);


      StrReplace(progressMsg, "%s1", nodeName);
      StrReplace(progressMsg, "%s2", IStr(node));


      FormatTrace(traceSource, functionName, TraceStatus::cmd_progress, progressMsg);
   }


	// --------------------------------------------------------------------------------------
	// Input parameter check function
	// --------------------------------------------------------------------------------------

	//====================================================================
	//
	// Internal function checkStringInput()
	//
   //--------------------------------------------------------------------
   // Description:
   // Check an input parameter which must be a string
	//====================================================================
   static function checkStringInput(variable funcId, variable parameterName, variable input)
   {
      if(GetType(input) != "s")
      {
         // Wrong type of parameter; '%s1(%s2)' must be a string.
         string msg;
         string param;
         variable funcName;
         msg = StringTable::Load(IDE::noStringValue);
         funcName = StringTable::Load(funcId);

         if(GetType(input) == "i")
            param = IStr(input);
         if(GetType(input) == "f")
            param = FStr(input, hslTrue);

         StrReplace(msg, "%s1", parameterName);
         StrReplace(msg, "%s2", param);


         errorCompleteTrace(funcId, msg);
			Error::RaiseEx(IDE::noStringValue, msg, GetFileName(), funcName, GetLineNumber());
      }
   }

	//====================================================================
	//
	// Internal function checkDoubleInput()
	//
   //--------------------------------------------------------------------
   // Description:
   // Check an input parameter which must be a double
	//====================================================================
   static function checkDoubleInput(
      variable funcId, variable parameterName, variable input)
   {
      if((GetType(input) != "f") && (GetType(input) != "i"))
      {
         // Wrong type of parameter; '%s1(%s2)' must be a number.
         string msg;
         string param("'%s'");
         variable funcName;
         msg = StringTable::Load(IDE::noDoubleValue);
         funcName = StringTable::Load(funcId);

         if(GetType(input) == "s")
            StrReplace(param, "%s", input);

         StrReplace(msg, "%s1", parameterName);
         StrReplace(msg, "%s2", param);

         errorCompleteTrace(funcId, msg);
			Error::RaiseEx(IDE::noDoubleValue, msg, GetFileName(), funcName, GetLineNumber());
      }
   }

	//====================================================================
	//
	// Internal function checkDoubleInputRange()
	//
   //--------------------------------------------------------------------
   // Description:
   // Check an input parameter which must be a double in a defined range
	//====================================================================
   static function checkDoubleInputRange(
      variable funcId, variable parameterName, variable input, variable min, variable max)
   {
      checkDoubleInput(funcId, parameterName, input);

      if((input < min) || (input > max))
      {
         // "Parameter out of range; '%s1(%s2)' must be between [%s3..%s4]."
         string msg;
         variable funcName;
         msg = StringTable::Load(IDS::parameterOutOfRange);
         funcName = StringTable::Load(funcId);

         StrReplace(msg, "%s1", parameterName);
         StrReplace(msg, "%s2", FStr(input, hslTrue));
         StrReplace(msg, "%s3", FStr(min, hslTrue));
         StrReplace(msg, "%s4", FStr(max, hslTrue));

         errorCompleteTrace(funcId, msg);
			Error::RaiseEx(IDE::syntaxParRangeError, msg, GetFileName(), funcName, GetLineNumber());
      }
   }

	//====================================================================
	//
	// Internal function checkIntegerInput()
	//
   //--------------------------------------------------------------------
   // Description:
   // Check an input parameter which must be a integer
	//====================================================================
   static function checkIntegerInput(
      variable funcId, variable parameterName, variable input)
   {
      if(GetType(input) != "i")
      {
         // Wrong type of parameter; '%s1(%s2)' must be a number.
         string msg;
         string param;
         variable funcName;
         msg = StringTable::Load(IDE::noIntegerValue);
         funcName = StringTable::Load(funcId);

         if(GetType(input) == "s")
         {
            param = "'";
            param = param + input;
            param = param + "'";
         }
         if(GetType(input) == "f")
            param = FStr(input, hslTrue);

         StrReplace(msg, "%s1", parameterName);
         StrReplace(msg, "%s2", param);

         errorCompleteTrace(funcId, msg);
			Error::RaiseEx(IDE::noIntegerValue, msg, GetFileName(), funcName, GetLineNumber());
      }
   }

	//====================================================================
	//
	// Internal function checkIntegerInputRange()
	//
   //--------------------------------------------------------------------
   // Description:
   // Check an input parameter which must be a integer in a defined range
	//====================================================================
   static function checkIntegerInputRange(
      variable funcId, variable parameterName, variable input, variable min, variable max)
   {
      checkIntegerInput(funcId, parameterName, input);

      if((input < min) || (input > max))
      {
         // "Parameter out of range; '%s1(%s2)' must be between [%s3..%s4]."
         string msg;
         variable funcName;
         msg = StringTable::Load(IDS::parameterOutOfRange);
         funcName = StringTable::Load(funcId);

         StrReplace(msg, "%s1", parameterName);
         StrReplace(msg, "%s2", IStr(input));
         StrReplace(msg, "%s3", IStr(min));
         StrReplace(msg, "%s4", IStr(max));

         errorCompleteTrace(funcId, msg);
			Error::RaiseEx(IDE::syntaxParRangeError, msg, GetFileName(), funcName, GetLineNumber());
      }
   }


	//====================================================================
	//
	// Internal function isStarDevice()
	//
   //--------------------------------------------------------------------
   // Description:
   // Check if the used deviceNumber from a ML_STAR
	//====================================================================
	static function isStarDevice(variable deviceNumber)
	{
		variable funcRc(hslFalse);
		variable devName;

		onerror goto Unexpected;

      SynEnterCriticalSection(m_HHCCriticalSection);
		devName = m_deviceHCName.GetAt(deviceNumber-1);
      SynLeaveCriticalSection(m_HHCCriticalSection);

		// check for usb name
		if(devName != m_HHCUsbObjectName)
		{
			funcRc = hslTrue;
		}

      return(funcRc);

		Unexpected:
		{
         SynLeaveCriticalSection(m_HHCCriticalSection);
   		Error::RaiseLast();
      }
	}

	//====================================================================
	//
	// Internal function getNodeFromDeviceNumber()
	//
   //--------------------------------------------------------------------
   // Description:
   // Retunrs the saved node ID dependent of the deviceNumber
	//====================================================================
	static function getNodeFromDeviceNumber(variable deviceNumber)
	{
		variable usedNode;

		onerror goto Unexpected;

      SynEnterCriticalSection(m_HHCCriticalSection);
		usedNode = m_nodeHCNumber.GetAt(deviceNumber-1);
      SynLeaveCriticalSection(m_HHCCriticalSection);

      return(usedNode);

		Unexpected:
		{
         SynLeaveCriticalSection(m_HHCCriticalSection);
   		Error::RaiseLast();
      }
	}


	//====================================================================
	//
	// Internal function checkDeviceNumber()
	//
   //--------------------------------------------------------------------
   // Description:
   // Check the given deviceNumber from a interface function
	//====================================================================
	static function checkDeviceNumber(variable funcId, variable deviceNumber)
	{
		variable devName, nodeNr;

		if((deviceNumber < m_firstDeviceNumber) || (deviceNumber > m_lastDeviceNumber))
		{
         string msg;
         variable funcName;
			// "Parameter 'deviceNumber' contains an invalid value! \r\nMust be created with function Connect() or CreateUsbDevice()"
         msg = StringTable::Load(IDS::invalidDeviceNumber);
         funcName = StringTable::Load(funcId);

         errorCompleteTrace(funcId, msg);
			Error::RaiseEx(IDE::retErr, msg, GetFileName(), funcName, GetLineNumber());
		}

		onerror goto Unexpected;

      SynEnterCriticalSection(m_HHCCriticalSection);
		devName = 	m_deviceHCName.GetAt(deviceNumber-1);
		nodeNr = 	m_nodeHCNumber.GetAt(deviceNumber-1);
      SynLeaveCriticalSection(m_HHCCriticalSection);

		// check for usb name
		if((devName == "") || (nodeNr == 0))
		{
         string msg;
         variable funcName;
			// "Parameter 'deviceNumber' contains an invalid value! \r\nMust be created with function Connect() or CreateUsbDevice()"
         msg = StringTable::Load(IDS::invalidDeviceNumber);
         funcName = StringTable::Load(funcId);

         errorCompleteTrace(funcId, msg);
			Error::RaiseEx(IDE::retErr, msg, GetFileName(), funcName, GetLineNumber());
		}

		return;

		Unexpected:
		{
         SynLeaveCriticalSection(m_HHCCriticalSection);
   		Error::RaiseLast();
      }
	}


	//====================================================================
	//
	// Internal function formatParam()
	//
   //--------------------------------------------------------------------
   // Description:
   // Formats an numeric input to a string with leading 0 to lenth of strWidth
	//====================================================================
	static function formatParam(
			variable param,											// i: the paramter to normalize (integer)
			variable strWidth)										// i: the width to be filled (integer)
	{
		string sParam; 
		sParam = IStr(param);
		StrFillLeft(sParam, "0", strWidth);
		return (sParam);
	}

	//====================================================================
	//
	// Internal function normalizeParam()
	//
   //--------------------------------------------------------------------
   // Description:
   // Formats an numeric (double)input to 1/10 values and format it
   //	to a string with leading 0 to lenth of strWidth
	//====================================================================
	static function normalizeParam(								// returns the given parameter normalized for firmware command as string
			variable param,											// i: the paramter to normalize as float or integer
			variable strWidth)										// i: the width to be filled (integer)
	{
		string sParam; 
		sParam = IStr(Floor(MthRound(param*10, 0)));
		StrFillLeft(sParam, "0", strWidth);
		return (sParam);
	}



	// --------------------------------------------------------------------------------------
	// Firmware error check function
	// --------------------------------------------------------------------------------------
	
	//====================================================================
	//
	// Internal function getFirmwErrorId()
	//
   //--------------------------------------------------------------------
   // Description:
   //	Reads the firmware error number from cmdResult string and convert it to a number
	//====================================================================
   static function getFirmwErrorId(string cmdResult)
   {
      variable errNr(0);
      variable startPos(0);
      startPos = cmdResult.Find("er");

      if((startPos >= 0) && ((startPos+4) <= cmdResult.GetLength()))
      {
         variable errNo;
         errNo = cmdResult.Mid((startPos+2), 2);
         errNr = IVal(errNo);
      }
      return (errNr);
   }

	//====================================================================
	//
	// Internal function getErrIdFromFirmwareError()
	//
   //--------------------------------------------------------------------
   // Description:
   //	Converts the firmware error number to function return error number
	//====================================================================
   static function getErrIdFromFirmwareError(string cmdResult)
   {
      variable firmwErrId(getFirmwErrorId(cmdResult));
      
      if(0 == firmwErrId)
         return (IDE::noError);
      else if(1 == firmwErrId)
         return (IDE::retErr);
      else if(2 == firmwErrId)
         return (IDE::retNotInitErr);
      else if(3 == firmwErrId)
         return (IDE::retNotConnectErr);
      else if (10 == firmwErrId)
         return (IDE::canError);
      else if (20 == firmwErrId)
         return (IDE::eepromError);
      else if (30 == firmwErrId)
         return (IDE::syntaxCmdError);
      else if (31 == firmwErrId)
         return (IDE::syntaxParUnkError);
      else if (32 == firmwErrId)
         return (IDE::syntaxParRangeError);
      else if (35 == firmwErrId)
         return (IDE::generalVoltError);
      else if (36 == firmwErrId)
         return (IDE::generalStopError);
      else if (37 == firmwErrId)
         return (IDE::generalAddrError);
      else if (40 == firmwErrId)
         return (IDE::parallelError);
      else if (41 == firmwErrId)
         return (IDE::parallelError);
      else if (42 == firmwErrId)
         return (IDE::parallelError);
      else if (50 == firmwErrId)
         return (IDE::CoolerInitError);
      else if (51 == firmwErrId)
         return (IDE::CoolerNotInitError);
      else if (52 == firmwErrId)
         return (IDE::CoolerStepLossError);
      else if (53 == firmwErrId)
         return (IDE::CoolerStartModeError);
      else if (55 == firmwErrId)
         return (IDE::plateLockInitError);
      else if (56 == firmwErrId)
         return (IDE::plateLockNotInitError);
      else if (57 == firmwErrId)
         return (IDE::plateLockStepLossError);
      else if (60 == firmwErrId)
         return (IDE::tempNotStartError);
      else if (61 == firmwErrId)
         return (IDE::tempTimeoutError);
      else if (62 == firmwErrId)
         return (IDE::tempSuperRangeError);
      else if (63 == firmwErrId)
         return (IDE::tempSecurRangeError);
      else if (64 == firmwErrId)
         return (IDE::tempSensorError);
      else if (98 == firmwErrId)
         return (IDE::commandSendTimeout);
      else
         return (IDE::unknowFwError);
   }

	//====================================================================
	//
	// Internal function isFirmwError()
	//
   //--------------------------------------------------------------------
   // Description:
   //	Check if an error is set in cmdResult string
	//====================================================================
   static function isFirmwError(variable funcId, string cmdResult, variable makeTrace)
   {
      variable rc(IDE::noError);

      if(cmdResult.Find(m_fwNoError) == -1)
      {
         variable errId;
         variable errText;
         errId = getErrIdFromFirmwareError(cmdResult);
         // string erXX was not found (answere command)
         if(errId != IDE::noError)
			{
				rc = errId;

				errText = StringTable::Load(errId);

				// make an exception handling for errors which contains a %s part
				if(errId == IDE::unknowFwError)
					StrReplace(errText, "%s", IStr(getFirmwErrorId(cmdResult)));
				if(errId == IDE::commandSendTimeout)
					StrReplace(errText, "%s", cmdResult.Left(4));

				if(makeTrace)
  					errorCompleteTrace(funcId, errText);
  			}
      }

      return (rc);
   }


	//====================================================================
	//
	// Internal function saveAndCreateDeviceNumber()
	//
   //--------------------------------------------------------------------
   // Description:
   //	save the device parameter and create the deviceNumber which must 
	// be used for each interface function
	//====================================================================
	static function saveAndCreateDeviceNumber(
		variable funcId,
		variable deviceName,
		object& 	starObject,
		variable isStarSimulate,
		variable usedNode)
	{
		variable deviceNumber(0);
		variable index(0);

		onerror goto Unexpected;

      SynEnterCriticalSection(m_HHCCriticalSection);

		// USB set always the starObject parameter with a null object
	   if(starObject.IsNull() && m_usbHCComObject.IsNull())
	   {
	      // create the usb object without event 
	      m_usbHCComObject.ReleaseObject();
	      m_usbHCComObject.CreateObject(m_HHCUsbObjectName, hslFalse);


	      if(!m_usbHCComObject.IsNull())
	      {
	         // "{BD0DAB87-838B-44c5-A114-1CBA5BE0E45F}", bufferSize(4090), vendorId(2223), productId, mainSerialNumber);
	         m_usbHCComObject.InitObject (m_HHCUsbProductNum, m_HHCUsbSerieNum);

	      }
	      else
	      {
	         string msg;
	         variable funcName;

		      SynLeaveCriticalSection(m_HHCCriticalSection);

				// "Parameter 'starDevice' contains an invalid object."
	         msg = StringTable::Load(IDS::cannotCreateUsbPort);
	         funcName = StringTable::Load(funcId);

	         errorCompleteTrace(funcId, msg);

				Error::RaiseEx(IDE::retErr, msg, GetFileName(), funcName, GetLineNumber());
	      }
	   }

		// check if this node allready used
      for( index = 0; index < m_maxHHC; index++)
      {
			variable devN, nodeNum;
			devN = m_deviceHCName.GetAt(index);
			nodeNum = m_nodeHCNumber.GetAt(index);

			// if equal, node already exist
			if((devN == deviceName) && (nodeNum == usedNode))
				deviceNumber = index+1;
		}

		if(deviceNumber == 0)
		{
			// node is not used, set it on the first free position
	      for( index = 0; index < m_maxHHC; index++)
	      {
				variable devN;
				devN = m_deviceHCName.GetAt(index);
				// if empty
				if(devN == "")
				{
					m_deviceHCName[index] = deviceName;
					m_starHCDeviceObj[index] = starObject;
					m_isStarHCSimulate[index] = isStarSimulate;
					m_nodeHCNumber[index] = usedNode;
					deviceNumber = index+1;
					break;
				}
	      }
		}
		
      SynLeaveCriticalSection(m_HHCCriticalSection);

		if(deviceNumber == 0)
		{
         string msg;
         variable funcName;
			// "Parameter 'starDevice' contains an invalid object."
         msg = StringTable::Load(IDS::maxHHCReached);
         funcName = StringTable::Load(funcId);

         errorCompleteTrace(funcId, msg);
			Error::RaiseEx(IDE::retErr, msg, GetFileName(), funcName, GetLineNumber());
		}


      return(deviceNumber);

		Unexpected:
		{
         SynLeaveCriticalSection(m_HHCCriticalSection);
   		Error::RaiseLast();
      }
	}

	//====================================================================
	//
	// Internal function Wait()
	//
   //--------------------------------------------------------------------
   // Description:
   //	Wait the given time
	//====================================================================
	static function wait(variable waitTime)
	{
		timer t;
		
      // Wait waitTime seconds
      t.SetTimer( waitTime );
      t.WaitTimer( hslFalse, hslFalse );
	}




	//====================================================================
	//
	// Internal function getCurrentTemp()
	//
   //--------------------------------------------------------------------
   // Description:
   //	Read the shaking speed of current HHC
	//====================================================================
	static function getCurrentTemp(variable deviceNumber, variable makeTrace)
	{
		variable temperature(0);
      variable command("RT");
      variable parameter("");
      string   cmdResult;
      variable startPos;
      variable firstVal;
      variable secVal;
      variable averageVal;

     	// wait for temperature is reached
      cmdResult = sendMsg(deviceNumber, command, parameter, m_usbMsgTimeout, makeTrace);

      // format: rt�#### �####
      startPos = cmdResult.Find("rt");
      if((startPos >= 0) && ((cmdResult.GetLength()-startPos) >= TemperateParam::tempTempRequestLength))
      {
	      // read both temperature and calculate the average 
	      // format: rt�#### �####
	      firstVal = FVal(cmdResult.Mid((startPos+2), 5));
	      secVal   = FVal(cmdResult.Mid((startPos+8), 5));

	      // calculate the average in 1/10 degrees
	      averageVal = ((firstVal + secVal) / 2) /10;
	      temperature = MthRound(averageVal, 1);
      }
		return (temperature);
	}



	//====================================================================
	//
	// Internal function pollingForRunningHeater()
	//
   //--------------------------------------------------------------------
   // Description:
   //	Polling until heater is in temperature controlling mode
	//	Polling is neccessary that during a long wait time an Abort()
	// command can be execute.
	//====================================================================
	static function pollingForRunningHeater(
		variable deviceNumber, variable maxPollingTime)
	{
      string   cmdResult;
		variable maxPTime(maxPollingTime);
		variable intervalTime(10);
		variable partResult("qd1");

		if(maxPollingTime > 10)
		{
	      // ask if heater in state heating up
			cmdResult = sendMsg(deviceNumber, "QD", "", m_usbMsgTimeout, hslFalse);

			while(cmdResult.Find(partResult) > 0 && maxPTime > 0)
			{
				maxPTime = maxPTime - intervalTime;
				wait(intervalTime);
				cmdResult = sendMsg(deviceNumber, "QD", "", m_usbMsgTimeout, hslFalse);
			}
		}
	}

	//====================================================================
	//
	// Internal function OnAbortHHCLibrary()
	//
   //--------------------------------------------------------------------
   // Description:
   //	Stop heating and shaking for all HHC module
	//====================================================================
	static function OnAbortHHCLibrary()
	{
		variable deviceNumber;

      for( deviceNumber = 1; deviceNumber <= m_maxHHC; deviceNumber++)
      {
         if(isHeaterInitialized(deviceNumber))
         {
            // call StartCooler with 1 base node
            StopTemperatureControl(deviceNumber);
         }
      }

		return;
	}


}

#endif
// $$author=Williams_R2$$valid=0$$time=2020-07-16 12:34$$checksum=b9ba9bad$$length=088$$