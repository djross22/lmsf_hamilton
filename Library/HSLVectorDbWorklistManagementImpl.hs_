// This is a part of the Vector Database Worklist Management Library.
// Copyright (C) by HAMILTON Bonaduz AG, CH-7402 Bonaduz.
// All rights reserved.
//
// Modification History
// 2006-03-01  bandenmatten : Initial file creation.
// 2006-05-02  bandenmatten : Moved SynEnterCriticalSection() in function GetJobIDs().
// 2006-05-11  bandenmatten : Renamed global variable from vectorDb_CriticalSection to vectorDb_WorklistManagementCS.
// 2006-05-11  bandenmatten : Renamed global function from VectorDb_InitCriticalSection to VectorDb_InitWorklistManagementCS.
// 2006-05-11  bandenmatten : Included shared definitions HSLVectorDb.hs_.
// 2006-05-31  bandenmatten : Included HSLVectorDbTracking.hsl.
// 2006-05-31  bandenmatten : Added parameter queryJobLabwareData to function GetJobIDs().
// 2006-06-14  bandenmatten : Added parameter deckID to function GetJobIDs().
// 2006-06-20  bandenmatten : Added functions AssignJobsToLabware() and UnassignJobsFromLabware().
// 2006-06-29  bandenmatten : Updated functions corresponding to changes of IHxVectorDbTracking.
// 2006-06-29  bandenmatten : Removed parameter deckID from function GetJobIDs().
// 2006-06-29  bandenmatten : Reimplemented function AssignJobsToLabware() using IHxVectorDbTracking::().
// 2006-09-15  bandenmatten : Renamed LabwareID to ElementID (labwareID to elementID).
// 2006-09-18  bandenmatten : Added function RemoveAllJobs().
// 2006-09-20  bandenmatten : Added static function WorklistManagementEnabled().
// 2006-10-06  bandenmatten : Added param runID to functions GetJobsForElementID(), GetJobsForElementIDSortedByPriority(), RemoveJobsForElementID().
// 2006-10-16  bandenmatten : Added runID to pars package of function HxVectorDbWorklistManagement.AddJobs().
// 2006-10-17  bandenmatten : Added check whether Vector Database is enabled.
// 2006-11-24  bandenmatten : Function InitLibrary() initialized some constants that have not been declared as global once only, 
//										so that they didn't have the expected value when they have been reset to their original value for 
//										the second and following tasks. Fixed this bug (//>> 20061124).
// 2007-01-11  mhosang      : Changed the function GetJobIDs() to allow different additional data combinations (except different types)
//	2007-01-15  mhosang      : Updated the function GetJobIDs() to prevent some errors


#ifndef __HSLVectorDbWorklistManagementImpl_hs___
#define __HSLVectorDbWorklistManagementImpl_hs___	1

// ----------------------------------------------------------------------------------------------------
// Includes
// ----------------------------------------------------------------------------------------------------

#ifndef __HSLUtilLib2_hsl__
	#include "HSLUtilLib2.hsl"
#endif

#ifndef __HSLUtilLib2Def_hs___
	#include "HSLUtilLib2Def.hs_"
#endif

#ifndef  __HSLSynLib_hsl__
	#include "HSLSynLib.hsl"
#endif

#ifndef __HSLStrLib_hsl__
	#include "HSLStrLib.hsl"
#endif

#include "HSLVectorDb.hs_"
#include "HSLVectorDbWorklistManagementDefs.hs_"

#ifndef  __HSLVectorDbTracking_hsl__
	#include "HSLVectorDbTracking.hsl"
#endif

#ifndef  __HSLVectorDbTrackingDefs_hs___
	#include "HSLVectorDbTrackingDefs.hs_"
#endif

// Implementation of the Vector Database Worklist Management Library
namespace VectorDb
{

	// --------------------------------------------------------------------------------------
	// Debugging
	// --------------------------------------------------------------------------------------

	// See HSLVectorDb.hs_

	// ----------------------------------------------------------------------------------------------------
	// Data 
	// ----------------------------------------------------------------------------------------------------

	static global object vectorDb_WorklistManagementObj;						// Worklist Management object (= IHxVectorDbWorklistManagement)
	static global variable vectorDb_WorklistManagementCS(0);					// Critical section
	static global variable vectorDb_WorklistManagementEnabled(hslFalse);	// True if Worklist Management is enabled

	// ----------------------------------------------------------------------------------------------------
	// Constants
	// ----------------------------------------------------------------------------------------------------

	namespace Constants
	{
		static const variable jobNameMin(0);
		static const variable jobNameMax(50);
		static const variable jobPriorityMin(0);
		static const variable jobPriorityMax(255);
		static 		 variable jobStateMin(0);
		static 		 variable jobStateMax(0);
		static const variable jobUserStateMin(0);
		static const variable jobUserStateMax(255);
		static const variable sourceBarcodeMin(0);
		static const variable sourceBarcodeMax(255);
		static const variable sourceLabwareIdMin(0);
		static const variable sourceLabwareIdMax(255);
		static const variable sourcePositionIdMin(0);
		static const variable sourcePositionIdMax(50);
		static const variable sourceRequiredMin(0);
		static const variable sourceRequiredMax(1);
		static const variable targetBarcodeMin(0);
		static const variable targetBarcodeMax(255);
		static const variable targetLabwareIdMin(0);
		static const variable targetLabwareIdMax(255);
		static const variable targetPositionIdMin(0);
		static const variable targetPositionIdMax(50);
		static const variable additionalDataKeyMin(1);
		static const variable additionalDataKeyMax(50);

		static const variable crlf("\013\010");																			// Carriage return linefeed combination
		static const variable helpFileShortName("HSLVectorDbWorklistManagement");								// Help file short name
		static const variable helpFileExtension(".chm");																// Help file extension
		static const variable traceSource("SYSTEM");																		// Trace source
		static const variable traceActionGetJobs("VectorDb::GetJobs");												// Trace action
		static const variable traceActionGetJobIDs("VectorDb::GetJobIDs");										// Trace action
		static const variable traceActionGetJob("VectorDb::GetJob");												// Trace action
		static const variable traceActionAddJob("VectorDb::AddJob");												// Trace action
		static const variable traceActionRemoveJob("VectorDb::RemoveJob");										// Trace action
		static const variable traceActionRemoveAllJobs("VectorDb::RemoveAllJobs");								// Trace action
		static const variable traceActionAddJobAdditionalData("VectorDb::AddJobAdditionalData");			// Trace action
		static const variable traceActionRemoveJobAdditionalData("VectorDb::RemoveJobAdditionalData");	// Trace action
		static const variable traceActionGetJobAdditionalData("VectorDb::GetJobAdditionalData");			// Trace action
		static const variable traceActionGetJobsSortedByPriority("VectorDb::GetJobsSortedByPriority");	// Trace action
		static const variable traceActionGetJobsForLabware("VectorDb::GetJobsForLabware");					// Trace action
		static const variable traceActionGetJobsForLabwareSortedByPriority(
																	"VectorDb::GetJobsForLabwareSortedByPriority");		// Trace action
		static const variable traceActionGetJobsForBarcode("VectorDb::GetJobsForBarcode");					// Trace action
		static const variable traceActionGetJobsForElementID("VectorDb::GetJobsForElementID");				// Trace action
		static const variable traceActionGetJobsForElementIDSortedByPriority(
																	"VectorDb::GetJobsForElementIDSortedByPriority");	// Trace action
		static const variable traceActionGetJobState("VectorDb::GetJobState");									// Trace action
		static const variable traceActionSetJobState("VectorDb::SetJobState");									// Trace action
		static const variable traceActionRemoveJobsForLabware("VectorDb::RemoveJobsForLabware");			// Trace action
		static const variable traceActionRemoveJobsForBarcode("VectorDb::RemoveJobsForBarcode");			// Trace action
		static const variable traceActionRemoveJobsForElementID("VectorDb::RemoveJobsForElementID");		// Trace action
	}

	// ----------------------------------------------------------------------------------------------------
	// Translated strings
	// ----------------------------------------------------------------------------------------------------

	namespace TrStr
	{
	}

	// ----------------------------------------------------------------------------------------------------
	// Traceing
	// ----------------------------------------------------------------------------------------------------

	// See HSLVectorDb.hs_

	// ----------------------------------------------------------------------------------------------------
	// Error handling
	// ----------------------------------------------------------------------------------------------------

	namespace Error
	{
		static const variable majorID(0x61);						// Major error id

		namespace MinorID													// Minor error ids
		{
			static const variable generalRuntimeError(0x0A);
			//static const variable ....(0x1F)
		}

		namespace ErrorCode												// Error codes
		{
			static const variable unexpected                   (0x0001);
			static const variable invalidParameter        		(0x0002);
			static const variable unknownType        				(0x0003);
			static const variable additionalDataMismatch       (0x0004);
			static const variable worklistManagementDisabled   (0x0005);

			//static const variable ....(0xFFFF)					// If a new ErrorCode is added, function Error::MakeErrorDescription() has to be updated
		}

		namespace TrStr													// Translated error strings
		{
			static const variable unexpected							(Translate("Unexpected error."));
			static const variable invalidParameter					(Translate("The parameter is invalid:"));
			static const variable unknownType						(Translate("Unknown type."));
			static const variable additionalDataMismatch			(Translate("The job additional data with the key '%1' has been multiple defined with different value types."));
			static const variable worklistManagementDisabled	(Translate("The Vector Database worklist management is disabled."));
			static const variable noErrorTextAvailable			(Translate("No error description available."));
		}

		// ----------------------------------------------------------------------------------------------------
		// Error functions
		// ----------------------------------------------------------------------------------------------------

		static function MakeErrorDescription(
			variable errorCode,
			variable& additionalDescription) variable
		{
			variable description("");
			variable errorNumber(0);
			variable additionalDescriptionHandled(hslFalse);

			if (ErrorCode::unexpected == errorCode)
				description = TrStr::unexpected;
			else if (ErrorCode::invalidParameter == errorCode)
				description = TrStr::invalidParameter;
			else if (ErrorCode::unknownType == errorCode)
				description = TrStr::unknownType;
			else if (ErrorCode::additionalDataMismatch == errorCode)
			{
				description = TrStr::additionalDataMismatch;
				StrReplace(description, "%1", additionalDescription);
				additionalDescriptionHandled = hslTrue;
			}
			else if (ErrorCode::worklistManagementDisabled == errorCode)
				description = TrStr::worklistManagementDisabled;
			//...		
			//...
			//... 
			//...
			//...
			else
			{
				description = TrStr::noErrorTextAvailable;
			}

			// Generate the full description
			if ( !additionalDescriptionHandled && (additionalDescription != "") )
			{
				description = description + "\n\n" + additionalDescription;
			}
			return(description);
		}
	}

	// ----------------------------------------------------------------------------------------------------
	// Utility functions
	// ----------------------------------------------------------------------------------------------------

	static function GetHelpFileName() variable	// Builds the library help file name
	{
		return(Constants::helpFileShortName + GetLanguage() + Constants::helpFileExtension);
	}

	static global function VectorDb_InitWorklistManagementCS() void
	{
		if (0 == vectorDb_WorklistManagementCS)
		{
			vectorDb_WorklistManagementCS = SynInitializeCriticalSection();
			if (0 == vectorDb_WorklistManagementCS)
			{
				Util2::Error::RaiseRuntimeError(Error::majorID, Error::MinorID::generalRuntimeError, Error::ErrorCode::unexpected,
												Error::MakeErrorDescription(Error::ErrorCode::unexpected, ""), 
												GetHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
			}

			#ifdef DEBUG_VECTOR_DB_CORE
			FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "Initialized critical section object, id = ", vectorDb_WorklistManagementCS);
			#endif
		}
	}

	static function InitLibrary() void			// Library initialization function
	{
		// Initialize critical section object 
		VectorDb_InitWorklistManagementCS();

		// Activate error handler
		onerror goto Unexpected;

		// Lock critical section
		SynEnterCriticalSection(vectorDb_WorklistManagementCS);

		if (vectorDb_WorklistManagementObj.IsNull())
		{
			// Create Worklist Management object (= IHxVectorDbWorklistManagement)
			vectorDb_WorklistManagementObj.CreateObject("Hamilton.HxVectorDbWorklistManagement");

			// Initialize Worklist Management object
			vectorDb_WorklistManagementObj.Init("");

			#ifdef DEBUG_VECTOR_DB_CORE
			FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "Created Worklist Management object, id = ", vectorDb_WorklistManagementObj);
			#endif

			// check if Tracking is enabled
			vectorDb_WorklistManagementEnabled = vectorDb_WorklistManagementObj.Enabled();
		//>> 20061124
		}
		//<< 20061124

		// Initialize Worklist Management constants exported via HSLVectorDbWorklistManagementDefs.hs_
		VectorDb_JobState::Unprocessed = vectorDb_WorklistManagementObj.HxVectorDbJobState_Unprocessed;
		VectorDb_JobState::Assigned = vectorDb_WorklistManagementObj.HxVectorDbJobState_Assigned;
		VectorDb_JobState::Processed = vectorDb_WorklistManagementObj.HxVectorDbJobState_Processed;
		VectorDb_JobState::Filter_Any = vectorDb_WorklistManagementObj.HxVectorDbJobState__Filter_Any;

		VectorDb_SortingDirection::Ascending = vectorDb_WorklistManagementObj.HxVectorDbSortingAlgorithm_Ascending;
		VectorDb_SortingDirection::Descending = vectorDb_WorklistManagementObj.HxVectorDbSortingAlgorithm_Descending;

		VectorDb_LabwareUsageType::Source = vectorDb_WorklistManagementObj.HxVectorDbLabwareUsageType_Source;
		VectorDb_LabwareUsageType::Target = vectorDb_WorklistManagementObj.HxVectorDbLabwareUsageType_Target;
		VectorDb_LabwareUsageType::Filter_Any = vectorDb_WorklistManagementObj.HxVectorDbLabwareUsageType__Filter_Any;
		VectorDb_LabwareUsageType::Filter_All = vectorDb_WorklistManagementObj.HxVectorDbLabwareUsageType__Filter_All;

		Constants::jobStateMin = VectorDb_JobState::Unprocessed;
		Constants::jobStateMax = VectorDb_JobState::Processed;
		//>> 20061124
		//}
		//<< 20061124

		// Check whether Vector Database is enabled
		if (!vectorDb_WorklistManagementEnabled)
		{
			Util2::Error::RaiseRuntimeError(Error::majorID, Error::MinorID::generalRuntimeError, Error::ErrorCode::worklistManagementDisabled,
											Error::MakeErrorDescription(Error::ErrorCode::worklistManagementDisabled, ""), 
											GetHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
		}

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

		return;

		Unexpected:
		{
			// Unlock critical section
			if (0 != vectorDb_WorklistManagementCS)
				SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 

	static function VectorDbTypOf(					// Maps the HSL type of the given value to its corresponding VectorDbValueType
		variable& value) variable						// [in]
	{
		variable hslType("");
		variable vectorDbTyp(0);

		hslType = GetType(value);
		if (hslInteger.Compare(hslType) == 0)
		{
			vectorDbTyp = vectorDb_WorklistManagementObj.HxVectorDbValueType_Integer;
		}
		else if (hslFloat.Compare(hslType) == 0)
		{
			vectorDbTyp = vectorDb_WorklistManagementObj.HxVectorDbValueType_Float;
		}
		else if (hslString.Compare(hslType) == 0)
		{
			vectorDbTyp = vectorDb_WorklistManagementObj.HxVectorDbValueType_String;
		}
		else
		{
			Util2::Error::RaiseRuntimeError(Error::majorID, Error::MinorID::generalRuntimeError, Error::ErrorCode::unknownType,
											Error::MakeErrorDescription(Error::ErrorCode::unknownType, ""), 
											GetHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
		}
		return(vectorDbTyp);
	}

	static function UnpackWorklistJobParsPackage(	// Unpacks the given worklist job pars package into the given arrays
		object& resultPars,									// [in]
		variable& jobIDs[],									// [in/out]
		variable& jobNames[],								// [in/out]
		variable& jobPriorities[], 						// [in/out]
		variable& jobStates[], 								// [in/out]
		variable& jobUserStates[], 						// [in/out]
		variable& sourceElementIDs[],						// [in/out]
		variable& sourceBarcodes[], 						// [in/out]
		variable& sourceLabwareIds[],						// [in/out]
		variable& sourcePositionIds[], 					// [in/out]
		variable& sourceRequiredFlags[], 				// [in/out]
		variable& targetElementIDs[],						// [in/out]
		variable& targetBarcodes[], 						// [in/out]
		variable& targetLabwareIds[], 					// [in/out]
		variable& targetPositionIds[], 					// [in/out]
		variable& targetVolumes[]) variable				// [in/out]
	{
		variable i(0);											// Loop index
		variable count(0);									// embedded pars package count
		variable numberOfJobs(0);							// Number of jobs added to output params

		// Unpack worklist job pars package
		count = resultPars.Count;
		for (i = 1; i <= count; i++)
		{
			object pars;
			variable jobID(0);
			variable jobName("");
			variable jobPriority(0);
			variable jobState(0);
			variable jobUserState(0);
			variable sourceBarcode("");
			variable sourceElementID(0);
			variable sourceLabwareId("");
			variable sourcePositionId("");
			variable sourceRequiredFlag(0);
			variable targetBarcode("");
			variable targetElementID(0);
			variable targetLabwareId("");
			variable targetPositionId("");
			variable targetVolume(0);

			pars = resultPars.Item1(i);
			jobID = pars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_JobID);
			jobName = pars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_JobName);
			jobPriority = pars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_JobPriority);
			jobState = pars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_JobState);
			jobUserState = pars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_UserJobState);
			sourceElementID = pars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_SourceElementID);
			sourceBarcode = pars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_SourceBarcode);
			sourceLabwareId = pars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_SourceLabwareId);
			sourcePositionId = pars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_SourcePositionId);
			sourceRequiredFlag = pars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_SourceRequired);
			targetElementID = pars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_TargetElementID);
			targetBarcode = pars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_TargetBarcode);
			targetLabwareId = pars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_TargetLabwareId);
			targetPositionId = pars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_TargetPositionId);
			targetVolume = pars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_TransportVolume);

			// Dump job data
			#ifdef DEBUG_VECTOR_DB_CORE
			FormatTrace(Constants::traceSource, Constants::traceActionGetJobs, TraceStatus::progress,	
																	"jobID = ", jobID, 
																	", jobName = ", jobName, 
																	", jobPriority = ", jobPriority, 
																	", jobState = ", jobState, 
																	", jobUserState = ", jobUserState, 
																	", sourceElementID = ", sourceElementID, 
																	", sourceBarcode = ", sourceBarcode, 
																	", sourceLabwareId = ", sourceLabwareId, 
																	", sourcePositionId = ", sourcePositionId, 
																	", sourceRequiredFlag = ", sourceRequiredFlag, 
																	", targetElementID = ", targetElementID, 
																	", targetBarcode = ", targetBarcode, 
																	", targetLabwareId = ", targetLabwareId, 
																	", targetPositionId = ", targetPositionId, 
																	", targetVolume = ", targetVolume);
			#endif

			// Add job data to out params
			jobIDs.AddAsLast(jobID);
			jobNames.AddAsLast(jobName);
			jobPriorities.AddAsLast(jobPriority);
			jobStates.AddAsLast(jobState);
			jobUserStates.AddAsLast(jobUserState);
			sourceElementIDs.AddAsLast(sourceElementID);
			sourceBarcodes.AddAsLast(sourceBarcode);
			sourceLabwareIds.AddAsLast(sourceLabwareId);
			sourcePositionIds.AddAsLast(sourcePositionId);
			sourceRequiredFlags.AddAsLast(sourceRequiredFlag);
			targetElementIDs.AddAsLast(targetElementID);
			targetBarcodes.AddAsLast(targetBarcode);
			targetLabwareIds.AddAsLast(targetLabwareId);
			targetPositionIds.AddAsLast(targetPositionId);
			targetVolumes.AddAsLast(targetVolume);
			numberOfJobs++;
		}

		return(numberOfJobs);
	} 

	static function GetCurrentRunID() variable // Returns current run ID (integer)
	{
		object vectorDbTrackingObject;

		vectorDbTrackingObject = GetVectorDbTrackerObject();
		return(vectorDbTrackingObject.GetRunID(GetUniqueRunId()));
	}

	// ----------------------------------------------------------------------------------------------------
	// Interface functions
	// ----------------------------------------------------------------------------------------------------

	function AddJob(
		variable& jobName, 									// [in]
		variable  jobPriority, 								// [in]
		variable  jobState, 									// [in]
		variable  jobUserState, 							// [in]
		variable& sourceBarcode, 							// [in]
		variable& sourceLabwareId, 						// [in]
		variable& sourcePositionId, 						// [in]
		variable  sourceRequiredFlag, 					// [in]
		variable& targetBarcode, 							// [in]
		variable& targetLabwareId, 						// [in]
		variable& targetPositionId, 						// [in]
		variable  targetVolume) variable					// [in]
	{
		variable errorDesc("");								// Error description
		object jobPars;										// Pars package containing job data
		object jobsPars;										// Pars package containing jobs
		object jobAdditionalDataPars;						// Pars package containing additional job data
		variable jobIds[];									// Place to retrieve ids of added jobs

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionAddJob, TraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(Constants::traceSource, Constants::traceActionAddJob, TraceStatus::progress,	
																	"jobName = ", jobName, 
																	", jobPriority = ", jobPriority, 
																	", jobState = ", jobState, 
																	", jobUserState = ", jobUserState, 
																	", sourceBarcode = ", sourceBarcode, 
																	", sourceLabwareId = ", sourceLabwareId, 
																	", sourcePositionId = ", sourcePositionId, 
																	", sourceRequiredFlag = ", sourceRequiredFlag, 
																	", targetBarcode = ", targetBarcode, 
																	", targetLabwareId = ", targetLabwareId, 
																	", targetPositionId = ", targetPositionId, 
																	", targetVolume = ", targetVolume);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		InitLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_WorklistManagementCS);

		// Check input params to be valid
		errorDesc = Constants::traceActionAddJob + Constants::crlf;
		Util2::CheckValueTypeAndRangeMinMax(jobName, hslString, Constants::jobNameMin, Constants::jobNameMax, 
							errorDesc + "jobName");
		Util2::CheckValueTypeAndRangeMinMax(jobPriority, hslInteger, Constants::jobPriorityMin, Constants::jobPriorityMax, 
							errorDesc + "jobPriority");
		Util2::CheckValueTypeAndRangeMinMax(jobState, hslInteger, Constants::jobStateMin, Constants::jobStateMax, 
							errorDesc + "jobState");
		Util2::CheckValueTypeAndRangeMinMax(jobUserState, hslInteger, Constants::jobUserStateMin, Constants::jobUserStateMax, 
							errorDesc + "jobUserState");
		Util2::CheckValueTypeAndRangeMinMax(sourceBarcode, hslString, Constants::sourceBarcodeMin, Constants::sourceBarcodeMax, 
							errorDesc + "sourceBarcode");
		Util2::CheckValueTypeAndRangeMinMax(sourceLabwareId, hslString, Constants::sourceLabwareIdMin, Constants::sourceLabwareIdMax, 
							errorDesc + "sourceLabwareId");
		Util2::CheckValueTypeAndRangeMinMax(sourcePositionId, hslString, Constants::sourcePositionIdMin, Constants::sourcePositionIdMax, 
							errorDesc + "sourcePositionId");
		Util2::CheckValueTypeAndRangeMinMax(sourceRequiredFlag, hslInteger, Constants::sourceRequiredMin, Constants::sourceRequiredMax, 
							errorDesc + "sourceRequiredFlag");
		Util2::CheckValueTypeAndRangeMinMax(targetBarcode, hslString, Constants::targetBarcodeMin, Constants::targetBarcodeMax, 
							errorDesc + "targetBarcode");
		Util2::CheckValueTypeAndRangeMinMax(targetLabwareId, hslString, Constants::targetLabwareIdMin, Constants::targetLabwareIdMax, 
							errorDesc + "targetLabwareId");
		Util2::CheckValueTypeAndRangeMinMax(targetPositionId, hslString, Constants::targetPositionIdMin, Constants::targetPositionIdMax, 
							errorDesc + "targetPositionId");
		Util2::CheckValueTypeAndRange(targetVolume, hslFloat, Util2::ValueCheck::RangeNumberGreaterOrEqualToZero, 
							errorDesc + "targetVolume");

		// Add job
		jobPars.CreateObject("HXPARAMSLib.HxPars");
		jobsPars.CreateObject("HXPARAMSLib.HxPars");
		jobAdditionalDataPars.CreateObject("HXPARAMSLib.HxPars");

		jobPars.Add(GetCurrentRunID(), vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_RunID);
		jobPars.Add(vectorDb_WorklistManagementObj.HxVectorDbJobState_Unprocessed, vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_JobState);
		jobPars.Add(jobName, vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_JobName);
		jobPars.Add(jobPriority, vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_JobPriority);
		jobPars.Add(jobState, vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_JobState);
		jobPars.Add(jobUserState, vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_UserJobState);
		jobPars.Add(0, vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_SourceElementID);
		jobPars.Add(sourceBarcode, vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_SourceBarcode);
		jobPars.Add(sourceLabwareId, vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_SourceLabwareId);
		jobPars.Add(sourcePositionId, vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_SourcePositionId);
		jobPars.Add(sourceRequiredFlag, vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_SourceRequired);
		jobPars.Add(0, vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_TargetElementID);
		jobPars.Add(targetBarcode, vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_TargetBarcode);
		jobPars.Add(targetLabwareId, vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_TargetLabwareId);
		jobPars.Add(targetPositionId, vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_TargetPositionId);
		jobPars.Add(targetVolume, vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_TransportVolume);
		jobPars.Add(jobAdditionalDataPars, vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_AdditionalData);
		
		jobsPars.Add(jobPars, 1);
		
		jobIds = vectorDb_WorklistManagementObj.AddJobs(jobsPars);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionAddJob, TraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

		// Return job id
		if (0 < jobIds.GetSize())
			return(jobIds.ElementAt(0));
		return(0);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_WorklistManagementCS)
				SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(Constants::traceSource, Constants::traceActionAddJob, TraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 

	static function AddJobAdditionalData(
		variable jobID,									// [in]
		variable& additionalDataKey,					// [in]
		variable& additionalDataValue) variable	// [in]
	{
		variable errorDesc("");							// Error description
		variable additionalDataType(0);				// Additional data type
		object dataPars;									// Data pars package
		object additionalDataPars;						// Additional data pars package

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionAddJobAdditionalData, TraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(Constants::traceSource, Constants::traceActionAddJobAdditionalData, TraceStatus::progress, 
																"jobID = ", jobID,
																", additionalDataKey = ", additionalDataKey, 
																", additionalDataValue = ", additionalDataValue); 
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		InitLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_WorklistManagementCS);

		// Check input params to be valid
		errorDesc = Constants::traceActionAddJobAdditionalData + Constants::crlf;
		Util2::CheckValueTypeAndRange(jobID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
							errorDesc + "jobID");
		Util2::CheckValueTypeAndRangeMinMax(additionalDataKey, hslString, Constants::additionalDataKeyMin, Constants::additionalDataKeyMax, 
							errorDesc + "additionalDataKey");

		// Add additional data
		additionalDataType = VectorDbTypOf(additionalDataValue);
		dataPars.CreateObject("HXPARAMSLib.HxPars");
		additionalDataPars.CreateObject("HXPARAMSLib.HxPars");

		dataPars.Add(additionalDataType, vectorDb_WorklistManagementObj.HxVectorDbParsKey_AdditionalData_ValueType);
		dataPars.Add(additionalDataValue, vectorDb_WorklistManagementObj.HxVectorDbParsKey_AdditionalData_Value);
		additionalDataPars.Add(dataPars, additionalDataKey);
		
		vectorDb_WorklistManagementObj.AddJobAdditionalData(jobID, additionalDataPars);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionAddJobAdditionalData, TraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

		return(hslTrue);

		Unexpected:
		{
			// Unlock critical section
			if (0 != vectorDb_WorklistManagementCS)
				SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(Constants::traceSource, Constants::traceActionAddJobAdditionalData, TraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 

	static function RemoveJob(
		variable jobID) variable				// [in]
	{
		variable errorDesc("");								// Error description

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionRemoveJob, TraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(Constants::traceSource, Constants::traceActionRemoveJob, TraceStatus::progress,	"jobID = ", jobID);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		InitLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_WorklistManagementCS);

		// Check input params to be valid
		errorDesc = Constants::traceActionRemoveJob + Constants::crlf;
		Util2::CheckValueTypeAndRange(jobID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
							errorDesc + "jobID");

		// Remove job
		vectorDb_WorklistManagementObj.RemoveJob(jobID);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionRemoveJob, TraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

		// Return status
		return(hslTrue);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_WorklistManagementCS)
				SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(Constants::traceSource, Constants::traceActionRemoveJob, TraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 

	static function RemoveJobAdditionalData(
		variable jobID,									// [in]
		variable& additionalDataKey) variable		// [in]
	{
		variable errorDesc("");							// Error description
		variable affectedRecords(0);					// Number of affected records
		variable additionalDataKeys[];				// Additional data keys

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionRemoveJobAdditionalData, TraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(Constants::traceSource, Constants::traceActionRemoveJobAdditionalData, TraceStatus::progress, 
																"jobID = ", jobID,
																", additionalDataKey = ", additionalDataKey);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		InitLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_WorklistManagementCS);

		// Check input params to be valid
		errorDesc = Constants::traceActionRemoveJobAdditionalData + Constants::crlf;
		Util2::CheckValueTypeAndRange(jobID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
							errorDesc + "jobID");
		Util2::CheckValueTypeAndRange(additionalDataKey, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
							errorDesc + "additionalDataKey");

		// Remove additional data
		additionalDataKeys.AddAsLast(additionalDataKey);
		affectedRecords = vectorDb_WorklistManagementObj.DeleteJobAdditionalData(jobID, additionalDataKeys);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionRemoveJobAdditionalData, TraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

		return(affectedRecords);

		Unexpected:
		{
			// Unlock critical section
			if (0 != vectorDb_WorklistManagementCS)
				SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(Constants::traceSource, Constants::traceActionRemoveJobAdditionalData, TraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 

	static function GetJobs(
		variable jobStateFilter,							// [in]
		variable& jobIDs[],									// [in/out]
		variable& jobNames[],								// [in/out]
		variable& jobPriorities[], 						// [in/out]
		variable& jobStates[], 								// [in/out]
		variable& jobUserStates[], 						// [in/out]
		variable& sourceElementIDs[],						// [in/out]
		variable& sourceBarcodes[], 						// [in/out]
		variable& sourceLabwareIds[],						// [in/out]
		variable& sourcePositionIds[], 					// [in/out]
		variable& sourceRequiredFlags[], 				// [in/out]
		variable& targetElementIDs[],						// [in/out]
		variable& targetBarcodes[], 						// [in/out]
		variable& targetLabwareIds[], 					// [in/out]
		variable& targetPositionIds[], 					// [in/out]
		variable& targetVolumes[]) variable				// [in/out]
	{
		variable errorDesc("");								// Error description
		variable numberOfJobs(0);							// Number of jobs
		object resultPars;									// Result pars package

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobs, TraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobs, TraceStatus::progress, "jobStateFilter = ", jobStateFilter);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		InitLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_WorklistManagementCS);

		// Check input params to be valid
		errorDesc = Constants::traceActionGetJobs + Constants::crlf;
		Util2::CheckValueTypeAndRangeMinMax(jobStateFilter, hslInteger, VectorDb_JobState::Filter_Any, VectorDb_JobState::Processed, 
							errorDesc + "jobStateFilter");

		// Get jobs
		resultPars = vectorDb_WorklistManagementObj.GetJobs(jobStateFilter);
		numberOfJobs = UnpackWorklistJobParsPackage(	resultPars,
																	jobIDs,
																	jobNames,
																	jobPriorities,
																	jobStates,
																	jobUserStates,
																	sourceElementIDs,
																	sourceBarcodes,
																	sourceLabwareIds,
																	sourcePositionIds,
																	sourceRequiredFlags,
																	targetElementIDs,
																	targetBarcodes,
																	targetLabwareIds,
																	targetPositionIds,
																	targetVolumes);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobs, TraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

		return(numberOfJobs);

		Unexpected:
		{
			// Unlock critical section
			if (0 != vectorDb_WorklistManagementCS)
				SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(Constants::traceSource, Constants::traceActionGetJobs, TraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 

	function GetJob(
		variable jobID,							// [in]
		variable& jobName,						// [in/out]
		variable& jobPriority, 					// [in/out]
		variable& jobState, 						// [in/out]
		variable& jobUserState, 				// [in/out]
		variable& sourceElementID,				// [in/out]
		variable& sourceBarcode, 				// [in/out]
		variable& sourceLabwareId,				// [in/out]
		variable& sourcePositionId, 			// [in/out]
		variable& sourceRequiredFlag, 		// [in/out]
		variable& targetElementID,				// [in/out]
		variable& targetBarcode, 				// [in/out]
		variable& targetLabwareId, 			// [in/out]
		variable& targetPositionId, 			// [in/out]
		variable& targetVolume) variable		// [in/out]
	{
		variable errorDesc("");								// Error description
		object resultPars;									// Result pars package

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionGetJob, TraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(Constants::traceSource, Constants::traceActionGetJob, TraceStatus::progress, "jobID = ", jobID);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		InitLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_WorklistManagementCS);

		// Check input params to be valid
		errorDesc = Constants::traceActionGetJob + Constants::crlf;
		Util2::CheckValueTypeAndRange(jobID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
							errorDesc + "jobID");

		// Get jobs
		resultPars = vectorDb_WorklistManagementObj.GetJob(jobID);
		jobID = resultPars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_JobID);
		jobName = resultPars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_JobName);
		jobPriority = resultPars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_JobPriority);
		jobState = resultPars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_JobState);
		jobUserState = resultPars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_UserJobState);
		sourceElementID = resultPars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_SourceElementID);
		sourceBarcode = resultPars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_SourceBarcode);
		sourceLabwareId = resultPars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_SourceLabwareId);
		sourcePositionId = resultPars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_SourcePositionId);
		sourceRequiredFlag = resultPars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_SourceRequired);
		targetElementID = resultPars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_TargetElementID);
		targetBarcode = resultPars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_TargetBarcode);
		targetLabwareId = resultPars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_TargetLabwareId);
		targetPositionId = resultPars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_TargetPositionId);
		targetVolume = resultPars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_Job_TransportVolume);

		// Dump job data
		#ifdef DEBUG_VECTOR_DB_CORE
		FormatTrace(Constants::traceSource, Constants::traceActionGetJob, TraceStatus::progress,	
																"jobID = ", jobID, 
																", jobName = ", jobName, 
																", jobPriority = ", jobPriority, 
																", jobState = ", jobState, 
																", jobUserState = ", jobUserState, 
																", sourceElementID = ", sourceElementID, 
																", sourceBarcode = ", sourceBarcode, 
																", sourceLabwareId = ", sourceLabwareId, 
																", sourcePositionId = ", sourcePositionId, 
																", sourceRequiredFlag = ", sourceRequiredFlag, 
																", targetElementID = ", targetElementID, 
																", targetBarcode = ", targetBarcode, 
																", targetLabwareId = ", targetLabwareId, 
																", targetPositionId = ", targetPositionId, 
																", targetVolume = ", targetVolume);
		#endif

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionGetJob, TraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

		return(hslTrue);

		Unexpected:
		{
			// Unlock critical section
			if (0 != vectorDb_WorklistManagementCS)
				SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(Constants::traceSource, Constants::traceActionGetJob, TraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 

	static function GetJobAdditionalData(
		variable jobID,										// [in]
		variable& additionalDataKeys[],					// [in/out]
		variable& additionalDataValues[]) variable	// [in/out]
	{
		variable errorDesc("");								// Error description
		variable numberOfAdditionalData(0);				// Number of additional data
		object resultPars;									// Result pars package
		object enum;											// Pars package enumerator (= IEnumVARIANT)
		object item;											// Pars package item 

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobAdditionalData, TraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobAdditionalData, TraceStatus::progress, "jobID = ", jobID);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		InitLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_WorklistManagementCS);

		// Check input params to be valid
		errorDesc = Constants::traceActionGetJobAdditionalData + Constants::crlf;
		Util2::CheckValueTypeAndRange(jobID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
							errorDesc + "jobID");

		// Get jobs
		resultPars = vectorDb_WorklistManagementObj.GetJobAdditionalData(jobID);
		enum = resultPars._NewEnum;
		while (enum.EnumNext(item))
		{
			object pars;
			variable additionalDataID_(0);
			variable additionalDataKey_(0);
			variable additionalDataValueType_(0);
			variable additionalDataValue_(0);

			pars = item.Value;
			additionalDataKey_ = item.Key;
			additionalDataID_= pars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_AdditionalData_AdditionalDataID);
			additionalDataValueType_= pars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_AdditionalData_ValueType);
			additionalDataValue_ = pars.Item1(vectorDb_WorklistManagementObj.HxVectorDbParsKey_AdditionalData_Value);

			// Dump job data
			#ifdef DEBUG_VECTOR_DB_CORE
			FormatTrace(Constants::traceSource, Constants::traceActionGetJobAdditionalData, TraceStatus::progress,
																				"additionalDataID = ", additionalDataID_, 
																				", additionalDataKey = ", additionalDataKey_, 
																				", additionalDataValueType = ", additionalDataValueType_, 
																				", additionalDataValue = ", additionalDataValue_);
			#endif

			additionalDataKeys.AddAsLast(additionalDataKey_);
			additionalDataValues.AddAsLast(additionalDataValue_);
			numberOfAdditionalData++;
		}

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobAdditionalData, TraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

		return(numberOfAdditionalData);

		Unexpected:
		{
			// Unlock critical section
			if (0 != vectorDb_WorklistManagementCS)
				SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(Constants::traceSource, Constants::traceActionGetJobAdditionalData, TraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 

	static function GetJobIDs(
		variable& searchCondition,							// [in]
		variable& orderByExpression,						// [in]
		variable queryJobAdditionalData,					// [in]
		variable queryJobLabwareData) variable[]						// [in]
	{
		variable errorDesc("");								// Error description

		variable searchConditionCleaned(searchCondition);

		variable jobStateFilter(0);						// Job state filter
		variable numberOfJobs(0);							// Number of jobs
		variable numberOfJobAdditionalData(0);			// Number of job additional data keys
		variable numberOfAdditionalDataValues(0);		// Number of additional data values
	
		variable jobIDs[];
		variable jobNames[];
		variable jobPriorities[];
		variable jobStates[];
		variable jobUserStates[];
		variable sourceElementIDs[];
		variable sourceBarcodes[];
		variable sourceLabwareIds[];
		variable sourcePositionIds[];
		variable sourceRequiredFlags[];
		variable targetElementIDs[];
		variable targetBarcodes[];
		variable targetLabwareIds[];
		variable targetPositionIds[];
		variable targetVolumes[];

		variable sourceLoadingTimes[];
		variable sourceXCoordinates[];
		variable sourceYCoordinates[];
		variable sourceZCoordinates[];
		variable targetLoadingTimes[];
		variable targetXCoordinates[];
		variable targetYCoordinates[];
		variable targetZCoordinates[];

		variable jobAdditionalDataKeys[];				// Job additional data keys
		variable jobAdditionalDataValues[];				// Job additional data values
		variable additionalDataValues[];					// Place to store additional data values of all jobs

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobIDs, TraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobIDs, TraceStatus::progress, 
																"searchCondition = ", searchCondition,
																"orderByExpression = ", orderByExpression,
																"queryJobAdditionalData = ", queryJobAdditionalData,
																"queryJobLabwareData = ", queryJobLabwareData);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		InitLibrary();

		// Check input params to be valid
		errorDesc = Constants::traceActionGetJobIDs + Constants::crlf;
		Util2::CheckValueType(searchCondition, hslString,
							errorDesc + "searchCondition");
		Util2::CheckValueType(orderByExpression, hslString,
							errorDesc + "orderByExpression");
		Util2::CheckValueTypeAndRangeMinMax(queryJobAdditionalData, hslInteger, 0, 1, 
							errorDesc + "queryJobAdditionalData");
		Util2::CheckValueTypeAndRangeMinMax(queryJobLabwareData, hslInteger, 0, 1, 
							errorDesc + "queryJobLabwareData");

		// Get jobs
		jobStateFilter = vectorDb_WorklistManagementObj.HxVectorDbJobState__Filter_Any;
		numberOfJobs = GetJobs(	jobStateFilter,jobIDs,jobNames,jobPriorities,jobStates,jobUserStates,
										sourceElementIDs,sourceBarcodes,sourceLabwareIds,sourcePositionIds,sourceRequiredFlags,
										targetElementIDs,targetBarcodes,targetLabwareIds,targetPositionIds,targetVolumes);

		StrReplace(searchConditionCleaned, " ", "");
		if (StrFind(searchConditionCleaned, StrConcat2(VectorDb_WorklistColumnName::jobName, "=")) >= 0)
		{
			variable i(0);

			for (i = 0; i < numberOfJobs; i++)
			{
				if (StrFind(searchCondition, jobNames.ElementAt(i)) < 0)
				{
					jobIDs.RemoveElementAt(i);
					jobNames.RemoveElementAt(i);
					jobPriorities.RemoveElementAt(i);
					jobStates.RemoveElementAt(i);
					jobUserStates.RemoveElementAt(i);
					sourceElementIDs.RemoveElementAt(i);
					sourceBarcodes.RemoveElementAt(i);
					sourceLabwareIds.RemoveElementAt(i);
					sourcePositionIds.RemoveElementAt(i);
					sourceRequiredFlags.RemoveElementAt(i);
					targetElementIDs.RemoveElementAt(i);
					targetBarcodes.RemoveElementAt(i);
					targetLabwareIds.RemoveElementAt(i);
					targetPositionIds.RemoveElementAt(i);
					targetVolumes.RemoveElementAt(i);

					--numberOfJobs;
					--i;
				}
			}
		}


		if (queryJobAdditionalData)
		{
			variable i(0);
			variable j(0);
			variable k(0);
			variable keys[];
			variable values[];
			variable tmpAdditionalDataCount[];
			variable tmpAdditionalDataKeys[];
			variable tmpAdditionalDataValues[];
			variable tmpAdditionalDataKeyFound(hslFalse);
			variable tmpAdditionalDataIndex(0);

			tmpAdditionalDataCount.SetSize(0);
			tmpAdditionalDataKeys.SetSize(0);
			tmpAdditionalDataValues.SetSize(0);

			for (i = 0; i < numberOfJobs; i++)
			{
				keys.SetSize(0);
				values.SetSize(0);
				tmpAdditionalDataCount.AddAsLast(GetJobAdditionalData(jobIDs.ElementAt(i), keys, values));

				for (j = 0; j < tmpAdditionalDataCount.ElementAt(i); j++)
				{
					tmpAdditionalDataKeys.AddAsLast(keys.ElementAt(j));
					tmpAdditionalDataValues.AddAsLast(values.ElementAt(j));

					tmpAdditionalDataKeyFound = hslFalse;

					for (k = 0; k < jobAdditionalDataKeys.GetSize(); k++)
					{
						if (jobAdditionalDataKeys.ElementAt(k) == keys.ElementAt(j))
						{
							if (GetType(jobAdditionalDataValues.ElementAt(k)) != GetType(values.ElementAt(j)))
							{
								Util2::Error::RaiseRuntimeError(Error::majorID, Error::MinorID::generalRuntimeError, Error::ErrorCode::additionalDataMismatch,
												Error::MakeErrorDescription(Error::ErrorCode::additionalDataMismatch, keys.ElementAt(j)), 
												GetHelpFileName(), GetFileName(), GetFunctionName(), GetLineNumber());
							}
						}
					}

					if (tmpAdditionalDataKeyFound == hslFalse)
					{
						jobAdditionalDataKeys.AddAsLast(keys.ElementAt(j));
						jobAdditionalDataValues.AddAsLast(values.ElementAt(j));
					}
				}
			}

			numberOfJobAdditionalData = jobAdditionalDataKeys.GetSize();

			additionalDataValues.SetSize(numberOfJobAdditionalData * tmpAdditionalDataCount.GetSize());

			for (i = 0; i < tmpAdditionalDataCount.GetSize(); i++)
			{
				for (j = 0; j < numberOfJobAdditionalData; j++)
				{
					//tmpAdditionalDataKeyFound = hslFalse;

					for (k = tmpAdditionalDataIndex; k < tmpAdditionalDataCount.ElementAt(i) + tmpAdditionalDataIndex; k++)
					{
						if (tmpAdditionalDataKeys.ElementAt(k) == jobAdditionalDataKeys.ElementAt(j))
							additionalDataValues.SetAt(i * numberOfJobAdditionalData + j, tmpAdditionalDataValues.ElementAt(k));
							//tmpAdditionalDataKeyFound = hslTrue;
					}

					//if (tmpAdditionalDataKeyFound == hslTrue)
					//{
					//	additionalDataValues.SetAt(, 
					//}
				}
				tmpAdditionalDataIndex = tmpAdditionalDataIndex + tmpAdditionalDataCount.ElementAt(i);
			}
		}

		// Check whether we should query job labware data 
		if (queryJobLabwareData)
		{
			variable i(0);

			// We should query job labware data 

			// Iterate over all jobs
			for (i = 0; i < numberOfJobs; i++)
			{
				variable loadingTime(0.0);
				variable deckID(0);
				variable deckCoordinateX(0.0);
				variable deckCoordinateY(0.0);
				variable deckCoordinateZ(0.0);

				// Get job source labware data
				if (0 < sourceElementIDs.ElementAt(i))
				{
					VectorDb_Labware::GetLabwareByElementID(	sourceElementIDs.ElementAt(i),
																deckID,
																0, // parentElementID,
																0, // labwareName,
																0, // labwareLevel,
																0, // barcode,
																0, // volume,
																0, // labwareState,
																0, // userLabwareState,
																deckCoordinateX,
																deckCoordinateY,
																deckCoordinateZ,
																0); // userLabwareTypeID);

					onerror resume next;
					loadingTime = VectorDb_Labware::GetLabwareLoadingTimeByElementID(
															deckID,
															sourceElementIDs.ElementAt(i),
															VectorDb_DateTimeFormat::Unformatted);
					onerror goto 0;
				}

				sourceLoadingTimes.AddAsLast(loadingTime);
				sourceXCoordinates.AddAsLast(deckCoordinateX);
				sourceYCoordinates.AddAsLast(deckCoordinateY);
				sourceZCoordinates.AddAsLast(deckCoordinateZ);

				loadingTime = 0.0;
				deckID = 0;
				deckCoordinateX = 0.0;
				deckCoordinateY = 0.0;
				deckCoordinateZ = 0.0;

				// Get job target labware data
				if (0 < targetElementIDs.ElementAt(i))
				{
					VectorDb_Labware::GetLabwareByElementID(	targetElementIDs.ElementAt(i),
																deckID,
																0, // parentElementID,
																0, // labwareName,
																0, // labwareLevel,
																0, // barcode,
																0, // volume,
																0, // labwareState,
																0, // userLabwareState,
																deckCoordinateX,
																deckCoordinateY,
																deckCoordinateZ,
																0); // userLabwareTypeID);


					onerror resume next;
					loadingTime = VectorDb_Labware::GetLabwareLoadingTimeByElementID(
															deckID,
															targetElementIDs.ElementAt(i),
															VectorDb_DateTimeFormat::Unformatted);
					onerror goto 0;
				}

				targetLoadingTimes.AddAsLast(loadingTime);
				targetXCoordinates.AddAsLast(deckCoordinateX);
				targetYCoordinates.AddAsLast(deckCoordinateY);
				targetZCoordinates.AddAsLast(deckCoordinateZ);
			}
		}		

		// Lock critical section
		SynEnterCriticalSection(vectorDb_WorklistManagementCS);

		// Apply values filter and values sorting to the results 
		if (0 < numberOfJobs)
		{
			variable i(0);									// Loop index
			variable j(0);									// Loop index
			variable tempFileName("");					// Temporary data base file name

			variable jobID(0);
			variable jobName("");
			variable jobState(0);
			variable jobUserState(0);
			variable jobPriority(0);
			variable sourceElementID(0);
			variable sourceBarcode("");
			variable sourceLabwareId("");
			variable sourcePositionId("");
			variable sourceRequiredFlag(0);
			variable targetElementID(0);
			variable targetBarcode("");
			variable targetLabwareId("");
			variable targetPositionId("");
			variable targetVolume(0);

			variable sourceLoadingTime(0.0);
			variable sourceXCoordinate(0.0);
			variable sourceYCoordinate(0.0);
			variable sourceZCoordinate(0.0);
			variable targetLoadingTime(0.0);
			variable targetXCoordinate(0.0);
			variable targetYCoordinate(0.0);
			variable targetZCoordinate(0.0);

			variable sqlCommandText("");				// SQL command text 
			object fso;										// File System Object
			file tmpDb;										// Temporary data base used to apply values filter and values sorting to the results 

			// Delete any temporary data base 
			fso.CreateObject("Scripting.FileSystemObject");
			tempFileName = GetLogFilesPath() + "\\" + Constants::helpFileShortName + "_" + GetUniqueRunId() + "_Jobs.mdb";
			if (fso.FileExists(tempFileName))
				fso.DeleteFile(tempFileName);

			// Write results to temporary data base 
			tmpDb.AddField(VectorDb_WorklistColumnName::jobID, jobID, hslInteger);
			tmpDb.AddField(VectorDb_WorklistColumnName::jobName, jobName, hslString);
			tmpDb.AddField(VectorDb_WorklistColumnName::jobPriority, jobPriority, hslInteger);
			tmpDb.AddField(VectorDb_WorklistColumnName::jobState, jobState, hslInteger);
			tmpDb.AddField(VectorDb_WorklistColumnName::jobUserState, jobUserState, hslInteger);
			tmpDb.AddField(VectorDb_WorklistColumnName::sourceElementID, sourceElementID, hslInteger);
			tmpDb.AddField(VectorDb_WorklistColumnName::sourceBarcode, sourceBarcode, hslString);
			tmpDb.AddField(VectorDb_WorklistColumnName::sourceLabwareId, sourceLabwareId, hslString);
			tmpDb.AddField(VectorDb_WorklistColumnName::sourcePositionId, sourcePositionId, hslString);
			tmpDb.AddField(VectorDb_WorklistColumnName::sourceRequired, sourceRequiredFlag, hslInteger);
			tmpDb.AddField(VectorDb_WorklistColumnName::targetElementID, targetElementID, hslInteger);
			tmpDb.AddField(VectorDb_WorklistColumnName::targetBarcode, targetBarcode, hslString);
			tmpDb.AddField(VectorDb_WorklistColumnName::targetLabwareId, targetLabwareId, hslString);
			tmpDb.AddField(VectorDb_WorklistColumnName::targetPositionId, targetPositionId, hslString);
			tmpDb.AddField(VectorDb_WorklistColumnName::targetVolume, targetVolume, hslFloat);
			numberOfAdditionalDataValues = additionalDataValues.GetSize();
			numberOfJobAdditionalData = jobAdditionalDataKeys.GetSize();
			for (i = 0; i < numberOfJobAdditionalData; i++)
			{
				tmpDb.AddField(jobAdditionalDataKeys.ElementAt(i), jobAdditionalDataValues.ElementAt(i), GetType(jobAdditionalDataValues.ElementAt(i)));
			}
			if (queryJobLabwareData)
			{
				tmpDb.AddField(VectorDb_WorklistColumnName::sourceLoadingTime, sourceLoadingTime, hslFloat);
				tmpDb.AddField(VectorDb_WorklistColumnName::sourceXCoordinate, sourceXCoordinate, hslFloat);
				tmpDb.AddField(VectorDb_WorklistColumnName::sourceYCoordinate, sourceYCoordinate, hslFloat);
				tmpDb.AddField(VectorDb_WorklistColumnName::sourceZCoordinate, sourceZCoordinate, hslFloat);
				tmpDb.AddField(VectorDb_WorklistColumnName::targetLoadingTime, targetLoadingTime, hslFloat);
				tmpDb.AddField(VectorDb_WorklistColumnName::targetXCoordinate, targetXCoordinate, hslFloat);
				tmpDb.AddField(VectorDb_WorklistColumnName::targetYCoordinate, targetYCoordinate, hslFloat);
				tmpDb.AddField(VectorDb_WorklistColumnName::targetZCoordinate, targetZCoordinate, hslFloat);
			}
			tmpDb.Open(tempFileName + " Job", hslAppend);
			for (i = 0; i < numberOfJobs; i++)
			{
				jobID = jobIDs.ElementAt(i);
				jobName = jobNames.ElementAt(i);
				jobState = jobStates.ElementAt(i);
				jobUserState = jobUserStates.ElementAt(i);
				jobPriority = jobPriorities.ElementAt(i);
				sourceElementID = sourceElementIDs.ElementAt(i);
				sourceBarcode = sourceBarcodes.ElementAt(i);
				sourceLabwareId = sourceLabwareIds.ElementAt(i);
				sourcePositionId = sourcePositionIds.ElementAt(i);
				sourceRequiredFlag = sourceRequiredFlags.ElementAt(i);
				targetElementID = targetElementIDs.ElementAt(i);
				targetBarcode = targetBarcodes.ElementAt(i);
				targetLabwareId = targetLabwareIds.ElementAt(i);
				targetPositionId = targetPositionIds.ElementAt(i);
				targetVolume = targetVolumes.ElementAt(i);
				for (j = 0; j < numberOfJobAdditionalData; j++)
				{
					jobAdditionalDataValues.SetAt(j, additionalDataValues.ElementAt(i * numberOfJobAdditionalData + j));
				}
				if (queryJobLabwareData)
				{
					sourceLoadingTime = sourceLoadingTimes.ElementAt(i);
					sourceXCoordinate = sourceXCoordinates.ElementAt(i);
					sourceYCoordinate = sourceYCoordinates.ElementAt(i);
					sourceZCoordinate = sourceZCoordinates.ElementAt(i);
					targetLoadingTime = targetLoadingTimes.ElementAt(i);
					targetXCoordinate = targetXCoordinates.ElementAt(i);
					targetYCoordinate = targetYCoordinates.ElementAt(i);
					targetZCoordinate = targetZCoordinates.ElementAt(i);
				}
				tmpDb.WriteRecord();
			}

			// Read results from temporary data base,
			// apply values filter and values sorting to the results 
			jobIDs.SetSize(0);
			sqlCommandText = "select JobID from Job";
			if ("" != searchCondition)
				sqlCommandText = sqlCommandText + " where " + searchCondition;
			if ("" != orderByExpression)
				sqlCommandText = sqlCommandText + " order by " + orderByExpression;
			tmpDb.RemoveFields();
			tmpDb.AddField("JobID", jobID, hslInteger);
			tmpDb.Open("", hslAppend, sqlCommandText);
			while (!tmpDb.Eof())
			{
				jobID = 0;
				tmpDb.ReadRecord();
				jobIDs.AddAsLast(jobID);
			}
			tmpDb.Close();

			// Delete any temporary data base 
			if (fso.FileExists(tempFileName))
				fso.DeleteFile(tempFileName);
		}

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobIDs, TraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

		return(jobIDs);

		Unexpected:
		{
			// Unlock critical section
			if (0 != vectorDb_WorklistManagementCS)
				SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(Constants::traceSource, Constants::traceActionGetJobIDs, TraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 

	static function GetJobsSortedByPriority(
		variable jobStateFilter,							// [in]
		variable sortingDirection,							// [in]
		variable& jobIDs[],									// [in/out]
		variable& jobNames[],								// [in/out]
		variable& jobPriorities[], 						// [in/out]
		variable& jobStates[], 								// [in/out]
		variable& jobUserStates[], 						// [in/out]
		variable& sourceElementIDs[],						// [in/out]
		variable& sourceBarcodes[], 						// [in/out]
		variable& sourceLabwareIds[],						// [in/out]
		variable& sourcePositionIds[], 					// [in/out]
		variable& sourceRequiredFlags[], 				// [in/out]
		variable& targetElementIDs[],						// [in/out]
		variable& targetBarcodes[], 						// [in/out]
		variable& targetLabwareIds[], 					// [in/out]
		variable& targetPositionIds[], 					// [in/out]
		variable& targetVolumes[]) variable				// [in/out]
	{
		variable errorDesc("");								// Error description
		variable numberOfJobs(0);							// Number of jobs
		object resultPars;									// Result pars package

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobsSortedByPriority, TraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobsSortedByPriority, TraceStatus::progress, 
																"jobStateFilter = ", jobStateFilter,
																"sortingDirection = ", sortingDirection);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		InitLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_WorklistManagementCS);

		// Check input params to be valid
		errorDesc = Constants::traceActionGetJobsSortedByPriority + Constants::crlf;
		Util2::CheckValueTypeAndRangeMinMax(jobStateFilter, hslInteger, VectorDb_JobState::Filter_Any, VectorDb_JobState::Processed, 
							errorDesc + "jobStateFilter");
		Util2::CheckValueTypeAndRangeMinMax(sortingDirection, hslInteger, VectorDb_SortingDirection::Ascending, VectorDb_SortingDirection::Descending, 
							errorDesc + "sortingDirection");

		// Get jobs
		resultPars = vectorDb_WorklistManagementObj.GetJobsSortedByPriority(jobStateFilter, sortingDirection);
		numberOfJobs = UnpackWorklistJobParsPackage(	resultPars,
																	jobIDs,
																	jobNames,
																	jobPriorities,
																	jobStates,
																	jobUserStates,
																	sourceElementIDs,
																	sourceBarcodes,
																	sourceLabwareIds,
																	sourcePositionIds,
																	sourceRequiredFlags,
																	targetElementIDs,
																	targetBarcodes,
																	targetLabwareIds,
																	targetPositionIds,
																	targetVolumes);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobsSortedByPriority, TraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

		return(numberOfJobs);

		Unexpected:
		{
			// Unlock critical section
			if (0 != vectorDb_WorklistManagementCS)
				SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(Constants::traceSource, Constants::traceActionGetJobsSortedByPriority, TraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	static function GetJobsForLabware(
		variable& labwareId,									// [in]
		variable& positionId,								// [in]
		variable labwareUsageType,							// [in]
		variable jobStateFilter,							// [in]
		variable& jobIDs[],									// [in/out]
		variable& jobNames[],								// [in/out]
		variable& jobPriorities[], 						// [in/out]
		variable& jobStates[], 								// [in/out]
		variable& jobUserStates[], 						// [in/out]
		variable& sourceElementIDs[],						// [in/out]
		variable& sourceBarcodes[], 						// [in/out]
		variable& sourceLabwareIds[],						// [in/out]
		variable& sourcePositionIds[], 					// [in/out]
		variable& sourceRequiredFlags[], 				// [in/out]
		variable& targetElementIDs[],						// [in/out]
		variable& targetBarcodes[], 						// [in/out]
		variable& targetLabwareIds[], 					// [in/out]
		variable& targetPositionIds[], 					// [in/out]
		variable& targetVolumes[]) variable				// [in/out]
	{
		variable errorDesc("");								// Error description
		variable numberOfJobs(0);							// Number of jobs
		object resultPars;									// Result pars package

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobsForLabware, TraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobsForLabware, TraceStatus::progress, 
																"labwareId = ", labwareId,
																"positionId = ", positionId,
																"labwareUsageType = ", labwareUsageType,
																"jobStateFilter = ", jobStateFilter);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		InitLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_WorklistManagementCS);

		// Check input params to be valid
		errorDesc = Constants::traceActionGetJobsForLabware + Constants::crlf;
		Util2::CheckValueTypeAndRange(labwareId, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
							errorDesc + "labwareId");
		Util2::CheckValueTypeAndRange(positionId, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
							errorDesc + "positionId");
		Util2::CheckValueTypeAndRangeMinMax(labwareUsageType, hslInteger, VectorDb_LabwareUsageType::Filter_Any, VectorDb_LabwareUsageType::Filter_All, 
							errorDesc + "labwareUsageType");
		Util2::CheckValueTypeAndRangeMinMax(jobStateFilter, hslInteger, VectorDb_JobState::Filter_Any, VectorDb_JobState::Processed, 
							errorDesc + "jobStateFilter");

		// Get jobs
		resultPars = vectorDb_WorklistManagementObj.GetJobsForLabware(labwareId, positionId, labwareUsageType, jobStateFilter);
		numberOfJobs = UnpackWorklistJobParsPackage(	resultPars,
																	jobIDs,
																	jobNames,
																	jobPriorities,
																	jobStates,
																	jobUserStates,
																	sourceElementIDs,
																	sourceBarcodes,
																	sourceLabwareIds,
																	sourcePositionIds,
																	sourceRequiredFlags,
																	targetElementIDs,
																	targetBarcodes,
																	targetLabwareIds,
																	targetPositionIds,
																	targetVolumes);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobsForLabware, TraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

		return(numberOfJobs);

		Unexpected:
		{
			// Unlock critical section
			if (0 != vectorDb_WorklistManagementCS)
				SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(Constants::traceSource, Constants::traceActionGetJobsForLabware, TraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	static function GetJobsForLabwareSortedByPriority(
		variable& labwareId,									// [in]
		variable& positionId,								// [in]
		variable labwareUsageType,							// [in]
		variable jobStateFilter,							// [in]
		variable sortingDirection,							// [in]
		variable& jobIDs[],									// [in/out]
		variable& jobNames[],								// [in/out]
		variable& jobPriorities[], 						// [in/out]
		variable& jobStates[], 								// [in/out]
		variable& jobUserStates[], 						// [in/out]
		variable& sourceElementIDs[],						// [in/out]
		variable& sourceBarcodes[], 						// [in/out]
		variable& sourceLabwareIds[],						// [in/out]
		variable& sourcePositionIds[], 					// [in/out]
		variable& sourceRequiredFlags[], 				// [in/out]
		variable& targetElementIDs[],						// [in/out]
		variable& targetBarcodes[], 						// [in/out]
		variable& targetLabwareIds[], 					// [in/out]
		variable& targetPositionIds[], 					// [in/out]
		variable& targetVolumes[]) variable				// [in/out]
	{
		variable errorDesc("");								// Error description
		variable numberOfJobs(0);							// Number of jobs
		object resultPars;									// Result pars package

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobsForLabwareSortedByPriority, TraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobsForLabwareSortedByPriority, TraceStatus::progress, 
																"labwareId = ", labwareId,
																"positionId = ", positionId,
																"labwareUsageType = ", labwareUsageType,
																"jobStateFilter = ", jobStateFilter,
																"sortingDirection = ", sortingDirection);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		InitLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_WorklistManagementCS);

		// Check input params to be valid
		errorDesc = Constants::traceActionGetJobsForLabwareSortedByPriority + Constants::crlf;
		Util2::CheckValueTypeAndRange(labwareId, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
							errorDesc + "labwareId");
		Util2::CheckValueTypeAndRange(positionId, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
							errorDesc + "positionId");
		Util2::CheckValueTypeAndRangeMinMax(labwareUsageType, hslInteger, VectorDb_LabwareUsageType::Filter_Any, VectorDb_LabwareUsageType::Filter_All, 
							errorDesc + "labwareUsageType");
		Util2::CheckValueTypeAndRangeMinMax(jobStateFilter, hslInteger, VectorDb_JobState::Filter_Any, VectorDb_JobState::Processed, 
							errorDesc + "jobStateFilter");
		Util2::CheckValueTypeAndRangeMinMax(sortingDirection, hslInteger, VectorDb_SortingDirection::Ascending, VectorDb_SortingDirection::Descending, 
							errorDesc + "sortingDirection");

		// Get jobs
		resultPars = vectorDb_WorklistManagementObj.GetJobsForLabwareSortedByPriority(labwareId, positionId, labwareUsageType, jobStateFilter, sortingDirection);
		numberOfJobs = UnpackWorklistJobParsPackage(	resultPars,
																	jobIDs,
																	jobNames,
																	jobPriorities,
																	jobStates,
																	jobUserStates,
																	sourceElementIDs,
																	sourceBarcodes,
																	sourceLabwareIds,
																	sourcePositionIds,
																	sourceRequiredFlags,
																	targetElementIDs,
																	targetBarcodes,
																	targetLabwareIds,
																	targetPositionIds,
																	targetVolumes);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobsForLabwareSortedByPriority, TraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

		return(numberOfJobs);

		Unexpected:
		{
			// Unlock critical section
			if (0 != vectorDb_WorklistManagementCS)
				SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(Constants::traceSource, Constants::traceActionGetJobsForLabwareSortedByPriority, TraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	static function GetJobsForBarcode(
		variable& barcode,									// [in]
		variable labwareUsageType,							// [in]
		variable jobStateFilter,							// [in]
		variable& jobIDs[],									// [in/out]
		variable& jobNames[],								// [in/out]
		variable& jobPriorities[], 						// [in/out]
		variable& jobStates[], 								// [in/out]
		variable& jobUserStates[], 						// [in/out]
		variable& sourceElementIDs[],						// [in/out]
		variable& sourceBarcodes[], 						// [in/out]
		variable& sourceLabwareIds[],						// [in/out]
		variable& sourcePositionIds[], 					// [in/out]
		variable& sourceRequiredFlags[], 				// [in/out]
		variable& targetElementIDs[],						// [in/out]
		variable& targetBarcodes[], 						// [in/out]
		variable& targetLabwareIds[], 					// [in/out]
		variable& targetPositionIds[], 					// [in/out]
		variable& targetVolumes[]) variable				// [in/out]
	{
		variable errorDesc("");								// Error description
		variable numberOfJobs(0);							// Number of jobs
		object resultPars;									// Result pars package

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobsForBarcode, TraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobsForBarcode, TraceStatus::progress, 
																"barcode = ", barcode,
																"labwareUsageType = ", labwareUsageType,
																"jobStateFilter = ", jobStateFilter);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		InitLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_WorklistManagementCS);

		// Check input params to be valid
		errorDesc = Constants::traceActionGetJobsForBarcode + Constants::crlf;
		Util2::CheckValueTypeAndRange(barcode, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
							errorDesc + "barcode");
		Util2::CheckValueTypeAndRangeMinMax(labwareUsageType, hslInteger, VectorDb_LabwareUsageType::Filter_Any, VectorDb_LabwareUsageType::Filter_All, 
							errorDesc + "labwareUsageType");
		Util2::CheckValueTypeAndRangeMinMax(jobStateFilter, hslInteger, VectorDb_JobState::Filter_Any, VectorDb_JobState::Processed, 
							errorDesc + "jobStateFilter");

		// Get jobs
		resultPars = vectorDb_WorklistManagementObj.GetJobsForBarcode(barcode, labwareUsageType, jobStateFilter);
		numberOfJobs = UnpackWorklistJobParsPackage(	resultPars,
																	jobIDs,
																	jobNames,
																	jobPriorities,
																	jobStates,
																	jobUserStates,
																	sourceElementIDs,
																	sourceBarcodes,
																	sourceLabwareIds,
																	sourcePositionIds,
																	sourceRequiredFlags,
																	targetElementIDs,
																	targetBarcodes,
																	targetLabwareIds,
																	targetPositionIds,
																	targetVolumes);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobsForBarcode, TraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

		return(numberOfJobs);

		Unexpected:
		{
			// Unlock critical section
			if (0 != vectorDb_WorklistManagementCS)
				SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(Constants::traceSource, Constants::traceActionGetJobsForBarcode, TraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	static function GetJobsForBarcodeSortedByPriority(
		variable& barcode,									// [in]
		variable labwareUsageType,							// [in]
		variable jobStateFilter,							// [in]
		variable sortingDirection,							// [in]
		variable& jobIDs[],									// [in/out]
		variable& jobNames[],								// [in/out]
		variable& jobPriorities[], 						// [in/out]
		variable& jobStates[], 								// [in/out]
		variable& jobUserStates[], 						// [in/out]
		variable& sourceElementIDs[],						// [in/out]
		variable& sourceBarcodes[], 						// [in/out]
		variable& sourceLabwareIds[],						// [in/out]
		variable& sourcePositionIds[], 					// [in/out]
		variable& sourceRequiredFlags[], 				// [in/out]
		variable& targetElementIDs[],						// [in/out]
		variable& targetBarcodes[], 						// [in/out]
		variable& targetLabwareIds[], 					// [in/out]
		variable& targetPositionIds[], 					// [in/out]
		variable& targetVolumes[]) variable				// [in/out]
	{
		variable errorDesc("");								// Error description
		variable numberOfJobs(0);							// Number of jobs
		object resultPars;									// Result pars package

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobsForLabwareSortedByPriority, TraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobsForLabwareSortedByPriority, TraceStatus::progress, 
																"barcode = ", barcode,
																"labwareUsageType = ", labwareUsageType,
																"jobStateFilter = ", jobStateFilter,
																"sortingDirection = ", sortingDirection);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		InitLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_WorklistManagementCS);

		// Check input params to be valid
		errorDesc = Constants::traceActionGetJobsForLabwareSortedByPriority + Constants::crlf;
		Util2::CheckValueTypeAndRange(barcode, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
							errorDesc + "barcode");
		Util2::CheckValueTypeAndRangeMinMax(labwareUsageType, hslInteger, VectorDb_LabwareUsageType::Filter_Any, VectorDb_LabwareUsageType::Filter_All, 
							errorDesc + "labwareUsageType");
		Util2::CheckValueTypeAndRangeMinMax(jobStateFilter, hslInteger, VectorDb_JobState::Filter_Any, VectorDb_JobState::Processed, 
							errorDesc + "jobStateFilter");
		Util2::CheckValueTypeAndRangeMinMax(sortingDirection, hslInteger, VectorDb_SortingDirection::Ascending, VectorDb_SortingDirection::Descending, 
							errorDesc + "sortingDirection");

		// Get jobs
		resultPars = vectorDb_WorklistManagementObj.GetJobsForBarcodeSortedByPriority(barcode, labwareUsageType, jobStateFilter, sortingDirection);
		numberOfJobs = UnpackWorklistJobParsPackage(	resultPars,
																	jobIDs,
																	jobNames,
																	jobPriorities,
																	jobStates,
																	jobUserStates,
																	sourceElementIDs,
																	sourceBarcodes,
																	sourceLabwareIds,
																	sourcePositionIds,
																	sourceRequiredFlags,
																	targetElementIDs,
																	targetBarcodes,
																	targetLabwareIds,
																	targetPositionIds,
																	targetVolumes);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobsForLabwareSortedByPriority, TraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

		return(numberOfJobs);

		Unexpected:
		{
			// Unlock critical section
			if (0 != vectorDb_WorklistManagementCS)
				SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(Constants::traceSource, Constants::traceActionGetJobsForLabwareSortedByPriority, TraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	static function GetJobsForElementID(
		variable runID,										// [in]
		variable elementID,									// [in]
		variable labwareUsageType,							// [in]
		variable jobStateFilter,							// [in]
		variable& jobIDs[],									// [in/out]
		variable& jobNames[],								// [in/out]
		variable& jobPriorities[], 						// [in/out]
		variable& jobStates[], 								// [in/out]
		variable& jobUserStates[], 						// [in/out]
		variable& sourceElementIDs[],						// [in/out]
		variable& sourceBarcodes[], 						// [in/out]
		variable& sourceLabwareIds[],						// [in/out]
		variable& sourcePositionIds[], 					// [in/out]
		variable& sourceRequiredFlags[], 				// [in/out]
		variable& targetElementIDs[],						// [in/out]
		variable& targetBarcodes[], 						// [in/out]
		variable& targetLabwareIds[], 					// [in/out]
		variable& targetPositionIds[], 					// [in/out]
		variable& targetVolumes[]) variable				// [in/out]
	{
		variable errorDesc("");								// Error description
		variable numberOfJobs(0);							// Number of jobs
		object resultPars;									// Result pars package

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobsForElementID, TraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobsForBarcode, TraceStatus::progress, 
																"runID = ", runID,
																"elementID = ", elementID,
																"labwareUsageType = ", labwareUsageType,
																"jobStateFilter = ", jobStateFilter);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		InitLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_WorklistManagementCS);

		// Check input params to be valid
		errorDesc = Constants::traceActionGetJobsForElementID + Constants::crlf;
		Util2::CheckValueTypeAndRange(runID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
							errorDesc + "runID");
		Util2::CheckValueTypeAndRange(elementID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
							errorDesc + "elementID");
		Util2::CheckValueTypeAndRangeMinMax(labwareUsageType, hslInteger, VectorDb_LabwareUsageType::Filter_Any, VectorDb_LabwareUsageType::Filter_All, 
							errorDesc + "labwareUsageType");
		Util2::CheckValueTypeAndRangeMinMax(jobStateFilter, hslInteger, VectorDb_JobState::Filter_Any, VectorDb_JobState::Processed, 
							errorDesc + "jobStateFilter");

		// Get jobs
		resultPars = vectorDb_WorklistManagementObj.GetJobsForElementID(runID, elementID, labwareUsageType, jobStateFilter);
		numberOfJobs = UnpackWorklistJobParsPackage(	resultPars,
																	jobIDs,
																	jobNames,
																	jobPriorities,
																	jobStates,
																	jobUserStates,
																	sourceElementIDs,
																	sourceBarcodes,
																	sourceLabwareIds,
																	sourcePositionIds,
																	sourceRequiredFlags,
																	targetElementIDs,
																	targetBarcodes,
																	targetLabwareIds,
																	targetPositionIds,
																	targetVolumes);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobsForElementID, TraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

		return(numberOfJobs);

		Unexpected:
		{
			// Unlock critical section
			if (0 != vectorDb_WorklistManagementCS)
				SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(Constants::traceSource, Constants::traceActionGetJobsForElementID, TraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	static function GetJobsForElementIDSortedByPriority(
		variable runID,										// [in]
		variable elementID,									// [in]
		variable labwareUsageType,							// [in]
		variable jobStateFilter,							// [in]
		variable sortingDirection,							// [in]
		variable& jobIDs[],									// [in/out]
		variable& jobNames[],								// [in/out]
		variable& jobPriorities[], 						// [in/out]
		variable& jobStates[], 								// [in/out]
		variable& jobUserStates[], 						// [in/out]
		variable& sourceElementIDs[],						// [in/out]
		variable& sourceBarcodes[], 						// [in/out]
		variable& sourceLabwareIds[],						// [in/out]
		variable& sourcePositionIds[], 					// [in/out]
		variable& sourceRequiredFlags[],					// [in/out]
		variable& targetElementIDs[],						// [in/out]
		variable& targetBarcodes[], 						// [in/out]
		variable& targetLabwareIds[], 					// [in/out]
		variable& targetPositionIds[], 					// [in/out]
		variable& targetVolumes[]) variable				// [in/out]
	{
		variable errorDesc("");								// Error description
		variable numberOfJobs(0);							// Number of jobs
		object resultPars;									// Result pars package

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobsForElementIDSortedByPriority, TraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobsForLabwareSortedByPriority, TraceStatus::progress, 
																"runID = ", runID,
																"elementID = ", elementID,
																"labwareUsageType = ", labwareUsageType,
																"jobStateFilter = ", jobStateFilter,
																"sortingDirection = ", sortingDirection);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		InitLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_WorklistManagementCS);

		// Check input params to be valid
		errorDesc = Constants::traceActionGetJobsForElementIDSortedByPriority + Constants::crlf;
		Util2::CheckValueTypeAndRange(runID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
							errorDesc + "runID");
		Util2::CheckValueTypeAndRange(elementID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
							errorDesc + "elementID");
		Util2::CheckValueTypeAndRangeMinMax(labwareUsageType, hslInteger, VectorDb_LabwareUsageType::Filter_Any, VectorDb_LabwareUsageType::Filter_All, 
							errorDesc + "labwareUsageType");
		Util2::CheckValueTypeAndRangeMinMax(jobStateFilter, hslInteger, VectorDb_JobState::Filter_Any, VectorDb_JobState::Processed, 
							errorDesc + "jobStateFilter");
		Util2::CheckValueTypeAndRangeMinMax(sortingDirection, hslInteger, VectorDb_SortingDirection::Ascending, VectorDb_SortingDirection::Descending, 
							errorDesc + "sortingDirection");

		// Get jobs
		resultPars = vectorDb_WorklistManagementObj.GetJobsForElementIDSortedByPriority(runID, elementID, labwareUsageType, jobStateFilter, sortingDirection);
		numberOfJobs = UnpackWorklistJobParsPackage(	resultPars,
																	jobIDs,
																	jobNames,
																	jobPriorities,
																	jobStates,
																	jobUserStates,
																	sourceElementIDs,
																	sourceBarcodes,
																	sourceLabwareIds,
																	sourcePositionIds,
																	sourceRequiredFlags,
																	targetElementIDs,
																	targetBarcodes,
																	targetLabwareIds,
																	targetPositionIds,
																	targetVolumes);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobsForElementIDSortedByPriority, TraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

		return(numberOfJobs);

		Unexpected:
		{
			// Unlock critical section
			if (0 != vectorDb_WorklistManagementCS)
				SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(Constants::traceSource, Constants::traceActionGetJobsForElementIDSortedByPriority, TraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	static function GetJobState(
		variable jobID) variable				// [in]
	{
		variable errorDesc("");								// Error description
		variable jobState(0);

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobState, TraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobState, TraceStatus::progress, "jobID = ", jobID);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		InitLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_WorklistManagementCS);

		// Check input params to be valid
		errorDesc = Constants::traceActionGetJobState + Constants::crlf;
		Util2::CheckValueTypeAndRange(jobID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
							errorDesc + "jobID");

		// Get jobs
		jobState = vectorDb_WorklistManagementObj.GetJobState(jobID);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionGetJobState, TraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

		return(jobState);

		Unexpected:
		{
			// Unlock critical section
			if (0 != vectorDb_WorklistManagementCS)
				SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(Constants::traceSource, Constants::traceActionGetJobState, TraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	static function SetJobState(
		variable jobID,							// [in]
		variable jobState) variable			// [in]
	{
		variable errorDesc("");								// Error description

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionSetJobState, TraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(Constants::traceSource, Constants::traceActionSetJobState, TraceStatus::progress, "jobID = ", jobID);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		InitLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_WorklistManagementCS);

		// Check input params to be valid
		errorDesc = Constants::traceActionSetJobState + Constants::crlf;
		Util2::CheckValueTypeAndRange(jobID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
							errorDesc + "jobID");
		Util2::CheckValueTypeAndRangeMinMax(jobState, hslInteger, VectorDb_JobState::Unprocessed, VectorDb_JobState::Processed, 
							errorDesc + "jobState");

		// Get jobs
		jobState = vectorDb_WorklistManagementObj.SetJobState(jobID, jobState);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionSetJobState, TraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

		return(jobState);

		Unexpected:
		{
			// Unlock critical section
			if (0 != vectorDb_WorklistManagementCS)
				SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(Constants::traceSource, Constants::traceActionSetJobState, TraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

	function RemoveJobsForLabware(
		variable& labwareId,						// [in]
		variable& positionId,					// [in]
		variable labwareUsageType,				// [in]
		variable jobStateFilter) variable	// [in]
	{
		variable errorDesc("");							// Error description
		variable affectedRecords(0);					// Number of affected records
		variable additionalDataKeys[];				// Additional data keys

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionRemoveJobsForLabware, TraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(Constants::traceSource, Constants::traceActionRemoveJobsForLabware, TraceStatus::progress, 
																"labwareId = ", labwareId,
																"positionId = ", positionId,
																"labwareUsageType = ", labwareUsageType,
																"jobStateFilter = ", jobStateFilter);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		InitLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_WorklistManagementCS);

		// Check input params to be valid
		errorDesc = Constants::traceActionRemoveJobsForLabware + Constants::crlf;
		Util2::CheckValueTypeAndRange(labwareId, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
							errorDesc + "labwareId");
		Util2::CheckValueTypeAndRange(positionId, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
							errorDesc + "positionId");
		Util2::CheckValueTypeAndRangeMinMax(labwareUsageType, hslInteger, VectorDb_LabwareUsageType::Filter_Any, VectorDb_LabwareUsageType::Filter_All, 
							errorDesc + "labwareUsageType");
		Util2::CheckValueTypeAndRangeMinMax(jobStateFilter, hslInteger, VectorDb_JobState::Filter_Any, VectorDb_JobState::Processed, 
							errorDesc + "jobStateFilter");

		// Remove additional data
		affectedRecords = vectorDb_WorklistManagementObj.RemoveJobsForLabware(labwareId, positionId, labwareUsageType, jobStateFilter);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionRemoveJobsForLabware, TraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

		return(affectedRecords);

		Unexpected:
		{
			// Unlock critical section
			if (0 != vectorDb_WorklistManagementCS)
				SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(Constants::traceSource, Constants::traceActionRemoveJobsForLabware, TraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 

	function RemoveJobsForBarcode(
		variable& barcode,						// [in]
		variable labwareUsageType,				// [in]
		variable jobStateFilter) variable	// [in]
	{
		variable errorDesc("");							// Error description
		variable affectedRecords(0);					// Number of affected records
		variable additionalDataKeys[];				// Additional data keys

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionRemoveJobsForBarcode, TraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(Constants::traceSource, Constants::traceActionRemoveJobsForBarcode, TraceStatus::progress, 
																"barcode = ", barcode,
																"labwareUsageType = ", labwareUsageType,
																"jobStateFilter = ", jobStateFilter);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		InitLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_WorklistManagementCS);

		// Check input params to be valid
		errorDesc = Constants::traceActionRemoveJobsForBarcode + Constants::crlf;
		Util2::CheckValueTypeAndRange(barcode, hslString, Util2::ValueCheck::RangeStringNotEmpty, 
							errorDesc + "barcode");
		Util2::CheckValueTypeAndRangeMinMax(labwareUsageType, hslInteger, VectorDb_LabwareUsageType::Filter_Any, VectorDb_LabwareUsageType::Filter_All, 
							errorDesc + "labwareUsageType");
		Util2::CheckValueTypeAndRangeMinMax(jobStateFilter, hslInteger, VectorDb_JobState::Filter_Any, VectorDb_JobState::Processed, 
							errorDesc + "jobStateFilter");

		// Remove additional data
		affectedRecords = vectorDb_WorklistManagementObj.RemoveJobsForBarcode(barcode, labwareUsageType, jobStateFilter);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionRemoveJobsForBarcode, TraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

		return(affectedRecords);

		Unexpected:
		{
			// Unlock critical section
			if (0 != vectorDb_WorklistManagementCS)
				SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(Constants::traceSource, Constants::traceActionRemoveJobsForBarcode, TraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 

	function RemoveJobsForElementID(
		variable runID,							// [in]
		variable elementID,						// [in]
		variable labwareUsageType,				// [in]
		variable jobStateFilter) variable	// [in]
	{
		variable errorDesc("");							// Error description
		variable affectedRecords(0);					// Number of affected records
		variable additionalDataKeys[];				// Additional data keys

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionRemoveJobsForElementID, TraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(Constants::traceSource, Constants::traceActionRemoveJobsForElementID, TraceStatus::progress, 
																"runID = ", runID,
																"elementID = ", elementID,
																"labwareUsageType = ", labwareUsageType,
																"jobStateFilter = ", jobStateFilter);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		InitLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_WorklistManagementCS);

		// Check input params to be valid
		errorDesc = Constants::traceActionRemoveJobsForElementID + Constants::crlf;
		Util2::CheckValueTypeAndRange(runID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
							errorDesc + "runID");
		Util2::CheckValueTypeAndRange(elementID, hslInteger, Util2::ValueCheck::RangeNumberGreaterThanZero, 
							errorDesc + "elementID");
		Util2::CheckValueTypeAndRangeMinMax(labwareUsageType, hslInteger, VectorDb_LabwareUsageType::Filter_Any, VectorDb_LabwareUsageType::Filter_All, 
							errorDesc + "labwareUsageType");
		Util2::CheckValueTypeAndRangeMinMax(jobStateFilter, hslInteger, VectorDb_JobState::Filter_Any, VectorDb_JobState::Processed, 
							errorDesc + "jobStateFilter");

		// Remove additional data
		affectedRecords = vectorDb_WorklistManagementObj.RemoveJobsForElementID(runID, elementID, labwareUsageType, jobStateFilter);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionRemoveJobsForElementID, TraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

		return(affectedRecords);

		Unexpected:
		{
			// Unlock critical section
			if (0 != vectorDb_WorklistManagementCS)
				SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(Constants::traceSource, Constants::traceActionRemoveJobsForElementID, TraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 

	static function RemoveAllJobs(
		variable jobStateFilter) variable			// [in]
	{
		variable errorDesc("");							// Error description

		variable jobIDs[];
		variable jobNames[];
		variable jobPriorities[];
		variable jobStates[];
		variable jobUserStates[];
		variable sourceElementIDs[];
		variable sourceBarcodes[];
		variable sourceLabwareIds[];
		variable sourcePositionIds[];
		variable sourceRequiredFlags[];
		variable targetElementIDs[];
		variable targetBarcodes[];
		variable targetLabwareIds[];
		variable targetPositionIds[];
		variable targetVolumes[];

		variable i(0);
		variable j(0);
		variable numberOfJobs(0);
		variable numberOfAdditionalData(0);
		variable additionalDataKeys[];
		variable additionalDataValues[];

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionRemoveAllJobs, TraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		FormatTrace(Constants::traceSource, Constants::traceActionRemoveAllJobs, TraceStatus::progress, "jobStateFilter = ", jobStateFilter);
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		InitLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_WorklistManagementCS);

		// Check input params to be valid
		errorDesc = Constants::traceActionRemoveAllJobs + Constants::crlf;
		Util2::CheckValueTypeAndRangeMinMax(jobStateFilter, hslInteger, VectorDb_JobState::Filter_Any, VectorDb_JobState::Processed, 
							errorDesc + "jobStateFilter");

		// Remove all jobs
		SynLeaveCriticalSection(vectorDb_WorklistManagementCS);
		numberOfJobs = GetJobs(jobStateFilter,jobIDs,jobNames,jobPriorities,jobStates,jobUserStates,sourceElementIDs,sourceBarcodes,sourceLabwareIds,
										sourcePositionIds,sourceRequiredFlags,targetElementIDs,targetBarcodes,targetLabwareIds,targetPositionIds,targetVolumes);
		for (i = 0; i < numberOfJobs; i++)
		{
			numberOfAdditionalData = GetJobAdditionalData(jobIDs.ElementAt(i),additionalDataKeys,additionalDataValues);
			for (j = 0; j < numberOfAdditionalData; j++)
			{
				RemoveJobAdditionalData(jobIDs.ElementAt(i), additionalDataKeys.ElementAt(j));
			}
			RemoveJob(jobIDs.ElementAt(i));
		}
		SynEnterCriticalSection(vectorDb_WorklistManagementCS);

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		FormatTrace(Constants::traceSource, Constants::traceActionRemoveAllJobs, TraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

		// Return status
		return(numberOfJobs);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_WorklistManagementCS)
				SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			FormatTrace(Constants::traceSource, Constants::traceActionRemoveAllJobs, TraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 

	static function WorklistManagementEnabled() variable
	{
		variable worklistManagementEnabled(hslFalse);

		// Trace start of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		//FormatTrace(Constants::traceSource, Constants::traceActionWorklistManagementEnabled, TraceStatus::start);
		#endif

		// Dump input params
		#ifdef DEBUG_VECTOR_DB_PARAM
		// Nothing to dump
		#endif

		// Activate error handler
		onerror goto Unexpected;

		// Init library
		InitLibrary();

		// Lock critical section
		SynEnterCriticalSection(vectorDb_WorklistManagementCS);

		// Check input params to be valid
		// Nothing to check

		// Get Worklist Management enabled flag
		worklistManagementEnabled = vectorDb_WorklistManagementObj.Enabled();

		// Trace completion of function
		#ifdef DEBUG_VECTOR_DB_FUNC
		//FormatTrace(Constants::traceSource, Constants::traceActionWorklistManagementEnabled, TraceStatus::complete);
		#endif

		// Unlock critical section
		SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

		// Return status
		return(worklistManagementEnabled);

		Unexpected:
 		{
			// Unlock critical section
			if (0 != vectorDb_WorklistManagementCS)
				SynLeaveCriticalSection(vectorDb_WorklistManagementCS);

			// Trace completion with error of function
			#ifdef DEBUG_VECTOR_DB_FUNC
			//FormatTrace(Constants::traceSource, Constants::traceActionWorklistManagementEnabled, TraceStatus::completeWithError);
			#endif

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	} 
}

#endif
// $$author=mhosang$$valid=0$$time=2007-01-15 15:55$$checksum=ef2ebf4d$$length=086$$