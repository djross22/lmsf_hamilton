/***************************************************************************************************
*  Library	: HslVerToolsLib.hs_
*  Copyright by HAMILTON Bonaduz AG, CH-7402 Bonaduz
****************************************************************************************************
*
*  Description : // Library for Methods of Microlab® STAR Verification 2
*
* ==================================================================================================
*  ATTENTION: Change this HSL only with HSL Editor of SW Version 3.2!
*              (Note: This library must run from SW-version 3.2 on)
* ==================================================================================================
*  Modification History:
* ----------------------
* Rev 1.91 2013-09-20 Erich Caflisch   
*					Options for GxP added (extended reporting)
*					Optimized balance commands
* --------------------------------------------------------------------------------------------------
* Rev 1.9 2013-08-08 Erich Caflisch   Project 276 (easyPunch), ECO 13197
*         		Add definitions for easyPunch verification
*         		Add definitions for Twister verification
*					Add temperature site for the "Gel Card Incubator" 
*					Add temperature site for the "Inheco Multi/Single TEC controller" included 
*					Add temperature site for the "Tube Heater" included 
*					Add temperature site for any heater or cooler without connection to ML-STAR 
*              New status dialog functions "ShowStatusDialog", "UpdateStatusDialog" and "HideStatusDialog"
*					More configurations defined in parameter "xn" and "xo"
*					New function function SetDialogTimer to set timer feature for function DialogInfo
*			ECO13560: Changed processed date for Roche application
*              Change report file naming in functions "CreateReportFile" & "ShowReports"
*					New configuration bit for "vertical cover" 
* --------------------------------------------------------------------------------------------------
* Rev 1.8 2012-05-21 Erich Caflisch   Project 263 (FV Roche)
*         		Changed processed date for Roche application
* --------------------------------------------------------------------------------------------------
* Rev 1.7 2012-05-10 Erich Caflisch   Project 263 (FV Roche)
*              Optimization of External Calibration (OWS Balance)
* --------------------------------------------------------------------------------------------------
* Rev 1.6 2012-03-15 Erich Caflisch   Project 263 (FV Roche)
*              Adpotions according ROCHE inputs
* --------------------------------------------------------------------------------------------------
* Rev 1.5 2011-12-16 Erich Caflisch   Project 263 (FV Roche)
*              Adjustment for ROCHE application
*					3 Balance Types included: Mettler Balance SAG, WXS and WMC (Cube) for Roche
*					Including Ethernet interface for WMC balance
*					Function 'MWPUserCommand' now as global function
* --------------------------------------------------------------------------------------------------
* Rev 1.4 2011-09-15 Erich Caflisch   Project 263 (FV Roche)
*              Adjustment for ROCHE application
*					Install Balance: Check position with teaching needle
* --------------------------------------------------------------------------------------------------
* Rev 1.3 2011-09-09 Erich Caflisch   Project 263 (FV Roche)
*              Adjustment for ROCHE application
*					Balance:Function "Set Zero" changed (check if value is zero)
* --------------------------------------------------------------------------------------------------
* Rev 1.2 2011-08-16 Erich Caflisch ECO 12'600 :    
*					Add check of reader initialisiation before each measurement, else execute initialisation
*					Balance type check for expression "AG" only (instaed of "SAG")
*					Balance WXS with or without terminal possible
*					Changed balance command "M29 1" without terminal to "USTB 0 3.6 1.1"
*					Warnings to prevent aborted run after CD reading in function "GetPhotoCheckPlateData"	
*					Added Calibration weight ID and gudance text for checkplte reference data in tool dialog
*					Adding Status references for external data storage and new STAR configuration
*					Change valid period for barcode carrier from one year to two years
*					Generate pdf file in windows 7 operating system with "PDF Creator" 
*						instead ""PDFcamp Printer Pro v2.3"" application
*              Get maximal autoload track number out of instrument
* --------------------------------------------------------------------------------------------------
* Rev 1.1 2010-08-10 Erich Caflisch   
*                AddCheckSum function exported in new library "HSLVerVariableFunctions.hs_"
* --------------------------------------------------------------------------------------------------
* Rev 1.0 2010-07-22 Erich Caflisch   
*                First released version for software version >=3.2.0 
* --------------------------------------------------------------------------------------------------
* Rev 0.1 2007-11-08	Erich Caflisch: 
*                First version, based on library "HslVerMetLib.hs_" of module "HxStarVerMet"
*					    Based on VolumeVerification.hsl,
*
*****************************************************************************************************/ 

#ifndef __HslVerToolsLib_hsl__
#define __HslVerToolsLib_hsl__	1

//================================
// deactivate for release version
//#define __develop__ 1
//---------------------

//#define _DEBUG 1
//---------------------

#ifdef __develop__
//	device ML_STAR("C:\\Program Files\\Hamilton\\Methods\\Verification\\Verification_Star.lay");
	device ML_STAR;
	#define HSL_RUNTIME 1
#endif

//================================
namespace VSID // string ID for verification text translation strings
{
	variable arrDefaultText[];
	variable arrTranslatedText[];
}

namespace VerDef	// general verification variable and constant definitions
{	

	static variable dlgTimeOut( 10 ); // dialog time out for simulated array data
	static variable useOfWindShield(hslFalse); // use of plate windshield

	// trace acknowledge
	static const variable CMD_START   ( 1 );
	static const variable CMD_COMPLET ( 2 );
	static const variable CMD_ERROR   ( 3 );
	static const variable CMD_PROGRESS( 4 );
	static const variable CMD_ERRCOMPL( 5 );

	// declaration of general variables
	static const variable CRLF("\013\010"); 	// new line: CR + LF
	static const variable SemiColon(";"); 		// semicolon use as delimiter
	static const variable oneYear(365);			// one year offset between calibration date and expiry date
	static const variable twoYears(730); 		// two years offset between calibration date and expiry date
	static const variable _200Days(200); 		// 200 days  offset between processing date and expiry date
	static const variable notDefined(" -x- ");// placeholder for not defined information
	static const variable notInstalled("notInstalled");// not installed application software
	static const variable coverLock(1);			// front cover lock
	static const variable coverUnlock(0);		// front cover unlock

	static variable valid("valid"); 				// valid state
	static variable invalid("invalid"); 		// invalid state
	static variable confirmed("confirmed"); 	// acceptance state confirmed by user
	static variable excluded("excluded"); 		// excluded state (by user)
	static variable passed("passed"); 			// passed state
	static variable failed("failed"); 			// failed state
	static variable indicatedTime(0);			// dialog (count down) timer  indicating time
	static variable dialogTimeOut(0);			// dialog (count down) timer  time out
	static variable dialogText(""); 				// dialog text 
	static variable channelPattern("");			// channel pattern of single pipetting heads
	static variable batchNo(0);					// batch nuber during repetitions

	// sub-directoriy names
	static const variable methodSubDirName("\\Verification\\");
	static const variable picturesSubDirName("\\Verification\\Pictures\\");
	static const variable templatesSubDirName("\\Verification\\Template\\");
	static const variable toolsSubDirName("\\Verification\\Tools\\");
	static const variable photoCheckPlateSubDirName("\\Verification\\Tools\\ReaderCheckPlate_XXXX\\");
 	variable 				 labwareSubDirName("\\ML_STAR\\Verification\\");
	// configuration
	static variable FVK2_ReleaseVersion("1020");		// Field verification release version as string, e.g. "(FVK 2: 01/01)" 
	static variable SWReleaseVersion;					// SW release version as string, e.g. "3.2.0" 
	static variable SWVersionNumber;						// SW release version as float, e.g. 3.2 
	static variable fwVersionC0; 							// Firmware version of master module C0 as float, e.g. 6.0 
	static variable isIVD(hslFalse);						// IVD application
	static variable isRoche(hslFalse);					// Roche application
	static variable is64BitArchitecture(hslFalse);	// 64 bit Operating Architecture
	static variable operatingSystem(hslFalse);		// Operating system

	static variable InstrumentName;
	static variable InstrumentSerialNo;
	static variable layoutFileName;
	static variable InstrumentNumberOfChannels;		// amount of 1000ul pipetting channels
	static variable RasterOf_1000ulChannels(9);		// raster of 1000ul pipetting channels (Default 9.0mm)
	static variable InstrumentNumberOf_5mlChannels;	// amount of 5ml pipetting channels
	static variable RasterOf_5mlChannels(36);			// raster of 5ml pipetting channels (Default 36.0mm)
	static variable leftCover(hslFalse);				// true, if instrument has a left cover
	static variable rightCover(hslFalse);				// true, if instrument has a right cover
	static variable verticalCover(hslFalse);			// true, if instrument has a vertical cover
	static variable iSWAP(0);								// > 0: if iSWAP is installed
	static variable CoverLocking(0);						// > 0: if main front cover monitoring is activated
	static variable AddtionalCoverLocking(0);			// > 0: if additional (front) cover monitoring is activated
	static variable AutoLoad;
	static variable multi96PipHead(0);					// > 0: if instrument has a 96multiPipettingHead (1 = 300ul, 2 = 1000ul, 3 = WA, 4 = WA+TADM)
	static variable multi384PipHead(0);					// > 0: if instrument has a 384multiPipettingHead (1 = 30ul, 2 = 50ul, 3 = STP)
	static variable NanoPipetter(hslFalse);			// true, if instrument has a NanoPipetter
	static variable hasLeftArm(hslFalse);				// true, if instrument has a left arm configured
	static variable hasRightArm(hslFalse);				// true, if instrument has a right arm configured
	static variable _5mlChannelOnRightArm(hslFalse);// true, if instrument 5ml pipetting channels are on right arm configured (else on left arm)
	static variable easyPunch(0);							// true, if instrument has a easyPunch module and easyPunch card gripper installed
	static variable Twisters(0);							// > 0: Number of installed robotic channels with twister with Barcode scanner
	static variable numberOfTemperatureSites(0);		// number of sites for temperature verification
	static variable numberOfShakerSites(0);			// number of sites for shaker verification

	static variable SimulationMode(hslFalse);
	static variable SimulationModeBalance(hslFalse);
	static variable SimulationModeReader(hslFalse);

	static variable predefinedLayout(hslFalse);

//	static variable firstDeckTrack;
//	static variable lastDeckTrack;
	static variable numbOfAutoLoadTracks(30);
	static variable instrumentNr;
	static variable amountOfChannels;	

	// pipetting head types
	static const variable singlePipHead_1000ul(2);
	static const variable singlePipHead_5ml(43);
	static const variable multi96PipHead_300ul(24);
	static const variable multi96PipHead_1000ul(24);
	static const variable multi384PipHead_50ul(30);
	static const variable multi384PipHead_STP(30);

	//layout information / files
	static variable balanceTrackPos;
	static variable tipPlateCarrierTrackPos;
	static variable tipPlateCarrierLoadable(0);
	static variable barcodeCarrierTrackPos;

	static const variable layoutFileName_Star("Verification\\Verification_Star");
	static const variable layoutFileName_StarPlus("Verification\\Verification_StarPlus");
	static const variable layoutFileName_Starlet("Verification\\Verification_Starlet");

	static const variable site_ResetAll("0"); 
	static const variable site_Balance("Balance");
	static const variable site_1("1");
	static const variable site_2("2");
	static const variable site_3("3");
	static const variable site_4("4");
	static const variable site_5("5");
	static const variable site_384erTipPos_1c("6"); // site 1 for 384 50ul conductive (black) Tips 
	static const variable site_384erTipPos_2c("7"); // site 2 for 384 50ul conductive (black) Tips 
	static const variable site_384erTipPos_3c("8"); // site 3 for 384 50ul conductive (black) Tips 
	static const variable site_384erTipPos_1t("9"); // site 1 for 384 50ul transparent (clear) Tips 
	static const variable site_384erTipPos_2t("10"); // site 2 for 384 50ul transparent (clear) Tips 
	static const variable site_384erTipPos_3t("11"); // site 3 for 384 50ul transparent (clear) Tips 
	static const variable site_Pyramid_1("12");
	static const variable site_Pyramid_2("13");
	static const variable site_Pyramid_3("14");
	static const variable site_Pyramid_4("15");

	//labware name / files
	static const variable carrierName_Reagent("VER_CAR_REAGENT");
	static const variable carrierName_TipPlate("VER_CAR_TIP_PLATE");
	static const variable carrierName_Barcode("VER_CAR_BARCODE");
	static const variable carrierName_Magazine_1("VER_CAR_MAGAZINE_1");
	static const variable carrierName_Magazine_2("VER_CAR_MAGAZINE_2");

	//labware properties
	static const variable PropVerDevice("verDevice");
			static const variable MFX_Cooling_Module("MFXCoolingModule");
			static const variable MFX_Heating_Module("MFXHeatingModule");
			static const variable Teleshaker("Teleshaker");
			static const variable Shaker_Heater_CAT("CATShakerHeater");
			static const variable TCC("TCC");
			static const variable HHS("HHS");
			static const variable Inheco_TEC("Inheco_TEC");
			static const variable GelCardIncubator("GelCardIncubator");
			static const variable TubeHeater("TubeHeater");
			static const variable AnyHeaterCooler("AnyHeaterCooler");

	static const variable PropVerDescription("VER__Description");
	static const variable PropVER_SerialPort("VER_ComPort");
	static const variable PropVerSerialNumber("VER_SerialNumber");
	static const variable PropVER_ModuleAddress("VER_ModuleAddress");

	static const variable PropVER_ShakerOrbit("VER_ShakerOrbit");
	static const variable PropVER_ShakerOrbitCriteria("VER_ShakerOrbitCriteria");
	static const variable PropVER_ShakerFrequency("VER_ShakerFrequency");
	static const variable PropVER_ShakerFrequencyCritera("VER_ShakerFrequencyCriteria");

	static const variable PropVER_Temperature("VER_Temperature");
	static const variable PropVER_Temperature_2("VER_Temperature_2");
	static const variable PropVER_TemperatureCritera("VER_TemperatureCritera");
	static const variable PropVER_TemperatureCritera_2("VER_TemperatureCritera_2");
	static const variable PropVER_TemperatureOffset("VER_TemperatureOffset");
	static const variable PropVER_TemperatureOffset_2("VER_TemperatureOffset_2");
	static const variable PropVER_SensorCorrection("verSensorCorr");
	static const variable PropVER_SensorCorrection_2("verSensorCorr_2");

	// carrier (template) types (labware level: 200)
	static const variable TipPlate_Carrier(201); 		// carrier with multiple usable sites
	static const variable ReagentCarBalance(202);		// only WXS or SAG balance with tube
	static const variable ReagentCarBalanceTube(203);	// reagent containers & balance with tube
	static const variable ReagentCarBalancePlate(204);	// reagent containers & balance with plate
	static const variable WMC_Balance(205);				// only WMC balance with tube
	static const variable BarcodeCarHorizonalBC(211);	// barcode carrier with horizontal barcode labels
	static const variable BarcodeCarVerticalBC(212);	// barcode carrier with vertical barcode labels
	static const variable easyPuncherModule(221);	   // easyPuncher module
	static const variable punchCardMagazine_1(222);	   // magazine carrier 1
	static const variable punchCardMagazine_2(223);	   // magazine carrier 2

	static variable		 balanceCarrierType(ReagentCarBalanceTube);

	// plate  (rack) types (labware level: 300)
	static const variable _96erPlate(301);
	static const variable _384erPlate(302);
	static const variable _8ml_Tube(303);
	static const variable _ReaderCheckPlate(304);
	static const variable _5ml_Bowl(305);
	static const variable _DWP_2ml(306);
				
	static const variable Reagent_Container_8Ch(311);
	static const variable Reagent_Container_96Ch(312);
	static const variable Reagent_Container_384Ch(313);

	static const variable TipRack_10ul(321);
	static const variable TipRack_50ul(322);
	static const variable TipRack_300ul(323);
	static const variable TipRack_1000ul(324);
	static const variable TipRack_5ml(325);
	static const variable TipRack_384pHead_50ul(326);		// tranparent, non conductive 50ul 384 tip rack
	static const variable TipRack_384pHead_50ul_c(327); 	// black, conductive 50ul 384 tip rack
	static const variable TipRack_1000ulFilter(328);
	static const variable TipRack_TeachingNeedles(330);
	static const variable TipRack_5mlTeachingNeedles(331);
	static const variable TipRack_96TeachingNeedles(332);
	static const variable TipRack_384TeachingNeedles(333);

	static const variable Pyramid(341);

	static const variable paperCard_Magazine_1(351);	            // Verification easyPunch card magazine with card type 1
	static const variable paperCard_Magazine_2(352);	            // Verification easyPunch card magazine with card type 2
	static const variable paperCard_Magazine_3(353);	            // Verification easyPunch card magazine with card type 3

	// 'global' verifcation data file information
	static const variable KeyBalanceCarTrack("BalanceCarTrack");	// Balance Carrier Track Position
	static const variable KeyTipPlateCarTrack("TipPlateCarTrack");	// Tip/Plate Carrier Track Position
	static const variable KeyBarCode_CarTrack("BarCode_CarTrack");	// Barcode Carrier Track Position
	static const variable KeyEasyPunch("easyPunch");	            // easyPunch features (puncher type,...)
	static const variable KeyTwister("Twister");	            		// Twister features (barcode, position,...)
	static const variable KeySave("Save");									// Safe data in statsu file

}

namespace PID	// process id definitions / process or step request
{	
	static const variable General("PID_");
	static const variable Temperature("PID_T_");
	static const variable Temperature_1("PID_T1_");
	static const variable Temperature_2("PID_T2_");
	static const variable Recorded_Temp("PID_TR_");  					// recodred internal temperature values
	static const variable Shaker("PID_S_");
	static const variable Shaker_Ampl("PID_A_");
	static const variable Shaker_Freq("PID_F_");

	static const variable DailyMaintenance(0);
	static const variable Barcode(3);
	static const variable CoverSafety(10);
	static const variable Summary(5);
	static const variable XYZ_1000ulChannel(2);
	static const variable XYZ_5mlChannel(11);
	static const variable XYZ_multi96PipHead(12);
	static const variable XYZ_multi384PipHead(13);
	static const variable Vol_1000ulChannel(4);
	static const variable Vol_5mlChannel(20);
	static const variable Vol_multi96PipHead(21);
	static const variable Vol_multi384PipHead(22);
	static const variable TemperatureSummary(16);
	static const variable ShakerSummary(17);
	static const variable EasyPunch(8);
	static const variable Twister(7);

	static variable doCoverSafety_Verification(-999); 				// Cover-Safety 
	static variable doBarcode_Verification(-999); 					//	Barcode		
	static variable doXYZ_Pos_96mpH_Verification(-999);			// X-Y-Z-Positioning 96 Multi Probe Head		
	static variable doXYZ_Pos_384mPh_Verification(-999);			// X-Y-Z-Positioning 384 Multi Probe Head		
	static variable doXYZ_Pos_1000ul_Channel_Verification(-999);// X-Y-Z-Positioning 1000ul single Heads 	
	static variable doXYZ_Pos_5ml_Channel_Verification(-999);	// X-Y-Z-Positioning 5ml single Heads 		
	static variable doXYZ_Pos_NanoPip_Verification(-999);			// X-Y-Z-Positioning Nanopipettor			
	static variable doVolume_96mpH_Verification(-999);				// Volume 96 Multi Probe Head	
	static variable doVolume_384mpH_Verification(-999);			// Volume 384 Multi Probe Head	
	static variable doVolume_1000ul_Channel_Verification(-999);	// Volume 1000ul single Heads
	static variable doVolume_5ml_Channel_Verification(-999);		// Volume 5ml single Heads
	static variable doVolume_NanoPip_Verification(-999);			// Volume Nanopipettor
	static variable doTemperature_Verification(-999);				// Temperature- Verification, TCC, HHS, Cooler, Tube Heater
	static variable doShaker_Verification(-999);						// Shaker- Verification
	static variable doEasyPunch_Verification(-999);					// easyPunch- Verification
	static variable doTwister_Verification(-999);					// Twister- Verification

	static variable summaryStatus;				// summary status of all configured functions/device
	static variable summaryRemainingDays;		// minimal remaining days of all configured functions/device
}

namespace PS	// process (state) definitions 
{	
	// process state definitions
	static const variable accepted(-11);		// Verification status accepted/confirmed by user
	static const variable excluded(-10);		// Verification status excluted (and marked 'failed') by user
	static const variable notStarted(-3);		// Method started but not the real verification (e.g. during initialisation) added 2004-04-27/cjoerg:
	static const variable open(-2);				// Verification in process.
	static const variable completed(-1);		// Verification completed, but results not evaluated at this time.
	static const variable failed(0);				// Verification has failed, value stored on instrument!
	static const variable successful(1);		// Verification OK, value stored on instrument!

	static variable doCheckBalancePosition(0);// Check of balance position
	
	static variable dataArray[];					// general array of measurement data, e.g. LLD measurment data for 3 loops
	timer	heatingUpPhase;							// delay for heating-up verification devices
	static variable heatUpTime15min(900);		// heat up time of 15min
	static variable heatUpTime20min(1200);		// heat up time of 20min
							
	// generel sequence definitions
	static sequence seq_TeachingNeedles;		// sequence definition of teaching needles
	static sequence seq_baseCheckPositions;	// sequence definition for XYZ verification: base positions of pyramids
	static sequence seq_BufferSolution;
	static sequence seq_DarkSolution;
	static sequence seq_LightSolution;
	static sequence seq_Waste;
	static sequence seq_Tips;
	static sequence seq_HighVolTips;
	static sequence seq_50ulTips;
	static sequence seq_LowVolTips;

	static sequence seq_Tube;
	static sequence seq_lowVolume_Plate;
	static sequence seq_mediumVolume_Plate;
	static sequence seq_highVolume_Plates;
	static sequence seq_BalancePlate;

	static variable showBalanceData(0);				// to show balance device data
//	static variable showTempDeviceData(0);			// to show temperature measurement device data	
	static variable showTempHumDeviceData(0);		// to show ambient temperature & humidity measurement device data	
	static variable showPhotoCheckPlateData(0);	// to show photometer check plate data			
	static variable showBC_CarrierData(0);			// to show barcode carrier data		
	static variable showBC_TwisterData(0);			// to show twister verification data		
}

namespace G_VAR	// general verification state management 
{	
	static variable arrProcessID[];				// array of verification process ID
	static variable arrStatus[];					// array of verification status
	static variable arrDeckPosition[];			// array of verification site deck position
	static variable arrVerificationInterval[];// array of verification interval
	static variable arrRemainingDays[];			// array of verification interval
	static variable arrDescription[];			// array of verification descriptions
	static variable arrInputRemarks[];			// array of verification remarks
	static variable arrExpiryDate[];				// array of verification expiry 
	static variable arrAction[];					// array of verification action selection
}

namespace S_VAR	// temperature verification state management 
{	
//	variable librariesIncluded(hslFalse);
	variable arrDeviceID[];						// array of verification device ID
	variable arrLabwareID[];				// array of verification labware ID
	variable arrStatus[];					// array of verification status
	variable arrSerialNumber[];			// array of verification device serial number
	variable arrDeckPosition[];			// array of verification site deck position
	variable arrDescription[];				// array of verification descriptions
	variable arrInputRemarks[];			// array of verification remarks
	variable arrExpiryDate[];				// array of verification expiry date
	variable arrAction[];					// array of verification action selection

	variable arrFreqSetValue[];			// array of frequence set value 
	variable arrFreqCriteriaValue[];		// array of frequence specification criteria value 
	variable arrFreqMeasuredValue[];		// array of frequence measured value 

	variable arrOrbitSetValue[];			// array of orbit set value 
	variable arrOrbitCriteriaValue[];	// array of orbit specification criteria value 
	variable arrOrbitMeasuredValue[];	// array of orbit measured value 
}

namespace T_VAR	// temperature verification state management 
{	
//	variable librariesIncluded(hslFalse);
	variable arrDeviceID[];					// array of verification device ID
	variable arrLabwareID[];				// array of verification labware ID
	variable arrStatus[];					// array of verification status
	variable arrSerialNumber[];			// array of verification device serial number
	variable arrDeckPosition[];			// array of verification site deck position
	variable arrDescription[];				// array of verification descriptions
	variable arrInputRemarks[];			// array of verification remarks
	variable arrExpiryDate[];				// array of verification expiry date
	variable arrAction[];					// array of verification action selection

	variable arrSetValue[];					// array of 1st set value 
	variable arrOffsetValue[];				// array of 1st offset value 
	variable arrCriteriaValue[];			// array of 1st specification criteria value 
	variable arrSensorCorrection[];		// array of 1st sensor coorection
	variable arrMeasuredValue[];			// array of 1st measured value 
	variable arrRecordedValues[];			// array of recorded (internal) temperature values of 1st heating-up period

	variable arrSetValue_2[];				// array of 2nd set value 
	variable arrOffsetValue_2[];			// array of 2nd offset value 
	variable arrCriteriaValue_2[];		// array of 2nd specification criteria value 
	variable arrSensorCorrection_2[];	// array of 2nd sensor coorection
	variable arrMeasuredValue_2[];		// array of 2nd measured value 
	variable arrRecordedValues_2[];		// array of recorded (internal) temperature values of 2nd heating-up period
}

namespace RPD	//  report definitions
{	
	// report definitions
	file reportFile;
	static variable reportFileName("");
	static variable reportTemplateFileName("");
	static variable reportExcelAreaName("Report$");
	static variable reportExcelAreaName_2("Data$");
	static variable pdfReportFileName("");
	static variable externalStoredFileName("");

	// Nominal test volumes
	static variable Nominal_Volume_1(10.0);					// 1st nominal test volume (e.g. low end, in ul)
	static variable Nominal_Volume_2(1000.0);					// 2nd nominal test volume (e.g high end, in ul)
	static variable Nominal_Volume_3(50.0);					// 3rd nominal test volume (e.g. medium range, in ul)
	// measurement data
	variable measured_Weight_1(0.0);		// measurement weight value for nominal volume 1
	variable measured_Weight_2(0.0);		// measurement weight value for nominal volume 2
	variable measured_Weight_3(0.0);		// measurement weight value for nominal volume 3
	variable measured_Volume_1(0.0);		// measurement volume value for nominal volume 1
	variable measured_Volume_2(0.0);		// measurement volume value for nominal volume 2
	variable measured_Volume_3(0.0);		// measurement volume value for nominal volume 3
	variable arr_ODData_Volume_1[];		// array of OD measurement values for nominal volume 1
	variable arr_ODData_Volume_2[];		// array of OD measurement values for nominal volume 2
	variable arr_ODData_Volume_3[];		// array of OD measurement values for nominal volume 3
	variable arr_Volume_Volume_1[];		// array of volume values for nominal volume 1 
	variable arr_Volume_Volume_2[];		// array of volume values for nominal volume 2 
	variable arr_Volume_Volume_3[];		// array of volume values for nominal volume 3 

	static variable channelVol_High[](160);	// high end test volume, must contains the volume in [nl] float. !
	static variable channelVol_Low[](160);		// low end test volume, must contains the volume in [nl] float!
	static variable calibWeightMeasured(0.0);	// weight [g] float
	static variable temperature(0.0);				// 
	static variable humidity(0.0);					// 
	static variable tipRackID_1(""); // for first tip rack, e.g. low volume tips
	static variable tipRackID_2(""); // for second tip rack, e.g. high volume tips

	static string operatorName("");
	static string laboratoryName("");
	static string verifcationReason("");
	static string solutionLotNumber("");
	static string solution1_ExpiryDate("");
	static string solution2_ExpiryDate("");
	static string solution3_ExpiryDate("");
	static string calibExpiryDate("");
	static string humidityDeviceSerial("");				// ambient temperature and humidity measurement device
	static string humidityDeviceCalDate("");
	static string humidityDeviceExpiryDate("");
	static string twisterToolSerial("");
	static string twisterToolCalDate("");
	static string twisterToolExpiryDate("");

	// Test criteria
	static variable measurementCriteria(0);						// mode for measuremnt cycles
	static variable specificationFactor(1.0);						// specification factor(i.e. for extended reporting of temperature)
	static variable supervisionStartTime(18.0);					// temperature supervision start time (for extended reporting of temperature)

	static variable measurmentCycles(8);							// amount of measured values
	static variable accuracyCriteria_Volume_1(5.00); 	 		// accuracy criteria for nominal volume 1 in % 
	static variable accuracyDisplay_Volume_1("<= +/- 5.00"); // accuracy in % ; display text for report
	static variable accuracyCriteria_Volume_2(5.00); 	 		// accuracy criteria for nominal volume 2 in %
	static variable accuracyDisplay_Volume_2("<= +/- 5.00");	// accuracy in % ; display text for report
	static variable accuracyCriteria_Volume_3(5.00); 	 		// accuracy criteria for for nominal volume 3 in %
	static variable accuracyDisplay_Volume_3("<= +/- 5.00");	// accuracy in % ; display text for report

	static variable precisionCriteria_Volume_1(2.50); 	 		// precision criteria for for nominal volume 1 in %
	static variable precisionDisplay_Volume_1("<= 2.50"); 	// precision in % ; display text for report
	static variable precisionCriteria_Volume_2(1.50); 			// precision criteria ffor nominal volume 2 in % 
	static variable precisionDisplay_Volume_2("<= 1.50");		// precision in % ; display text for report
	static variable precisionCriteria_Volume_3(1.50); 			// precision criteria for nominal volume 3 in %
	static variable precisionDisplay_Volume_3("<= 1.50");		// precision in % ; display text for report
	
	static const string 	calibRange("20 +/- 0.00034"); 		// Range calibration weight, text for report

	// extended reporting
   variable ExtendedReportingKey(""); 
	variable extendedReportMode(-1);		// different level of reporting (<1=standard/1=add TADM data,2=add heating up)
	variable keepExcelFile(0);
	variable showCellWriting(0);
}

namespace RPBARC	// Barcode verification report definitions
{	
	// report definitions
	static string BC_CarrierSerial("");
	static string BC_CarrierCalDate("");
	static string BC_CarrierExpiryDate("");
}

namespace IR_Temp
{	
	// IR Temperature measurement device features
	static variable Sensor_SerialNo("");
	static variable Sensor_ComPort(9);
	static variable Sensor_CalDate("");
	static variable Sensor_ExpiryDate("");
}

namespace Balance // balance
{	
	// Variable for the Balance
	static object waage;		
	static variable Type("");
	static variable Type_SAG("Mettler SAG");
	static variable Type_WXS("Mettler WXS");
	static variable Type_WMC("Roche OWS");
	static variable balanceTerminal(hslTrue);
	static variable SerialNumber("");
	static variable CalibrationDate("");
	static variable CalibrationWeight(0.0);
	static variable CalibrationWeightDate("");
	static variable CalibrationWeightID("");
	static variable CalibrWeightExpiryDate("");
	static variable CheckedStatus("");
	static variable ExpiryDate("");	
	static variable ComPort(3);
	static variable emptyWeight(0.0);
	// Arguments
	static variable DisplayMode1("1");			// Display mode #.#mg
	static variable DisplayMode2("0");			// Display mode #.##mg

	static variable MeasureMode1(-1);			// Wait for a stable value
	static variable MeasureMode3(-3);			// Wait 3 seconds, then wait for a stable value
	static variable MeasureMode_0(0);			// Immediately measurement
	static variable MeasureMode_1(1);			// Measure weight at 1 seconds +/- 0.75s
	static variable MeasureMode_2(2);			// Measure weight at 2 seconds +/- 1.5s
	static variable MeasureMode_3(3);			// Measure weight at 3 seconds +/- 2.25s
	static variable MeasureMode_4(4);			// Measure weight at 4 seconds +/- 3s
	static variable MeasureMode_6(6);			// Measure weight at 6 seconds +/- 4.5s
	
	//static string resetWaage("@");				// command for reset
//	static variable setZero("Z");					// command to set balance to zero and wait until stable state
//	static variable setInstantlyZero("ZI");	// command toset balance instantly to zero
	static variable WeightInstrNr("I4");		// command for the serial number
	static variable BalanceData("I2");			// command for inquiry the balance data

	static const variable platePlatform("PlatePlatform");
	static const variable tubePlatform("TubePlatform");
}

namespace Reader
{	
	static const variable ReferenceFileName("FOT_REF.TEX");
	static const variable waveLenght(405);
	static const variable firstRow(47); // first row number of 96plate scan data 

	static object Device;
	static variable ID(""); 
	static variable partNo("P/N 189'115");
	static variable deviceSerialNo("");
	static variable CheckedStatus("");
	static variable deviceCheckDate("");

	static variable photoCheckPlatePartNo("");
	static variable photoCheckPlateSerial("");
	static variable photoCheckPlateCalDate("");
	static variable photoCheckPlateExpiryDate("");
	
	static variable isInitialized(hslFalse);
	static variable newReferenceData(hslFalse); //: new reference date red from mini CD
}

namespace TipType
{	
	// Variable for tip (rack) type
	static variable noTip(-1);
	static variable _300ulStandardVolumeTip(0);
	static variable _300ulStandardVolumeTipwFilter(1);
	static variable _10ulLowVolumeTip(2);
	static variable _10ulLowVolumeTipwFilter(3);
	static variable _1000ulHighVolumeTip(4);
	static variable _1000ulHighVolumeTipwFilter(5);
	static variable _50ul_384ClearTip(20);
	static variable _50ulTip(22);
	static variable _50ulTipwFilter(23);
	static variable _50ul_384Tip(33);
	static variable _4mlTipwFilter(29);
	static variable _5mlTip(25);
}

namespace LiquidType
{	
	// Variable for liquid type
	static variable HVS_Solution(0);
	static variable DarkDye_Solution(1);	// = Verification solution #1
	static variable Buffer_Solution(2);		// = Verification solution #2	
	static variable LightDye_Solution(3);	// = Verification solution #3
	static variable LC_LowVolume("");		// liquid class for low volume pipetting
	static variable LC_MediumVolume("");	// liquid class for medium volume pipetting
	static variable LC_HighVolume("");		// liquid class for highvolume pipetting
}

namespace Dlg
{	
	static const variable Green(1);
	static const variable Yellow(2);
	static const variable Red(3);
	static const variable Gray(4);

	// Variables for dialog handling
	variable dialogOpen(hslFalse);
	variable dialogTitle;
	variable handle;
	variable handles[ ];

   static object  statusDlg;
}

//--------------------------------------------------------------------------------------------------------------------------------------
// Section 1 : Interface of VerificationLibrary
//--------------------------------------------------------------------------------------------------------------------------------------

#ifndef HSL_RUNTIME	// Parser constant, always defined at
							// run-time, but not at edit-time.

namespace VerTool	// This will prevent clashing of variable 
							// and function names across libraries.
{
	//-----------------------------------------------------------------------------------------------------
	function InitializeDataVariables(); 
	//-----------------------------------------------------------------------------------------------------
	// Initialize variable for measurement andevaluation data 
	// 
	// RETURN		none
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function convertToFloat(variable tempValue);
	//-----------------------------------------------------------------------------------------------------
	// Converts to float number

	//-----------------------------------------------------------------------------------------------------
	function convertToInteger(variable tempValue);
	//-----------------------------------------------------------------------------------------------------
	// Converts to integer number

	//-----------------------------------------------------------------------------------------------------
	function convertToString(variable tempValue);
	//-----------------------------------------------------------------------------------------------------
	// Converts to string 

	//-----------------------------------------------------------------------------------------------------
	function convertXYcoordToTrackSite(variable tempValue);
	//-----------------------------------------------------------------------------------------------------
	// Converts a string with X- / Y- cooddinate (" xxxx / yyyy") to track/site posiition ("track TT / site SS ") string

	//-----------------------------------------------------------------------------------------------------
	function ValidateDate(variable date, variable timeOffset, variable& expiryDate, 
									variable& validState, variable& validRemarks) variable ; // remaining days
	//-----------------------------------------------------------------------------------------------------
	// Validate (calibration) date :   remaining days to 'now' plus offset value


	//-----------------------------------------------------------------------------------------------------
	function addArrayInformation(variable& mainArray[], variable additionalArray[]);
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function checkInputValue(variable inputValue, variable upperLimit, variable lowerLimit,variable& outputValue) variable;
	//-----------------------------------------------------------------------------------------------------
	
	// --------------------------------------------------------------------------------------
   function ExistLiquidClass( variable liquidClassName) variable;
	// Check if Liquid Class exists in DB. Attention Name case sensitve	
	// --------------------------------------------------------------------------------------

	// --------------------------------------------------------------------------------------
	function statisticCalculation(
								variable dataArray[],				// array of (n x 96 or nx384) measurment data (A1 ..H1..H12..P24)
								variable	rowSize,						// data row size: 1 .. 8 .. 16 ( = channel A ..  H .. P)
								variable columnSize,					// data column size: 1 .. 12 .. 24
								variable firstRow,					// first row number 1 .. 8 .. 16 ( = channel A ..  H .. P)
								variable lastRow,						// last row number (>= firstRow, 1 .. 8 .. 16 ( = channel A ..  H .. P)	
								variable firstColumn,				// first column number (1 .. 12 ..24)
								variable lastColumn,					// last column number (>= firstColumn, 1 .. 12 ..24) 
								variable measurementLoops,			// amount of measurement loops (of same well)
								variable& arrMeanValue[],			// array of average value (index 0: average of all wells)
								variable& arrMinValue[],			// array of minimal value (index 0: min of all wells)
								variable& arrMaxValue[],			// array of maximal value (index 0: max of all wells)
								variable& arrStandardDeviation[])// array of standard deviation (index 0: std of all wells)
																	 variable; // true, if calculation could perform
	//-----------------------------------------------------------------------------------------------------

	// --------------------------------------------------------------------------------------
	function linearInterpolation(
								variable	X_Value,			 			// input variable (X value)
								variable arrInterPoints[])			// array of interpolation points (String "x_value y_value")
																 variable; // result: interpolated value (Y value)
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function Density(variable  liquidType, 				// in: liquid type
							variable  temperature				// in: ambient temerature in [°C] as float
															) variable;	
	// Evaluate the densitiy of the verification liquid for passed temperature.
	// Only a temperature range >=15 and <= 35.0 degrees is supported.
	// RETURN		density value of correspondng verification liquid
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function ChannelPattern(variable firstChannel, variable numberOfUsedChannels, variable numberOfChannels) variable;
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function ChannelAddress(variable firstCharakater, variable ChannelNo) variable;
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function GetErrorCodes( variable channelPattern, variable &arrayMainError[], variable &arraySlaveError[]) variable;
	// Get error codes of last step, step error and main and salve error for each channel (block)
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function FwCommand( variable &fwCommand, variable &fwParameter, variable errCheck, device ML_STAR );
	//-----------------------------------------------------------------------------------------------------
	// Executes firmware command and checks return value (if errCheck is hslTrue)
	//
	// RETURN		answer of firmware
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function ML_STAR_Initialize(device& ML_STAR);
	//-----------------------------------------------------------------------------------------------------
	// Initialize ML_STAR 
	// 
	// RETURN		none
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function CoverLock( device ML_STAR , variable lockStatus );
	// lock front cover if lockStatus = VerDef::coverLocked;, unlock if lockStatus = VerDef::coverUnlocked;		
	//-----------------------------------------------------------------------------------------------------
	// Move dispense head and autoload to the left most position
	// 
	// RETURN		none
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function MoveToEndPositions(device ML_STAR) ;
	//-----------------------------------------------------------------------------------------------------
	// Move arms to end positions:
	// In case of single arm: 	Move arm to defined right end position						
	// In case of dual arm: 	Move arms to end positions, left arm to defined left end position (but inside side cover), 
	//																			right arm to defined right end position
	// Move autoload to extreme right position
	// Move multiProbeHeads to Y-home position and switch of current of Y- motor 
	// Switch of current of X-motor(s)
	// RETURN		none
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function GetNoOfChannels() ;
	//-----------------------------------------------------------------------------------------------------
	// Ask for number of channels for the initialized instrument
	// 
	// RETURN		number of channels
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function GetNoOf_5mlChannels() ;
	//-----------------------------------------------------------------------------------------------------
	// Ask for number of 5ml channels for the initialized instrument
	// 
	// RETURN		number of 5ml pipetting channels
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function GetInstrSerialNo() ;
	//-----------------------------------------------------------------------------------------------------
	// Ask for instrument serial number
	// 
	// RETURN		serial number of instrument
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function MoveToPosition( device ML_STAR, variable pipettingHeadType, variable channelPattern, 
												sequence seqTargetPositions, variable zOffset) variable;
	//-----------------------------------------------------------------------------------------------------
	// Move pipettingHead to defined position (corrected with zOffset)
	// 
	// RETURN	step execution	state : hslTrue / hslFalse
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function TraceDlgYes( string &dlg ) ; 
	//-----------------------------------------------------------------------------------------------------
	// Trace for pressing dialog button <OK>
	// 
	// RETURN		none
	//-----------------------------------------------------------------------------------------------------
	
	//-----------------------------------------------------------------------------------------------------
	function TraceDlgNo( string &dlg ) ; 
	//-----------------------------------------------------------------------------------------------------
	// Trace for pressing dialog button <OK>
	// 
	// RETURN		none
	//-----------------------------------------------------------------------------------------------------
	
	//-----------------------------------------------------------------------------------------------------
	function TraceDlgOK( string &dlg ) ; 
	//-----------------------------------------------------------------------------------------------------
	// Trace for pressing dialog button <OK>
	// 
	// RETURN		none
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function TraceDlgCancel( string &dlg ) ; 
	//-----------------------------------------------------------------------------------------------------
	// Trace for pressing dialog button <Cancel>
	// 
	// RETURN		none
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function TraceArray(variable arrayName, variable arrayToTrace[]) ; 
	// Trace content of array
	// 
	// RETURN		none
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function displayArrayData(variable displayTitel, variable& arrayToDisplay[]); 
	// Display array data to enable changes (for simulation mode)
	// 
	// RETURN		none
	//-----------------------------------------------------------------------------------------------------
	
	//-----------------------------------------------------------------------------------------------------
	function GetConfigurationData(variable& layoutFileName, variable& instrumentNo);
	// Get instrument data as 
	// corresponding deck file, instrument type , use of pre-defined decklayout
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	// Get deck layout data as balance and tip/plate carrier track position
	function GetStarConfiguration( device ML_STAR);
	//-----------------------------------------------------------------------------------------------------

	// -------------------------------------------------------------------------------------------------------
	// Update verifications configuration data according pre-defined deck layout
	function UpdateVerificationDataDueToDeckInfo(device ML_STAR);
	// -------------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	// Read cell content from Excel report file
	function ReadCell( variable column, variable row, variable& output);
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	// Write cell content into Excel report file
	function WriteCell( variable column, variable row, variable value);
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	// Write cell content into Excel report file
	function WriteCell_2( variable column, variable row, variable value, variable valueType);
	//-----------------------------------------------------------------------------------------------------

	//--------------------------------------------------------------------------------
	// Get verification information from corresponding information arrays
	function GetVerificationInformation(
						variable VerificationInfoType,		//	requested verification information key word
						variable& VerificationProperty,		// corresponding property
						variable& VerificationProperty_2,	// corresponding second property
						variable& VerificationProperty_3,	// corresponding third property
						variable& VerificationSerialNo,		// corresponding serial number
						variable& VerificationDate,			// corresponding date (calibration date , expiry date ...)
						variable& VerificationLastChange,	// corresponding date of last change
						variable& VerificationChangeBy		// corresponding operator of last change
																	) variable;  // index number
	//--------------------------------------------------------------------------------

	//--------------------------------------------------------------------------------
	// Update verification information (option: store into file "...system\ML_STARVer_####.csv")
	function UpdateVerificationInformation(
						variable storeDataInFile,			// store  all data in file
						variable VerificationInfoType,	//	 verification information key word
						variable VerificationProperty,	// corresponding property
						variable VerificationProperty_2,	// corresponding second property
						variable VerificationProperty_3,	// corresponding third property
						variable VerificationSerialNo,	// corresponding serial number
						variable VerificationDate			// corresponding date (calibration date , expiry date ...)
															) variable; // size of informations

	//--------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function GetProcessDataFromFile(variable processId, variable& processedState, 
														variable& processedDate , variable& processedTime, variable& verificationInterval);
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function GetProcessDataFromInstrument(device ML_STAR, variable processId,  variable& processedState,
														variable& processedDate , variable& processedTime, variable& verificationInterval) ;
	//-----------------------------------------------------------------------------------------------------
	// Get process data for process with id 'processId' from instrument
	// 	'time stamp' and 'processedState' 
	//
	// Note: If data could not stored on instrument (processId > 9 for FW  version C0 <6.3S else processId > 24 )
	//  		get data from verification configuration file
	//
	// RETURN		none
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function StoreProcessDataOnInstrument( variable processId, variable processedState, device ML_STAR ) ;
	//-----------------------------------------------------------------------------------------------------
	// Store time stamp and 'processedState' for process with id 'processId' on instrument
	//
	// Note: If data could not stored on instrument (processId > 9 for FW  version C0 <6.3S else processId > 24 )
	//  		store data in verification configuration file
	//
	// RETURN		none
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function OpenReportFile_2( variable& templateFile,variable fileCreate);
	//-----------------------------------------------------------------------------------------------------
	// Creates an open a verification report file for extended reporting
	//
	// RETURN		none
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function CreateReportFile( variable& templateFile);
	//-----------------------------------------------------------------------------------------------------
	// Creates a verification report file
	//
	// RETURN		none
	//-----------------------------------------------------------------------------------------------------

	// -------------------------------------------------------------------------------------------------------
	function GeneratePDF_File( )	void;
	// Generate a pdf file from a source excel file with program "PDFcamp Printer Pro v2.3" respectively "PDF Creator"
	// Generated pdf file has same basic name as sourc file plus date and time information plus pdf extention															  
	// -------------------------------------------------------------------------------------------------------

	// -------------------------------------------------------------------------------------------------------
	static function FormatNumber_PointAsDecimal(variable& numberToFormat, variable countOfDecimals) variable;
	// -------------------------------------------------------------------------------------------------------
	// Return a string number with the desired number of decimals.
	// As decimal delimiter always the point ('.') is used, not language specific!
	// Integer and float values may be passed for formatting. If a other type is passed the string
	// "---" is is returned.
	// -------------------------------------------------------------------------------------------------------

	// -------------------------------------------------------------------------------------------------------
	// Remove specific labware from deck, if present
	static function RemovePresentLabware(device ML_STAR, variable labwareID);
	// -------------------------------------------------------------------------------------------------------

	// -------------------------------------------------------------------------------------------------------
	// Add template  on deck
		function AddTemplateOnDeck(
									device ML_STAR, 					// ML_STAR device
									variable templateID,				// template ID
									variable carrierType,			// template type
									variable trackNo);					// track position

	// -------------------------------------------------------------------------------------------------------

	// -------------------------------------------------------------------------------------------------------
	// Add rack on carrier 
	static function AddRackOnCarrier(
									variable carrierPosition,		// carrier position (= site ID)
									variable rackType,				// racktype
									variable rackID,					// rack ID
									sequence& seqRackPositions);	// add sequence position of corresponding rack 
	// -------------------------------------------------------------------------------------------------------

	// -------------------------------------------------------------------------------------------------------
	// Load carrier with pre-defined racks (=>AddRackOnCarrier) and if autoload available load carrier on deck
	static function Load_Carrier(device ML_STAR, 
											variable carrierName, 
											variable trackPosition,
											variable checkRackBarcode);  
	// -------------------------------------------------------------------------------------------------------

	// -------------------------------------------------------------------------------------------------------
	function Unload_TipCarrier(device& ML_STAR); 
	// -------------------------------------------------------------------------------------------------------

	// -------------------------------------------------------------------------------------------------------
	function Unload_Consumables(device& ML_STAR, variable unLoadReader); 
	// -------------------------------------------------------------------------------------------------------

	// -------------------------------------------------------------------------------------------------------
	// functions to communicate with the weighting programm
	function MWPUserComand(string command, variable timeOut);
	function MWPUserComand_2(string command, variable timeOut);
	function MWPInitialize(variable& comPort) variable;
	function MWPBalanceDisplay(string DisplayMode) ;
	function MWPInternalCalibration() ;
	function MWP_ExternalCalibration() variable;
	function MWPSettingOfTheWeighingParameters() ;
	function MWPSetZero(variable immediately);
	function MWPMeasure(variable  measureMode, variable simulatedValue) ;
	function MWPTerminate();

	// -------------------------------------------------------------------------------------------------------
	// Install Balance and check status
	function Install_Balance(device ML_STAR, variable minTrackNo) variable; // hslOK, hslCancel
	// -------------------------------------------------------------------------------------------------------

	// -------------------------------------------------------------------------------------------------------
	// functions to communicate with the reader384 programm  
	function Reader_Initialize() variable;
	function Reader_IdleMode() variable;
	function Reader_GetStatus(variable& wavelengthSet[], variable& serialNumber, variable& versionFW )variable;
	function Reader_OpenDoor()  variable;
	function Reader_CloseDoor()  variable;
	function Reader_ShakePlate(shakingTime, variable intensity )  variable;
	function Trace_384erPlate_OD_Values(variable& plate_OD_ValueSet[],variable& delimiter,variable& dataFileName) variable;
	function Trace_96erPlate_OD_Values(variable& plate_OD_ValueSet[], variable& delimiter, variable& dataFileName) variable;
	//--------------------------------------------------------------------------------------------------
	function Measure_Plate_OD_Values(device ML_STAR,
												variable i_DialogTitle,		//	dialog titel of plate loading on reader
												variable i_plateNumber,		//	plate number for input dialog: 0 no specific infomation
												variable plateType, 			// 96er plate or 384er plate
												variable& OD_ValueSet[]) variable;
	//--------------------------------------------------------------------------------------------------

	// --------------------------------------------------------------------------------------
	// Check loading of balance: Glas or 96er plate or 384er plate
	function CheckLoadingOnBalance(device ML_STAR, variable labwareOnBalance) variable;  // true or false
	// --------------------------------------------------------------------------------------
	
	// --------------------------------------------------------------------------------------
	function Check_Balance(device ML_STAR) variable;
	// Check balance
	// --------------------------------------------------------------------------------------

	// --------------------------------------------------------------------------------------
	// Install Photometer and check status
	function Install_Photometer( ) variable;
	// --------------------------------------------------------------------------------------

	// --------------------------------------------------------------------------------------
	function Check_Photometer( ) variable;  
	// Check Photometer: measured and check data of processed check plate in photometer 'Reader384'
	// --------------------------------------------------------------------------------------

	// --------------------------------------------------------------------------------------
	// Check presence of program and ML-STAR Software version
	function CheckPrograms(variable firstSW_Version) variable;
	// --------------------------------------------------------------------------------------

	//------------------------------------------------------------------------------
	function Check_PreConditions(device ML_STAR, variable processIDs[], variable dialogTitle); //variable
	//------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function getTipType(variable tipType,  variable& tipTypeRemark) variable;
	//-----------------------------------------------------------------------------------------------------
	//-----------------------------------------------------------------------------------------------------
	function SelectFileNameDialog(variable& io_fileName, variable& io_pathName, variable i_fileFilter) variable;
	// Return file and path name of selected file
	//-----------------------------------------------------------------------------------------------------
	
	//-----------------------------------------------------------------------------------------------------
	function ShowStatusDialog(variable i_DialogTitle);
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function UpdateStatusDialog(variable i_DialogTitle, variable i_StatusText, variable iBackgroundColor); 
   //	iBackgroundColor : 1 = green, 2 = yellow, 3 = red , else gray 
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function HideStatusDialog(); // hide &close Dialog
	//-----------------------------------------------------------------------------------------------------
	
	//-----------------------------------------------------------------------------------------------------
	function DialogEnvironmentData(variable i_DialogTitle)variable;//	dialog titel,  answer hslOkay or hslCancel
	//-----------------------------------------------------------------------------------------------------
	function DialogVerifcationToolData(
									variable i_DialogTitle				//	dialog titel information of environment
																) variable;	// hslOkay, hslCanel, hslAbort
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function NewTextLine(variable i_resetVariable, variable i_DialogText)void;
	//	add new dialog text line to variable "VerDef::dialogText", e.g. can be used for function "DialogInfoData"
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function SetDialogTimer(variable i_indicatedTime, variable i_dialogTimeOut)void;
	//	add time out information used in function "DialogInfoData"
	//-----------------------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------------------
	function DialogInfoData(variable i_DialogTitle,				//	dialog titel information
									variable i_pictureFile,				// picture file name (in subdirectory "..\\Methods\Verification\Pictures\""
									variable i_DialogInfoText,			// dialog information text
									variable i_WarningText,				// Warning text
									variable i_buttonsTypes,			// indicate the buttons: hslOKOnly (0), hslOKCancel (1), hslYesNo(4) 
									variable i_defaultButton,			// define other default button: hslCancel(2), hslNo(7) (else first button as default)
									variable i_inputDescription,		// input value description (if "" no value will e displayed
									variable i_inputRemarks,			// remarks for input value: units, range, meanng
									variable& io_variableValue			// input / output value to be changed (string)
																) variable;
	//-----------------------------------------------------------------------------------------------------
	function DialogVerifcationConsumableData(
									variable i_DialogTitle,				//	dialog titel information of environment
									variable i_solutionPartNo,			// solution part number
									variable i_showSolution_1			// to show verification solution 1 data
																) variable; // hslOkay, hslCanel, hslAbort
	//-----------------------------------------------------------------------------------------------------

	//------------------------------------------------------------------------------
	function VerificationUserMessagesDialog(variable dialogTitle,  variable userMessages[], variable warning); //variable
	//------------------------------------------------------------------------------

	//------------------------------------------------------------------------------
	function VerificationNotImplementedDialog(variable dialogTitle, variable warning); //variable
	//------------------------------------------------------------------------------
	
	//-----------------------------------------------------------------------------------------------------
	function VerificationFailedDialog(variable dialogTitle, variable warning); //variable
	//-----------------------------------------------------------------------------------------------------

	//------------------------------------------------------------------------------
	function ShowVerificationData(
						variable i_DialogTitle,		//	dialog titel information of environment
						variable i_DialogInfoType	// dialog information type : G = general, T = temperature, S = Shake;
																) variable;
	//-----------------------------------------------------------------------------------------------------

} // end namespace VerTool

//--------------------------------------------------------------------------------
// Get language dependent text out of corresponding language file
	function LdT(variable defaultText	//	default text, willbe used if no translate text is available
												) variable;  // translated text
//--------------------------------------------------------------------------------

#endif	// end of HSL_RUNTIME = 0

//===============================================================================================================================
// Section 2 : Implementation of VerificationLibrary
//===============================================================================================================================

#ifdef HSL_RUNTIME	// Parser constant, always defined at
							// run-time, but not at edit-time.

#ifndef __HSLDeckVisualize_hsl__
#include "HSLDeckVisualize.hsl"
#endif

#ifndef __HSLDevLib_hsl__
#include "HSLDevLib.hsl"
#endif

#ifndef __HSLMthLib_hsl__
#include "HSLMthLib.hsl"
#endif

#ifndef __HSLStrLib_hsl__
#include "HSLStrLib.hsl"
#endif

#ifndef __HSLTimLib_hsl__
#include "HSLTimLib.hsl"
#endif

#ifndef __HSLTrcLib_hs__
#include "HSLTrcLib.hsl"
#endif

#ifndef  __HSLUtilLib_hsl__
 #include "HSLUtilLib.hsl"
#endif

#ifndef __HSLML_STARLib_hsl__
#include "HSLML_STARLib.hsl"
#endif

#ifndef __HSLVerVariableFunctions_hs___
#include "HSLVerVariableFunctions.hs_"
#endif


	//------------------------------------------------------------------------------
	private function OnStatusDialog_Abort() 
	//------------------------------------------------------------------------------
	{
      Dlg::statusDlg.Hide();
	}  // -- end of function "OnStatusDialog_Abort"

//--------------------------------------------------------------------------------
// Get language dependent text out of corresponding language file
	function LdT( variable defaultText	//	default text, will be used if no translate text is available
													) variable  // translated text
//--------------------------------------------------------------------------------
{
	const variable languageTextFileName("HslVerToolsLib_"); // HslVerToolsLib_Enu.csv"
	const variable headerDefaultText("Default_Text");
	const variable headerTranslatedText("Translated_Text");
	const variable delimiter("|");

	variable fileName("");					// File name inclusive path 
	variable defaultTxt("");				// temporary default text
	variable translatedText("");			// translated text

	variable index(0),sizeOfData(0);
	variable traceSource(""),traceAction( "Translate text");
	file 		textFile;										
	object 	fso;  // file system object

	traceSource = GetFunctionName() + ": ";
	sizeOfData = VSID::arrDefaultText.GetSize();

	if (sizeOfData ==0)
	{	// read all translated text out of file "...template\HslVerToolsLib_Enu.trl" 
		if (fso.IsNull()) fso.CreateObject("Scripting.FileSystemObject");
		
		fileName = GetConfigPath() + "\\" + languageTextFileName + GetLanguage() + ".csv";
 		if (!fso.FileExists(fileName))
		{ // english file
			fileName = GetConfigPath() + "\\" + languageTextFileName + "Enu.csv";
		}

 		if (fso.FileExists(fileName))
		{ // read data from file
			VSID::arrDefaultText.SetSize(0);
	  		VSID::arrTranslatedText.SetSize(0);

			textFile.AddField(headerDefaultText,	defaultTxt,		hslString);
			textFile.AddField(headerTranslatedText,translatedText,hslString);		
			textFile.SetDelimiter(delimiter);
			if( 0 == textFile.Open(fileName, hslRead) )
			{
		 		FormatTrace(traceSource, "Open file", VerDef::CMD_ERRCOMPL, " Open file ", fileName , " failed"); 
			}
			else
			{
				index = 0;
				while (!textFile.Eof())
				{
					textFile.ReadRecord(); 
					if ((GetType(defaultTxt) == "s") && (StrGetLength(defaultTxt) > 0))
					{
						index++;
						VSID::arrDefaultText.AddAsLast(defaultTxt);
						if ((GetType(translatedText) == "s") && (StrGetLength(translatedText) > 0)) 
									VSID::arrTranslatedText.AddAsLast(translatedText);	
						else		VSID::arrTranslatedText.AddAsLast(defaultTxt);	
					}		
//Trace(traceSource, " Test: ==> index ==>", index, 
//						"<== \t default Text =>", defaultTxt, 
//						"<== \t translated Text =>", translatedText,			
//						"<==");	
				}
				textFile.Close();
				textFile.RemoveFields();
			}
		}
		sizeOfData = VSID::arrDefaultText.GetSize();
	}

	// search for default text
	for (index = 0;index < sizeOfData; index++)
	{
		if(defaultText == VSID::arrDefaultText.GetAt(index))
		{ // info found
			translatedText = VSID::arrTranslatedText.GetAt(index);	// corresponding text
//Trace("Test: function LdT: defaultText =>",defaultText,"< translatedText ==>",translatedText,"<==");
			return(translatedText);
		}
	}
	// add default text to text arrays
	VSID::arrDefaultText.AddAsLast(defaultText);
	VSID::arrTranslatedText.AddAsLast(defaultText);
//Trace("Test: function LdT: defaultText =>",defaultText,"< --> no translatedText found!");
	return(defaultText);

}  // ----  end of function "LdT" ---

namespace VerTool	// This will prevent clashing of variable 
						// and function names across libraries.
{
	//=====================================================================================================
	// general data 
	//=====================================================================================================
	static object	dtScriptControl;

	//=====================================================================================================
	// declaration of variables and constants
	//=====================================================================================================

	// firmware acknowledge
	static const string 		fwRetOk("er00");
	static const variable 	fwRetOkLength(4); // number of char from fwRetOk

	// initialization state of the Verification Methods Library
	static variable initializedLib(hslFalse);			

	// deck positions
	static const variable deckPosFirst(1);
	static const variable deckPosFistHigh(29);
	variable y_MaxPos_1000ulpCh(0);
	variable y_MinPos_1000ulpCh(0);
	variable y_MaxPos_5mlpCh(0);
	variable y_MinPos_5mlpCh(0);

	// deck loading information
	variable arrayRackID[];
	variable arrayRackConfigFile[];

	//--- verifcation data file information
	static const variable readDataOnly(1);
	static const variable writeData(0);
	const variable verficationStatusFileName("ML_STARVer"); // fileName "ML_STARVer.csv"

	const variable headerInfoType("InfoType");
	const variable headerSerialNo("SerialNo");
	const variable headerDate("Date");
	const variable headerLastChange("LastChange");
	const variable headerChangeBy("ChangeBy");
	const variable headerProperty("Property");
	const variable headerProperty_2("Property_2");
	const variable headerProperty_3("Property_3");

	variable arrayInfoTypes[];
	variable arraySerialNo[];
	variable arrayDate[];
	variable arrayLastChange[];
	variable arrayChangeBy[];
	variable arrayProperty[];
	variable arrayProperty_2[];
	variable arrayProperty_3[];

	const variable KeyOperator("Operator");
	const variable KeyLaboratory("Laboratory");
   const variable KeyReason("Reason"); 
	const variable KeyTemperature("Temperature");
   const variable KeyHumidity("Humidity"); 
	const variable KeyReagent("Reagent");
	const variable KeyTipRack("TipRack");							// Tip rack # 1 .. 3
	const variable KeyBalance("Balance");
	const variable KeyCalWeight("CalWeight");
//	const variable KeyTempDevice("Temp_Device");
	const variable KeyHumidityDevice("Humidity_Device");
	const variable KeyPhotoCheckPlate("PhotoCheckPlate");
	const variable KeyReader384("Reader384");
	const variable KeyBC_Carrier("BC_Carrier");
	const variable KeyTwisterTool("TiwsterTool");
	const variable KeyTempCheckPlate("TempCheckPlate");			// Temperature check plate # 1 .. 5

	const variable KeyPDFcampExecFile("PDFcampExecFile");			// PDFcamp Printer Pro v2.3 (ExecutableProgram)
	const variable KeyAcrobatReader("AcrobatReaderExecFile");	// AcrobatReader (ExecutableProgram)
	const variable KeyExcelViewer("ExcelViewerExecFile");			// Excel Viewer (ExecutableProgram)
	const variable KeyExternalDataStorage("ExternalDataStorage");// for external data stroae
	const variable KeyExtraConfiguration("ExtraConfiguration"); // for extra instrument configurations


	// additional executable programs 	
	static variable PDF_CreatorExecutableProgram("C:\\Program Files\\VeryPDF PDFcamp Printer Pro v2.3\\BatchPDF.exe");
	static variable AcrobatExecutableProgram("C:\\Program Files\\Adobe\Reader 8.0\\Reader\\AcroRd32.exe");
//	static variable ExcelExecutableProgram("C:\\Program Files\Microsoft Office\OFFICE11\\EXCEL.EXE");
	static variable ExcelViewerProgram("XLView.exe");

	// labware config file names
	static const variable carFileName_TipPlate("VER_CAR_L5_MS_A00.tml"); 			// carrier with multiple usable sites
	static const variable carFileName_Balance("VER_BALANCE.tml");						// only balance with tube
	static const variable carFileName_WMCBalance("VER_WMC_BALANCE.tml");			// only WMC balance with tube
	static const variable carFileName_BalanceTube("VER_BALANCE_Tube.tml");			// reagent containers & balance with tube
	static const variable carFileName_BalancePlate("VER_BALANCE_Plate.tml");		// reagent containers & balance with plate
	static const variable carFileName_BC_horizontal("VER_CAR_BC_HREAD_A00.tml");	// Barcode carrier, horizontal reading
	static const variable carFileName_BC_vertical("VER_CAR_BC_VREAD_A00.rck");	 	// Barcode carrier, vertical reading
	static const variable carFileName_PuncherModule("VER_PuncherModule.tml");	   // easy puncher module
	static const variable carFileName_Magazine_1("VER_CAR_MAG_CAR_L5_DMPK.tml");  // easy punch magazine carrier 1 (DMPK cards, p/n 803416)
	static const variable carFileName_Magazine_2("VER_CAR_MAG_CAR_L5.tml");	      // easy punch magazine carrier 2 (p/n 803606)

	static const variable rackFileName_Reagent_8("VER_300ml_8C_RGT.rck");
	static const variable rackFileName_Reagent_96("VER_300ml_96C_RGT.rck");
	static const variable rackFileName_Reagent_384("VER_300ml_384C_RGT.rck");

	static const variable rackFileName_8mlTube("VER_BALANCE.rck");						// Balance with 8ml tube (glas)
	static const variable rackFileName_5mlBowl("VER_WMC_BALANCE.rck");				// WMC Balance with 5ml bowl (glas)
	static const variable rackFileName_96erPlate("VER_Plate_96.rck");
	static const variable rackFileName_384erPlate("VER_Plate_384.rck");

	static const variable rackFileName_TipRack_10ul("VER_LT.rck");
	static const variable rackFileName_TipRack_50ul("VER_50ulT.rck");
	static const variable rackFileName_TipRack_300ul("VER_ST.rck");
	static const variable rackFileName_FilterTipRack_300ul("VER_STF.rck");
	static const variable rackFileName_TipRack_1000ul("VER_HT.rck");
	static const variable rackFileName_FilterTipRack_1000ul("VER_HTF.rck");
	static const variable rackFileName_TipRack_5ml("VER_5mlT.rck");
	static const variable rackFileName_TipRack_384Tips_50ul("VER_384_50ul_Tip.rck");
	static const variable rackFileName_TipRack_384cTips_50ul("VER_384_50ul_cTip.rck");
	static const variable rackFileName_TipRack_TeachingNeedles("VER_TeachingNeedles.rck");
	static const variable rackFileName_TipRack_96TeachingNeedles("VER_TeachingNeedles96.rck");
	static const variable rackFileName_TipRack_384TeachingNeedles("VER_TeachingNeedles384.rck");
	static const variable rackFileName_TipRack_5mlTeachingNeedles("VER_5mlTeachingNeedles.rck");
	static const variable rackFileName_Pyramid("VER_RCK_PositionSite.rck");
	static const variable rackFileName_PaperCardMagazine_1("VER_PaperCard_Magazine_1.rck");
	static const variable rackFileName_PaperCardMagazine_2("VER_PaperCard_Magazine_2.rck");
   static const variable rackFileName_PaperCardMagazine_3("VER_PaperCard_Magazine_3.rck");
	static const variable rackFileName_DWP_2ml("VER_DWP_2ml.rck");

	// carriers on deck and loading tray
	static variable deckLowPos;	 		// deck positions low (<deckPosFistHigh)
	static variable deckHighPos; 			// deck positions high (>=deckPosFistHigh)
	static variable loadingTrayLowPos;	// loading tray positions (<deckPosFistHigh)
	static variable loadingTrayHighPos;	// loading tray positions (>=deckPosFistHigh)

	// report file: constants for volume verification	
	static variable 			weigthingCycles(8);						// amount of measured values
	static const string		accuracy("<= +/- 5.00"); 		// accuracy in % text for report
	static const variable  	valueAccuracy(5.00); 	 		// accuracy in % for calculation
	static const string    	precision1000("<= 1.50"); 	// precision in % for 1000µl text for report
	static const variable 	valuePrecision1000(1.50);	 	// precision in % for 1000µl for calculation
	static const string 	  	precision50("<= 2.50"); 		// precision in % for 50µl text for report
	static const variable 	valuePrecision50(2.50);	 	// precision in % for 50µl for calculation
	static const string 		calibRange("20 +/- 0.00034"); // Range calibration weight, text for report
																		// (the value for calculation is defined in the VolumeVerification method)

	//=====================================================================================================
	// prototyping local functions
	//=====================================================================================================

	// initializes the Verification Tools Library (only once)
	static function InitVerToolsLibrary();				
	
	// get String value from processed state
	static function GetProcessedStateAsString(variable &processedState);

	// get String value from check state (tightness or cLLD)
	static function GetCheckStateAsString( variable &state);

	// trace array content
	static function TraceArray(variable arrayName, variable arrayToTrace[]);

	//=====================================================================================================
	// local functions
	//=====================================================================================================

	//-----------------------------------------------------------------------------------------------------
	function convertToFloat(variable tempValue)
	//-----------------------------------------------------------------------------------------------------
	// Converts to float number
	{
		variable output(0.0);
		variable varType;

		varType = GetType(tempValue);
//Trace("Test: tempValue =>",tempValue,"< has type ==>",varType,"<==");
		if (varType == "s") output = FVal(tempValue); // string
		else output = tempValue;
		return(output);
	}

	//-----------------------------------------------------------------------------------------------------
	function convertToInteger(variable tempValue)
	//-----------------------------------------------------------------------------------------------------
	// Converts to integer number
	{
		variable output(0);
		variable varType;

		varType = GetType(tempValue);
//Trace("Test: tempValue =>",tempValue,"< has type ==>",varType,"<==");

		if (varType == "s") output = IVal(tempValue);
		if (varType == "f")  output = Floor(tempValue + 0.5);
		if (varType == "i")  output = tempValue;
		return(output);
	}

	//-----------------------------------------------------------------------------------------------------
	function convertToString(variable tempValue)
	//-----------------------------------------------------------------------------------------------------
	// Converts to string 
	{
	// --- Convert to string --------------------------------
		variable output("");
		variable varType;

		varType = GetType(tempValue);
//Trace("Test: tempValue =>",tempValue,"< has type ==>",varType,"<==");


		if (varType == "f")	output = FVal(tempValue);
		if (varType == "i") 	output = IStr(tempValue);
		if (varType == "s")	output = tempValue;
		return(output);
	}

	//-----------------------------------------------------------------------------------------------------
	static function FormatNumber_PointAsDecimal(variable& numberToFormat, variable countOfDecimals) variable;
	//-----------------------------------------------------------------------------------------------------
	// Return a string number with the desired number of decimals.
	// As decimal delimiter always the point ('.') is used, not language specific!
	// Integer and float values may be passed for formatting. If a other type is passed an empty string is returned.


	namespace StepReturnEx
	{
		// Searches the first block position for which the block data 'num' corresponds to the
		// given number.
		// Returns zero if no corresponding block is found.
		static function lookupBlockPos(
			variable number,							// i: block data 'num' to search
			variable& stepReturn) variable;		// i: star step return (block data string) to parse
	}

	//-----------------------------------------------------------------------------------------------------
	static function InitScriptControl() void
	// Create VB Script control
	{
		if (dtScriptControl.IsNull())
		{
			if ( 0 == dtScriptControl.CreateObject("MSScriptControl.ScriptControl") )
			{
				Trace("CreateObject(\"MSScriptControl.ScriptControl\") failed.");
				abort;
			}
			dtScriptControl.Language = "VBScript"; 		// VBScript documentation see: http://msdn.microsoft.com/en-us/library/t0aew7h6.aspx
		}
	}
		//------------------------------------------------------------------------------
	// Gets the version of the computer's operating system.
	// Returns: The version of the computer's operating system (string).
	// Remarks: The GetOSVersion function formats the version as "major.minor.build.revision". 
	function GetOSVersion() variable
		// Operating system Version number 
		// 6.1 => Windows 7  
		// 6.1 => Windows Server 2003 /2008 
		// 6.1 => Windows Vista 6.0 
		// 5,2 => Windows XP 64-Bit Edition 
		// 5.1 => Windows XP 
		// 5.0 => Windows 2000 
	//------------------------------------------------------------------------------
	{
		object scriptControl;	// Script Control
		variable strVersion("");											
		variable version(0.0);

		scriptControl.CreateObject("MSScriptControl.ScriptControl");
		scriptControl.Language = "VBScript";
		scriptControl.AddCode
		("																																									\n\
			Option Explicit																																			\n\
																																											\n\
			Function GetOSVersion()																																	\n\
				Dim strComputer																																		\n\
				Dim objWMIService																																		\n\
				Dim objOperatingSystem																																\n\
				Dim colOperatingSystems																																\n\
				Dim Wscript																																				\n\
				strComputer = \".\"																																	\n\
				Set objWMIService = GetObject(\"winmgmts:{impersonationLevel=impersonate}!\\\\\" & strComputer & \"\\root\\cimv2\")	\n\
				Set colOperatingSystems = objWMIService.ExecQuery(\"select * from Win32_OperatingSystem\")									\n\
				For Each objOperatingSystem in colOperatingSystems																							\n\
			   	GetOSVersion = objOperatingSystem.Version																									\n\
					Exit For																																				\n\
				Next																																						\n\
			End Function																																				\n\
		");
//		strVersion = StrLeft(scriptControl.Eval("GetOSVersion()"), 3);
		strVersion = scriptControl.Eval("GetOSVersion()");

//		Trace("Test:  GetOSVersion =>",scriptControl.Eval("GetOSVersion()"),"<  strVersion ==>", strVersion,"< FVal ===>",FVal(strVersion));

		return(FVal(strVersion));
	}

	//------------------------------------------------------------------------------
	function GetProcessorArchitecture() variable
	// Gets the processor architecture used by the platform.
	// Return: True if 64 bit ,, else false 
	// The processor architecture used by the platform (integer).
	// 			Value			Meaning 
	//				0 (0x0) 		x86
	//				1 (0x1) 		MIPS
	//				2 (0x2) 		Alpha
	//				3 (0x3) 		PowerPC
	//				6 (0x6) 		Intel Itanium Processor Family (IPF)
	//				9 (0x9) 		x64
	//------------------------------------------------------------------------------
	{
//		object scriptControl;											// Script Control

//		scriptControl.CreateObject("MSScriptControl.ScriptControl");
//		scriptControl.Language = "VBScript";
		InitScriptControl();
				dtScriptControl.AddCode
				("																																									\n\
					Option Explicit																																			\n\
																																													\n\
					Function GetProcessorArchitecture()																													\n\
						Dim strComputer																																		\n\
						Dim objWMIService																																		\n\
						Dim colProcessor																																		\n\
						Dim colProcessors																																		\n\
						Dim Wscript																																				\n\
						strComputer = \".\"																																	\n\
						Set objWMIService = GetObject(\"winmgmts:{impersonationLevel=impersonate}!\\\\\" & strComputer & \"\\root\\cimv2\")	\n\
						Set colProcessors = objWMIService.ExecQuery(\"select * from Win32_Processor\")													\n\
						For Each colProcessor in colProcessors																											\n\
					   	GetProcessorArchitecture = colProcessor.Architecture																					\n\
							Exit For																																				\n\
						Next																																						\n\
					End Function																																				\n\
				");
		if ( dtScriptControl.Eval("GetProcessorArchitecture()") == 9) 	return(hslTrue);
		else																				return(hslFalse);
	} // ---- end of function "GetProcessorArchitecture"

	static function Date() variable					// Returns the current system date (float).
	{
		InitScriptControl();
		return(dtScriptControl.Eval("Date()"));
	}

	function DateSerial(						// Returns a variable of subtype Date (float) for a specified year, month, and day.
		variable year,							// i: Number between 100 and 9999, inclusive, or a numeric expression.
		variable month, 						// i: Any numeric expression.
		variable day) variable					// i: Any numeric expression.
	{
		InitScriptControl();
		return(dtScriptControl.Eval("DateSerial(" + IStr(year) + "," + IStr(month) + "," + IStr(day) + ")"));
	}

	static function FormatISO_Date(variable date) variable //// Returns the ISO formated date of system date (float).
	{
		variable year, month, day;
		variable formatedDate;
		
		InitScriptControl();

		year  = dtScriptControl.Eval("Year(" + FStr(date) + ")");
		month = dtScriptControl.Eval("Month(" +FStr(date) + ")");
		day   = dtScriptControl.Eval("Day(" + FStr(date) + ")");

		formatedDate = IStr(year) + "-" + StrFillLeft(IStr(month), "0", 2) + "-" + StrFillLeft(IStr(day), "0", 2);

		return( formatedDate );
	}
	// --------------------------------------------------------------------------------------
	static function IsLeapYear(variable year) variable
	{
		if (0 == year % 4)
		{
			if (0 == year % 100)
			{ 
				if (0 == year % 400) 
					return (hslTrue);
				else
					return (hslFalse);
			}
			else
			{
				return (hslTrue);
			}
		}
		return (hslFalse);
	}
	// --------------------------------------------------------------------------------------
	static function CheckDate(variable year, variable month, variable day) variable
	{
		if ((month < 1) || (month > 12))
			return (hslFalse);
		if ((day < 1) || (day > 31))
			return (hslFalse);
		if (((month / 8) == (month % 2)) && (day > 30))
			return (hslFalse);
		if (month == 2)
		{
			if(hslTrue == IsLeapYear(year))
			{
				if (day > 29)
					return (hslFalse);
			}
			else
			{
				if (day > 28)
					return (hslFalse);
			}
		}
		return (hslTrue);
	}

	// --------------------------------------------------------------------------------------
	static function CheckTime(variable hour, variable minute, variable second) variable
	{
		if ((hour < 0) || (hour > 24))
			return (hslFalse);
		if ((hour == 24) && (minute != 0) && (second != 0))
			return (hslFalse);
		if ((minute < 0) || (minute > 59))
			return (hslFalse);
		if ((second < 0) || (second > 59))
			return (hslFalse);
		return (hslTrue);
	}
	
	// --------------------------------------------------------------------------------------
	static function SplitFromISODate(variable& dateAsStr, variable& year, variable& month, variable& day) void
	{
		string tmp;
		tmp = dateAsStr;
		year = IVal(tmp.Mid(0,4));
		if (tmp.Mid(5,1) == "0")
			month = IVal(tmp.Mid(6,1));
		else
			month = IVal(tmp.Mid(5,2));
		if (tmp.Mid(8,1) == "0")
			day = IVal(tmp.Mid(9,1));
		else
			day = IVal(tmp.Mid(8,2));
		if (hslFalse == CheckDate(year, month, day))
			err.Raise(1,LdT("Illegal input date!"));
	}

	// --------------------------------------------------------------------------------------
	static function SplitFromISOTime(variable& timeAsStr, variable& hour, variable& minute, variable& second) void
	{
		string tmp;
		tmp = timeAsStr;
		if (tmp.Mid(0,1) == "0")
			hour = IVal(tmp.Mid(1,1));
		else
			hour = IVal(tmp.Mid(0,2));
		if (tmp.Mid(3,1) == "0")
			minute = IVal(tmp.Mid(4,1));
		else
			minute = IVal(tmp.Mid(3,2));
		if (tmp.Mid(6,1) == "0")
			second = IVal(tmp.Mid(7,1));
		else
			second = IVal(tmp.Mid(6,2));
		if (hslFalse == CheckTime(hour, minute, second))
			err.Raise(1, LdT("Illegal input time!" ));
	}

	// --------------------------------------------------------------------------------------
	static function CheckISODate(variable dateAsStr) variable // check format YYYY-MM-DD
	{
		variable year, month, day;
		string tmp;
		tmp = dateAsStr;

		if (StrGetLength(dateAsStr) != 10) 	return(hslFalse);
		if (StrFind(dateAsStr,"-") == StrReverseFind(dateAsStr,"-")) return(hslFalse);

		year = IVal(tmp.Mid(0,4));
		if (tmp.Mid(5,1) == "0")
			month = IVal(tmp.Mid(6,1));
		else
			month = IVal(tmp.Mid(5,2));
		if (tmp.Mid(8,1) == "0")
			day = IVal(tmp.Mid(9,1));
		else
			day = IVal(tmp.Mid(8,2));

		return(CheckDate(year, month, day));
	}
	// --------------------------------------------------------------------------------------
	static function DayInYear(variable year, variable month, variable day) variable
	{
		variable days(0);
		variable m(0);

		if (hslFalse == CheckDate(year, month, day))
			err.Raise(1, LdT("Illegal input date!"));

		days = day;
		for ( m=1; m < month ; m++)
		{
			if (m == 2)
			{
				days = days + 28;
				if(hslTrue == IsLeapYear(year))
					days = days + 1;
			}
			else
			{
				days = days + 30;
				if (!((m / 8) == (m % 2)))
					days = days + 1;
			}
		}
		return(days);
	}

	// --------------------------------------------------------------------------------------
	static function DaysOfISODate(variable ISOdate) variable // returns days of ISO date (format YYYY-MM-DD)
	{
		variable days(0);
		variable year, month, day;
		variable m(0);
		variable tempText;

		if (hslFalse == CheckISODate(ISOdate))
		{
			tempText = LdT("Illegal input date of ISO date '%s1'!");
			StrReplace(tempText,"%s1",ISOdate);
			err.Raise(1,tempText);
		}
		InitScriptControl();
		SplitFromISODate(ISOdate, year, month, day);
		days = dtScriptControl.Eval("DateSerial(" + IStr(year) + "," + IStr(month) + "," + IStr(day) + ")");

// Trace("Test: ISO Date '",ISOdate, "' has =>", days, "days");

		return(days);
	}

	// --------------------------------------------------------------------------------------
	static function DeltaDateInDays(variable year1, variable month1, variable day1, variable year2, variable month2, variable day2) variable
	{
		variable dayNum1(0);
		variable dayNum2(0);
		variable startYear(0);
		variable endYear(0);
		variable tempYear(0);
		variable firstIsOlder(hslTrue);
		variable delta(0);

		if ((year1*10000+month1*100+day1) < (year2*10000+month2*100+day2))
		{
			firstIsOlder = hslTrue;
			startYear = year1;
			endYear = year2;
			dayNum1 = DayInYear(year1, month1, day1);
			dayNum2 = DayInYear(year2, month2, day2);
		}
		else
		{
			firstIsOlder = hslFalse;
			startYear = year2;
			endYear = year1;
			dayNum1 = DayInYear(year2, month2, day2);
			dayNum2 = DayInYear(year1, month1, day1);
		}

		delta = -1 * dayNum1;	
		for(tempYear=startYear;tempYear<endYear;tempYear++)
		{
			if (hslTrue == IsLeapYear(tempYear))
				delta = delta + 366;
			else
				delta = delta + 365;
		}
		delta = delta + dayNum2;
		if (!firstIsOlder) delta = -1 * delta;

		return(delta);
	}

	//--------------------------------------------------------------------------------------------------
	static private function ComposeCompletePrm(
										variable prmName, 					// e.g. for "hd###" = "hd"
										variable noOfDigits,					// e.g. for "hd###" = 3
										variable value)						// e.g. 12
																			// e.g. ==> "hd012"
	//------------------------------------------------------------------------------
	{
		string completePrm;

		completePrm=IStr(Ceiling(value));
		while(completePrm.GetLength() < noOfDigits) completePrm = "0" + completePrm;
		completePrm = prmName + completePrm;
		#ifdef _DEBUG
			Trace("Test: complete parameter ==>",completePrm,"<==");
		#endif
		return(completePrm);
	} // --- end of function "ComposeCompletePrm" ----


	function convertXYcoordToTrackSite(variable XY_coordinates)
	//-----------------------------------------------------------------------------------------------------
	// Converts a string with X- / Y- cooddinate (" xxxx / yyyy") to track/site posiition ("track TT / site SS ") string
	{
		variable trackSiteInfo(""), xPos,yPos, trackNo , siteNo;

		xPos 		= FVal(StrLeft(XY_coordinates,StrFind(XY_coordinates," / ") ) );
		yPos 		= FVal(StrMid(XY_coordinates,StrFind(XY_coordinates," / " ) + 3 ,100) );
		trackNo 	= Floor((xPos - 77.5) / 22.5); //examples: range xPos = 100.. 122.5  => track 1 ; range xPos = 1225.. 1247.5 => track 50 
		siteNo 	= Ceiling((503.5 - yPos) / 96.0);//examples: range yPos = 407.5 ..503.5 => side 1 ; range yPos = 23.5 ..119.5.5 => side 5
//Trace("Test: convertXYcoordToTrackSite: XY_coordinates =>", XY_coordinates,"<  xPos =>",xPos,"< trackNo ==>",trackNo,"<==");
//Trace("Test:  ------------------------: XY_coordinates =>", XY_coordinates,"<  yPos =>",yPos,"< siteNo  ==>",siteNo ,"<==");

		trackSiteInfo = LdT("track '%s1' / site '%s2'");
		StrReplace(trackSiteInfo, "%s1",IStr(trackNo));
		StrReplace(trackSiteInfo, "%s2",IStr(siteNo));
		return(trackSiteInfo);
	}

	//=====================================================================================================
	// Reader 384 general functions (copied from "HSL_BioMedInstruments.hs_")
	//=====================================================================================================
   static function ResultCodeToString( variable resultCode) variable
	//--------------------------------------------------------------------------------------------------
   {
      if (resultCode == Reader::Device.ResultCodes_Succeeded) {
         return ("ResultCodes_Succeeded");
      }
      else if (resultCode == Reader::Device.ResultCodes_NotConfigured) {
         return ("ResultCodes_NotConfigured");
      }
      else if (resultCode == Reader::Device.ResultCodes_Disconnected) {
         return ("ResultCodes_Disconnected");
      }
      else if (resultCode == Reader::Device.ResultCodes_Busy) {
         return ("ResultCodes_Busy");
      }
      else if (resultCode == Reader::Device.ResultCodes_Timeout) {
         return ("ResultCodes_Timeout");
      }
      else if (resultCode == Reader::Device.ResultCodes_Aborted) {
         return ("ResultCodes_Aborted");
      }
      else if (resultCode == Reader::Device.ResultCodes_Failed) {
         return ("ResultCodes_Failed");
      }
      else if (resultCode == Reader::Device.ResultCodes_NotBusy) {
         return ("ResultCodes_NotBusy");
      }
      else if (resultCode == Reader::Device.ResultCodes_InvalidArgument) {
         return ("ResultCodes_InvalidArgument");
      }
      else {
         return ("**unknown code**");
      }
   }

	static function TxRxCommand( variable instrID, variable command, variable parameter, variable &response, variable timeout ) variable
	//------------------------------------------------------------------------------------	//--------------------------------------------------------------------------------------------------
	{
		string txBuffer(""), rxBuffer("");
		variable traceText(""),textBlock(900),i(0);
	   variable resultCode;

		// Activate error handler
		onerror goto Unexpected;

		txBuffer = StrConcat4( instrID, command, parameter, "" );
	   FormatTrace( GetFunctionName(), "()", VerDef::CMD_PROGRESS, " TxB = <", txBuffer, ">, timeout = ", timeout );

		if(VerDef::SimulationModeReader)
      {
         rxBuffer = StrConcat4( instrID, command, response, "" );
         resultCode = 0;
      }
      else
      {
		   rxBuffer = Reader::Device.SendReceive( txBuffer, Floor( timeout ), resultCode );
      }
      // check the result code
      if( resultCode == 0 )
      {
         // no error occurred
			traceText = rxBuffer;
			if(StrGetLength(traceText) > textBlock) traceText = StrLeft(traceText,textBlock) + " ...";
   	   FormatTrace( GetFunctionName(), "()", VerDef::CMD_PROGRESS, " RxB = <", traceText, ">" );

   		if( "id" == StrMid( rxBuffer, 4, 2 ))
   			response = StrMid( rxBuffer, 10, StrGetLength( rxBuffer ) - 10 );
   		else
   			response = StrMid( rxBuffer, 4, StrGetLength( rxBuffer ) - 4 );
      }
      else
      {
         // in case of error, the result string is empty
         response = "";
      }

		// trace response (but max 900 character per line)
		traceText = response;
		for(i = 1;StrGetLength(traceText) > textBlock;i++)
		{
			FormatTrace( GetFunctionName(), "()", VerDef::CMD_PROGRESS, " response part ",i," ==>", StrLeft(traceText,textBlock), "<==" );
			traceText = StrRight(traceText, StrGetLength(traceText) - textBlock);
		}
		FormatTrace( GetFunctionName(), "()", VerDef::CMD_COMPLET, " response ==>", traceText, "<==" );

      if (resultCode != 0)
      {
         // trace driver error code 
			FormatTrace(GetFunctionName(),"()",VerDef::CMD_ERRCOMPL," ",command,parameter," command failed: error code= ", ResultCodeToString(resultCode));
         return (resultCode+100);
      }
		if("er00"!=StrMid(response,0,4))
		{	// trace device error code 
			FormatTrace(GetFunctionName(),"()",VerDef::CMD_ERRCOMPL," ",command,parameter," command failed: error code= ",StrMid(response,0,4));
			return(IVal(StrMid(response,2,2)));
		}

		return (0);

		Unexpected:
		{
		   FormatTrace( GetFunctionName(), "()", VerDef::CMD_ERROR, " Error: id=", err.GetId(), " desc=", err.GetDescription());
   		resume next;
		}
	}

	static function getLabwarePropertyData( device ML_STAR, variable labwareID, variable propertyID, 
															variable format, variable& userMessages[]) variable
	//--------------------------------------------------------------------------------------------------
	{
      variable result, propertyValue, propertyValueMinor;


//		FormatTrace( GetFunctionName(), "()", VerDef::CMD_START, "labwareID =>", labwareID,"< propertyName =>",propertyID,"<==");

		propertyValue = DevGetLabwareData(ML_STAR, labwareID, propertyID);
		propertyValueMinor = propertyValue;
		StrMakeLower(propertyValueMinor);
		if(StrFind(propertyValueMinor,"(tbd)") >= 0)
		{	
			userMessages.AddAsLast( labwareID + ": property = '" + propertyID + "' with data = '" + propertyValue + "'" );
			propertyValue = StrLeft(propertyValue,StrFind(propertyValueMinor,"(tbd)") +1);
		}
		if(StrMakeLower(format) == "i")
		{	// expected value: integer
			result = IVal(propertyValue);
		}
		else if(StrMakeLower(format) == "f")
		{	// expected value: float
			result = FVal(propertyValue);
		}
		else result = propertyValue;

//Trace("Test: ", GetFunctionName(), ": "," labwareID =>", labwareID,"< propertyName =>",propertyID,"<  propertyValue =>", result, "<==" );
		return( result);
	} 

	//------------------------------------------------------------------------------
	static function SearchFileInFolder(variable& fileName, variable sourceFolderName, variable folderNameIndex, variable& subFolderNames[]
																) variable
	//------------------------------------------------------------------------------
	{
		variable i, index;
		variable subFolderName;

		object sourceFolder; 
		object enumerator;
		object files;
		object fileItem;
		object folders;
		object folderItem;
		object fso;  // file system object

		if (fso.IsNull()) fso.CreateObject("Scripting.FileSystemObject");

		onerror resume next;

		// serach for file in folder
		sourceFolder = fso.GetFolder(sourceFolderName);

		files = sourceFolder.Files();
		// get enumerator from files collection
		enumerator = files._NewEnum;

		// iterate through files collection
		i = 0;
		while (enumerator.EnumNext(fileItem))
		{
			i++;
//			Trace("At loop =>",i,"<  Name ==>", fileItem.Name(),"<   File path & name ==>",fileItem.Path(),"<==");
			if(fileName == fileItem.Name()) 
				{
//					Trace(" ");
//					Trace("File =>",fileName,"<  found in File path & name ==>",fileItem.Path(),"<==");
					fileName = fileItem.Path();
					return(hslTrue);
				}
		}
		enumerator.ReleaseObject();
		files.ReleaseObject();

		// get subfolder collection from source folder
		folders = sourceFolder.SubFolders; 
		// get enumerator from subfolder collection
		enumerator = folders._NewEnum;
		index = folderNameIndex + 1;
		while (enumerator.EnumNext(folderItem))
		{
//			Trace(" ");
//			Trace("----  At index  =>",index,"   subfolder path ==>",folderItem.Path(),"<==");
							
			subFolderName = folderItem.Path();
			if (index < subFolderNames.GetSize()) subFolderNames.InsertElementAt( index, subFolderName);
				else 										  subFolderNames.AddAsLast(subFolderName);	

			index++;
			folderItem.ReleaseObject();
		}
		enumerator.ReleaseObject();

		return(hslFalse);
	}  // -- end of function "SearchFileInFolder"

	//------------------------------------------------------------------------------
	static function searchFilePathName(variable fileName, variable folderName) variable
	//------------------------------------------------------------------------------
	{
		variable i(0);
		variable pathFileName("");

		variable subFolderNames[];

		if(StrFind(folderName,"\\") > 2) folderName = StrLeft(folderName, StrReverseFind(folderName,"\\"));
		else 										folderName = StrLeft(folderName, StrReverseFind(folderName,"\\") + 1);

		FormatTrace(GetFunctionName( ),"File searching",VerDef::CMD_START, " Form base folder =>",folderName,"< on searching for file =>",fileName,"<    Please wait.....");

		subFolderNames.SetSize(0);
		subFolderNames.AddAsLast(folderName);	
		pathFileName = fileName;	
		i = 0;
		while (i < subFolderNames.GetSize( ))
		{
			if(SearchFileInFolder(pathFileName, subFolderNames.GetAt( i ) ,i , subFolderNames)) break;
			i++;
		}

		if(fileName == pathFileName) pathFileName = ""; // not found in folder or subfolders
//		Trace(" ");
//		Trace(" ");
//		Trace("Test: searchFilePathName: File =>",fileName,"<  found in  File path & name ==>",pathFileName,"<===");
		
		return(pathFileName);

	}  // -- end of function "searchFilePathName"

//=====================================================================================================
// implementation interface functions
//=====================================================================================================

	//-----------------------------------------------------------------------------------------------------
	function InitializeDataVariables() 
	//-----------------------------------------------------------------------------------------------------
	// Initialize variable for processing, measurement- and evaluation data 
	// 
	// RETURN		none
	//-----------------------------------------------------------------------------------------------------
	{
		sequence emptySequence; // sequence with no seuence positions
		// translate text
		VerDef::valid 			= LdT("valid"); 		// valid state
		VerDef::invalid 		= LdT("invalid"); 	// invalid state
		VerDef::confirmed 	= LdT("confirmed"); 	// acceptance state confirmed by user
		VerDef::excluded 		= LdT("excluded"); 	// excluded state (by user)
		VerDef::passed 		= LdT("passed"); 		// passed state
		VerDef::failed 		= LdT("failed"); 		// failed state
//		VerDef::notInstalled = LdT("not installed"); // not installed state
		// reset values
		RPD::measured_Weight_1 = 0.0;				// measurement weight value for nominal volume 1
		RPD::measured_Weight_2 = 0.0;				// measurement weight value for nominal volume 2
		RPD::measured_Weight_3 = 0.0;				// measurement weight value for nominal volume 3
		RPD::measured_Volume_1 = 0.0;				// measurement volume value for nominal volume 1
		RPD::measured_Volume_2 = 0.0;				// measurement volume value for nominal volume 2
		RPD::measured_Volume_3 = 0.0;				// measurement volume value for nominal volume 3
		RPD::arr_ODData_Volume_1.SetSize( 0 );	// array of OD measurement values for nominal volume 1
		RPD::arr_ODData_Volume_2.SetSize( 0 );	// array of OD measurement values for nominal volume 2
		RPD::arr_ODData_Volume_3.SetSize( 0 );	// array of OD measurement values for nominal volume 3
		RPD::arr_Volume_Volume_1.SetSize( 0 );	// array of volume values for nominal volume 1 
		RPD::arr_Volume_Volume_2.SetSize( 0 );	// array of volume values for nominal volume 2 
		RPD::arr_Volume_Volume_3.SetSize( 0 );	// array of volume values for nominal volume 3 
		PS::dataArray.SetSize( 0 );

		// reset general sequence definitions
		PS::seq_BufferSolution.CopySequence( emptySequence);
		PS::seq_DarkSolution.CopySequence( emptySequence);
		PS::seq_LightSolution.CopySequence( emptySequence);
		
		PS::seq_TeachingNeedles.CopySequence( emptySequence);
		PS::seq_baseCheckPositions.CopySequence( emptySequence);

		PS::seq_Tips.CopySequence( emptySequence);
		PS::seq_HighVolTips.CopySequence( emptySequence);
		PS::seq_50ulTips.CopySequence( emptySequence);
		PS::seq_LowVolTips.CopySequence( emptySequence);

		PS::seq_lowVolume_Plate.CopySequence( emptySequence);
		PS::seq_mediumVolume_Plate.CopySequence( emptySequence);
		PS::seq_highVolume_Plates.CopySequence( emptySequence);
		PS::seq_BalancePlate.CopySequence( emptySequence);
	} // -- end of function "InitializeDataVariables"

	//------------------------------------------------------------------------------
	function VerificationUserMessagesDialog(variable dialogTitle,  variable userMessages[], variable foodnote) 
	//------------------------------------------------------------------------------
	{
		variable userMessage("");
		variable userResponse;
		variable index;
		dialog userDialog;

//VerTool::TraceArray(" --- VerificationUserMessagesDialog: array userMessages -----", userMessages);

		if(userMessages.GetSize() == 0) return; // no user messages to display
			
		userMessage = userMessage +  "\n " + dialogTitle;
		userMessage = userMessage +  "\n " + " --------------------------------------------------" ;
		userMessage = userMessage +  "\n ";

		for (index = 0; index < userMessages.GetSize(); index++)
		{
			userMessage = userMessage +  "\n\n " +  userMessages.GetAt(index) + "          ";
		}
		userMessage = userMessage +  "\n\n " + foodnote;
		userMessage = userMessage +  "\n\n " + LdT("Press 'Cancel' to stop the Verification.");
		userDialog.SetOutput(userMessage);
		userResponse= userDialog.ShowOutput( LdT("User Message:"), hslOKCancel | hslInformation, hslInfinite );
		if (userResponse == hslCancel) abort;

	}  // -- end of function "VerificationUserMessagesDialog"

 	// --------------------------------------------------------------------------------------
	// Validate if date is later than actual date  (date must be in ISO-format YYYY-MM-DD)
	function ValidateDate(variable date, variable timeOffset, variable& expiryDate, 
									variable& validState, variable& validRemarks) variable // remaining days
	{
		variable remainingDays;
//		variable yearsOffset(0),monthsOffset(0);
		variable year(2000), thisYear(2000), month(1), thisMonth(1), day(1), toDay(1);

//Trace("Test:  date =>", date,"<=  later than ==>", GetDate("%Y-%m-%d"), "<   time offset==>", timeOffset ,"<  ??");

		expiryDate		= "2000-01-01";
		validRemarks	= LdT("Date expired!");
		validState		= 0;
	
		if(!CheckISODate(date)) 
		{	
			validRemarks	= LdT("Invalid date format!");
			validState		= 0;
			Trace("WARNING: Invalid ISO date format of =>", date,"<==");
			return(-9999);
		}

		// time offset is defined in days
		remainingDays 	= DaysOfISODate(date) + timeOffset;
		expiryDate 		= FormatISO_Date(remainingDays);
		remainingDays 	= Floor(remainingDays - DaysOfISODate(GetDate("%Y-%m-%d")));

//	Trace("Test:  transformed date =>", year,"_",month,"_",day,"<=  later than ==>", thisYear,"_",thisMonth,"_",toDay,  
//			"=>  remaining days =>", remainingDays,"<==");
//	Trace("Test:  Remaining time until =>", expiryDate,"<  are ==>", remainingDays," days.");

		if (remainingDays < 0)
		{  
			validRemarks	= LdT("Date expired!");
			validState		= 0;
		}
		else 
		{
			validRemarks	= StrConcat4(LdT("Remaining Days =")," "," ", remainingDays);
			validState		= 1;
		}
		return(remainingDays);

	} // -- end of function "ValidateDate"

	//-----------------------------------------------------------------------------------------------------
	function CreateFolder(variable folderName)		// i: folder name (string), e.g. "C:\\Verification"
	//-----------------------------------------------------------------------------------------------------
	{
		object fso;  // file system object
		
		if (fso.IsNull()) fso.CreateObject("Scripting.FileSystemObject");

		if (StrRight(folderName,1) == "\\") folderName = StrLeft(folderName,StrGetLength(folderName)-1);

		onerror resume next;
//Trace("Test CreateFolder =>",folderName,"<==");	
 		if (!fso.FolderExists(folderName)) fso.CreateFolder(folderName);
	}

	//-----------------------------------------------------------------------------------------------------
	function DeleteFile(variable fileName)		// i: file name (string), e.g. "C:\\Verification\\demo.xls"
	//-----------------------------------------------------------------------------------------------------
	{
		object fso;  // file system object

		if (fso.IsNull()) fso.CreateObject("Scripting.FileSystemObject");

		onerror resume next;

 		if (fso.FileExists(fileName)) fso.DeleteFile(fileName , 1);
	}

	//-----------------------------------------------------------------------------------------------------
	function CopyFile(
		variable& sourceFileName,		// i: source file name (string), e.g. "C:\\Verification\\demo.xls"
		variable& targetFileName,  	// i: target file name (string), e.g. "C:\\Verification\\demo_1.xls"
		variable& changeFiles, 	// i: > 1: hide target file / > 0: delete source file 
		variable& deleteOldTargetFile)// i: delete old target file (else do not copy)
	//-----------------------------------------------------------------------------------------------------
	{
		object 	fso;  // file system object
		object 	changingFile;
		variable fileAttribute_ReadOnly(1); 		// Read-only file. Attribute is read/write. 
		variable fileAttribute_Hidden(2);			// Hidden file. Attribute is read/write. 
		variable targetPathName("");
		variable description;
		if (fso.IsNull()) fso.CreateObject("Scripting.FileSystemObject");

		onerror resume next;


	 	if (fso.FileExists(targetFileName) && (deleteOldTargetFile == 0)) return;

 		if (!fso.FileExists(sourceFileName)) 
		{
			description = LdT("Run information: File '%s1' does not exist. Run will be aborted!");
			StrReplace(description, "%s1", sourceFileName);
			FormatTrace(GetFunctionName(),"()", VerDef::CMD_COMPLET," ", description);	
			abort;
		}

		DeleteFile(targetFileName); 		// if file does exist
		targetPathName = StrLeft(targetFileName,StrReverseFind(targetFileName,"\\"));
		CreateFolder (targetPathName); 	// if folder does not exist

		fso.CopyFile(sourceFileName, targetFileName);
		description = LdT("Run information: File '%s1' copied to '%s2'.");
		StrReplace(description, "%s1", sourceFileName);
		StrReplace(description, "%s2", targetFileName);
		FormatTrace(GetFunctionName(),"()", VerDef::CMD_COMPLET ," ",description);	
		if (changeFiles > 1) // hide target file
		{
				changingFile = fso.GetFile(targetFileName);	
				changingFile.Attributes = changingFile.Attributes | fileAttribute_Hidden;
				changingFile.Attributes = changingFile.Attributes | fileAttribute_ReadOnly;
//				Trace("Test: Run information: File '", targetFileName, "' set to 'hidden' & 'read only'.");	
		}
		if (changeFiles > 0) DeleteFile(sourceFileName); // delete source file
	}//-- end of function "CopyFile"

	


	//-----------------------------------------------------------------------------------------------------
	function getTipType(variable tipType,  variable& tipTypeRemark)variable
	//-----------------------------------------------------------------------------------------------------

	//namespace TipType
	{	
		// Variable for tip (rack) type
		tipTypeRemark = "";
		if (GetType(tipType) != "i") return(hslFalse);
		 // _300ulStandardVolumeTip(0)	
		if (tipType == 0)	{	tipTypeRemark		 = LdT("300ul Standard Volume Tip");}
		// _300ulStandardVolumeTipwFilter(1)
		if (tipType == 1) {	tipTypeRemark		 = LdT("300ul Standard Volume Tip with Filter");}
		// _10ulLowVolumeTip(2);
		if (tipType == 2) 	{	tipTypeRemark	 = LdT("10ul Low Volume Tip");}
		//_10ulLowVolumeTipwFilter(3);
		if (tipType == 3) 	{	tipTypeRemark	 = LdT("10ul Low Volume Tip with Filter");}
		// _1000ulHighVolumeTip(4);
		if (tipType == 4) 	{	tipTypeRemark	 = LdT("1000ul High Volume Tip");}
		// _1000ulHighVolumeTipwFilter(5);
		if (tipType == 5) 	{	tipTypeRemark	 = LdT("1000ul High Volume Tip with Filter");}
		// _50ul_384ClearTip(20);
		if (tipType == 20) 	{	tipTypeRemark	 = LdT("384 Head 50ul Clear Tip");}
		// _50ulTip(22);
		if (tipType == 22) 	{	tipTypeRemark	 = LdT("50ul Tip");}
		 // _50ulTipwFilter(23);
		if (tipType == 23)	{ tipTypeRemark	 = LdT("50ul Tip with Filter");}
		// _5mlTip(25);
		if (tipType == 25) 	{ tipTypeRemark	 = LdT("5ml Tip");}
		// _4mlTipwFilter(29);
		if (tipType == 29) 	{ tipTypeRemark	 = LdT("4ml Tip with Filter");}
		// _50ul_384Tip(33);
		if (tipType == 33) 	{ tipTypeRemark	 = LdT("384 Head 50ul Tip");}

		if(tipTypeRemark == "") return(hslFalse);
		return(hslTrue);
	}

	// --------------------------------------------------------------------------------------
   function ExistLiquidClass( variable liquidClassName) variable
   {
      variable result( hslFalse);
      variable val;
      variable instClassCfgFil;
		variable iReadOnly;

	   object parsLiquidClassNames;
	   object MLSTAR_LIQUIDCLASSLib_HxStarLiquidClass;
      object HxRegistry;

      parsLiquidClassNames.CreateObject("HXPARAMSLib.HxPars");

      if (MLSTAR_LIQUIDCLASSLib_HxStarLiquidClass.IsNull( ) == hslTrue)
      {
         HxRegistry.CreateObject("HXREGLib.HxRegistry");
         MLSTAR_LIQUIDCLASSLib_HxStarLiquidClass.CreateObject("Hamilton.HxStarLiquidClass");

         instClassCfgFil = HxRegistry.InstClassCfgFile("ML_STAR");
         #ifdef _DEBUG_UserConfig
            FormatTrace("DEBUG", GetFunctionName(), VerDef::CMD_PROGRESS,
                        "ML_STAR", " instrument class config file name: ", instClassCfgFil);
         #endif

         MLSTAR_LIQUIDCLASSLib_HxStarLiquidClass.InitStarLiquidClass( instClassCfgFil, iReadOnly);
      }

      if (MLSTAR_LIQUIDCLASSLib_HxStarLiquidClass.IsNull()) 
         err.Raise( -1, "MLSTARLiquidClassLib: Library is not initialized!\n\n> Use function MLSTAR_LIQUIDCLASSLib::Initialize().\n");

      MLSTAR_LIQUIDCLASSLib_HxStarLiquidClass.GetLiquidClassNames( parsLiquidClassNames);
      result = parsLiquidClassNames.LookupItem1( liquidClassName, val);
//Trace("Test: Existence of Liquid Class >",liquidClassName,"<  is =>",result,"<==");
      return (result);
   }

	// --------------------------------------------------------------------------------------
	function statisticCalculation(
								variable dataArray[],				// array of (n x 96 or nx384) measurment data (A1 ..H1..H12..P24)
								variable	rowSize,						// data row size: 1 .. 8 .. 16 ( = channel A ..  H .. P)
								variable columnSize,					// data column size: 1 .. 12 .. 24
								variable firstRow,					// first row number 1 .. 8 .. 16 ( = channel A ..  H .. P)
								variable lastRow,						// last row number (>= firstRow, 1 .. 8 .. 16 ( = channel A ..  H .. P)	
								variable firstColumn,				// first column number (1 .. 12 ..24)
								variable lastColumn,					// last column number (>= firstColumn, 1 .. 12 ..24) 
								variable measurementLoops,			// amount of measurement loops (of same well)
								variable& arrMeanValue[],			// array of average value (index 0: average of all wells)
								variable& arrMinValue[],			// array of minimal value (index 0: min of all wells)
								variable& arrMaxValue[],			// array of maximal value (index 0: max of all wells)
								variable& arrStandardDeviation[])// array of standard deviation (index 0: std of all wells)
																	 variable // true, if calculation could perform
	//-----------------------------------------------------------------------------------------------------
	{	
		variable i, dataIndex, rowIndex, loopNo;
		variable plateOffset, usedColumns;//columnSize, rowSize, 
		variable actualValue(0.0), amountOfValues(0.0), actualDeviation(0.0), squareDifference(0.0);

//Trace("Test:statisticCalculation for plate type ==>", plateType, "<  firstColumn=>", firstColumn ,"<   lastColumn =>", lastColumn," <==");

		arrMeanValue.SetSize( 0 );
		arrMaxValue.SetSize( 0 );
		arrMinValue.SetSize( 0 );
		arrStandardDeviation.SetSize( 0 );

		//-- specify plate type specific variables
		plateOffset = columnSize * rowSize;
		if (measurementLoops < 1) measurementLoops = 1;
		if ((measurementLoops * columnSize * rowSize) > dataArray.GetSize()) return(hslFalse);

		loop(rowSize +1)			
		{	// -- set default values
			arrMeanValue.AddAsLast( 0.0 );
			arrMinValue.AddAsLast( 99999.9 );
			arrMaxValue.AddAsLast( -99999.9 );
			arrStandardDeviation.AddAsLast( 0.0 );
		}

		//-- calculate summary of all values
		usedColumns = lastColumn - firstColumn + 1;
		if (usedColumns < 1) usedColumns = 1;
		for(loopNo = 0; loopNo < measurementLoops; loopNo++)
		{  // calculate over measurement repetition 
			dataIndex = (loopNo * plateOffset) + (firstColumn * rowSize) - rowSize;
//Trace("Test:statisticCalculation: calculate summary at loopNo==>", loopNo, "<  first data Index=>", dataIndex ," <==");
			loop(usedColumns)
			{
				for(rowIndex = 1; rowIndex <= rowSize; rowIndex++)
				{	 
					if ((rowIndex >= firstRow) && (rowIndex <= lastRow))
					{ // values of corresponding rows are calculated
						actualValue = dataArray.GetAt(dataIndex);
						// summary/min/max of all values
						arrMeanValue.SetAt(0 , arrMeanValue.GetAt(0) + actualValue);
						if( actualValue < arrMinValue.GetAt(0)) arrMinValue.SetAt(0, actualValue);
						if( actualValue > arrMaxValue.GetAt(0)) arrMaxValue.SetAt(0, actualValue);
						// summary/min/max of row specific values
						arrMeanValue.SetAt(rowIndex, arrMeanValue.GetAt(rowIndex) + actualValue);
						if( actualValue < arrMinValue.GetAt(rowIndex)) arrMinValue.SetAt(rowIndex, actualValue);
						if( actualValue > arrMaxValue.GetAt(rowIndex)) arrMaxValue.SetAt(rowIndex, actualValue);
//Trace("Test ==> raw data at ",dataIndex," => actualValue =>", actualValue,"<  row =",rowIndex," --> sum meanValue =>", arrMeanValue.GetAt(rowIndex)," <==");
					}
					dataIndex++;
				} 
			}
		}
		//-- calculate mean values
		amountOfValues = 1.0 * measurementLoops * usedColumns;
		for(rowIndex = 1; rowIndex <= rowSize; rowIndex++) 
		{
			arrMeanValue.SetAt(rowIndex, arrMeanValue.GetAt(rowIndex) / amountOfValues);
		}
		arrMeanValue.SetAt(0, arrMeanValue.GetAt(0) / (1.0* amountOfValues * (lastRow-firstRow+1)));

		// -- Definition: standard deviation = SquareRoot( Sum(Square(wellValue- meanValue))/(1-n) )
		for(loopNo = 0; loopNo < measurementLoops; loopNo++)
		{  // calculate over measurement repetition 
			dataIndex = (loopNo * plateOffset) + (firstColumn * rowSize) - rowSize;
//Trace("Test:statisticCalculation: calculate standard deviation at loopNo==>", loopNo, "<  first dataIndex=>", dataIndex ," <==");
			loop(usedColumns)
			{
				for(rowIndex = 1; rowIndex <= rowSize; rowIndex++)
				{	 
					if ((rowIndex >= firstRow) && (rowIndex <= lastRow))
					{ // values of corresponding rows are calculated
						// square summary deviation of all values
						actualDeviation = dataArray.GetAt(dataIndex) - arrMeanValue.GetAt(0);
						arrStandardDeviation.SetAt(0 , arrStandardDeviation.GetAt(0) + actualDeviation^2);
						// square summary deviation of row specific values
						actualDeviation = dataArray.GetAt(dataIndex) - arrMeanValue.GetAt(rowIndex);
						arrStandardDeviation.SetAt(rowIndex , arrStandardDeviation.GetAt(rowIndex) + actualDeviation^2);
//Trace("Test:statisticCalculation: sum standard deviation at dataIndex ==>", dataIndex, "<  ==>", arrStandardDeviation.GetAt(rowIndex) ," <==");
					}
					dataIndex++;
				}
			}
		}

		//-- calculate standard deviation
		for(rowIndex = firstRow; rowIndex <= lastRow; rowIndex++) 
		{
			if ((arrMeanValue.GetAt(rowIndex) != 0) && (amountOfValues > 1))
			{
				squareDifference = (arrStandardDeviation.GetAt(rowIndex) / (amountOfValues -1))^0.5;
				arrStandardDeviation.SetAt(rowIndex, 100.0 * squareDifference / arrMeanValue.GetAt(rowIndex));		
			}
			else arrStandardDeviation.SetAt(rowIndex, 9999999.999);
//Trace("meanValue =>",arrMeanValue.GetAt(rowIndex),"<  	CV =>",arrStandardDeviation.GetAt(rowIndex),">==");
		}

		if ((arrMeanValue.GetAt(0) != 0) && (amountOfValues*rowSize > 1))
		{
			squareDifference = (arrStandardDeviation.GetAt(0) / (amountOfValues *(lastRow-firstRow+1) -1))^0.5;
			arrStandardDeviation.SetAt(0, 100.0 * squareDifference / arrMeanValue.GetAt(0));
		}
		else arrStandardDeviation.SetAt(0, 9999999.999);
//Trace("general meanValue =>",arrMeanValue.GetAt(0),"<  	CV =>",arrStandardDeviation.GetAt(0),">==");

	} // end of function "statisticCalculation"

	// --------------------------------------------------------------------------------------
	function linearInterpolation(
								variable	X_Value,			 			// input variable (X value)
								variable arrInterPoints[])			// array of interpolation points (String "x_value y_value")
																 variable // result: interpolated value (Y value)
	//-----------------------------------------------------------------------------------------------------
	{
		variable i, arrSize, Y_Value;
		variable arrX_Val[], arrY_Val[];
		variable tempText;

		arrSize	= arrInterPoints.GetSize();
		arrX_Val.SetSize(arrSize);
		arrY_Val.SetSize(arrSize);
		
		for (i = 0 ;i < arrSize; i++)
		{
			tempText = arrInterPoints.GetAt(i);
			arrX_Val.SetAt(i, FVal(StrLeft(tempText,StrFind(tempText," "))) );
			arrY_Val.SetAt(i, FVal(StrRight(tempText,StrGetLength(tempText) - StrFind(tempText," "))) );
		}

		if(X_Value <= arrX_Val.GetAt(0)) Y_Value = arrY_Val.GetAt(0);
		else if(X_Value > arrX_Val.GetAt(arrSize-1)) Y_Value = arrY_Val.GetAt(arrSize-1);
		else
		{// interpolation
			i=1;
			while(X_Value > arrX_Val.GetAt(i)) i++;
			// Y = Y0 + (X-X0) * (Y1-Y0)/(X1-X0)
			Y_Value = arrY_Val.GetAt(i-1) + 
						(X_Value - arrX_Val.GetAt(i-1)) * (arrY_Val.GetAt(i) - arrY_Val.GetAt(i-1)) / (arrX_Val.GetAt(i) - arrX_Val.GetAt(i-1) );
		}
		return(Y_Value);
	} // end of function "linearInterpolation"


	//-----------------------------------------------------------------------------------------------------
	function checkInputValue(variable inputValue, variable upperLimit, variable lowerLimit,variable& outputValue) variable
	//-----------------------------------------------------------------------------------------------------
	{
		variable index, startIndex;
		variable amountOfDelimiter(0), checkOK(hslFalse);
		variable digits("0123456789.");
		variable prefix("+-");

		outputValue = 0;
		if(GetType(inputValue) == "s")
		{ // check complete string to be converted to integer or float
//Trace("Test: inputValue =>",inputValue,"<==");
			StrReplace(inputValue,",",".");
			if(StrFind(prefix, StrLeft(inputValue,1)) < 0) 	startIndex = 0;
			else															startIndex = 1;
			for(index = startIndex; index < StrGetLength(inputValue); index++)
			{	
				if(StrFind(digits,StrMid(inputValue,index, 1)) < 0) return(hslFalse);
				if(StrFind(digits,StrMid(inputValue,index, 1)) > 9) amountOfDelimiter++;
				if(amountOfDelimiter > 1) return(hslFalse); // to many delimiter
			}
			if(GetType(upperLimit) == "i") outputValue = IVal(inputValue);
			else									 outputValue = FVal(inputValue);
		}
		else outputValue = inputValue;
//Trace("Test: outputValue 1 =>",outputValue,"<==");
		// check range
		checkOK = hslTrue;
		if(outputValue < lowerLimit) 
		{
			checkOK 		= hslFalse;
			outputValue = lowerLimit;
		}
//Trace("Test: outputValue 2=>",outputValue,"<==");
		if(outputValue > upperLimit) 
		{
			checkOK 		= hslFalse;
			outputValue = upperLimit;
		}		
//Trace("Test: outputValue 3=>",outputValue,"<==");
		
		return(checkOK);
	} // end of function "checkInputValue"

	//------------------------------------------------------------------------------
	function NewTextLine(variable i_resetVariable, variable i_DialogText)void
	//	add new dialog text line to varialble VerDef::dialogText
	//------------------------------------------------------------------------------
	{
		if (i_resetVariable > 0) VerDef::dialogText = i_DialogText;
		else 	  VerDef::dialogText = StrConcat4(VerDef::dialogText, VerDef::CRLF,i_DialogText,"");
	}
	
	//-----------------------------------------------------------------------------------------------------
	function addArrayInformation(variable& mainArray[], variable additionalArray[])
	//-----------------------------------------------------------------------------------------------------
	{
		variable arraySize, i;
		
		arraySize= additionalArray.GetSize();

		// Trace array values
		for (i = 0; i < arraySize; i++) mainArray.AddAsLast( additionalArray.GetAt( i ) );

		return;

	} // end of function "addArrayInformation"

	//-----------------------------------------------------------------------------------------------------
	function displayArrayData(variable displayTitel, variable& arrayToDisplay[]) variable
	// Display array data to enable changes (for simulation mode)
	//-----------------------------------------------------------------------------------------------------
	{
		variable index(0), userResponse;
		variable promptText("");
		variable amountOfData;
		variable dataType(hslFloat);
		dialog 	userDialog;

		amountOfData = arrayToDisplay.GetSize();
		if ((VerDef::SimulationMode > 0 ) && (VerDef::dlgTimeOut > 0))
		{
			dataType = GetType( arrayToDisplay.GetAt(0) );
			userDialog.SetInputSize( amountOfData);
			for(index = 0; index < amountOfData; index++)
			{
				promptText = StrConcat4(" Value at index ",index," is =>","");
				userDialog.SetInputField( index, promptText, dataType, arrayToDisplay.GetAt(index));
			}
			userResponse = userDialog.ShowInput( displayTitel, VerDef::dlgTimeOut);
			if(userResponse == hslCancel) return(hslFalse);

			for(index = 0; index < amountOfData; index++)
			{
				arrayToDisplay.SetAt( index, userDialog.GetInputField(index) );
			}
			VerTool::TraceArray("Test: Simulted data of" + displayTitel, arrayToDisplay);	
		}
		return(hslTrue);
	}	// end of function "displayArrayData"

	//-----------------------------------------------------------------------------------------------------
	function TraceArray(variable arrayName, variable arrayToTrace[])
	//-----------------------------------------------------------------------------------------------------
	{
		variable arraySize, i;
		
		arraySize= arrayToTrace.GetSize();

		Trace(" ------  Array >", arrayName, "<   with size =>", arraySize, "<--------");

		// Trace array values
		for (i = 0; i < arraySize; i++)
							Trace(" ----  at pos>", i, "<   with value ==>", arrayToTrace.GetAt( i )	, "<=");
	
		return;

	} // end TraceArray

	//-----------------------------------------------------------------------------------------------------
	function Density(variable  liquidType, 				// in: liquid type
							variable  temperature				// in: ambient temerature in [°C] as float
															) variable	
	// Evaluate the densitiy of the verification liquid for passed temperature.
	// Only a temperature range >=15 and <= 35.0 degrees is supported.
	// RETURN		density value of correspondng verification liquid
	//-----------------------------------------------------------------------------------------------------
	{
		const variable lDensity20(0.999);	// verification liquid (20°C), [g/cm3] = [mg/ul]
		variable density(-1.0);

		// init the out-parameter first
		density = -1.0;

		#ifdef _DEBUG_VolVer
			Trace("Test: Liquid origin density at 20°C: ", lDensity20, "[mg/ul] ");
		#endif

		if(liquidType == LiquidType::HVS_Solution)
		{
	  		if		(temperature <= 15.0) density = lDensity20 * 1.0009;
			else if(temperature <= 15.5) density = lDensity20 * 1.0008;
			else if(temperature <= 16.5) density = lDensity20 * 1.0007;
			else if(temperature <= 17.0) density = lDensity20 * 1.0006;
			else if(temperature <= 17.5) density = lDensity20 * 1.0005;
			else if(temperature <= 18.0) density = lDensity20 * 1.0004;
			else if(temperature <= 18.5) density = lDensity20 * 1.0003;
			else if(temperature <= 19.0) density = lDensity20 * 1.0002;
			else if(temperature <= 19.5) density = lDensity20 * 1.0001;
			else if(temperature <= 20.0) density = lDensity20 * 1.0000;
			else if(temperature <= 20.5) density = lDensity20 * 0.9999;
			else if(temperature <= 21.0) density = lDensity20 * 0.9998;
			else if(temperature <= 21.5) density = lDensity20 * 0.9997;
			else if(temperature <= 22.0) density = lDensity20 * 0.9996;
			else if(temperature <= 22.5) density = lDensity20 * 0.9995;
			else if(temperature <= 23.0) density = lDensity20 * 0.9993;
			else if(temperature <= 23.5) density = lDensity20 * 0.9992;
			else if(temperature <= 24.0) density = lDensity20 * 0.9991;
			else if(temperature <= 24.5) density = lDensity20 * 0.9990;
			else if(temperature <= 25.0) density = lDensity20 * 0.9988;
			else if(temperature <= 25.5) density = lDensity20 * 0.9987;
			else if(temperature <= 26.0) density = lDensity20 * 0.9986;
			else if(temperature <= 26.5) density = lDensity20 * 0.9984;
			else if(temperature <= 27.0) density = lDensity20 * 0.9983;
			else if(temperature <= 27.5) density = lDensity20 * 0.9982;
			else if(temperature <= 28.0) density = lDensity20 * 0.9980;
			else if(temperature <= 28.5) density = lDensity20 * 0.9979;
			else if(temperature <= 29.0) density = lDensity20 * 0.9977;
			else if(temperature <= 29.5) density = lDensity20 * 0.9976;
			else if(temperature <= 30.0) density = lDensity20 * 0.9974;
			else if(temperature <= 30.5) density = lDensity20 * 0.9973;
			else if(temperature <= 31.0) density = lDensity20 * 0.9971;
			else if(temperature <= 31.5) density = lDensity20 * 0.9970;
			else if(temperature <= 32.0) density = lDensity20 * 0.9968;
			else if(temperature <= 32.5) density = lDensity20 * 0.9967;
			else if(temperature <= 33.0) density = lDensity20 * 0.9965;
			else if(temperature <= 33.5) density = lDensity20 * 0.9963;
			else if(temperature <= 34.0) density = lDensity20 * 0.9962;
			else if(temperature <= 34.5) density = lDensity20 * 0.9960;
			else if(temperature <= 35.0) density = lDensity20 * 0.9958;
		}

		if(liquidType == LiquidType::DarkDye_Solution)
		{
			//	Solution 1 (dark dye)	07463 lot 52509/1	
			// T (° C)	D (g/cm3)
			// 	15		1.0018
			//		20		1.0008
			//		25		0.9996
			//		30		0.9982
			//		35		0.9966
			//
			// => Polynom D = -4E-06T*T - 6E-05*T + 1.0036		
			
			density = -0.000004*temperature*temperature - 0.00006*temperature + 1.0036;
		}

		if(liquidType == LiquidType::Buffer_Solution)
		{
			//	Solution 2 (buffer)	07162 lot 12609/1	
			// T (° C)	D (g/cm3)
			// 	15		1.0015
			//		20		1.0006
			//		25		0.9994
			//		30		0.9980
			//		35		0.9963
			//
			// => Polynom D =  -5E-06*T*T - 3E-06*T + 1.0027			
			
			density = -0.000005*temperature*temperature - 0.000003*temperature + 1.0027;
		}

		if(liquidType == LiquidType::LightDye_Solution)
		{	//	Solution 3 (light dye)		92421 lot 42509/1
			// T (° C)	D (g/cm3)
			// 	15		1.0015
			//		20		1.0006
			//		25		0.9994
			//		30		0.9980
			//		35		0.9963
			//
			// => Polynom D =  -5E-06*T*T - 3E-06*T + 1.0027			
			
			density = -0.000005*temperature*temperature - 0.000003*temperature + 1.0027;
		}

		if(temperature < 15) 	density = -1.0;		// unexpected temperature
		if(temperature > 35)		density = -1.0;		// unexpected temperature

		#ifdef _DEBUG_VolVer
			Trace("Calculated density for temperature ", temperature, "[°C] = ", density, "[g/cm3]");
		#endif

		if ( density <= 0.0 )
		{
			variable message;
			message = LdT("Temperature out of range.");
			message = message + "  " + FStr(temperature, hslTrue) + "°C";
			err.Raise(1 , message); 
		}
//		if (VerDef::SimulationMode) density = 1.0000;
		
		// reduce density value to 4 digits #.####
		density = 1.0 * Floor(10000.0 * density + 0.5)/10000.0;
		return(density);
	} //---- end of function "Density"

	//-----------------------------------------------------------------------------------------------------
	function ChannelPattern(variable firstChannel, variable numberOfUsedChannels, variable numberOfChannels) variable
	//-----------------------------------------------------------------------------------------------------
	{
		variable channelPattern("");
		variable remainingChannels(0);

		loop(firstChannel-1) 		channelPattern = channelPattern + "0"; 
		loop(numberOfUsedChannels) channelPattern = channelPattern + "1"; 

		remainingChannels = numberOfChannels -  numberOfUsedChannels - firstChannel + 1;
		if (remainingChannels < 0) remainingChannels = 0;
		loop(remainingChannels)		channelPattern = channelPattern + "0"; 

		return (channelPattern);

	} // end of function "ChannelPattern"


	//-----------------------------------------------------------------------------------------------------
	function ChannelAddress(variable firstCharakter, variable channelNo) variable
	//-----------------------------------------------------------------------------------------------------
	{
		variable adr("");

		firstCharakter = StrConcat2(firstCharakter,"");
		adr 			= StrConcat2(firstCharakter,channelNo);

		if     (channelNo < 1)   adr = firstCharakter + "X";
		else if(channelNo == 10) adr = firstCharakter + "A";
		else if(channelNo == 11) adr = firstCharakter + "B";
		else if(channelNo == 12) adr = firstCharakter + "C";
		else if(channelNo == 13) adr = firstCharakter + "D";
		else if(channelNo == 14) adr = firstCharakter + "E";
		else if(channelNo == 15) adr = firstCharakter + "F";
		else if(channelNo == 16) adr = firstCharakter + "G";
		else if(channelNo >  16) adr = firstCharakter + "X";

		return(adr);
	} // end of function "ChannelAdress"


	//-----------------------------------------------------------------------------------------------------
	function GetErrorCodes( variable channelPattern, variable &arrayMainError[], variable &arraySlaveError[]) variable 
	//-----------------------------------------------------------------------------------------------------
	{
		// Get error codes of last step, step error and main and salve error for each channel (block)

		const variable NoError(0);
		const variable InsufficientLiquidError(6);
		const variable LiquidLevelError(102);
		const string 	strActiveChannel("1");
		
		variable channelNo, size;
		variable blockPos;
		variable stepError(-1); // main step return error code
		variable rc[];
		variable errorReturnString("");
		string strChannelPattern;

		rc = err.GetData();

		if ( rc.GetSize() > 2 )
		{
			errorReturnString = rc.GetAt( 2 );
			stepError			= StepReturn::GetErrorCode(errorReturnString);

			size = strChannelPattern.GetLength();
			arrayMainError.SetSize(0);

			arraySlaveError.SetSize(0);
			loop(size+1)
			{
				arrayMainError.AddAsLast(0);
				arraySlaveError.AddAsLast(0);
			}
			for (channelNo = 1; channelNo <= size; channelNo++)
			{
				if ( strActiveChannel.Compare(strChannelPattern.Mid(channelNo-1, 1)) == 0 )
				{ // Active Channel, get its block position and its main and slave error
					blockPos = StepReturn::GetPositionFromNum(channelNo, errorReturnString);
					if ( blockPos > 0 )
					{
						arrayMainError.SetAt(channelNo, StepReturn::GetMainError(blockPos, errorReturnString));
                  arraySlaveError.SetAt(channelNo, StepReturn::GetSlaveError(blockPos, errorReturnString));
//Trace("Test: Main error of  index =>",channelNo, "<  blockPos =>",blockPos, "> === Error code ==>",arrayMainError.GetAt(channelNo),"<  slave error ==>",arraySlaveError.GetAt(channelNo),"<==");
					}
				}
			}
		}
		return(stepError);
	} // end of function "GetErrorCodes"

	//-----------------------------------------------------------------------------------------------------
	function FwCommand( variable &fwCommand, variable &fwParameter, variable errCheck, device ML_STAR )
	//-----------------------------------------------------------------------------------------------------
	{
		variable arrRetValues[];
		string answer;

		// call firmware command
		arrRetValues =		ML_STAR.FirmwareCommand( "d7e8564a_f933_4a30_bb7c2bc19e3322b7" );
		answer = arrRetValues.GetAt(3);

		// check firmware return value
		if ( hslTrue == errCheck )
		{
			if ( 0 != fwRetOk.Compare(answer.Left(fwRetOkLength)) )
			{
				string errorDesc;
				errorDesc = LdT("Firmware command <%s1> with parameter <%s2> failed! - return value <%s3>");
				StrReplace(errorDesc, "%s1", fwCommand);
				StrReplace(errorDesc, "%s2", fwParameter);
				StrReplace(errorDesc, "%s3", answer);
			   err.Raise(1 , errorDesc);
			}
		}
		return (answer);

	} // end FwCommand


	//-----------------------------------------------------------------------------------------------------
	function CoverLock( device ML_STAR , variable lockStatus )
	// lock front cover if lockStatus = VerDef::coverLock; to unlock if lockStatus = VerDef::coverUnlock;		
	//-----------------------------------------------------------------------------------------------------
	{
		if((lockStatus > 0) && (VerDef::CoverLocking > 0)) 	ML_STAR.LockFrontCover( "dec64794_c417_4003_9808f2d2d740ebe5" );
		if(lockStatus == 0)												ML_STAR.LockFrontCover( "dec64794_c417_4003_9808f2d2d740ebe5" );

	} // end CoverLock

 	//-----------------------------------------------------------------------------------------------------
	function ML_STAR_Initialize(device& ML_STAR)
	//-----------------------------------------------------------------------------------------------------
	// Initialize ML_STAR 
	// 
	// RETURN		none
	//-----------------------------------------------------------------------------------------------------
	{
		ML_STAR.Initialize( "28ef8d3e_db5d_4bc7_b0d8890aff6c6110" );
	} // end of function "ML_STAR_Initialize"

	function MoveToEndPositions(device ML_STAR)
	//-----------------------------------------------------------------------------------------------------
	// Move arms to end positions:
	// In case of single arm: 	Move arm to defined right end position						
	// In case of dual arm: 	Move arms to end positions, left arm to defined left end position (but inside side cover), 
	//																			right arm to defined right end position
	// Move multiProbeHeads to Y-home position and switch of current of Y- motor 
	// Switch of current of X-motor(s)

	// Move autoload to extreme right position
	// RETURN		none
	//-----------------------------------------------------------------------------------------------------
	{
		variable xPos;
		variable cmd, prm, response, tempText;
		variable xDrive_1_Pos(""), xDrive_2_Pos(""), maxAutoload;

		// --------------------------------------------------------------------------
		// Lock front cover, if requested (VerDef::CoverLocking > 0)
		CoverLock(ML_STAR , VerDef::coverLock);

		// Request extreme positions: Command C0RU => C0RUid6644er00/00ru01820 16290 06000 20470
		// ru##### ##### ##### #####
		//	1.value: minimal left X drive position
		//	2.value: maximal left X drive position
		//	3.value: minimal right X drive position
		//	4.value: maximal right X drive position
		//	(value "00000" = drive is not defined)
		onerror goto executionFailed;

		cmd = "C0RU";
		prm = "";	
		response	= FwCommand(cmd, prm, hslTrue,  ML_STAR);

		if(!VerDef::hasRightArm)
		{ // single left arm configuration
			xDrive_1_Pos = StrMid(response, StrReverseFind(response,"ru") +8, 5); // maximal right position for left arm
		}
		else
		{ 
			xDrive_1_Pos = StrMid(response, StrReverseFind(response,"ru") +2, 5); // minimal left position for left arm
			if((IVal(xDrive_1_Pos) > 0) && (IVal(xDrive_1_Pos) < 3420) ) xDrive_1_Pos = "03420";
		}
		xDrive_2_Pos 	= StrMid(response, StrReverseFind(response,"ru") +20, 5); // maximal right position for right arm

		if((VerDef::hasRightArm) && (IVal(xDrive_2_Pos) > 0))
		{ // move right arm to max right position
			cmd = "C0KR";	
			prm = StrConcat2( "xs", xDrive_2_Pos);
			FwCommand(cmd, prm, hslTrue, ML_STAR );
		}

		if((VerDef::hasLeftArm) && (IVal(xDrive_1_Pos) > 0) )
		{	// move left arm to min left position
			cmd = "C0KX";	
			prm = StrConcat2("xs", xDrive_1_Pos );
			FwCommand(cmd, prm, hslTrue, ML_STAR );
		}
		
		if(VerDef::multi96PipHead > 0)
		{ // Move 96 multiProbeHead to Y-home position and switch of current of Y- motor 
			cmd = "H0YP";
			prm = "yp0";	
			FwCommand(cmd, prm, hslTrue, ML_STAR );
			cmd = "H0YO";
			prm = "";	
			FwCommand(cmd, prm, hslTrue, ML_STAR );
		}

		if(VerDef::multi384PipHead > 0)
		{ // Move 384 multiProbeHead to Y-home position and switch of current of Y- motor 
			cmd = "D0YP";
			prm = "yp0";	
			FwCommand(cmd, prm , hslTrue, ML_STAR );
			cmd = "D0YO";
			prm = "";	
			FwCommand(cmd, prm , hslTrue, ML_STAR );
		}
	
		// Switch of current of X-motor(s)
		cmd = "X0XO";
		prm = "";	
		if(VerDef::hasLeftArm) 	FwCommand(cmd, prm , hslTrue, ML_STAR ); // switch off current left x motor
		cmd = "X0SO";
		if(VerDef::hasRightArm) FwCommand(cmd, prm , hslTrue, ML_STAR ); // switch off current right x motor	

		// if installed move autoload to right position
		cmd = "Autoload";
		prm = "";	
		maxAutoload = VerDef::numbOfAutoLoadTracks;
		if(VerDef::numbOfAutoLoadTracks >0) ML_STAR.MoveAutoLoad( "47478309_339e_483f_885962822d8c394c" );
		
		return;

		// ------------------------------------------------------			
		executionFailed:
		{
			tempText = LdT("Command execution of '%s1%s2' failed!");
			StrReplace(tempText,"%s1",cmd);
			StrReplace(tempText,"%s2",prm);
			Trace(tempText);
			resume next;
		}
	} // end MoveToEndPositions

	//-----------------------------------------------------------------------------------------------------
	function MoveToPosition( device ML_STAR, variable pipettingHeadType, variable channelPattern, 
												sequence seqTargetPositions, variable zOffset) variable
	// Move pipettingHead to defined position (corrected with zOffset)
	//-----------------------------------------------------------------------------------------------------
	{
		variable labID(""), posID(""), rackID(""), templateConfigFile;
		variable currentPosition, sizeOfPattern;
		variable cmd(""), prm(""), prmYpos(""), prmZpos(""), prmTPpos(""),tempText("");
		variable i, last, xPos(0.0), yPos(0.0), zPos(5.0);

		variable arrLabPosition[];

		sequence seq_emptyDefinitions;

//		TrcTraceSequence(seqTargetPositions);
//Trace("Test: Move to position FW command: pipettingHeadType= >",pipettingHeadType,"<==");

		sizeOfPattern		= StrGetLength(channelPattern);
		currentPosition 	= seqTargetPositions.GetCurrentPosition();
		labID = seqTargetPositions.GetLabwareId();
		posID = seqTargetPositions.GetPositionId();
		ML_STAR.GetLabwarePosition(labID, arrLabPosition,posID );
		xPos	= arrLabPosition.GetAt(0);
		yPos	= arrLabPosition.GetAt(1);
		zPos	= arrLabPosition.GetAt(2);

		onerror goto executionFailed;

		if (pipettingHeadType == VerDef::singlePipHead_1000ul)
		{
		// FW positioning command for ML-STAR 1000ul pipetting head:
		// C0JMid3333tm0 0 1 1 1 1 0&xp05186&th2500yp2375 2375 2375 2195 2015 1835 0000&zp2450 2450 1720 1720 1720 1720 2450&;
			cmd = "C0JM";
			prm = ComposeCompletePrm("xp", 5, 10 * xPos);
			if(sizeOfPattern == 1) 	prm = prm + "th2470";
			else						 	prm = prm + "&th2470";	
			prmYpos = "yp";
			prmZpos = "zp";
			prmTPpos = "tm";
         for (i = 0; i < sizeOfPattern; i++) 
			{
//Trace("Test:  Move to position at index =>", i,"< labID=>",labID,"< posID=>",posID,"< xPos=>",xPos,"< yPos=>",yPos,"< zPos=>",zPos,"<==");
				if (StrMid(channelPattern,i,1) == "0")
				{ 
					prmYpos = prmYpos + ComposeCompletePrm("", 4, 10 * yPos)+ " ";
					prmZpos = prmZpos + "2450 ";
               prmTPpos = prmTPpos + "0 ";
				}
				else
				{
					prmTPpos = prmTPpos + "1 ";
               if (seqTargetPositions.GetCurrentPosition()> 0)
					{
						labID = seqTargetPositions.GetLabwareId();
						posID = seqTargetPositions.GetPositionId();
					}
					ML_STAR.GetLabwarePosition(labID, arrLabPosition,posID );
					yPos	= arrLabPosition.GetAt(1);
					zPos	= arrLabPosition.GetAt(2);

					prmYpos = prmYpos + ComposeCompletePrm("", 4, 10 * yPos)+ " ";
					if((zPos + zOffset)> 245)	prmZpos = prmZpos + "2450 ";
					else								prmZpos = prmZpos + ComposeCompletePrm("", 4, 10 * (zPos + zOffset))+ " ";
					seqTargetPositions.Increment( 1 );
				}
 			}
			prm = StrLeft(prmTPpos, StrGetLength(prmTPpos) - 1) + prm + 
                   StrLeft(prmYpos, StrGetLength(prmYpos) - 1) + StrLeft(prmZpos, StrGetLength(prmZpos) - 1);

//Trace("Test:  Move to position FW command =>", cmd,"< prm =>",prm,"<==");
			FwCommand( cmd, prm, hslTrue, ML_STAR );

		} // end of VerDef::singlePipHead_1000ul

		if (pipettingHeadType == VerDef::singlePipHead_5ml)
		{
		// FW positioning command for ML-STAR 5ml pipetting head:
		// C0LLid3333tr0 0 1 1 0&xb05186&th2500yp2375 2375 2375 2195 0000&zp2450 2450 1720 1720 2450&;

		// Command "LL": Move all XL channels to defined position 
			cmd = "C0LL";
			// 	Parameter:
			//		xb##### (n)	0..25000	0		X-Position in 0.1mm
			//		th####	0..3600	3600		Minimum traverse height at beginning of a command in 0.1mm (refers to all channels independent of Tip pattern parameter "tr")
			prm = ComposeCompletePrm("xb", 5, 10 * xPos) ;
			if(sizeOfPattern == 1) 	prm = prm + "th2470";
			else						 	prm = prm + "&th2470";	

			prmYpos = "yf"; 	//	yf#### (n)	0..6500	0		Y-Position in 0.1mm
			prmZpos = "pz";	//	pz#### (n)	0..3600	0		Z-Position of channels involved at end of command in 0.1mm
			// 	tr# (n)	0..1	1		Tip pattern (channels involved)
			prmTPpos = "tr";
         for (i = 0; i < sizeOfPattern; i++) 
			{
//Trace("Test:  Move to position at index =>", i,"< labID=>",labID,"< posID=>",posID,"< xPos=>",xPos,"< yPos=>",yPos,"< zPos=>",zPos,"<==");
				if (StrMid(channelPattern,i,1) == "0")
				{ 
					prmYpos = prmYpos + ComposeCompletePrm("", 4, 10 * yPos)+ " ";
					prmZpos = prmZpos + "2450 ";
               prmTPpos = prmTPpos + "0 ";
				}
				else
				{
					prmTPpos = prmTPpos + "1 ";
               if (seqTargetPositions.GetCurrentPosition()> 0)
					{
						labID = seqTargetPositions.GetLabwareId();
						posID = seqTargetPositions.GetPositionId();
					}
					ML_STAR.GetLabwarePosition(labID, arrLabPosition,posID );
					yPos	= arrLabPosition.GetAt(1);
					zPos	= arrLabPosition.GetAt(2);

					prmYpos = prmYpos + ComposeCompletePrm("", 4, 10 * yPos)+ " ";
					prmZpos = prmZpos + ComposeCompletePrm("", 4, 10 * (zPos + zOffset))+ " ";
					seqTargetPositions.Increment( 1 );
				}
 			}
			prm = StrLeft(prmTPpos, StrGetLength(prmTPpos) - 1) + prm + 
                   StrLeft(prmYpos, StrGetLength(prmYpos) - 1) + StrLeft(prmZpos, StrGetLength(prmZpos) - 1);

//Trace("Test:  Move to position FW command =>", cmd,"< prm =>",prm,"<==");
			FwCommand( cmd, prm, hslTrue, ML_STAR );

		} // end of VerDef::singlePipHead_5ml

		if ((pipettingHeadType == VerDef::multi96PipHead_300ul)||(pipettingHeadType == VerDef::multi96PipHead_1000ul))
		{
		// FW positioning command for ML-STAR 96er multi pipetting head
			// C0EMid3333xs05186xd0yh2375za2450zh2450; Move CoRe 96 Head to defined position
			cmd = "C0EM";
			
			//	Parameter:
			//	xs##### 	0..30000	0		X-Position in 0.1mm of Tip A1
			//	xd#	0..1	0		X direction 0 = positive	1 = negative 
			//	zh####	0..3425	3425		Minimal height at begin of command in 0.1mm
			prm = ComposeCompletePrm("xs", 5, 10 * xPos);
			if (xPos > 0) 	prm = prm + "xd0zh2450";
			else 				prm = prm + "xd1zh2450";
			// yh####	1080..5600	5600		Y-Position in 0.1mm
			prm = prm +  "yh" + ComposeCompletePrm("", 4, 10 * yPos);
			// za####	0..3425	3425		Z-Position in 0.1mm
			prm = prm + "za" + ComposeCompletePrm("", 4, 10 * (zPos + zOffset));

//Trace("Test:  Move to position FW command =>", cmd,"< prm =>",prm,"<==");
			FwCommand( cmd, prm, hslTrue, ML_STAR );
		} // end of VerDef::multi96PipHead

		if ((pipettingHeadType == VerDef::multi384PipHead_50ul) || (pipettingHeadType == VerDef::multi384PipHead_STP))
		{
		// FW positioning command for ML-STAR 384er multi pipetting head
			// C0ENid3333xs05186xd0yk2375je2450zf2450; Move CoRe 384 Head to defined position
			cmd = "C0EN";		
			// 	Parameter:
			//	xs##### 	0..30000	0		X-Position in 0.1mm of Tip A1
			//	xd#		0..1	0			X direction 0 = positive	1 = negative 
			//	zf####	0..3270	3270	Minimal height at begin of command in 0.1mm
			prm = ComposeCompletePrm("xs", 5, 10 * xPos);
			if (xPos > 0) 	prm = prm + "xd0zf2450";
			else 				prm = prm + "xd1zf2450";
			// yk####	1110..5640	5640		Y-Position in 0.1mm
			prm = prm +  "yk" + ComposeCompletePrm("", 4, 10 * yPos);
			// je####	0..3270	3270		Z-Position in 0.1mm
			prm = prm + "je" + ComposeCompletePrm("", 4, 10 * (zPos + zOffset));

//Trace("Test:  Move to position FW command =>", cmd,"< prm =>",prm,"<==");
			FwCommand( cmd, prm, hslTrue, ML_STAR );
		} // end of VerDef::multi384PipHead
		
		seqTargetPositions.SetCurrentPosition(currentPosition);

		return(hslTrue);

		// ------------------------------------------------------			
		executionFailed:
		{
//			err.GetData( );
//			Trace(" Error: =>", err.GetDescription( ),"<  Error ID==>",err.GetId( ), "<==");
			err.Clear();

			tempText = LdT("Command execution of '%s1%s2' failed!");
			StrReplace(tempText,"%s1",cmd);
			StrReplace(tempText,"%s2",prm);
			Trace(tempText);
			return(hslFalse);
		}

	} // end of function "MoveToPosition"

	//-----------------------------------------------------------------------------------------------------
	function GetNoOfChannels() 
	//-----------------------------------------------------------------------------------------------------
	{
		return (VerDef::InstrumentNumberOfChannels);
	} // end GetNoOfChannels

	//-----------------------------------------------------------------------------------------------------
	function GetNoOf_5mlChannels() 
	//-----------------------------------------------------------------------------------------------------
	{
		return (VerDef::InstrumentNumberOf_5mlChannels);
	} // end GetNoOf_5mlChannels

	//-----------------------------------------------------------------------------------------------------
	function TraceDlgYes( string &dlg )
	//-----------------------------------------------------------------------------------------------------
	{
		string traceText;

		// initialize library (if necessary)
		InitVerToolsLibrary();
		// trace
		traceText = LdT("Dialog <%s> -> button <Yes> pressed.");
		StrReplace(traceText, "%s", dlg);
		Trace( traceText );

	} // end TraceOK

	//-----------------------------------------------------------------------------------------------------
	function TraceDlgNo( string &dlg )
	//-----------------------------------------------------------------------------------------------------
	{
		string traceText;

		// initialize library (if necessary)
		InitVerToolsLibrary();
		// trace
		traceText = LdT("Dialog <%s> -> button <No> pressed.");
		StrReplace(traceText, "%s", dlg);
		Trace( traceText );

	} // end TraceOK

	//-----------------------------------------------------------------------------------------------------
	function TraceDlgOK( string &dlg )
	//-----------------------------------------------------------------------------------------------------
	{
		string traceText;

		// initialize library (if necessary)
		InitVerToolsLibrary();
		// trace
		traceText = LdT("Dialog <%s> -> button <OK> pressed.");
		StrReplace(traceText, "%s", dlg);
		Trace( traceText );

	} // end TraceOK

	//-----------------------------------------------------------------------------------------------------
	function TraceDlgCancel( string &dlg )
	//-----------------------------------------------------------------------------------------------------
	{
		string traceText;

		// initialize library (if necessary)
		InitVerToolsLibrary();
		// trace
		traceText = LdT("Dialog <%s> -> aborted by button <Cancel>.");
		StrReplace(traceText, "%s", dlg);
		Trace( traceText );

	} // end TraceCancel

//--------------------------------------------------------------------------------
// Get verification information from corresponding information arrays
	function GetVerificationInformation(
					variable VerificationInfoType,		//	requested verification information key word
					variable& VerificationProperty,		// corresponding property
					variable& VerificationProperty_2,	// corresponding second property
					variable& VerificationProperty_3,	// corresponding third property
					variable& VerificationSerialNo,		// corresponding serial number
					variable& VerificationDate,			// corresponding date (calibration date , expiry date ...)
					variable& VerificationLastChange,	// corresponding date of last change
					variable& VerificationChangeBy		// corresponding operator of last change
																) variable  // sequence index number

//--------------------------------------------------------------------------------
{
//		variable toolType, serialNo, expiryDate, property_1, property_2, lastChangedDate;
		file verificationFile;										
		variable templateFileName(""), fileName("");					// File name inclusive path 
		variable semiColon(";");
		variable index(0),sizeOfData(0);
		variable found(hslFalse);
		variable infoType, serialNo, date, lastChange, changeBy, property, property_2, property_3;
		variable traceSource(""),traceAction( "Assign data");
		variable tempText("");
		variable userMessages[];
		object fso;  // file system object
		if (fso.IsNull()) fso.CreateObject("Scripting.FileSystemObject");


		traceSource = GetFunctionName() + ": ";
//Trace(traceSource, ":  Verification Property =>", VerificationProperty,	"<================ VerDef::InstrumentSerialNo=>",VerDef::InstrumentSerialNo,"<===");

		sizeOfData = arrayInfoTypes.GetSize();
		fileName = StrConcat8(GetSystemPath(), "\\", verficationStatusFileName,"_",VerDef::InstrumentSerialNo,".csv","","") ;

		if ((sizeOfData == 0) && !fso.FileExists(fileName) ) 
		{
Trace(" New status file =>"+ fileName + "<= created "); 

			templateFileName = GetMethodsPath() + VerDef::toolsSubDirName + verficationStatusFileName + ".csv";
			CopyFile(templateFileName,  fileName, 0, 1);
		}
		else if((sizeOfData == 0) && !VerifyCheckSum(fileName))
	 	{
			tempText = LdT("Checksum file '%s1' failed!") + "   ";
			StrReplace(tempText, "%s1", fileName );
			userMessages.AddAsLast( tempText );
			userMessages.AddAsLast( "");
			userMessages.AddAsLast( LdT("Press 'OK' to continue verification with Default Status File."));
	 		FormatTrace(traceSource, LdT("File Check"), VerDef::CMD_ERRCOMPL, tempText ); 

			VerificationUserMessagesDialog(LdT("File Check"), userMessages, "");
			Trace(" New status file =>"+ fileName + "<= created "); 

			templateFileName = GetMethodsPath() + VerDef::toolsSubDirName + verficationStatusFileName + ".csv";
			CopyFile(templateFileName,  fileName, 0, 1);
	 	}


 		if ((sizeOfData ==0) && fso.FileExists(fileName))
		{ // read data from file "...tools\ML_STARVer.csv"
			
 
			Trace(" Open verification config file =>"+ fileName + "<== "); 
			verificationFile.AddField(headerInfoType,		infoType,	hslString);
			verificationFile.AddField(headerProperty, 	property, hslString);
			verificationFile.AddField(headerProperty_2, 	property_2, hslString);
			verificationFile.AddField(headerProperty_3, 	property_3, hslString);
			verificationFile.AddField(headerSerialNo, 	serialNo, 	hslString);
			verificationFile.AddField(headerDate, 			date, hslString);	
			verificationFile.AddField(headerLastChange, 	lastChange, hslString);
			verificationFile.AddField(headerChangeBy, 	changeBy, hslString);				
			verificationFile.SetDelimiter(semiColon);
			if( 0 == verificationFile.Open(fileName, hslRead) )
			{
				tempText = LdT("Open file '%s1' failed!");
				StrReplace(tempText, "%s1", fileName );
		 		FormatTrace(traceSource, LdT("Open file"), VerDef::CMD_ERRCOMPL, tempText ); 
	   		abort;
			}
			index = 0;
//Trace("Test: ------------------ GetVerificationInformation-------------------");
//Trace(" Verification info file =>"+ fileName + "<== "); 
			while (!verificationFile.Eof())
			{
				verificationFile.ReadRecord(); 
				if ((GetType(serialNo) =="s") && (serialNo != ""))
				{
					index++;
					arrayInfoTypes.AddAsLast( infoType );
					arraySerialNo.AddAsLast( serialNo);
					arrayDate.AddAsLast( date );
					arrayLastChange.AddAsLast(lastChange );
					arrayChangeBy.AddAsLast( changeBy);
					arrayProperty.AddAsLast(property );
					arrayProperty_2.AddAsLast(property_2 );
					arrayProperty_3.AddAsLast(property_3 );
				}
				#ifdef _DEBUG
				{
					Trace("Test:",traceSource, " read data ==> index ==>", index, 
								"<== \t infoType =>", 	infoType, //"<=type =>",GetType(toolType),
								"<== \t property =>", 	property,				//"<== \t Property =>", property,"<==",	
								"<== \t property_2 =>", property_2,				//"<== \t Property =>", property,"<==",	
								"<== \t property_3 =>", property_3,
								"<== \t serialNo =>", 	serialNo, //"<=type =>",GetType(serialNo),
								"<== \t date =>", 		date,				//"<== \t Property =>", property,"<==",	
								"<== \t lastChange =>", lastChange,				//"<== \t Property =>", property,"<==",	
								"<== \t changeBy =>", 	changeBy,"<==");				//"<== \t Property =>", property,"<==",	
				}
				#endif
			}
			verificationFile.Close();
			verificationFile.RemoveFields();
	
			sizeOfData =arrayInfoTypes.GetSize();
		}


//VerTool::TraceArray(" --- arrayInfoTypes ---------", arrayInfoTypes);
//VerTool::TraceArray(" --- arrayProperty ---------", arrayProperty);

		// search for info key word
		found = hslFalse;
		for (index = 0;index < sizeOfData; index++)
		{
			if (VerificationInfoType == arrayInfoTypes.GetAt(index))
			{ // info found
				found = hslTrue;
				VerificationProperty		= arrayProperty.GetAt(index);	// corresponding property
				VerificationProperty_2	= arrayProperty_2.GetAt(index);// corresponding second property
				VerificationProperty_3	= arrayProperty_3.GetAt(index);// corresponding third property
				VerificationSerialNo 	= arraySerialNo.GetAt(index);	// corresponding serial number
				VerificationDate			= arrayDate.GetAt(index);		// corresponding date (calibration date , expiry date ...)
				VerificationLastChange	= arrayLastChange.GetAt(index);// corresponding date of last change
				VerificationChangeBy		= arrayChangeBy.GetAt(index);	// corresponding operator of last change
				break;
			}
		}

		#ifdef _DEBUG
		{
			Trace(traceSource, " Test ==> found at index ==>", index, 
							"<== \t infoType =>", 	VerificationInfoType, 	//"<=type =>",GetType(VerificationInfoType),
							"<== \t property =>", 	VerificationProperty,		
							"<== \t property_2 =>", VerificationProperty_2,	
							"<== \t property_3 =>", VerificationProperty_3,
							"<== \t serialNo =>", 	VerificationSerialNo, 
							"<== \t date =>", 		VerificationDate,		
							"<== \t lastChange =>", VerificationLastChange,	
							"<== \t changeBy =>", 	VerificationChangeBy,"<==");
		}
		#endif

		if (found) return(index+1);

//Trace(traceSource, "Test: ==> infoType =>", VerificationInfoType, " not found!");

		VerificationProperty		= "";
		VerificationProperty_2	= "";
		VerificationProperty_3	= "";
		VerificationSerialNo 	= "";
		VerificationDate			= "";
		VerificationLastChange	= "";
		VerificationChangeBy		= "";

		return(0);

}  // ----  end of function "GetVerificationInformation" ---


//--------------------------------------------------------------------------------
// Update verification information (option: store into file "...system\ML_STARVer_####.csv")
	function UpdateVerificationInformation(
					variable storeDataInFile,			// store  all data in file
					variable VerificationInfoType,	//	 verification information key word
					variable VerificationProperty,	// corresponding property
					variable VerificationProperty_2,	// corresponding second property
					variable VerificationProperty_3,	// corresponding third property
					variable VerificationSerialNo,	// corresponding serial number
					variable VerificationDate			// corresponding date (calibration date , expiry date ...)
														) variable // size of informations

//--------------------------------------------------------------------------------
{
		file verificationFile;										
		variable fileName("");					// File name inclusive path 
		variable semiColon(";");
		variable index(0),sizeOfData(0);
		variable found(hslFalse);
		variable infoType, serialNo, date, lastChange, changeBy, property, property_2, property_3;
		variable traceSource(""),traceAction( "Assign data");
		variable tempText("");

		sizeOfData =arrayInfoTypes.GetSize();
		if (sizeOfData == 0) GetVerificationInformation(VerificationInfoType,property, property_2, property_3,
																			 serialNo,date,lastChange,changeBy);

		VerificationProperty 	= StrConcat2(VerificationProperty ,"");
		VerificationProperty_2 	= StrConcat2(VerificationProperty_2 ,"");
		VerificationProperty_3 	= StrConcat2(VerificationProperty_3 ,"");
		VerificationSerialNo 	= StrConcat2(VerificationSerialNo ,"");
		VerificationDate			= StrConcat2(VerificationDate ,"");

		if (VerificationProperty == "") 		VerificationProperty 	= VerDef::notDefined;
		if (VerificationProperty_2 == "") 	VerificationProperty_2 	= VerDef::notDefined;
		if (VerificationProperty_3 == "") 	VerificationProperty_3 	= VerDef::notDefined;
		if (VerificationSerialNo == "") 		VerificationSerialNo 	= VerDef::notDefined;
		if (VerificationDate == "") 			VerificationDate 			= VerDef::notDefined;

		// search for info key word
		found = hslFalse;
		for (index = 0;index < sizeOfData; index++)
		{
			if (VerificationInfoType == arrayInfoTypes.GetAt(index))
			{ // info found
				found = hslTrue;
				arrayProperty.SetAt(index,VerificationProperty);		// corresponding property
				arrayProperty_2.SetAt(index,VerificationProperty_2);	// corresponding second property
				arrayProperty_3.SetAt(index,VerificationProperty_3);	// corresponding third property
				arraySerialNo.SetAt(index,VerificationSerialNo);
				arrayDate.SetAt(index,VerificationDate);		
				arrayLastChange.SetAt(index,GetDate("%Y-%m-%d"));		// date = today
				arrayChangeBy.SetAt(index, RPD::operatorName);			// current operator
				break;
			}
		}
		if (!found)
		{  // add new key word with corresponding information
			arrayInfoTypes.AddAsLast( VerificationInfoType );
			arrayProperty.AddAsLast(VerificationProperty );
			arrayProperty_2.AddAsLast(VerificationProperty_2 );
			arrayProperty_3.AddAsLast(VerificationProperty_3 );
			arraySerialNo.AddAsLast( VerificationSerialNo);
			arrayDate.AddAsLast( VerificationDate );
			arrayLastChange.AddAsLast(GetDate("%Y-%m-%d"));
			arrayChangeBy.AddAsLast( RPD::operatorName);
			sizeOfData++;
		}

		if (storeDataInFile < 1) return(sizeOfData);  // end of update arrays information

		//--- write all data into file "..\System\ML_STARVer_<serialNo>.csv"
		fileName = StrConcat8(GetSystemPath(), "\\", verficationStatusFileName,"_",VerDef::InstrumentSerialNo,".csv","","");

		traceSource = GetFunctionName() + ": ";

		verificationFile.AddField(headerInfoType,		infoType,	hslString);
		verificationFile.AddField(headerProperty, 	property, hslString);
		verificationFile.AddField(headerProperty_2, 	property_2, hslString);
		verificationFile.AddField(headerProperty_3, 	property_3, hslString);
		verificationFile.AddField(headerSerialNo, 	serialNo, 	hslString);
		verificationFile.AddField(headerDate, 			date, hslString);	
		verificationFile.AddField(headerLastChange, 	lastChange, hslString);
		verificationFile.AddField(headerChangeBy, 	changeBy, hslString);				
		verificationFile.SetDelimiter(semiColon);

		if( 0 == verificationFile.Open(fileName, hslWrite) )
		{
			tempText = LdT("Open file '%s1' failed!");
			StrReplace(tempText, "%s1", fileName );
			FormatTrace(traceSource, LdT("Open file"), VerDef::CMD_ERRCOMPL, tempText); 
   		abort;
		}
		for (index = 0;index < sizeOfData; index++)
		{
			infoType		= arrayInfoTypes.GetAt(index);
			property		= arrayProperty.GetAt(index);		// corresponding property
			property_2	= arrayProperty_2.GetAt(index);	// corresponding second property
			property_3	= arrayProperty_3.GetAt(index);	// corresponding third property
			serialNo 	= arraySerialNo.GetAt(index);		// corresponding serial number
			date			= arrayDate.GetAt(index);			// corresponding date (calibration date , expiry date ...)
			lastChange	= arrayLastChange.GetAt(index);	// corresponding date of last change
			changeBy		= arrayChangeBy.GetAt(index);		// corresponding operator of last change

			#ifdef _DEBUG
			{	Trace(traceSource, " Test ==> found at index ==>", index, 
								"<== \t infoType =>", 	infoType, //"<=type =>",GetType(infoType),
								"<== \t property =>", 	property,
								"<== \t property_2 =>", property_2,
								"<== \t property_3 =>", property_3,
								"<== \t serialNo =>", 	serialNo, //"<=type =>",GetType(serialNo),
								"<== \t date =>", 		date,			
								"<== \t lastChange =>", lastChange,		
								"<== \t changeBy =>", 	changeBy,"<==");	
			}
			#endif
		
			verificationFile.WriteRecord();
		}

		verificationFile.Close();
		verificationFile.RemoveFields();
		
		// ------------------ AddCheckSum -------------------
		VerVarFct::addCheckSum(fileName);

		return(sizeOfData);

}  // ----  end of function "UpdateVerificationInformation" ---

	//-----------------------------------------------------------------------------------------------------
	function GetProcessDataFromFile(variable processId, variable& processedState, 
														variable& processedDate , variable& processedTime, variable& verificationInterval)
	//-----------------------------------------------------------------------------------------------------
	{
		variable proState(""), verInterval(""), proTime(""), proDate("");
		variable prop1, prop2, prop3, sn(""), date(""),lcd(""),lcb(""); // dummy place holder ;


		// Get process data stored in configuration file 
		if (GetVerificationInformation(processId,proState,verInterval,proTime,sn,proDate,lcd,lcb)> 0)
		{
			processedDate 	= proDate;
			processedTime 	= proTime;
			processedState = IVal(proState);
			verificationInterval = IVal(verInterval);
			if(verificationInterval <= 0) verificationInterval = VerDef::_200Days;
		}
		else 
		{
			processedDate 	= "2000-01-01";
			processedTime 	= "00:00";
			processedState = 1;
			if(verificationInterval == 0) verificationInterval = VerDef::_200Days;
		}	

	} // End of function "GetProcessDataFromFile"

	//-----------------------------------------------------------------------------------------------------
	function GetProcessDataFromInstrument(device ML_STAR, variable processId, variable& processedState, 
														variable& processedDate , variable& processedTime, variable& verificationInterval)
	//-----------------------------------------------------------------------------------------------------
	{
		string fwCommand;
		string fwParameter;
		variable answer;
		variable digits;
		variable proState(""), verInterval(""), proTime(""), proDate("");
		variable prop1, prop2, prop3, sn(""), date(""),lcd(""),lcb(""); // dummy place holder ;


		// Get process data stored in configuration file 
		GetProcessDataFromFile(StrConcat2(PID::General,processId), processedState, processedDate , processedTime, verificationInterval);

		if(Util::IsInteger(processId) ) 
		{
			if ((processId < 10) || ((VerDef::fwVersionC0 >= 6.3) && (processId < 25)))
			{  // processdata are stored on instrument
				if (VerDef::fwVersionC0 < 6.0) digits = 1; // FW version < 6.0: process ID definition with 1 digit (vo#)
					else 								 digits = 2; // FW version >= 6.0: process ID definition with 2 digits (vo##)

				// firmware command and parameter to read verification data
				fwCommand = "C0RV";
				fwParameter = ComposeCompletePrm("vo", digits, processId);
				answer	= FwCommand(fwCommand , fwParameter, hslTrue,  ML_STAR);  // ==> C0RVid0143er00/00vd2002-04-24 12:25vs1
				if(!VerDef::SimulationMode)
				{
					processedDate 	= StrMid(answer, StrReverseFind(answer,"vd")+2, 10);
					processedTime 	= StrMid(answer, StrReverseFind(answer,"vd")+13, 5);
					processedState = IVal(StrMid(answer, StrReverseFind(answer,"vs")+2, 1));
				}
			}	
		}

//Trace( "Test: Stored process data for process ID ", processId, ":  processedDate =>",processedDate,
//			"<  processedTime ==>",processedTime, "< verificationInterval ==>",verificationInterval, "< processedState ==>",processedState,"<==");

	} // End of function "GetProcessDataFromInstrum

	//-----------------------------------------------------------------------------------------------------
	function StoreProcessDataOnInstrument( variable processId, variable processedState, device ML_STAR )
	//-----------------------------------------------------------------------------------------------------
	{
		variable fwCommand;
		variable fwParameter;
		variable answer;
		variable proState, processStatus(""), verInterval, processDate(""), processTime("");
		variable prop1, prop2, prop3, sn(""), date(""),lcd(""),lcb(""); // dummy place holder ;
		variable digits, sizeOfData, index(0);
		variable remainingDays, minimumRemainingDays, expiryDate, dateOkay, remarks;

		processDate = GetDate("%Y-%m-%d");
		processTime = GetTime("%H:%M");
		if ( processedState == PS::successful ) 	
		{
			proState = "1";
			processStatus = VerDef::valid;
		}
		else
		{
			proState = "0";
			processStatus = VerDef::failed;
		}	

		if(processId == PID::TemperatureSummary)
		{// --- get temperature process information
			minimumRemainingDays = 9999;					// = very large 
			sizeOfData =  T_VAR::arrAction.GetSize();
			for(index = 0; index < sizeOfData; index++)
			{	// check for lowest value of remaining days
				remainingDays = ValidateDate(T_VAR::arrExpiryDate.GetAt(index), 0, expiryDate, dateOkay, remarks);		
				if (remainingDays < minimumRemainingDays ) minimumRemainingDays = remainingDays;																	
//Trace("Test: Temp.T_VAR::arrExpiryDate.GetAt(index) =>",T_VAR::arrExpiryDate.GetAt(index),"<   remainingDays 	 =>", remainingDays, "<  minimumRemainingDays =>", minimumRemainingDays, "<==");			
			}
			remainingDays 	= ValidateDate(processDate, minimumRemainingDays, expiryDate, dateOkay, remarks);		
			processDate 	= expiryDate;
			processTime 	= "23:59";
		}		

		if(processId == PID::ShakerSummary)
		{ // ---- get shaker process information
			minimumRemainingDays = 9999;					// = very large 
			sizeOfData =  S_VAR::arrAction.GetSize();
			for(index = 0; index < sizeOfData; index++)
			{	// check for lowest value of remaining days
				remainingDays = ValidateDate(S_VAR::arrExpiryDate.GetAt(index), 0, expiryDate, dateOkay, remarks);		
				if (remainingDays < minimumRemainingDays ) minimumRemainingDays = remainingDays;																	
			}
			remainingDays 	= ValidateDate(processDate, minimumRemainingDays, expiryDate, dateOkay, remarks);		
			processDate 	= expiryDate;
			processTime 	= "23:59";
		}		

		if(Util::IsInteger(processId)) 
		{
			if ((processId < 10) || ((VerDef::fwVersionC0 >= 6.3) && (processId < 25)))
			{  // process data will be stored on instrument
				if (VerDef::fwVersionC0 < 6.0) digits = 1; // FW version < 6.0: process ID definition with 1 digit (vo#)
					else 								 digits = 2; // FW version >= 6.0: process ID definition with 2 digits (vo##

				// firmware command and parameter to store verification data
				fwCommand = "C0AV";

				fwParameter = ComposeCompletePrm("vo", digits, processId);
				fwParameter = fwParameter + "vd";
				fwParameter = fwParameter + processDate;
				fwParameter = fwParameter + " " + processTime;
				fwParameter = fwParameter + "vs";
				fwParameter = fwParameter + proState;
	
				FwCommand( fwCommand, fwParameter, hslTrue, ML_STAR );
			}
		}
		// ---- update current process ID information
		PID::summaryStatus 			= PS::successful;
		PID::summaryRemainingDays 	= 9999;					// = very large 

		sizeOfData = G_VAR::arrProcessID.GetSize();
		for(index = 0; index < sizeOfData; index++)
		{
			if (processId == G_VAR::arrProcessID.GetAt(index) )
			{
				verInterval = G_VAR::arrVerificationInterval.GetAt(index);
				G_VAR::arrStatus.SetAt(index, processStatus);
				if((processId == PID::TemperatureSummary) || (processId == PID::ShakerSummary)) 
								G_VAR::arrRemainingDays.SetAt(index, minimumRemainingDays);
				else 			G_VAR::arrRemainingDays.SetAt(index, verInterval);
			}
			if (G_VAR::arrStatus.GetAt(index) != VerDef::valid) PID::summaryStatus = PS::failed;
			// check for lowest value of remaining days
			if (PID::summaryRemainingDays > G_VAR::arrRemainingDays.GetAt(index)) 
																		PID::summaryRemainingDays = G_VAR::arrRemainingDays.GetAt(index);	
//Trace("Test: Compare remainingDays at index =>",index,"<  for process ID ", G_VAR::arrProcessID.GetAt(index), ":  =>",G_VAR::arrRemainingDays.GetAt(index), "< summaryRemainingDays ==>",PID::summaryRemainingDays ,"<==");
		}		
		sn = "";
		UpdateVerificationInformation(0,StrConcat2(PID::General,processId),proState, verInterval, processTime, sn, processDate);

//Trace("Test: Storing process data for process ID ", processId, ":  processDate =>",processDate,
//					"<  processTime ==>",processTime, "< verificationInterval ==>",verInterval, "< proState ==>",proState,"<==");

		// --- store summary state
		if ( PID::summaryStatus == PS::successful ) 	proState = "1";
			else 													proState = "0";
		processDate = GetDate("%Y-%m-%d");
		verInterval = 0;
      if(VerDef::isRoche) remainingDays = ValidateDate(processDate, PID::summaryRemainingDays - VerDef::_200Days, expiryDate, dateOkay, remarks);
      else	              remainingDays = ValidateDate(processDate, PID::summaryRemainingDays, expiryDate, dateOkay, remarks);

		UpdateVerificationInformation(1,StrConcat2(PID::General,PID::Summary),proState, verInterval, processTime, sn, expiryDate);

//Trace("Test: Storing process summary data for process ID ", PID::Summary, ":  expiryDate =>",expiryDate, "< proState ==>",proState,"<==");

		// summary process data will be stored on instrument
		if (VerDef::fwVersionC0 < 6.0) digits = 1; // FW version < 6.0: process ID definition with 1 digit (vo#)
			else 								 digits = 2; // FW version >= 6.0: process ID definition with 2 digits (vo##

		// firmware command and parameter to store verification data
		fwCommand = "C0AV";

		fwParameter = ComposeCompletePrm("vo", digits, PID::Summary);
		fwParameter = fwParameter + "vd";
		fwParameter = fwParameter + expiryDate;
		fwParameter = fwParameter + " 23:59";
		fwParameter = fwParameter + "vs";
		fwParameter = fwParameter + proState;

		FwCommand( fwCommand, fwParameter, hslTrue, ML_STAR );

	} // End of function "StoreProcessDataOnInstrument"

// -------------------------------------------------------------------------------------------------------
// Update verifications configuration data according pre-defined deck layout
function UpdateVerificationDataDueToDeckInfo(device ML_STAR)
// -------------------------------------------------------------------------------------------------------
{
		variable array_of_templateNames[], array_of_labwareNames[], arrLabPosition[];
		variable templateID, labwareID, labDeviceType, temperatureNominalValue, frequencyNominalValue;
		variable i, index, k;
		variable processID, keyWord(""), comPort(""),validStatus(""), processStatus(""), trackNo, trackNo_old, siteNo, serialNo("");
		variable deviceType, processDate, timeOffset, expiryDate, dateOkay, remarks, remainingDays;
		variable processedState, processedDate , processedTime, verInterval;
		variable setValue, setOffset, specValue, sensorCorr, measuredValue, measuredValue_2;
		variable prop2, prop3, sn, date,lastCheck(""),lcd(""),lcb(""); // dummy place holder ;
		variable isVerCarrier(hslTrue), requestedAction;
		variable userMessages[];
		variable labArrangeNo, labPositionText; 
		variable summaryStatus, summaryRemainingDays;
		variable arrTLabID[], arrTLabArrangeNo[], arrTLabPositionText[], arrTLabDeviceID[];	
		variable arrSLabID[], arrSLabArrangeNo[], arrSLabPositionText[];	

		userMessages.SetSize(0);
		// update  data from deck file
		timeOffset = VerDef::_200Days;
		ML_STAR.GetTemplateLabwareNames( array_of_templateNames, array_of_labwareNames );
//VerTool::TraceArray(" UpdateVerificationDataDueToDeckInfo: --- array_of_templateNames ----", array_of_templateNames);
//VerTool::TraceArray(" UpdateVerificationDataDueToDeckInfo: --- array_of_labwareNames ----", array_of_labwareNames);

		for (i = 0; i < array_of_labwareNames.GetSize();i++ )
		{ 
			// check for verification labware definitions 
			templateID		= array_of_templateNames.ElementAt(i);
			labwareID 		= array_of_labwareNames.ElementAt(i);
//			labDeviceType 	= DevGetLabwareData(ML_STAR, labwareID, VerDef::PropVerDevice);
			labDeviceType 	= getLabwarePropertyData(ML_STAR, labwareID, VerDef::PropVerDevice, "s",userMessages);
			if(labDeviceType != "")
			{
				ML_STAR.GetLabwarePositionEx( labwareID , arrLabPosition, "" );
//Trace(" CarrierName =>",labwareID,	"<  X1 position => ",arrLabPosition.GetAt(6),
//												"<  y1 position => ",arrLabPosition.GetAt(7),
//												"<==");
//				Trace("Labware =>", labwareID,"<  labPropValue ==>",labDeviceType ,"<==");
				trackNo = Ceiling((arrLabPosition.GetAt(6)-80)/22.5);
				// calculate  value which represents deck arrangment (lowest value is on rear, left side of the deck)
				labArrangeNo = 1000 * Ceiling(arrLabPosition.GetAt(6)) + 800 - Ceiling(arrLabPosition.GetAt(7)) + (0.001 * i) +0.5;
				labPositionText = StrConcat4(Ceiling(arrLabPosition.GetAt(6))," / " , Ceiling(arrLabPosition.GetAt(7)),"");
				isVerCarrier = hslTrue;
				if 		(labDeviceType == VerDef::carrierName_Reagent ) keyWord = VerDef::KeyBalanceCarTrack;
				else if 	(labDeviceType == VerDef::carrierName_TipPlate) keyWord = VerDef::KeyTipPlateCarTrack;
				else if 	(labDeviceType == VerDef::carrierName_Barcode ) keyWord = VerDef::KeyBarCode_CarTrack;
				else isVerCarrier = hslFalse;

				if (isVerCarrier)
				{ // update carrier position definitions
					if (VerDef::predefinedLayout > 0 )
					{
						GetVerificationInformation(keyWord, trackNo_old, serialNo, validStatus ,sn, lastCheck,lcd,lcb);
						if(labDeviceType == VerDef::carrierName_Reagent ) trackNo = trackNo  + 6;

//	Trace(" CarrierName =>",labwareID,"<  X position => ",arrLabPosition.GetAt(6),"< track position =>",trackNo);	
						UpdateVerificationInformation(0, keyWord,trackNo, serialNo, validStatus ,sn, lastCheck);
					}
				}
				else
				{  // heater/cooler and shaker labware definitions
//					temperatureNominalValue = IVal(DevGetLabwareData(ML_STAR, labwareID, VerDef::PropVER_Temperature));
					temperatureNominalValue = getLabwarePropertyData(ML_STAR, labwareID, VerDef::PropVER_Temperature, "i",userMessages);
					if (temperatureNominalValue == 0) //temperatureNominalValue = IVal(DevGetLabwareData(ML_STAR, labwareID, VerDef::PropVER_Temperature_2));
						temperatureNominalValue = getLabwarePropertyData(ML_STAR, labwareID, VerDef::PropVER_Temperature_2, "i",userMessages);

					if (temperatureNominalValue > 0) 
					{
						arrTLabID.AddAsLast(labwareID);
						arrTLabArrangeNo.AddAsLast(labArrangeNo);
						arrTLabPositionText.AddAsLast(labPositionText);
						if	(labDeviceType == VerDef::TCC) arrTLabDeviceID.AddAsLast(templateID);
							else 									 arrTLabDeviceID.AddAsLast("");
					}

//					frequencyNominalValue = IVal(DevGetLabwareData(ML_STAR, labwareID, VerDef::PropVER_ShakerFrequency) );
					frequencyNominalValue = getLabwarePropertyData(ML_STAR, labwareID, VerDef::PropVER_ShakerFrequency, "i",userMessages);
					if (frequencyNominalValue > 0) 
					{
						arrSLabID.AddAsLast(labwareID);
						arrSLabArrangeNo.AddAsLast(labArrangeNo);
						arrSLabPositionText.AddAsLast(labPositionText);
					}		

					//Trace("Test: Labware =>", labwareID,"<  labPropValue ==>",labDeviceType ,"<  labArrangeNo==>",labArrangeNo,
					//	"< temperatureNominalValue ==>",temperatureNominalValue,"< frequencyNominalValue ==>",frequencyNominalValue,"<==");
				}
			}
		}

		// ------------ get features of temperature verification sites ----------------------------------------

		i							= VerDef::numberOfTemperatureSites = arrTLabID.GetSize();
		
		summaryStatus 			= PS::successful;
		summaryRemainingDays = 9999;
		T_VAR::arrDeviceID.SetSize(i);
		T_VAR::arrLabwareID.SetSize(i);
		T_VAR::arrStatus.SetSize(i);
		T_VAR::arrDeckPosition.SetSize(i);
		T_VAR::arrSerialNumber.SetSize(i);
		T_VAR::arrDescription.SetSize(i);
		T_VAR::arrInputRemarks.SetSize(i);
		T_VAR::arrExpiryDate.SetSize(i);
		T_VAR::arrAction.SetSize(i);

		T_VAR::arrSetValue.SetSize(i);
		T_VAR::arrOffsetValue.SetSize(i);
		T_VAR::arrCriteriaValue.SetSize(i);
		T_VAR::arrSensorCorrection.SetSize(i);
		T_VAR::arrMeasuredValue.SetSize(i);
		T_VAR::arrRecordedValues.SetSize(i);

		T_VAR::arrSetValue_2.SetSize(i);
		T_VAR::arrOffsetValue_2.SetSize(i);
		T_VAR::arrCriteriaValue_2.SetSize(i);
		T_VAR::arrSensorCorrection_2.SetSize(i);
		T_VAR::arrMeasuredValue_2.SetSize(i);
		T_VAR::arrRecordedValues_2.SetSize(i);

		for (i = 0; i < VerDef::numberOfTemperatureSites;i++ )
		{ 
			index = 0;
			labwareID 		= arrTLabID.GetAt(i);
			labArrangeNo 	= arrTLabArrangeNo.GetAt(i);
			for (k = 0; k < VerDef::numberOfTemperatureSites; k++ ) if ( labArrangeNo > arrTLabArrangeNo.GetAt(k)) index++; 

			processID = PID::Temperature + arrTLabID.GetAt(i);
//Trace("Test: Temp processID =>", processID ,"<  labArrangeNo ==>",labArrangeNo ,"<  index==>",index,"<==");
		
			T_VAR::arrLabwareID.SetAt(index, labwareID);			// array of verification labware ID
			GetProcessDataFromFile(processID, processedState, processedDate , processedTime, verInterval);
//Trace("Test: Temp processID =>", processID ,"<  processedState ==>",processedState ,"<  processedDate ==>",processedDate,"< verInterval ==>",verInterval,"<==");
			remainingDays	= VerTool::ValidateDate(processedDate, verInterval, expiryDate, dateOkay, remarks);
//Trace("Test: Remaining days =>",remainingDays,"<==");
			requestedAction 	= 0;
			processStatus 		= VerDef::valid;
			if (remainingDays < 0) 
			{
				requestedAction	= 1;
				processStatus 		= VerDef::invalid;
				remarks				= VerDef::invalid;
				summaryStatus 		= PS::failed;
			}
			if (processedState == PS::failed) 
			{
				requestedAction 	= 1;
				processStatus 		= VerDef::failed;
				remarks				= VerDef::failed;
				summaryStatus 		= PS::failed;
			}
			if (processedState == PS::excluded) 
			{ // Verification status was excluded by user
				requestedAction 	= 1;
				processStatus 		= VerDef::excluded;
				remarks				= VerDef::excluded;
				summaryStatus 		= PS::failed;
			}
			if (processedState == PS::accepted) 
			{ // Verification status was accepted/confirmed by user
				processStatus 		= VerDef::confirmed;
			}

			T_VAR::arrStatus.SetAt(index, 			processStatus);
			T_VAR::arrDeckPosition.SetAt(index, 	arrTLabPositionText.GetAt(i));
			T_VAR::arrSerialNumber.SetAt(index, 	//DevGetLabwareData(ML_STAR, labwareID, VerDef::PropVerSerialNumber));
															getLabwarePropertyData(ML_STAR, labwareID, VerDef::PropVerSerialNumber, "s",userMessages));
			
			T_VAR::arrDescription.SetAt(index, 		//DevGetLabwareData(ML_STAR, labwareID, VerDef::PropVerDescription));
															getLabwarePropertyData(ML_STAR, labwareID, VerDef::PropVerDescription, "s",userMessages));
			T_VAR::arrInputRemarks.SetAt(index, 	remarks);
			T_VAR::arrExpiryDate.SetAt(index, 		expiryDate);
			T_VAR::arrAction.SetAt(index, 			requestedAction);
			T_VAR::arrDeviceID.SetAt(index, 			arrTLabDeviceID.GetAt(i));

			// check for lowest value of remaining days
			if (summaryRemainingDays > remainingDays) summaryRemainingDays = remainingDays;

			processID = PID::Temperature_1 + labwareID ;
			if(GetVerificationInformation(processID , setValue, setOffset, measuredValue, specValue, date, lcd, lcb) == 0)
			{
				measuredValue	= "0.0";
			}
			setValue		= getLabwarePropertyData(ML_STAR, labwareID, VerDef::PropVER_Temperature, "s",userMessages);
			setOffset	= getLabwarePropertyData(ML_STAR, labwareID, VerDef::PropVER_TemperatureOffset, "s",userMessages);
			specValue	= getLabwarePropertyData(ML_STAR, labwareID, VerDef::PropVER_TemperatureCritera, "s",userMessages);
			sensorCorr	= getLabwarePropertyData(ML_STAR, labwareID, VerDef::PropVER_SensorCorrection, "s",userMessages);

			T_VAR::arrSetValue.SetAt(index, 			FVal(setValue));
			T_VAR::arrOffsetValue.SetAt(index, 		FVal(setOffset)); 
			T_VAR::arrCriteriaValue.SetAt(index,	FVal(specValue)); 
			T_VAR::arrSensorCorrection.SetAt(index,FVal(sensorCorr)); 
			T_VAR::arrMeasuredValue.SetAt(index, 	FVal(measuredValue));

			processID = PID::Temperature_2 + labwareID ;
			if(GetVerificationInformation(processID , setValue, setOffset, measuredValue, specValue, date, lcd, lcb) == 0)
			{
				measuredValue	= "0.0";
			}
			setValue		= getLabwarePropertyData(ML_STAR, labwareID, VerDef::PropVER_Temperature_2, "s",userMessages);
			setOffset	= getLabwarePropertyData(ML_STAR, labwareID, VerDef::PropVER_TemperatureOffset_2, "s",userMessages);
			specValue	= getLabwarePropertyData(ML_STAR, labwareID, VerDef::PropVER_TemperatureCritera_2, "s",userMessages);
			sensorCorr	= getLabwarePropertyData(ML_STAR, labwareID, VerDef::PropVER_SensorCorrection_2, "s",userMessages);


			T_VAR::arrSetValue_2.SetAt(index, 		FVal(setValue));
			T_VAR::arrOffsetValue_2.SetAt(index, 	FVal(setOffset)); 
			T_VAR::arrCriteriaValue_2.SetAt(index,	FVal(specValue)); 
			T_VAR::arrSensorCorrection_2.SetAt(index,FVal(sensorCorr)); 
			T_VAR::arrMeasuredValue_2.SetAt(index, FVal(measuredValue));

			processID = PID::Recorded_Temp + labwareID ;
			if(GetVerificationInformation(processID ,measuredValue, measuredValue_2, prop3, sn, date,lcd,lcb) == 0)
			{
				measuredValue	= measuredValue_2 = "/ /";
			}
//Trace("Test: GetData of =>",processID,"<  measuredValue ==>",measuredValue,"<==");
//Trace("Test: GetData of =>",processID,"<  measuredValue_2 ==>",measuredValue_2,"<==");
			T_VAR::arrRecordedValues.SetAt(index, measuredValue);
			T_VAR::arrRecordedValues_2.SetAt(index, measuredValue_2);
		}
//VerTool::TraceArray("Test: UpdateVerificationDataDueToDeckInfo: --- T_VAR::arrDescription ----", T_VAR::arrDescription);
//VerTool::TraceArray("Test: UpdateVerificationDataDueToDeckInfo: --- T_VAR::arrSetValue ----", T_VAR::arrSetValue);
//VerTool::TraceArray("Test: UpdateVerificationDataDueToDeckInfo: --- T_VAR::arrSetValue_2 ----", T_VAR::arrSetValue_2);
//VerTool::TraceArray("Test: UpdateVerificationDataDueToDeckInfo: --- T_VAR::arrAction----",T_VAR::arrAction);
		
		// store temperature device summary state
		processID 		= PID::TemperatureSummary;
		processedDate 	= GetDate("%Y-%m-%d");
		processedTime	= GetTime("%H:%M");
		verInterval 	= 0;
		sn					= "";

		ValidateDate(processedDate , summaryRemainingDays, expiryDate, dateOkay, remarks);	
		UpdateVerificationInformation(0,StrConcat2(PID::General, processID), summaryStatus, verInterval, processedTime, sn, expiryDate);
		
		//------------ get features of shaker verification sites		--------------------------------------------------------

		i 							= VerDef::numberOfShakerSites = arrSLabID.GetSize();
		summaryStatus 			= PS::successful;
		summaryRemainingDays = 9999;

		S_VAR::arrDeviceID.SetSize(i);		
		S_VAR::arrLabwareID.SetSize(i);
		S_VAR::arrStatus.SetSize(i);
		S_VAR::arrSerialNumber.SetSize(i);
		S_VAR::arrDeckPosition.SetSize(i);
		S_VAR::arrDescription.SetSize(i);
		S_VAR::arrInputRemarks.SetSize(i);
		S_VAR::arrExpiryDate.SetSize(i);
		S_VAR::arrAction.SetSize(i);

		S_VAR::arrFreqSetValue.SetSize(i);
		S_VAR::arrFreqCriteriaValue.SetSize(i);
		S_VAR::arrFreqMeasuredValue.SetSize(i);

		S_VAR::arrOrbitSetValue.SetSize(i);
		S_VAR::arrOrbitCriteriaValue.SetSize(i);
		S_VAR::arrOrbitMeasuredValue.SetSize(i);

		for (i = 0; i < VerDef::numberOfShakerSites;i++ )
		{ 
			index = 0;
			labwareID 		= arrSLabID.GetAt(i);
			labArrangeNo 	= arrSLabArrangeNo.GetAt(i);
			for (k = 0; k < VerDef::numberOfShakerSites; k++ ) if ( labArrangeNo > arrSLabArrangeNo.GetAt(k)) index++; 
			processID = PID::Shaker + arrSLabID.GetAt(i);
			//Trace("Test: Shaker Labware =>", arrSLabID.GetAt(i),"<  labArrangeNo ==>",labArrangeNo ,"<  index==>",index,"<==");

			S_VAR::arrLabwareID.SetAt(index, labwareID);			// array of verification labware ID
			// array of verification process ID
			GetProcessDataFromFile(processID, processedState, processedDate , processedTime, verInterval);

			//Trace("Test: GetProcessDataFromFile:  processID =>", processID,"<  processedState ==>",processedState ,"<  processedDate ==>",processedDate,"<==");

			remainingDays	= VerTool::ValidateDate(processedDate, verInterval, expiryDate, dateOkay, remarks);
//Trace("Test: Remaining days =>",remainingDays,"<==");
			requestedAction 	= 0;
			processStatus 		= VerDef::valid;
			if (remainingDays < 0) 
			{
				requestedAction 	= 1;
				processStatus 		= VerDef::invalid;		
				remarks		 		= VerDef::invalid;		
				summaryStatus 		= PS::failed;
			}
			if (processedState == PS::failed) 
			{
				requestedAction	= 1;
				processStatus 		= VerDef::failed;
				remarks		 		= VerDef::failed;
				summaryStatus 		= PS::failed;
			}
			if (processedState == PS::excluded) 
			{ // Verification status was excluded by user
				requestedAction 	= 1;
				processStatus 		= VerDef::excluded;
				remarks				= VerDef::excluded;
				summaryStatus 		= PS::failed;
			}
			if (processedState == PS::accepted) 
			{ // Verification status was accepted/confirmed by user
				processStatus 		= VerDef::confirmed;
			}

			S_VAR::arrStatus.SetAt(index, 		processStatus);
			S_VAR::arrDeckPosition.SetAt(index, arrSLabPositionText.GetAt(i));
			S_VAR::arrSerialNumber.SetAt(index, //DevGetLabwareData(ML_STAR, labwareID, VerDef::PropVerSerialNumber));
															getLabwarePropertyData(ML_STAR, labwareID, VerDef::PropVerSerialNumber, "s",userMessages));

			S_VAR::arrDescription.SetAt(index, 	//DevGetLabwareData(ML_STAR, labwareID, VerDef::PropVerDescription));
															getLabwarePropertyData(ML_STAR, labwareID, VerDef::PropVerDescription, "s",userMessages));
			S_VAR::arrInputRemarks.SetAt(index, remarks);
			S_VAR::arrExpiryDate.SetAt(index, 	expiryDate);
			S_VAR::arrAction.SetAt(index, 		requestedAction);
			S_VAR::arrDeviceID.SetAt(index, 		//DevGetLabwareData(ML_STAR, labwareID, VerDef::PropVER_ModuleAddress));
															getLabwarePropertyData(ML_STAR, labwareID, VerDef::PropVER_ModuleAddress, "s",userMessages));

			// check for lowest value of remaining days
			if (summaryRemainingDays > remainingDays) summaryRemainingDays = remainingDays;

			processID = PID::Shaker_Ampl + labwareID ;
			if(GetVerificationInformation(processID , setValue, measuredValue, specValue, sn, date, lcd, lcb) == 0)
			{
				measuredValue	= "0.0";
			}
//			setValue 	= DevGetLabwareData(ML_STAR, labwareID, VerDef::PropVER_ShakerOrbit);
			setValue 	= getLabwarePropertyData(ML_STAR, labwareID, VerDef::PropVER_ShakerOrbit, "s",userMessages);
//			specValue	= DevGetLabwareData(ML_STAR, labwareID, VerDef::PropVER_ShakerOrbitCriteria);
			specValue	= getLabwarePropertyData(ML_STAR, labwareID, VerDef::PropVER_ShakerOrbitCriteria, "s",userMessages);
			S_VAR::arrOrbitSetValue.SetAt(index, 		FVal(setValue));
			S_VAR::arrOrbitCriteriaValue.SetAt(index,	FVal(specValue)); 
			S_VAR::arrOrbitMeasuredValue.SetAt(index, 	FVal(measuredValue));

			processID = PID::Shaker_Freq + labwareID ;
			if(GetVerificationInformation(processID , setValue, measuredValue, specValue, sn, date, lcd, lcb) == 0)
			{
				measuredValue	= "0.0";
			}
//			setValue 	= DevGetLabwareData(ML_STAR, labwareID, VerDef::PropVER_ShakerFrequency);
			setValue 	= getLabwarePropertyData(ML_STAR, labwareID, VerDef::PropVER_ShakerFrequency, "s",userMessages);
//			specValue	= DevGetLabwareData(ML_STAR, labwareID, VerDef::PropVER_ShakerFrequencyCritera);
			specValue	= getLabwarePropertyData(ML_STAR, labwareID, VerDef::PropVER_ShakerFrequencyCritera, "s",userMessages);

			S_VAR::arrFreqSetValue.SetAt(index, 		FVal(setValue));
			S_VAR::arrFreqCriteriaValue.SetAt(index,	FVal(specValue)); 
			S_VAR::arrFreqMeasuredValue.SetAt(index, 	FVal(measuredValue));
		}

//VerTool::TraceArray("Test: UpdateVerificationDataDueToDeckInfo: --- S_VAR::arrDescription ----", S_VAR::arrDescription);
//VerTool::TraceArray("Test: UpdateVerificationDataDueToDeckInfo: --- S_VAR::arrFreqSetValue ----", S_VAR::arrFreqSetValue);
//VerTool::TraceArray("Test: UpdateVerificationDataDueToDeckInfo: --- S_VAR::arrAction----",S_VAR::arrAction);
//VerTool::TraceArray("Test: UpdateVerificationDataDueToDeckInfo: --- S_VAR::arrStatus----",S_VAR::arrStatus);
		
		// store temperature device summary state
		processID 		= PID::ShakerSummary;
		processedDate 	= GetDate("%Y-%m-%d");
		processedTime	= GetTime("%H:%M");
		verInterval 	= 0;
		sn					= "";

		ValidateDate(processedDate , summaryRemainingDays, expiryDate, dateOkay, remarks);	
		UpdateVerificationInformation(0,StrConcat2(PID::General, processID), summaryStatus, verInterval, processedTime, sn, expiryDate);

		UpdateVerificationInformation(1, VerDef::KeySave,"", "", "","", ""); // write configuration data to coresponding file
		//Trace("Test: Number of defined temperature controlled sites =>", VerDef::numberOfTemperatureSites,"<==");
		//Trace("Test: Number of defined frequency controlled sites   =>", VerDef::numberOfShakerSites,"<==");

		VerTool::VerificationUserMessagesDialog(LdT("Error in heater/cooler definitions on modified deck:"),  userMessages, LdT("Define all requested properties, marked with '(tbd)'."));

} // End of function "UpdateVerificationDataDueToDeckInfo"

// -------------------------------------------------------------------------------------------------------
// Remove specific labware from deck, if present
function RemovePresentLabware(device ML_STAR, variable labwareID)
// -------------------------------------------------------------------------------------------------------
{
		variable array_of_templateNames[], array_of_labwareNames[];
		variable i;

		//If labware name already exists, remove "old" labware first
		ML_STAR.GetTemplateLabwareNames( array_of_templateNames, array_of_labwareNames );
		for (i = 0; i < array_of_labwareNames.GetSize();i++ )
		{
			if (array_of_labwareNames.ElementAt(i) == labwareID)
			{
//Trace(" Labware ", array_of_labwareNames.ElementAt(i), " had to be removed previous adding same labware on deck!");
					ML_STAR.RemoveLabware( labwareID);
					break;
			}
		}
} // End of function "RemovePresentLabware"

// -------------------------------------------------------------------------------------------------------
// Add rack on carrier 
	function AddRackOnCarrier(
								variable carrierPosition,		// carrier position (= site ID)
								variable rackType,				// racktype
								variable rackID,					// rack ID
								sequence& seqRackPositions)	// add sequence position of corresponding rack 
// -------------------------------------------------------------------------------------------------------
{
		variable rackConfigFile(""), labwarePath("");
		variable index, rackPositions,loopNo, currentPosition;
		variable tempText("");

		if (carrierPosition == VerDef::site_ResetAll)
		{ // restet array definitions of carrier site information
		 	arrayRackID.SetSize( 0 );
			arrayRackConfigFile.SetSize( 0 );
			loop (16)
			{
				arrayRackID.AddAsLast( "" );
				arrayRackConfigFile.AddAsLast( "" );
			}
			return;
		}
//Trace("Test: AddRackOnCarrier of ", carrierPosition, "<  		rackType =>", rackType,"<  rackID =>", rackID, "<==");	
		rackPositions 	= 96;
		loopNo			= 1;
		if (rackType == VerDef::_5ml_Bowl)	 				{rackConfigFile = rackFileName_5mlBowl;rackPositions = 1; loopNo = 16;}
		if (rackType == VerDef::_8ml_Tube)	 				{rackConfigFile = rackFileName_8mlTube;rackPositions = 1; loopNo = 16;}
		if (rackType == VerDef::_96erPlate) 				rackConfigFile = rackFileName_96erPlate;
		if (rackType == VerDef::_384erPlate)				{rackConfigFile = rackFileName_384erPlate;rackPositions = 384;}
		if (rackType == VerDef::Reagent_Container_8Ch)	{rackConfigFile = rackFileName_Reagent_8;rackPositions = 8; loopNo = 2;}
		if (rackType == VerDef::Reagent_Container_384Ch){rackConfigFile = rackFileName_Reagent_384; rackPositions = 384;}
		if (rackType == VerDef::Reagent_Container_96Ch)	rackConfigFile = rackFileName_Reagent_96;

		if (rackType == VerDef::TipRack_10ul) 				rackConfigFile = rackFileName_TipRack_10ul;
		if (rackType == VerDef::TipRack_50ul) 				rackConfigFile = rackFileName_TipRack_50ul;
		if (rackType == VerDef::TipRack_300ul) 			rackConfigFile = rackFileName_TipRack_300ul;
		if (rackType == VerDef::TipRack_1000ul) 			rackConfigFile = rackFileName_TipRack_1000ul;
		if (rackType == VerDef::TipRack_1000ulFilter)	rackConfigFile = rackFileName_FilterTipRack_1000ul;
		if (rackType == VerDef::TipRack_5ml)				{rackConfigFile = rackFileName_TipRack_5ml;rackPositions = 24;loopNo = 1;}
		if (rackType == VerDef::TipRack_384pHead_50ul)	
														{rackConfigFile = rackFileName_TipRack_384Tips_50ul; rackPositions = 384;loopNo = 1;}
		if (rackType == VerDef::TipRack_384pHead_50ul_c)	
														{rackConfigFile = rackFileName_TipRack_384cTips_50ul; rackPositions = 384;loopNo = 1;}
		if (rackType == VerDef::TipRack_TeachingNeedles)
														{rackConfigFile = rackFileName_TipRack_TeachingNeedles;rackPositions = 4; loopNo = 1;}																				
		if (rackType == VerDef::TipRack_5mlTeachingNeedles)
														{rackConfigFile = rackFileName_TipRack_5mlTeachingNeedles;rackPositions = 2; loopNo = 1;}																				
		if (rackType == VerDef::TipRack_96TeachingNeedles)
														{rackConfigFile = rackFileName_TipRack_96TeachingNeedles;rackPositions = 96; loopNo = 1;}																				
		if (rackType == VerDef::TipRack_384TeachingNeedles)
														{rackConfigFile = rackFileName_TipRack_384TeachingNeedles;rackPositions = 384; loopNo = 1;}
		if (rackType == VerDef::Pyramid)		{rackConfigFile = rackFileName_Pyramid; rackPositions = 1;}
		if (rackType == VerDef::paperCard_Magazine_1) 	{rackConfigFile = rackFileName_PaperCardMagazine_1; rackPositions = 4;}
		if (rackType == VerDef::paperCard_Magazine_2) 	{rackConfigFile = rackFileName_PaperCardMagazine_2; rackPositions = 4;}
		if (rackType == VerDef::paperCard_Magazine_3) 	{rackConfigFile = rackFileName_PaperCardMagazine_3; rackPositions = 4;}
		if (rackType == VerDef::_DWP_2ml)					{rackConfigFile = rackFileName_DWP_2ml; rackPositions = 96;}
		if (rackConfigFile == "")
		{
			tempText = LdT("WARNING:") + " " + LdT("No labware  for  rack type '%s1' found!");
			StrReplace(tempText,"%s1",rackType);
			Trace(tempText);
			return;
		}
		
		// add information to corresponding array position
		if (carrierPosition == VerDef::site_Balance) index = 0;
		else 														index = IVal(carrierPosition);

		labwarePath = VerDef::labwareSubDirName;
		rackConfigFile = labwarePath + rackConfigFile ;
				
		arrayRackID.SetAt( index, rackID );
		arrayRackConfigFile.SetAt( index, rackConfigFile );
	
		// Add additional sequence position to pre-defined sequence. 
		//  Attention: only numeric position IDs (no alpha-numeric)
		loop(loopNo)
		{
			for (index = 1; index <= rackPositions; index++ )
			{
				seqRackPositions.Add( rackID, IStr(index));
			}
		}
		if (seqRackPositions.GetCurrentPosition() == 0)	seqRackPositions.SetCurrentPosition( 1 );

//Trace("Test: AddRackOnCarrier:	rackType =>", rackType,"<  rackPositions =>", rackPositions, "<  loopNo ==>",loopNo,"<  		rackConfigFile ==>",		rackConfigFile ,"<==");	

		return;

}  // ----  end of function "AddRackOnCarrier" ---


// -------------------------------------------------------------------------------------------------------
// Add template  on deck
	function AddTemplateOnDeck(
								device ML_STAR, 					// ML_STAR device
								variable templateID,				// template ID
								variable carrierType,			// template type
								variable trackNo)					// track position

// -------------------------------------------------------------------------------------------------------
{
		variable templateConfigFile(""),labwarePath("");//, plateName;
		variable i, xPos(0.0),yPos(0.0),zPos(0.0);
		variable arrayOfPositions[];
		variable array_of_templateNames[], array_of_labwareNames[];
		variable tempText("");

		if (carrierType == VerDef::TipPlate_Carrier) 		templateConfigFile = carFileName_TipPlate;
		if (carrierType == VerDef::ReagentCarBalance) 		templateConfigFile = carFileName_Balance;	
		if (carrierType == VerDef::WMC_Balance) 				templateConfigFile = carFileName_WMCBalance;				
		if (carrierType == VerDef::ReagentCarBalanceTube)	templateConfigFile = carFileName_BalanceTube;
		if (carrierType == VerDef::ReagentCarBalancePlate) templateConfigFile = carFileName_BalancePlate;
		if (carrierType == VerDef::BarcodeCarHorizonalBC) 	templateConfigFile = carFileName_BC_horizontal;
		if (carrierType == VerDef::BarcodeCarVerticalBC) 	templateConfigFile = carFileName_BC_vertical;
		if (carrierType == VerDef::easyPuncherModule)    	templateConfigFile = carFileName_PuncherModule;
		if (carrierType == VerDef::punchCardMagazine_1)   	templateConfigFile = carFileName_Magazine_1;
		if (carrierType == VerDef::punchCardMagazine_2)   	templateConfigFile = carFileName_Magazine_2;

		if (templateConfigFile == "")
		{
			tempText = LdT("WARNING:") + " " + LdT("No labware  for  carrier type '%s1' found!");
			StrReplace(tempText,"%s1",carrierType);
			Trace(tempText);
			return;
		}
		labwarePath = VerDef::labwareSubDirName;
		templateConfigFile = labwarePath + templateConfigFile;

		//If labware name already exists, remove "old" labware first
		ML_STAR.GetTemplateLabwareNames( array_of_templateNames, array_of_labwareNames );
		for (i = 0; i < array_of_labwareNames.GetSize();i++ )
		{
			if (array_of_labwareNames.ElementAt(i) == templateID)
			{
//Trace("Test:Warning: Labware ", array_of_labwareNames.ElementAt(i), " had to be removed previous adding same labware on deck!");
					ML_STAR.RemoveLabware( templateID);
					break;
			}
		}
		xPos = trackNo * 22.5 + 77.5; // track no 1 = x-pos = 100, offset = 22.5
		yPos = 63.0;
		zPos = 100.0;

		if (carrierType == VerDef::BarcodeCarVerticalBC) 	
		{ // adding offset of 1st position of rack: X= +14.5, Y = +479.5 Z = 0
			xPos = xPos +  14.5;
			yPos = yPos + 479.5;			
		}

		arrayOfPositions.SetSize( 4 );
		arrayOfPositions.SetAt( 0, xPos );
		arrayOfPositions.SetAt( 1, yPos );
		arrayOfPositions.SetAt( 2, zPos );
		arrayOfPositions.SetAt( 3, 0 );

		// Add new labware to deck 
		ML_STAR.AddLabware( templateID, templateConfigFile, arrayOfPositions, "" );
//Trace("Test: Deck: New template ->",templateID,"< at track =>",trackNo,"<  positions: X =>",arrayOfPositions.GetAt(0),
//					"<   positions Y =>", arrayOfPositions.GetAt(1),"<  positions Z =>", arrayOfPositions.GetAt(2), "<=");
		return;

}  // ----  end of function "AddTemplateOnDeck" ---

	//-----------------------------------------------------------------------------------------------------
	function ReadCell( variable column, variable row, variable& output)
	// Read cell content from Excel report file
	//-----------------------------------------------------------------------------------------------------
	{
		row = row - 1;
		
		RPD::reportFile.AddField(column, output, hslString );
		RPD::reportFile.Seek(row - 1 ,hslFirst);
		RPD::reportFile.ReadRecord();
		RPD::reportFile.RemoveFields();
	
		Trace("Test:  --- Read content of cell row =>",row,"<  column =>",column,"<  value =>",output,"< GetType ==>",GetType(output),"<==");

	} // -- end of function "ReadCell"

	//-----------------------------------------------------------------------------------------------------
	// Write cell content into Excel report file
	function WriteCell_2( variable column, variable row, variable value, variable valueType)
	//-----------------------------------------------------------------------------------------------------
	{
		variable checkString(""); 
		variable input;
	
		input = value;
		if(StrFind(valueType,"s") >=0) { input = StrConcat2(value,"");}
//		else								 	 { input = Floor(value +0.5);}

		if(RPD::showCellWriting > 0)
		{
			checkString = StrConcat2(input,"");
			StrReplace(checkString," ","");
			if(StrGetLength(checkString) > 0) Trace("Test:  --- Write content to cell row =>",row,"<  column =>",column,"<  value =>",input,"<==");
		}

		row = row - 1;
		
		RPD::reportFile.AddField(column, input, valueType );
		RPD::reportFile.Seek(row - 1 ,hslFirst);
		RPD::reportFile.UpdateRecord();
		RPD::reportFile.RemoveFields();

	} // ----  end of function "WriteCell" ---
	//-----------------------------------------------------------------------------------------------------
	static function WriteCell( variable column, variable row, variable value)
	// Write cell content into Excel report file
	//-----------------------------------------------------------------------------------------------------
	{
		WriteCell_2(column, row, value, hslString);

	} // ----  end of function "WriteCell" ---

	//-----------------------------------------------------------------------------------------------------
	private function newReportFile( variable& templateFile)
	// Create report file and open P_Data Worksheet (for extented data reporting)
	// variable &processId, variable &processedState)
	//-----------------------------------------------------------------------------------------------------
	{
		variable templateFileName, testedFiles, traceSource ;
		variable fileName, templateFileNotExist, fileOpenFailed;
		object reportReadOnly;
		object fso;  // file system object

		if (fso.IsNull()) fso.CreateObject("Scripting.FileSystemObject");
		traceSource = GetFunctionName() + ": ";

		// Evaluate the template file name respecting the current phoenix langauge.
		templateFileName = GetMethodsPath() + VerDef::templatesSubDirName + templateFile + GetLanguage() + ".xls";	// phoenix specific

 		if (!fso.FileExists(templateFileName)) 
		{
			testedFiles = templateFileName;
			templateFileName = GetMethodsPath() + "\\" + templateFile + "Enu.xls";		// The default language
			if (!fso.FileExists(templateFileName))
			{	
				testedFiles = testedFiles + "\n" + templateFileName;
				templateFileName = GetMethodsPath() + "\\" + templateFile + ".xls";		// No language
				if ("" == SearchPath(templateFileName))
				{
					string errorDesc;
					testedFiles = testedFiles + "\n" + templateFileName;
					templateFileNotExist = LdT("%s1 (%s2) : The template file for the report does not exist.\n\nOne of the following files must be provided as a template:\n%s3");
					errorDesc = templateFileNotExist;
					StrReplace(errorDesc, "%s1", GetFileName());
					StrReplace(errorDesc, "%s2", GetLineNumber());
					StrReplace(errorDesc, "%s3", testedFiles);
				   err.Raise(1 , errorDesc);
				}
			}
		}		
		if(VerDef::isRoche) 
		{
			fileName = StrConcat8("SN", VerDef::InstrumentSerialNo,"_",templateFile ,"_", GetDate("%Y%m%d"), GetTime("%H%M"),"");
		}
		else
		{
			fileName = StrConcat8(templateFile ,"_", VerDef::InstrumentSerialNo,"_", GetDate("%Y%m%d"), GetTime("%H%M"),"","");
		}
		RPD::reportFileName 	= StrConcat4(GetSystemPath(),"\\" , fileName,".xls");
		RPD::pdfReportFileName = StrConcat2(fileName, ".pdf");

		// If exist delete a previous created read-only report file & create a new report based on the template.
		// If its not read only the following copy will overrite it, but if its read only the copy fails.
		// A report file may already exist only if create report is called often for same report file name.
		CopyFile(templateFileName,  RPD::reportFileName, 0, 1);

		//make file writable
		reportReadOnly = fso.GetFile(RPD::reportFileName);
		reportReadOnly.Attributes = reportReadOnly.Attributes & 0;
		reportReadOnly.ReleaseObject();
		fso.ReleaseObject();

	} // end newReportFile


	//-----------------------------------------------------------------------------------------------------
	function OpenReportFile_2( variable& templateFile,variable fileCreate)
	// Create report file and open P_Data Worksheet (for extented data reporting)
	// variable &processId, variable &processedState)
	//-----------------------------------------------------------------------------------------------------
	{
		variable fileOpenFailed, sheetName;

		RPD::reportFile.Close();

		if(fileCreate) 
		{	
			sheetName = RPD::reportExcelAreaName_2;
			newReportFile(templateFile);
		}
		else 
		{
			sheetName = RPD::reportExcelAreaName;
		}
		
		// open file
		if (!RPD::reportFile.Open(RPD::reportFileName + " " + sheetName, hslAppend))
		{
			string errorDesc;
			fileOpenFailed = LdT("%s1 (%s2) : Failed to open the report file.");
			errorDesc = fileOpenFailed;
			StrReplace(errorDesc, "%s1", GetFileName());
			StrReplace(errorDesc, "%s2", GetLineNumber());
		   err.Raise(1 , errorDesc);
		}

	} // end OpenReportFile_2


	//-----------------------------------------------------------------------------------------------------
	function CreateReportFile( variable& templateFile)
	//, variable &processId, variable &processedState)
	//-----------------------------------------------------------------------------------------------------
	{
		variable fileOpenFailed;

		newReportFile(templateFile);	

		// open file with report worksheet
		if (!RPD::reportFile.Open(RPD::reportFileName + " " + RPD::reportExcelAreaName, hslAppend))
		{
			string errorDesc;
			fileOpenFailed = LdT("%s1 (%s2) : Failed to open the report file.");
			errorDesc = fileOpenFailed;
			StrReplace(errorDesc, "%s1", GetFileName());
			StrReplace(errorDesc, "%s2", GetLineNumber());
		   err.Raise(1 , errorDesc);
		}

	} // end CreateReportFile


	//-----------------------------------------------------------------------------------------------------
	function ShowReportFile( variable fileAndPath) variable
	//-----------------------------------------------------------------------------------------------------
	{
		variable program, executableProgram(""), tempText(""),traceSource;
		variable retVal;
		timer 	shortDelay;
		object fso;  // file system object

		if (fso.IsNull()) fso.CreateObject("Scripting.FileSystemObject");
		traceSource = GetFunctionName() + ": ";
		// open pdf file with acrobat reader
//Trace("Test: ", traceSource,":  File =>", fileAndPath,"<===");
		if (fso.FileExists(fileAndPath)) 
		{		
			executableProgram = "";
			StrMakeLower(fileAndPath);
			if(StrFind(fileAndPath, ".pdf") > 0) executableProgram = AcrobatExecutableProgram;
			if(StrFind(fileAndPath, ".xls") > 0) executableProgram = GetBinPath() + "\\" + ExcelViewerProgram;

			if (executableProgram == "") return(hslFalse);

			fileAndPath = "\"" + fileAndPath + "\"";
			if (StrFind(executableProgram,"\"") == 0 )	program = StrConcat4(executableProgram , " ", fileAndPath,"");
			else														program = StrConcat4("\"",executableProgram , "\" ", fileAndPath);

			shortDelay.SetTimer( 1 );
			shortDelay.WaitTimer( hslFalse, hslFalse );
Trace (GetFunctionName(), ": execute command  =>",program,"<==");
			retVal = Shell(program,hslShow, hslAsynchronous);	
			if (retVal == 0)
				{
					string errorMessage;
					errorMessage = "Failed to start program '%s1'";
					StrReplace(errorMessage , "%s1", program);
					MessageBox(errorMessage, "ERROR", hslError);
					return(hslFalse);
				}
			shortDelay.SetTimer( 1 );
			shortDelay.WaitTimer( hslFalse, hslFalse );
		}
		else
		{
			tempText = LdT("Open file '%s1' failed!");
			StrReplace(tempText,"%s1", fileAndPath );
			FormatTrace(traceSource, LdT("Open file"), VerDef::CMD_ERRCOMPL, tempText ); 
			return(hslFalse);
		}
		return(hslTrue);
	}  // ---  end of function "ShowReportFile"


	// --------------------------------------------------------------------------------------
	// Generate a pdf file from a source excel file with (alternative) program "PDF Creator" 
	// Generated pdf file has same basic name as source file plus date and time information but pdf extention
	function GeneratePDF_File_2(	)
	// --------------------------------------------------------------------------------------
	{
      variable Ready;
      variable Error,Description;
	   variable parameters;
		variable excelFileAndPath, tempText("");
		variable pdfFileName;
		variable traceSource(""), description;
	   object 	PDFCreatorObj;
	   object 	PDFCreatorOptionsObj;
	   object 	PDFCreatorErrorObj;
	   object 	PDFCreatorOptions;
		object 	fso;  // file system object
		timer  	delay;

		if (fso.IsNull()) fso.CreateObject("Scripting.FileSystemObject");
		traceSource = GetFunctionName() + ": ";
 
		// close file
		RPD::reportFile.Close();

		excelFileAndPath 	= RPD::reportFileName;

		onerror resume next;

		if (!fso.FileExists(excelFileAndPath)) 
		{
			tempText = LdT("Open file '%s1' failed!");
			StrReplace(tempText,"%s1", excelFileAndPath );
	 		FormatTrace(traceSource, LdT("Open file"), VerDef::CMD_ERRCOMPL, tempText); 
			return;
		}

		pdfFileName = RPD::pdfReportFileName;
		DeleteFile(GetSystemPath() + "\\" + pdfFileName);

Trace(" Test: Convert file with PDF Creator =>",excelFileAndPath,"<   into file ==>",pdfFileName,"<==");

		description= LdT("PDF file '%s1' will be generated soon ...");
		StrReplace(description, "%s1", pdfFileName );
 		FormatTrace(traceSource, "File generation:",VerDef::CMD_START , description); 

   //---------------------------------------------------------
   // Analyzes the COM object. If necessary it creates a 
   // reference to the COM object.
   //---------------------------------------------------------
		if (PDFCreatorObj.IsNull()) 			PDFCreatorObj.CreateObject("PDFCreator.clsPDFCreator");
		if (PDFCreatorOptionsObj.IsNull())	PDFCreatorOptionsObj.CreateObject("PDFCreator.clsPDFCreatorOptions");
      if (PDFCreatorErrorObj.IsNull())    PDFCreatorErrorObj.CreateObject("PDFCreator.clsPDFCreatorError");
   
		StrReplace(pdfFileName, ".pdf", "");
      parameters = "/NoProcessingAtStartup";
      PDFCreatorObj.cStart(parameters);
      PDFCreatorObj.cErrorClear();                           
      PDFCreatorOptions = PDFCreatorObj.cOptions;
      PDFCreatorOptions.UseAutosave = 1;                    // Use auto save functionality.
      PDFCreatorOptions.UseAutosaveDirectory = 1;           // Use directory for saving the file.   
      PDFCreatorOptions.AutosaveDirectory = GetSystemPath();// Name of the output directory.   
      PDFCreatorOptions.AutosaveFilename = pdfFileName;  	// Name of the output file name.
      PDFCreatorOptions.AutosaveFormat = 0;                 // Format in which file is to be saved. 0 if for pdf.
      PDFCreatorOptions.AutosaveStartStandardProgram = 0;   // don't open pdf file after creation
      PDFCreatorObj.cOptions = PDFCreatorOptions;            
      PDFCreatorObj.cSaveOptions(PDFCreatorOptions);
      PDFCreatorObj.cShowOptionsDialog(0);                  //    Hide the options dialog during processing:  
      PDFCreatorObj.cClearCache();
      PDFCreatorObj.cVisible = 0 ;                          // FALSE; = 0 PDF nicht anziegen!
	   PDFCreatorObj.cPrintFile(excelFileAndPath);
      PDFCreatorObj.cPrinterStop = 0;  

      Ready = 0;      // FLASE = 0 TRUE = 1
		while (!Ready == 1)
		{
			Ready = PDFCreatorObj.cIsConverted;
		}

      PDFCreatorErrorObj = PDFCreatorObj.cError;
      Error = PDFCreatorErrorObj.Number;
		if (!Error == 0)
		{
			Trace("Test PDFCreatorObj Return code  ==>" ,Error,"<==");
			/*
			-2 Unknown Event! 
			-1 Test Error Event. 
			1 The ActiveX-Server has not been started! Please use function "cStart()" to start the ActiveX-Server! 
			2 An instance of the PDFCreator is already running. It is not allowed to have more than one instance running! 
			3 Unknown Options Name '%1' in '%2'! 
			4 Ghostscript Error: '%1'! 
			5 The file '%1' could not be found! 
			6 No valid path '%1' was given! 
			7 The file '%1' is in use! 
			8 Function '%1': Options1 is not a 'clsPDFCreatorOptions' type! 
			9 No valid postscript file '%1' was given! 
			10 Empty array 'Arguments'! 
			11 The profile '%1' doesn't exists! 
			12 The profile '%1' already exists! 
			13 The name for the profile mustn't be empty! 
			14 You can't delete the profile '%1' because it is associated with the printer '%2'. 
			15 The old profile '%1' has the same name like the new profile '%2'. 
			16 The printer '%1' is not installed! 
			17 The printer '%1' is already installed! 
			18 You must be an administrator to install or delete a printer! 
			19 The printer is not a PDFCreator printer! 
			*/  
			Trace("Test: Can not converter PDF!","PDF Conversion Error Code " ,hslError);
		}
		//release objects
		if (!PDFCreatorObj.IsNull())
		{
			PDFCreatorObj.cPrinterStop = 1;   // TRUE = 1
			delay.SetTimer(1); delay.WaitTimer( hslFalse, hslFalse );
			PDFCreatorObj.cClose;                    
			PDFCreatorObj.ReleaseObject(); // release the object
			delay.SetTimer(3); delay.WaitTimer( hslFalse, hslFalse );
		}
		if (!PDFCreatorOptionsObj.IsNull()) 	PDFCreatorOptionsObj.ReleaseObject(); // release the object
		if (!PDFCreatorErrorObj.IsNull())	   PDFCreatorErrorObj.ReleaseObject(); // release the object
		if (!PDFCreatorObj.IsNull())			   PDFCreatorObj.ReleaseObject(); // release the object

		delay.SetTimer( 4 );delay.WaitTimer( hslFalse, hslFalse );

		pdfFileName = GetSystemPath() + "\\" + RPD::pdfReportFileName;
		if (fso.FileExists(pdfFileName)) 
		{	
			if(RPD::keepExcelFile < 1) DeleteFile(excelFileAndPath);
			description= LdT("PDF file '%s1' generated!");
			StrReplace(description, "%s1", pdfFileName );
 			FormatTrace(traceSource, "File generation:",VerDef::CMD_COMPLET , description); 
			ShowReportFile(pdfFileName);
		}
		else 	ShowReportFile(excelFileAndPath);
	
	return;
	}  // end of function "GeneratePDF_File_2"

	// --------------------------------------------------------------------------------------
	// Generate a pdf file from a source excel file with program "PDFcamp Printer Pro v2.3" respectively "PDF Creator"
	// Generated pdf file has same basic name as source file plus date and time information plus pdf extention
	function GeneratePDF_File(	)
	// --------------------------------------------------------------------------------------
	{
		variable excelFileAndPath, tempText("");
		variable pdfFileName, pdfFileAndPath;
		variable cmdLine;
		variable program;
		variable retVal;
		variable traceSource(""),traceAction( "Assign data"), description;
		timer 	shortDelay;
		object 	fso;  // file system object
		object 	objWshShell;
  		object 	objWshScriptExec;

		if(PDF_CreatorExecutableProgram == VerDef::notInstalled)	
		{
			GeneratePDF_File_2(); // ShowReportFile(excelFileAndPath);
			return;
		}
		if (fso.IsNull()) fso.CreateObject("Scripting.FileSystemObject");
		traceSource = GetFunctionName() + ": ";

		// close file
		RPD::reportFile.Close();

		excelFileAndPath 	= RPD::reportFileName;
		pdfFileAndPath 	= RPD::reportFileName;
		StrReplace(pdfFileAndPath,".xls", ".pdf");

		onerror resume next;
			
		// register licence key	for PDFcamp programm
		objWshShell.CreateObject("WScript.Shell");
		objWshShell.RegWrite("HKEY_CURRENT_USER\\Software\\verypdf\\pdfcamp\\RegisterNO", "62V281B3UR89PJ78", "REG_SZ");
		objWshShell.RegWrite("HKEY_CURRENT_USER\\Software\\verypdf\\pdfcamp\\RegisterName", "Hamilton Bonaduz AG", "REG_SZ");
		objWshShell.ReleaseObject();

		if (!fso.FileExists(excelFileAndPath)) 
		{
			tempText = LdT("Open file '%s1' failed!");
			StrReplace(tempText,"%s1", excelFileAndPath );
	 		FormatTrace(traceSource, LdT("Open file"), VerDef::CMD_ERRCOMPL, tempText); 
			return;
		}

		// Merge program and command
		cmdLine = StrConcat8("\"", excelFileAndPath, "\"", " ","\"", pdfFileAndPath,	 "\"", "");

		if (StrFind(PDF_CreatorExecutableProgram,"\"") == 0 ) program = StrConcat4(PDF_CreatorExecutableProgram , " ", cmdLine,"");
			else																program = StrConcat4("\"",PDF_CreatorExecutableProgram , "\" ", cmdLine);

	//		if (StrFind(excelFileAndPath_2," ") >=0 ) 
		program = StrConcat4("\"",PDF_CreatorExecutableProgram , "\" ", cmdLine);
//Trace ("PDF create command  =>",program,"<==");

		// hslSynchronous = The execution of the running HSL program will be blocked until the program to execute terminates
		description= LdT("PDF file '%s1' will be generated soon ...");
		StrReplace(description, "%s1", pdfFileAndPath );
 		FormatTrace(traceSource, "File generation:",VerDef::CMD_START , description); 

		retVal = Shell(program,hslHide,hslSynchronous);	
		if (retVal == 0)
			{
				string errorMessage;
				errorMessage = "Failed to start program '%s1'";
				StrReplace(errorMessage , "%s1", program);
				MessageBox(errorMessage, "ERROR", hslError);
			}
		shortDelay.SetTimer( 4 );
		shortDelay.WaitTimer( hslFalse, hslFalse );

		if (fso.FileExists(pdfFileAndPath)) 
		{	
			if(RPD::keepExcelFile < 1) DeleteFile(excelFileAndPath);
			ShowReportFile(pdfFileAndPath);
			description= LdT("PDF file '%s1' generated!");
			StrReplace(description, "%s1", pdfFileAndPath );
 			FormatTrace(traceSource, "File generation:",VerDef::CMD_COMPLET , description); 
		}
		else 	ShowReportFile(excelFileAndPath);
	
		return;
	}  // end of function "GeneratePDF_File"

	//=====================================================================================================
	// local functions
	//=====================================================================================================

	//-----------------------------------------------------------------------------------------------------
	static function InitVerToolsLibrary()
	//-----------------------------------------------------------------------------------------------------
	{
		// initializes the Verification Methods Library (only once)
		if (!initializedLib)
		{
			initializedLib = hslTrue;
		}
		return(initializedLib);
	}

	//-----------------------------------------------------------------------------------------------------
	static function GetProcessedStateAsString(variable &processedState)
	//-----------------------------------------------------------------------------------------------------
	{
		string stateText("---");

		if ( processedState == PS::successful )
			stateText = LdT("successful");

		else if ( processedState == PS::failed )
			stateText = LdT("failed");

		return (stateText);

	} // end GetCheckStateAsString


	//-----------------------------------------------------------------------------------------------------
	static function GetCheckStateAsString( variable &state)
	//-----------------------------------------------------------------------------------------------------
	{
		string stateText("---");

		if ( state == PS::successful )
			stateText = LdT("passed");

		else if ( state == PS::failed )
			stateText = LdT("failed");

		return (stateText);

	} // end GetCheckStateAsString


	//-----------------------------------------------------------------------------------------------------
	static function FormatNumber_PointAsDecimal(variable& numberToFormat, variable countOfDecimals) variable
	//-----------------------------------------------------------------------------------------------------
	{
		const variable decimalDelimiter(".");		// Fixed decimal used for formating
		variable isInteger(hslFalse);

		if ( hslInteger.Compare(GetType(numberToFormat)) == 0 )
		{
			// Convert to float and continue
			numberToFormat = numberToFormat * 1.0;
			isInteger = hslTrue;
		}

		if ( hslFloat.Compare(GetType(numberToFormat)) == 0 )
		{
			// For formating of numbers for specific count of decimals the VBScript function FormatNumber() is used.
			// This works well for great numbers, but note, for small numbers (e.g. 1.23E-7) this results in a
			// null value if the count of digits is not enough large.
			variable vbScriptFormatedNumber;
			variable evalCode;					// Code string evaluated by vbScript.
//			object objScriptControl;			// Script Control
			string strTemp;
			variable languageDelimiter;
			
			InitScriptControl();

			evalCode = "FormatNumber("+ FStr(numberToFormat, hslFalse, 16) +","+ IStr(countOfDecimals)+",-1,0,0)";

//Trace("Test: FormatNumber_PointAsDecimal: ScriptControl.Eval(", evalCode, ")");

			vbScriptFormatedNumber = dtScriptControl.Eval(evalCode);

			// The formated number contains now the language specific decimal delimiter. We need to know it, pars it out of 
			// a formatted 0.0.
			strTemp = dtScriptControl.Eval("FormatNumber(0.0,1,-1,0,0)");	// Format zero by using one digit and leading zero.
			languageDelimiter = strTemp.Mid(1,1);
			//#ifdef __develop__
			//	Trace("Test: Language specific decimal delimiter = '", languageDelimiter, "'");
			//#endif

			// Replace the language delimiter by the HSL decimal delimiter
			StrReplace(vbScriptFormatedNumber, languageDelimiter, decimalDelimiter);

			// Now have a string formated by vbScript. Never uses exponential format. (Examples with 4 digits):
			// 3.1415  ;  12547.0000  ;  12547.0500  ;  0.0015  ;  15789875975713351548.0150  ;  0.0000
			// (Please note the last example which may be the result of FormatNumber(0.000,...) or of
			//  FormatNumber(0.0000015,.....) )

			#ifdef __develop__
				Trace("Test: Value ('", numberToFormat, "') formated to: '" , vbScriptFormatedNumber, "'");
			#endif

			if(isInteger)	numberToFormat = IVal(vbScriptFormatedNumber);
			else				numberToFormat = FVal(vbScriptFormatedNumber);

//Trace("Value ('", numberToFormat, "') formated to: '", vbScriptFormatedNumber, "'");

			return( vbScriptFormatedNumber );
		}
		else
		{
			#ifdef __develop__
				Trace(GetFunctionName(), ": Not a number passed to format: ", numberToFormat);
			#endif
			return( "---" );
		}
	}

	//-----------------------------------------------------------------------------------------------------
	function UpdateStatusDialog(variable i_DialogTitle, variable i_StatusText, variable iBackgroundColor)
   //	iBackgroundColor : 1 = green, 2 = yellow, 3 = red , else 3 
  	//-----------------------------------------------------------------------------------------------------
   {  
      variable dialogTitle(i_DialogTitle);
      variable statusText(i_StatusText);
      variable backgroundColor(iBackgroundColor);
//      Trace("Test: UpdateStatusDialog starting : Dialog Title ==>",dialogTitle," <  Status text =>",	statusText,"<  status background ==>",backgroundColor,"<   Status dialog ==>",Dlg::dialogOpen,"<==");
      if(!Dlg::dialogOpen) return;
  		onerror resume next;
      Dlg::statusDlg.SetStatusInfo(dialogTitle, statusText,backgroundColor);     
      
   } // -- end of function "UpdateStatusDialog"

	//-----------------------------------------------------------------------------------------------------
	function HideStatusDialog()
	//-----------------------------------------------------------------------------------------------------
   {
   	timer 	shortDelay;

      Trace("Test: HideStatusDialog starting : Status  dialogOpen ==>",Dlg::dialogOpen,"<==");
  		onerror resume next;
//      if(!Dlg::dialogOpen) return;
      Dlg::statusDlg.Hide();
      Dlg::dialogOpen = hslFalse;
      // end parallel process
      if (Join(Dlg::handles, 9999) == 0) 
      {
      	//err.Raise(1, "Failed to join handles");
      	Trace( "---------------  Failed to join handles");
         Trace("Test: -------------- End of Status Dialog  displayed ------------------");                          
      }
		UnregisterAbortHandler( "VerTool::OnStatusDialog_Abort" );
      shortDelay.SetTimer( 1 ); shortDelay.WaitTimer( hslFalse, hslFalse ); // wait 1 second
   } // -- end of function "HideStatusDialog"

	//-----------------------------------------------------------------------------------------------------
	private function showStatusDialog() variable
	//-----------------------------------------------------------------------------------------------------
   {
		const string DialogObjectName("HxStarVer2Dlg.VerStatusDlg"); //	function of HxStarVer2Dlg.dll
		const string message("Create Object Failed -->");
     	timer 	    shortDelay;

		RegisterAbortHandler( "OnStatusDialog_Abort" );

      onerror resume next;
		if ( 0 == Dlg::statusDlg.CreateObject(DialogObjectName) )
		{		
			Trace("Test: showStatusDialog: Error Message => ", message, DialogObjectName, "<---");
			return( hslAbort );
		}
		Dlg::statusDlg.Show(Dlg::dialogTitle);
		return( hslOK);
   } // -- end of function "ShowStatusDialog"


	//-----------------------------------------------------------------------------------------------------
	function ShowStatusDialog(variable i_DialogTitle)
	//-----------------------------------------------------------------------------------------------------
   {
		const string DialogObjectName("HxStarVer2Dlg.VerStatusDlg"); //	function of HxStarVer2Dlg.dll
		const string message("Create Object Failed -->");
      timer 	shortDelay;

      if(Dlg::dialogOpen) VerTool::HideStatusDialog();

      Dlg::dialogTitle = i_DialogTitle;

      Trace("Test:  Show Status Dialog  starting.   i_DialogTitle =>",i_DialogTitle,"<===");
   	Dlg::handle = Fork("showStatusDialog");
   	if (0 == Dlg::handle) err.Raise(0, "Failed to start 'ShowDialog'");
   	Dlg::handles.AddAsLast(Dlg::handle);

      Dlg::dialogOpen = hslTrue;
      // short delay of 1 s
      shortDelay.SetTimer( 1 ); shortDelay.WaitTimer( hslFalse, hslFalse );
      Trace("Test: ShowStatusDialog: Status  dialogOpen ==>",Dlg::dialogOpen,"<==");
   } // -- end of function "ShowStatusDialog"

	//------------------------------------------------------------------------------
	function MWPUserComand(string command, variable timeOut) variable
	//------------------------------------------------------------------------------
	{
		string retVal;
		string message;
		variable balanceCommandFailed;

		// initialize library (if necessary)
		InitVerToolsLibrary();
//		message = LdT("Execute command on balance:");
		message = StrConcat4(LdT("Execute command on balance:"), "  " , command,"");
		FormatTrace( LdT("Balance"),  message, VerDef::CMD_START );

		onerror goto comErrorRecovery;
		if (VerDef::SimulationModeBalance) retVal = "    simulatedMWPresponse";
		else retVal = Balance::waage.UserComand(command, timeOut);

		message = message + " ==>: ";
		message = message + retVal;

		// Check for error in returned string
		if (		( retVal.Compare("")   != 0 )
				&& ( retVal.Compare("ES") != 0 )
				&& ( retVal.Compare("ET") != 0 )
				&& ( retVal.Compare("EL") != 0 ) )
		{
			// No error detected in returned string
			FormatTrace( LdT("Balance"),  message, VerDef::CMD_COMPLET );
		}
		else
		{	
			balanceCommandFailed = LdT( "Execution of balance command failed!");
			FormatTrace( LdT("Balance"),  balanceCommandFailed , VerDef::CMD_ERROR, message);
			retVal = VerDef::notDefined;
		}
		return( retVal );

		// ------------------------------------------------------			
		comErrorRecovery:
		{
			err.Clear( );
			FormatTrace( LdT("Balance"),  balanceCommandFailed , VerDef::CMD_ERROR, message);
			retVal = VerDef::failed;
			return( retVal );		
		}
	} // end MWPUserCommand

	//------------------------------------------------------------------------------
	function MWPUserComand_2(string command, variable timeOut) variable
	//------------------------------------------------------------------------------
	{
		string retVal;
		string message;
		variable balanceCommandFailed;

		// initialize library (if necessary)
		InitVerToolsLibrary();

		if (VerDef::SimulationModeBalance) retVal = "    simulatedMWPresponse";
		else retVal = Balance::waage.UserComand_2(command, timeOut);

		message = LdT("Execute command on balance:");
		message = message + command;
		message = message + " ==>";
		message = message + retVal;
		message = message + "<==";

		// Check for error in returned string
		if (		( retVal.Compare("")   != 0 )
				&& ( retVal.Compare("ES") != 0 )
				&& ( retVal.Compare("ET") != 0 )
				&& ( retVal.Compare("EL") != 0 ) )
		{
			// No error detected in returned string
			FormatTrace( LdT("Balance"),  message, VerDef::CMD_COMPLET );
		}
		else
		{	
			balanceCommandFailed = LdT( "Execution of balance command failed!");
			FormatTrace( LdT("Balance"),  balanceCommandFailed , VerDef::CMD_ERROR, message);
			retVal = VerDef::notDefined;
		}
		return( retVal );

	} // end MWPUserComand_2

	//------------------------------------------------------------------------------
	function MWPTerminate()
	//------------------------------------------------------------------------------
	{
		variable trcBalance, trcActionMWPTerminate, balanceCommandFailed;

		if (VerDef::SimulationModeBalance) return;
		
		// initialize library (if necessary)
		InitVerToolsLibrary();
		trcBalance 							= LdT("Balance");
		trcActionMWPTerminate 			= LdT("Terminate communication to balance");
		balanceCommandFailed 			= LdT("Execution of balance command failed!");

		if(Balance::waage.ReleaseObject())
		{
			FormatTrace( trcBalance,  trcActionMWPTerminate, VerDef::CMD_COMPLET );
		}
		else
		{
			FormatTrace( trcBalance, trcActionMWPTerminate, VerDef::CMD_ERROR);
		}
		return;
	} // --- end of function "MWPTerminate" ----

	//------------------------------------------------------------------------------
	function MWPInitialize(variable& comPort) variable
	//------------------------------------------------------------------------------
	{
		variable portSettings("2400,e,7,1");
		variable port(1);
		variable portFound(hslFalse);
		variable message;
		variable createObjectFailed, trcActionInitialize, balanceCommandFailed;
		string 	response;
		timer		delay;

		// initialize library (if necessary)
		InitVerToolsLibrary();

		onerror goto portNotFound;

		trcActionInitialize = LdT("Initialize balance");
		balanceCommandFailed = LdT("Execution of balance command failed!");

		FormatTrace( LdT("Balance"), trcActionInitialize , VerDef::CMD_START);
		comPort = StrConcat2("", comPort);
		port = IVal(comPort);
		portSettings = "9600,n,8,1"; // set port setting for WXS & WMC balance
		if (Balance::Type == Balance::Type_SAG ) portSettings = "2400,e,7,1"; // set port setting for SAG balance
		if(port < 0) portSettings = ""; // set port setting for WMC balance, Ethernet IPAddress "192.168.95.248"
		loop(20)
		{
			MWPTerminate();
			if ( 0 == Balance::waage.CreateObject("HxStarVer2Dlg.VerBalanceCom") )
			{
				createObjectFailed = LdT("Create object failed:");
				message = createObjectFailed;
				message = message + "\"HxStarVer2Dlg.VerBalanceCom\"";
				err.Raise(1 , message);
			}
         VerTool::UpdateStatusDialog("",StrConcat2(LdT("Balance initializing at Com Port "),port),Dlg::Yellow);
	Trace("Test : balance info-------->: ComPort =>",port,"<  balanceType =>", Balance::Type, "<  portSettings =>", portSettings,"<");

			if (VerDef::SimulationModeBalance) return(hslTrue);
		
			// Verbindungsaufbau
			if(port > 20) port = 1; 
			if(Balance::waage.Connect(port, portSettings))
			{
				delay.SetTimer( 2 );delay.WaitTimer( hslFalse, hslFalse );
				// We are Connected but to ensure that all is OK (cables are plugged in / balance is 
				// turned on) we send a user command
				// Answer not used, only traced.
				response = MWPUserComand(Balance::BalanceData, 1);		// Raise an exception if not connected and turned on
//Trace("Test 1: MWPInitialize : Balance response ==>",response,"<==");			
				if(response.Compare(VerDef::notDefined) == 0) 
				{
					delay.SetTimer( 2 );delay.WaitTimer( hslFalse, hslFalse );
					response = MWPUserComand(Balance::BalanceData, 1);		
				}
//Trace("Test 2: MWPInitialize : Balance response ==>",response,"<==");
				// Check if correct balance type is connected
				if ((Balance::Type == Balance::Type_WXS ) && ( response.Find("WXS") >= 0)) portFound = hslTrue; 
				if ((Balance::Type == Balance::Type_SAG ) && ( response.Find("AG") >= 0))  portFound = hslTrue; 
				if ((Balance::Type == Balance::Type_WMC ) && ( response.Find("WMC") >= 0)) portFound = hslTrue;
//Trace("Test 3: MWPInitialize : Balance Type ==>",Balance::Type,"/",Balance::Type_WMC,"<=  response.Find('WMC') ==>",response.Find("WMC"),"<  port found =>",portFound );
				if(portFound)
				{
					if (Balance::Type == Balance::Type_SAG )	Balance::balanceTerminal = hslTrue;
					else													Balance::balanceTerminal = hslFalse; 
					// In case of balance type WXS: response for configuration with terminal is "WXS205S..." , without "WXSS205..." 
					if (response.Find("WXSS") >= 0) Balance::balanceTerminal = hslTrue; // WXS balance with terminal
					// In case of balance type WMC: response for configuration with terminal is ""WMCS15SH..."" , without "WMC15-SH..."
					if (response.Find("WMCS") >= 0) Balance::balanceTerminal = hslTrue; // WMC balance with terminal

					comPort = IStr(port);

					Trace("Test : balance info-------->: ComPort =>",port,"<  balanceType =>", Balance::Type, "<  balance with terminal =>", Balance::balanceTerminal,"<");
					FormatTrace( LdT("Balance"),  trcActionInitialize, VerDef::CMD_COMPLET ,LdT("Communication found at Com Port Number"), " =>", port,"<==");
					return(hslTrue);
				}
			}
			else
			{
				if(port < 0) 
				{ // No ethernet comunication
					FormatTrace( LdT("Balance"),  trcActionInitialize, VerDef::CMD_PROGRESS ,LdT("No communication on Ethernet."));
				}
				else	FormatTrace( LdT("Balance"),  trcActionInitialize, VerDef::CMD_PROGRESS ,LdT("Communication not found at Com Port Number"), " =>", port,"<==");
			}
			portFound = hslFalse;
			if(port < 0) break; // only one trial for ethernet connection
			port++;
		}


		// Connection failed
		onerror goto 0;
		FormatTrace( LdT("Balance"), trcActionInitialize, VerDef::CMD_ERROR);
		return(hslFalse);

		// ------------------------------------------------------			
		portNotFound:
		{
			err.Clear( );
			FormatTrace( LdT("Balance"), trcActionInitialize, VerDef::CMD_ERROR, "Communication not found at Com Port Number =>",port,"<==");
			resume next;
		}		
	} // --- end of function "MWPInitialize"


	//------------------------------------------------------------------------------
	function MWPBalanceDisplay(string DisplayMode) void
	//------------------------------------------------------------------------------
	{  // Digit display mode:	0: 1d (max accuracy), 1: 10d (faster)	

		string antwort("");
		string commandString("");
		variable trcActionSetWeightingParameter;
		variable  portSettings("");
		variable port(-1);
		timer  delay;
		variable message;
		variable createObjectFailed, trcActionInitialize, balanceCommandFailed;
		variable rdbMode(""); // Commands "RDB 4" or "RDB 5" reset balance firmware

		// initialize library (if necessary)
		InitVerToolsLibrary();
		trcActionSetWeightingParameter = LdT("Set weighting parameter");

		if (Balance::Type == Balance::Type_SAG )
		{ // for balance type SAG 
			commandString = "MW 2 0 1 9 0 " + DisplayMode + " 0 0 0 0 1 0 0";
		}
		if (Balance::Type == Balance::Type_WXS )
		{ // for balance type WXS 
			if (Balance::balanceTerminal)	commandString = "M23 " + DisplayMode;
			else 
			{
				commandString = "RDB";
				if (DisplayMode.Find("1") < 0)	rdbMode = " 5"; 
				else	 									rdbMode = " 4"; 
			}
		}
		if (Balance::Type == Balance::Type_WMC )
		{ // for balance type WMC 
			if (Balance::balanceTerminal)	commandString = "M23 " + DisplayMode;
			else 
			{	
				commandString = "RDB";
				if (DisplayMode.Find("1") < 0)	rdbMode = " 5"; 
				else	 									rdbMode = " 4"; 
			}
		}

		onerror goto CommandError;
		if(commandString.Compare("RDB") == 0)
		{
			// check balance state and wait in case initialisation is running
			antwort = MWPUserComand(commandString, 10);
			if( antwort.Find(rdbMode) < 0 )
			{// change to other display mode
				commandString = StrConcat2(commandString, rdbMode);
				antwort = MWPUserComand(commandString, 10);
				while ( antwort.Find("g") < 0 )
				{
					delay.SetTimer(2);
					delay.WaitTimer( hslFalse, hslFalse );
					antwort = MWPUserComand("SI", 10);
				}
			}
		}
		else antwort = MWPUserComand(commandString,10);
		if (VerDef::SimulationModeBalance) return;

		FormatTrace( LdT("Balance"),  trcActionSetWeightingParameter,VerDef::CMD_COMPLET );
		return;

		// ------------------------------------------------------			
		CommandError:
		{
			FormatTrace( LdT("Balance"),  trcActionSetWeightingParameter,VerDef::CMD_ERROR);
			err.Raise();
		}
	} // end MWPBalanceDisplay

	//------------------------------------------------------------------------------
	function MWPInternalCalibration() void
	//------------------------------------------------------------------------------
	{
		variable trcBalance, trcActionInternalCalibration, balanceCommandFailed;

		if (Balance::Type == Balance::Type_WMC ) return;  // no internal calibration (command "C3") for WMC balance available

		// initialize library (if necessary)
		InitVerToolsLibrary();
		trcBalance 							= LdT("Balance");
		trcActionInternalCalibration 	= LdT("Internal Calibration");
		balanceCommandFailed 			= LdT("Execution of balance command failed!");

		FormatTrace( trcBalance ,  trcActionInternalCalibration, VerDef::CMD_START);

		if (VerDef::SimulationModeBalance) return;
      
      VerTool::UpdateStatusDialog("",LdT("Internal Calibration running..."),Dlg::Yellow);
		if(Balance::waage.intCalib)
		{
			FormatTrace( trcBalance,  trcActionInternalCalibration, VerDef::CMD_COMPLET );
         VerTool::UpdateStatusDialog("",LdT("Internal Calibration completed."),Dlg::Green);
		}
		else
		{
         VerTool::UpdateStatusDialog("",LdT("Internal Calibration  erroneous."),Dlg::Red);
			FormatTrace( trcBalance, trcActionInternalCalibration , VerDef::CMD_ERROR);
			err.Raise(1 , balanceCommandFailed);
		}

	} // end MWPInternalCalibration

	//------------------------------------------------------------------------------
	function MWPSettingOfTheWeighingParameters()
	//------------------------------------------------------------------------------
	{ // set balance to optimized weightning mode
		// New setting for MWP settings:
		// SAG Command "MW 2 0 1 9 0 " & Trim(Mid(strArgs, 3, 1)) & " 0 0 0 0 1 0 0"
      //                 ¦ Par 1: Weighing speed (2: medium; 3:high vib (faster)¦
      //                   ¦ Par 2: display behavior                            ¦
		//                     ¦ Par 3: stability criteria                        ¦
      //                       ¦ Par 4: weight unit (mg)                        ¦
      //                         ¦ Par 5: auto zero correction (on)             ¦
      //                                 ¦ Par 6: display / readability         ¦
      //																								  ¦ Par 13: English

		string 	antwort("");
		string 	weightParameter("");
		variable i;
		variable weightParameter_SAG("MW 2 0 1 9 0 0 0 0 0 0 1 0 0"); // WeightParameter for balance type SAG285
		variable weightParameter_WXS[]; // Settings for balance type WXS
		variable weightParameter_WMC[]; // Settings for balance type WMC

		variable trcBalance, trcActionSetWeightingParameter;

		// initialize library (if necessary)
		InitVerToolsLibrary();

		trcBalance 								= LdT("Balance");
		trcActionSetWeightingParameter 	= LdT("Set weighting parameter");	

		for (i = 0; i < 14; i++) {weightParameter_WXS.AddAsLast( "" );weightParameter_WMC.AddAsLast( "" );}
		// Weight Parameter correlation between SAG285 (command 'MW') and WXS/WMC commands
		weightParameter_WXS.SetAt( 1, "M02 2");	// MT-SICS only for balance type WXS, substitutes MW-Parameter #1 
		weightParameter_WMC.SetAt( 1, "M02 2");	// MT-SICS only for balance type WMC, substitutes MW-Parameter #1 
		weightParameter_WXS.SetAt( 2, "M01 0");	// MT-SICS only for balance type WXS, substitutes MW-Parameter #2
		weightParameter_WMC.SetAt( 2, "M01 0");	// MT-SICS only for balance type WMC, substitutes MW-Parameter #2
		weightParameter_WXS.SetAt( 4, "M21 0 3");	// MT-SICS only for balance type WXS, substitutes MW-Parameter #4
		weightParameter_WMC.SetAt( 4, "M21 0 3");	// MT-SICS only for balance type WMC, substitutes MW-Parameter #4
		weightParameter_WXS.SetAt( 5, "M03 0"); 	// MT-SICS only for balance type WXS, substitutes MW-Parameter #5 
		weightParameter_WMC.SetAt( 5, "M03 0"); 	// MT-SICS only for balance type WMC, substitutes MW-Parameter #5 
		//weightParameter_WXS.SetAt( 6, "M23 0"); 	// MT-SICS only for balance type WXS, substitutes MW-Parameter #6

		if (Balance::balanceTerminal)	
		{
			weightParameter_WXS.SetAt(13, "M15 0"); 	// MT-SICS only for balance type WXS, substitutes MW-Parameter #13
			weightParameter_WMC.SetAt(13, "M15 0"); 	// MT-SICS only for balance type WMC, substitutes MW-Parameter #13
			weightParameter_WXS.SetAt( 3, "M29 1"); 	// MT-SICS only for balance type WXS, substitutes MW-Parameter #3 
			weightParameter_WMC.SetAt( 3, "M29 1"); 	// MT-SICS only for balance type WMC, substitutes MW-Parameter #3 
		}
		else
		{
			weightParameter_WXS.SetAt( 3, "USTB 0 3.6 1.1"); // MT-SICS only for balance type WXS without terminal, substitutes MW-Parameter #3 
			weightParameter_WMC.SetAt( 3, "M29 1"); 			// MT-SICS only for balance type WMC without terminal
		}		 	
		// rest of MW parameter not applicable / relevant for control of balance type WXS

		onerror goto CommandError;
		
		if (Balance::Type == Balance::Type_SAG )
		{  // setting for balance SAG
			antwort = MWPUserComand(weightParameter_SAG, 10);
			FormatTrace( trcBalance,  trcActionSetWeightingParameter,VerDef::CMD_COMPLET );
		}
		if (Balance::Type == Balance::Type_WXS )
		{ // setting for balance WXS
			for (i = 1; i < 14; i++) 
			{
				weightParameter = weightParameter_WXS.GetAt( i);
				if (weightParameter.GetLength() > 0)			 
				{
					antwort = MWPUserComand(weightParameter, 10);
					FormatTrace( trcBalance, trcActionSetWeightingParameter,VerDef::CMD_COMPLET );
				}
			}
		}
		if (Balance::Type == Balance::Type_WMC )
		{  // setting for balance WMC
			for (i = 1; i < 14; i++) 
			{
				weightParameter = weightParameter_WMC.GetAt( i);
				if (weightParameter.GetLength() > 0)			 
				{
					antwort = MWPUserComand(weightParameter, 10);
					FormatTrace( trcBalance, trcActionSetWeightingParameter,VerDef::CMD_COMPLET );
				}
			}
		}
		return;

		// ------------------------------------------------------			
		CommandError:
		{
			FormatTrace( trcBalance,  trcActionSetWeightingParameter, VerDef::CMD_ERROR);
			err.Raise();
		}		
	}	

	// -----------------------------------------------------------------------------
	function measureMultipleWeight(variable measureMode, variable& deviation) variable
	//------------------------------------------------------------------------------
	{
		variable average(0.0), endTime(0.0), data;
		variable immediateMeasurement(0);
		variable i, k;
		variable sizeOfData, lowIndex, highIndex;
		variable arrayOfData[], arrSortedData[]; 
		variable notInserted(hslTrue);
		variable tempText("");
		timer delay;

		//wait 25% measuring time
		delay.SetTimer( 0.25 * measureMode );
		delay.WaitTimer( hslFalse, hslFalse );

		// measure mulltiple data during measuring time or at least 8 measurement
	   endTime     = 1.75* measureMode;
		arrayOfData.SetSize(0);
		sizeOfData = 0;
		while(hslTrue)
		{
			arrayOfData.AddAsLast(FVal(Balance::waage.WeightOne(immediateMeasurement)));
         tempText = StrConcat2(arrayOfData.GetAt(sizeOfData)/1000.0," mg");
         VerTool::UpdateStatusDialog("", tempText, Dlg::Yellow);
			sizeOfData++;
//   		Trace( " sizeOfData =>",sizeOfData,"<  delay.GetElapsedTime( ) =>",delay.GetElapsedTime( ),"<==");
			if((sizeOfData>=8) && (delay.GetElapsedTime( ) > endTime)) break;
		}
		
		sizeOfData = arrayOfData.GetSize();
		if(sizeOfData == 0) return(0.0);
		arrSortedData.SetSize(0);

		// sort data
		i = 0;
		for(i = 0; i < sizeOfData ; i++)
		{
			notInserted = hslTrue;
			data = arrayOfData.GetAt( i );
			for(k = 0; k < arrSortedData.GetSize(); k++)
			{
				if( data < arrSortedData.GetAt( k )) 
				{
					arrSortedData.InsertElementAt( k, data);
					notInserted = hslFalse;
					break;
				}
			}
			if(notInserted) arrSortedData.AddAsLast(data);
		}
//		VerTool::TraceArray(" --- raw data ----", arrayOfData);
//		VerTool::TraceArray(" ---sorted data ----", arrSortedData);

		// calculate avarage value of middle 50% data values
		average 		= 0.0;
		k				= 0;
		lowIndex 	= Floor(0.25 * sizeOfData);
		highIndex	= Ceiling(0.75 * sizeOfData);
		for(i = lowIndex; i < highIndex ; i++)
		{
			average 	= average + arrSortedData.GetAt( i );
			k++;
		}		
		if(k > 0) average 	= average / (1.0 * k); 	
		// calculate deviation between loest and highest used measurement value
		deviation = arrSortedData.GetAt(highIndex)- arrSortedData.GetAt(lowIndex);
		if(deviation > (220*1000000.0)) 
		{// some measurement values outside measurment range
			deviation = 999999999; // substitute value 999.999999 g
			average = deviation;
		}
//		Trace("Test: measureMultipleWeight: lowIndex =>",lowIndex,">  highIndex =>",highIndex,">  average =>",average);
//		Trace("Test: measureMultipleWeight:  Min =>",arrSortedData.GetAt(0),
//					">  Max =>",arrSortedData.GetAt(sizeOfData-1),
//					">  extreme deviation =>",arrSortedData.GetAt(sizeOfData-1) - arrSortedData.GetAt(0));
		Trace("Test: measureMultipleWeight:  lowest =>",arrSortedData.GetAt(lowIndex),
					">  highest =>",arrSortedData.GetAt(highIndex),
					">  deviation =>", arrSortedData.GetAt(highIndex)- arrSortedData.GetAt(lowIndex),
					">  average =>",average);
		return (average);
	}

	//------------------------------------------------------------------------------
	function MWPMeasure(variable measureMode, variable simulatedValue) variable
	//------------------------------------------------------------------------------
	{ // measured weight on MWP device. Measurement result in [ug], simulated value in [mg]
		string strWaegeResult("0");
		variable description;
		variable weight(0.0), deviation(0.0);
		variable trcBalance, balanceCommandFailed;

		// initialize library (if necessary)
		InitVerToolsLibrary();
		trcBalance 							= LdT("Balance");
		balanceCommandFailed 			= LdT("Execution of balance command failed!");

		onerror goto CommandError;
		
		if (VerDef::SimulationModeBalance ) 
		{
			weight = simulatedValue *1000.0;
		}
		else 
		{
			if(measureMode <= 0) 
			{	
				strWaegeResult = Balance::waage.WeightOne(measureMode);
				weight = FVal(strWaegeResult);
			}
			else weight = measureMultipleWeight(measureMode, deviation);
			description= StrConcat4("MWPMeasure:  Balance measurement value is ==>", weight, " ug","");
			Trace(description);
         if(weight < 999999999)
         {
            description = StrConcat2(weight/1000.0," mg");
            VerTool::UpdateStatusDialog("",description,Dlg::Green);
         }
         else
         {
            VerTool::UpdateStatusDialog("",LdT("No weight measurement data!"),Dlg::Red);
         }
		}
		
		return( weight );

		// ------------------------------------------------------			
		CommandError:
		{
			FormatTrace( trcBalance, LdT("Weight Measurment"), VerDef::CMD_ERROR);
			err.Raise(1 , balanceCommandFailed);
		}		
	}	

	//------------------------------------------------------------------------------
	function MWPSetZero(variable immediately)
	//------------------------------------------------------------------------------
	{
		variable reponse;
		variable trcBalance, trcActionTare, balanceCommandFailed;
		variable weight;
		timer		delay;

		// initialize library (if necessary)
		InitVerToolsLibrary();
		trcBalance 							= LdT("Balance");
		trcActionTare 						= LdT("Tare");
		balanceCommandFailed 			= LdT("Execution of balance command failed!");

		if (VerDef::SimulationModeBalance) return;

		FormatTrace( trcBalance,  LdT(trcActionTare), VerDef::CMD_START);

		onerror goto CommandError;

		if(immediately > 0)
		{
			loop(10)
			{
				reponse = MWPUserComand("ZI", 10);		// Set display value to zero instantly
				weight  = VerTool::MWPMeasure(Balance::MeasureMode_0, 0.0)/1000000.0; // [g]
				if((weight > -0.1) && (weight < 0.1)) break;
				delay.SetTimer( 1 );
				delay.WaitTimer( hslFalse, hslFalse );
			}
		}	
		else						reponse = MWPUserComand("Z", 30);		// Set display value to zero
		FormatTrace( trcBalance,  trcActionTare, VerDef::CMD_COMPLET );
		return;

		// ------------------------------------------------------			
		CommandError:
		{
			FormatTrace( trcBalance, trcActionTare, VerDef::CMD_ERROR);
			err.Raise(1 , balanceCommandFailed);
		}
	} // end of function "MWPSetZero"

   //--------------------------------------------------------------------------------------------------
	function Reader_OpenCommunication() 
   { 
		variable cmd, prm;
  		variable comSettings( "P0:Reader384:0,P1:Reader384:1");
   	variable cInstruments;
	   variable iInstrument;
      variable resultCode;
		timer t1;

      if(Reader::Device.IsNull())
      {
   		FormatTrace( GetFunctionName(), "()", VerDef::CMD_START );

         Reader::Device.CreateObject( "BioMed.Instruments", hslTrue );
         resultCode = Reader::Device.SetSetting( comSettings );
         if( resultCode != 0 )
         {
            // trace error code and raise error
   			FormatTrace( GetFunctionName(), "()", VerDef::CMD_ERRCOMPL, " command failed: error code= ", ResultCodeToString( resultCode ));
            err.Raise( -1, "Failed to configure BioMed.Instruments: " +  ResultCodeToString( resultCode ));
         }

			// ----  Trace available instruments 
		   FormatTrace( GetFunctionName(), "()", VerDef::CMD_START, "Available instruments:" );

	   	cInstruments = Reader::Device.GetDeviceCount();
		   for( iInstrument = 0; iInstrument < cInstruments; ++iInstrument )
	   	{
		      variable sDevicePath, sUserID, sUserData;

	      	Reader::Device.GetDeviceInfo( iInstrument, sDevicePath, sUserID, sUserData );
	   	   FormatTrace( GetFunctionName(), "()", VerDef::CMD_PROGRESS, " ", iInstrument, ". ", sDevicePath );
		      FormatTrace( GetFunctionName(), "()", VerDef::CMD_PROGRESS, "      DeviceType = " , sUserID );
	      	FormatTrace( GetFunctionName(), "()", VerDef::CMD_PROGRESS, "      DeviceID   = " , sUserData );
	   	}

	     	FormatTrace( GetFunctionName(), "()", VerDef::CMD_COMPLET );

			if(Reader::Device.IsConnected( "P1" )) Reader::ID = "P1";
			else												Reader::ID = "P0";
   	   FormatTrace( GetFunctionName(), "()", VerDef::CMD_PROGRESS, "Reader384 connection status is : ", Reader::Device.IsConnected( Reader::ID ));
   		FormatTrace( GetFunctionName(), "()", VerDef::CMD_COMPLET );
      }

   }  // --- end of function "Reader_OpenCommunication" ----

   //--------------------------------------------------------------------------------------------------
	function Reader_TerminateCommunication() 
   { 
      if( !Reader::Device.IsNull())
		{
         Reader::Device.ReleaseObject();
		}
   }  // --- end of function "Reader_TerminateCommunication" ----

   //--------------------------------------------------------------------------------------------------
	function Reader_TransmitCommand(variable command, variable parameter, variable &response, variable timeout ) 
   {
      variable resultCode;
		variable traceText(""),textBlock(900),i(0);
		variable deviceID(Reader::ID);


		FormatTrace( GetFunctionName(), "()", VerDef::CMD_START, " command=", deviceID, command, parameter );

		resultCode = TxRxCommand( deviceID, command, parameter, response, timeout );
      if( resultCode != 0 ) return( resultCode);

		// trace response (but max 1000 charkter per line)
		traceText = response;
		for(i = 1;StrGetLength(traceText) > textBlock;i++)
		{
			FormatTrace( GetFunctionName(), "()", VerDef::CMD_PROGRESS, " response part ",i," ==>", StrLeft(traceText,textBlock), "<==" );
			traceText = StrRight(traceText, StrGetLength(traceText) - textBlock);
		}
		FormatTrace( GetFunctionName(), "()", VerDef::CMD_COMPLET, " response ==>", traceText, "<==" );
		return( 0 );

   }   // --- end of function "Reader_TransmitCommand" ----

   //--------------------------------------------------------------------------------------------------
	function Reader_Initialize() 
	{
		variable cmd, prm, rsp, resultCode, readerID;

		if(Reader::ID == "") 
		{
			Reader_TerminateCommunication();
			Reader_OpenCommunication();
		}

		readerID = Reader::ID;
		FormatTrace( GetFunctionName(), "()", VerDef::CMD_START, " Reader ID = ",  readerID);
	
		cmd = "PI";
		prm = "";
      rsp = "er00";
		resultCode = TxRxCommand( readerID, cmd, prm, rsp, 30 );
      if( resultCode != 0 ) return(resultCode);

		FormatTrace( GetFunctionName(), "()", VerDef::CMD_COMPLET );
		return( 0 );
	}   // --- end of function "Reader_Initialize" ----

   //--------------------------------------------------------------------------------------------------
	function Reader_IdleMode() 
   { 
		variable response;

		response = "er00";	
		Reader_TransmitCommand("YI","", response, 20);
		Reader_TransmitCommand("YO","", response, 10);

   }  // --- end of function "Reader_IdleMode" ----

   //--------------------------------------------------------------------------------------------------
	function Reader_GetStatus(
//					variable& readerID,
					variable& wavelengthSet[],
					variable& serialNumber,
					variable& versionFW ) 
	{
		variable readerID,cmd, prm, rsp, ii, resultCode;

		readerID = Reader::ID;
		FormatTrace( GetFunctionName(), "()", VerDef::CMD_START, " Reader ID = ", readerID );

		cmd = "RF";
		prm = "";		
      rsp = "er00rfReader runs in simulation mode!";
		resultCode = TxRxCommand( readerID, cmd, prm, rsp, 10 );
      if( resultCode != 0 ) return(resultCode);

		versionFW = StrMid( rsp, 6, StrGetLength( rsp ) -6 );

		wavelengthSet.SetSize( 0 );
		for( ii = 0; ii < 6; ii++ )
		{
			cmd = "RL";
			prm = "sf" + IStr( ii + 1 );	
              if( 0 == ii ) rsp = "er00sf1sv001sn1234";	
         else if( 1 == ii ) rsp = "er00sf2sv405sn1234";	
         else if( 2 == ii ) rsp = "er00sf3sv003sn1234";	
         else if( 3 == ii ) rsp = "er00sf4sv004sn1234";	
         else if( 4 == ii ) rsp = "er00sf5sv005sn1234";	
         else               rsp = "er00sf6sv006sn1234";	
			resultCode = TxRxCommand( readerID, cmd, prm, rsp, 10 );
	      if( resultCode != 0 ) return(resultCode);
   
			wavelengthSet.AddAsLast( IVal( StrMid( rsp, StrFind( rsp, "sv" ) + 2, 3 )));
		}

		cmd = "RS";
		prm = "";
      rsp = "er00sn1234";		
		resultCode = TxRxCommand( readerID, cmd, prm, rsp, 10 );
      if( resultCode != 0 ) return(resultCode);

		serialNumber = StrMid( rsp, StrFind( rsp, "sn" ) + 2, 4 );
		
		FormatTrace( GetFunctionName(), "()", VerDef::CMD_COMPLET );
		return( 0 );
	}   // --- end of function "Reader_GetStatus" ----

   //--------------------------------------------------------------------------------------------------
	function Reader_OpenDoor() 
	{
		variable readerID, cmd, prm, rsp, resultCode;

		readerID = Reader::ID;
		
		FormatTrace( GetFunctionName(), "()", VerDef::CMD_START, " Reader ID = ", readerID );

		cmd = "OD";
		prm = "";
      rsp = "er00";
		resultCode = TxRxCommand( readerID, cmd, prm, rsp, 20 );
      if( resultCode != 0 ) return(resultCode);

		FormatTrace( GetFunctionName(), "()", VerDef::CMD_COMPLET );
		return( 0 );
	}   // --- end of function "Reader_OpenDoor" ----


   //--------------------------------------------------------------------------------------------------
	function Reader_CloseDoor() 
	{
		variable readerID, cmd, prm, rsp, resultCode;

		readerID = Reader::ID;
		FormatTrace( GetFunctionName(), "()", VerDef::CMD_START," Reader ID = ", readerID );

		cmd = "CD";
		prm = "";
      rsp = "er00";
		resultCode = TxRxCommand( readerID, cmd, prm, rsp, 20 );
      if( resultCode != 0 ) return(resultCode);

		FormatTrace( GetFunctionName(), "()", VerDef::CMD_COMPLET );
		return( 0 );
	}  // --- end of function "Reader_CloseDoor" ----

 
   //--------------------------------------------------------------------------------------------------
	function Reader_ShakePlate( variable shakingTime, variable intensity ) 
	{
		variable readerID, cmd, prm, rsp, resultCode;

		readerID = Reader::ID;
		FormatTrace( GetFunctionName(), "()", VerDef::CMD_START, " Reader ID = ", readerID, " shaking time = ", shakingTime, " intensity = ", intensity );

		cmd = "SP";
		prm = ComposeCompletePrm( "cy", 3, shakingTime );
		prm = prm + "in" + IStr( intensity );
      rsp = "er00";
		resultCode = TxRxCommand( readerID, cmd, prm, rsp, shakingTime + 20 );
      if( resultCode != 0 ) return(resultCode);

		FormatTrace( GetFunctionName(), "()", VerDef::CMD_COMPLET );
		return( 0 );
	}  // --- end of function "Reader_ShakePlate" ----

  //--------------------------------------------------------------------------------------------------
	function Reader_Measure_96erPlate(
					variable measureWavelength,
					variable referenceWavelength,
					variable& primaryOD_ValueSet[],
					variable& referenceOD_ValueSet[] )														 
   //--------------------------------------------------------------------------------------------------
	{
		variable readerID, cmd, prm, rsp, resultCode, ii, jj, rsp1, deviceOrientation, temp;
		readerID = Reader::ID;
		deviceOrientation = 0; // normal plate reading well "A1" in back right position

		FormatTrace( GetFunctionName(), "()", VerDef::CMD_START," Reader ID = ", readerID );

		prm = "af" + IStr( measureWavelength );
		if( 0 == referenceWavelength )
		{ // single mode measurement
			cmd = "MN";
		}
		else
		{ // dual mode measurement
			cmd = "MD";
			prm = prm + "bf" + IStr( referenceWavelength );
		}
      rsp = "er00";
		resultCode = TxRxCommand( readerID, cmd, prm, rsp, 30 );
      if( resultCode != 0 ) return(resultCode);

		prm = "ms0";
		if(0==referenceWavelength)
		{ // single mode measurement
			cmd = "RN";
         rsp = "er00ms0af450";
         rsp = rsp + "my01om 00037 00023 00029 00022 00036 00054 00068 00077";
         rsp = rsp + "my02om -0004 40001 -0003 40001 -0004 40001 -0003 40001";
         rsp = rsp + "my03om 40001 -0003 40001 -0002 40001 -0002 40001 -0003";
         rsp = rsp + "my04om 02699 02687 02686 02686 02683 02681  0692 02696";
         rsp = rsp + "my05om 05529 05511 05508 05497 05487 05480 05477 05472";
         rsp = rsp + "my06om 11631 11645 11675 11703 11712 11743 11738 11769";
         rsp = rsp + "my07om 20778 20735 20771 20941 20811 20933 20749 20965";
         rsp = rsp + "my08om 01053 01051 01045 01068 01047 01071 01053 01054";
         rsp = rsp + "my09om 40001 40001 40001 40001 40001 40001 40001 40001";
         rsp = rsp + "my10om 40001 40001 40001 40001 40001 40001 40001 40001";
         rsp = rsp + "my11om 00001 00000 00001 00000 00000 00000 00001 00001";
         rsp = rsp + "my12om 00013 00012 00015 00014 00012 00019 00015 00017";
		}
		else
		{ // dual mode measurement
			cmd = "RD";
         rsp = "er00ms0af405bf620";
         rsp = rsp + "my01om 00037 00023 00029 00022 00036 00054 00068 00077";
         rsp = rsp + "or 00033 00024 00030 00023 00033 00049 00062 00065";
         rsp = rsp + "my02om -0004 40001 -0003 40001 -0004 40001 -0003 40001";
         rsp = rsp + "or -0003 40001 -0005 40001 -0005 40001 00000 40001";
         rsp = rsp + "my03om 40001 -0003 40001 -0002 40001 -0002 40001 -0003";
         rsp = rsp + "or 40001 -0004 40001 -0006 40001 -0005 40001 -0001";
         rsp = rsp + "my04om 02699 02687 02686 02686 02683 02681  0692 02696";
         rsp = rsp + "or 02844 02831 02824 02832 02823 02829 02830 02843";
         rsp = rsp + "my05om 00037 00023 00029 00022 00036 00054 00068 00077";
         rsp = rsp + "or 00033 00024 00030 00023 00033 00049 00062 00065";
         rsp = rsp + "my06om -0004 40001 -0003 40001 -0004 40001 -0003 40001";
         rsp = rsp + "or -0003 40001 -0005 40001 -0005 40001 00000 40001";
         rsp = rsp + "my07om 40001 -0003 40001 -0002 40001 -0002 40001 -0003";
         rsp = rsp + "or 40001 -0004 40001 -0006 40001 -0005 40001 -0001";
         rsp = rsp + "my08om 02699 02687 02686 02686 02683 02681  0692 02696";
         rsp = rsp + "or 02844 02831 02824 02832 02823 02829 02830 02843";
         rsp = rsp + "my09om 00037 00023 00029 00022 00036 00054 00068 00077";
         rsp = rsp + "or 00033 00024 00030 00023 00033 00049 00062 00065";
         rsp = rsp + "my10om -0004 40001 -0003 40001 -0004 40001 -0003 40001";
         rsp = rsp + "or -0003 40001 -0005 40001 -0005 40001 00000 40001";
         rsp = rsp + "my11om 40001 -0003 40001 -0002 40001 -0002 40001 -0003";
         rsp = rsp + "or 40001 -0004 40001 -0006 40001 -0005 40001 -0001";
         rsp = rsp + "my12om 02699 02687 02686 02686 02683 02681  0692 02696";
         rsp = rsp + "or 02844 02831 02824 02832 02823 02829 02830 02843";
		}

		resultCode = TxRxCommand( readerID, cmd, prm, rsp, 10 );
      if( resultCode != 0 ) return(resultCode);
		
		primaryOD_ValueSet.SetSize( 0 );
		referenceOD_ValueSet.SetSize( 0 );
		for( jj = 0; jj < 12; jj++ )
		{
			rsp1 = "my";
			if( 10 > jj + 1 ) rsp1 = rsp1 + "0";
			rsp1 = rsp1 + IStr( jj + 1 );

			rsp = StrMid( rsp, StrFind( rsp, rsp1 ), StrGetLength( rsp ));

			for( ii = 0; ii < 8; ii++ )
			{
				primaryOD_ValueSet.AddAsLast( FVal( StrMid( rsp, StrFind( rsp, "om" ) + 3 + 6 * ii, 5 )) / 10000.0 );
				if( 0 == referenceWavelength )
				{
					referenceOD_ValueSet.AddAsLast( 0.0 );
				}
				else
				{
					referenceOD_ValueSet.AddAsLast( FVal( StrMid( rsp, StrFind( rsp, "or" ) + 3 + 6 * ii, 5 )) / 10000.0 );
				}
			}
		}
		// not used yet: inverse plate reading: well "A1" in front left side 
		if(( deviceOrientation == 1 ) || ( deviceOrientation == 3 ))
		{
			for( ii = 0; ii < 48; ii++ )
			{
				temp = primaryOD_ValueSet.GetAt( ii );
				primaryOD_ValueSet.SetAt( ii, primaryOD_ValueSet.GetAt( 95 - ii ));
				primaryOD_ValueSet.SetAt( 95 - ii, temp );
				temp = referenceOD_ValueSet.GetAt( ii );
				referenceOD_ValueSet.SetAt( ii, referenceOD_ValueSet.GetAt( 95 - ii ));
				referenceOD_ValueSet.SetAt( 95 - ii, temp );
			}
		}

		FormatTrace( GetFunctionName(), "()", VerDef::CMD_COMPLET );
		return( 0 );
	}  // --- end of function "Reader_Measure_96erPlate" ----

	//--------------------------------------------------------------------------------------------------
	function Reader_Measure_Plate(
					variable plateType, 			// 96er plate or 384er plate
					variable measurementMode, // 0 = Normal ("A1" at rear, right);  1 = Revese ("O24" at rear , right side of plate transport)
					variable& plate_OD_ValueSet[] )variable
   //--------------------------------------------------------------------------------------------------
					
	{
		static const variable maxODValue(4.0001);
		static const variable minODValue(0.0001);
		variable readerID, cmd, prm, rsp, rsp1, resultCode, ii, jj, temp;
		variable firstRowPosition, rowDistance, amountOfRows;
		variable wellBorder_1,wellBorder_2;
		variable datablock_StartPos, dataIncrement;
		variable transmission_Data, OD_Data,referenceRow;
		variable meanTransData, minTransData, maxTransData;
		variable wellData_ValueSet[];
		
		variable rowNumber, columnNumber;
		variable rowDataBlockNumber, wellDataBlockNumber;
		variable rowPositionScanData[];
		variable wellIndex(0);

		// ------ extract all scan data out of return string	----------------
		if (plateType == VerDef::_384erPlate)
		{	
			firstRowPosition 	= Reader::firstRow - (2.25/0.2);  // data row #36
			rowDistance			= 4.5; // 9mm raster
			amountOfRows		= 24;
			if (plate_OD_ValueSet.GetSize() < 384)
			{
				plate_OD_ValueSet.SetSize(0);
			}
			if (measurementMode > 0)
			{
			 	wellIndex = 382; 	// = index to  well "O24"
				dataIncrement = -2;
			}
			else
			{
				wellIndex = 1;		// = index to  well "B1"
				dataIncrement		= 2;
				loop (384) plate_OD_ValueSet.AddAsLast(0.0);
			}
		}
		else
		{	
			firstRowPosition	= Reader::firstRow;  // data row #47
			rowDistance			= 9.0; // 9mm raster
			amountOfRows		= 12;
			wellIndex 			= 0;
			dataIncrement		= 1;
			plate_OD_ValueSet.SetSize(0);
			loop (96) plate_OD_ValueSet.AddAsLast(0.0);
		}


		rowPositionScanData.SetSize(0);
		for(rowNumber = 0; rowNumber < amountOfRows; rowNumber++) 
		{
				rowPositionScanData.AddAsLast(Floor((5.0 * rowNumber* rowDistance) + firstRowPosition) );	
//Trace("Test: rowPositionScanData at row  =>",rowNumber,"<  is =>",rowPositionScanData.GetAt(rowNumber),"<==");
		}
		readerID = Reader::ID;
		wellData_ValueSet.SetSize(40);  // 5 measurements per well for all 8 channels

		FormatTrace(GetFunctionName(),"()",VerDef::CMD_START," Reader ID = ",readerID);

		if(VerDef::SimulationModeReader == hslTrue)
		{	// define default values 
			for(jj=0;jj<plate_OD_ValueSet.GetSize();jj++) plate_OD_ValueSet.SetAt(jj, 1.0 + 0.01*jj);	
			return(0);
		}

		// ------ command for scan measurement
		cmd = "MS";
		prm = "af"+IStr(Reader::waveLenght);
		rsp = "er00";

		resultCode = TxRxCommand( readerID, cmd, prm, rsp, 30 );
      if( resultCode != 0 ) return(resultCode);

 		// ------ command for scan measurement data request
		cmd = "RT";
		prm = "";
		rsp = "er00";
		resultCode = TxRxCommand(readerID,cmd,prm,rsp, 20);
      if( resultCode != 0 ) return(resultCode);

		rsp1="my00";
		datablock_StartPos = StrFind(rsp,rsp1);
//Trace("Test: Data with lenght '",StrGetLength(rsp)," = from pos =>", datablock_StartPos,"< = data =>", rsp, "<==");

		if((StrGetLength(rsp) < 30024) || (datablock_StartPos < 5))
		{
			FormatTrace(GetFunctionName(),"()",VerDef::CMD_ERRCOMPL," ",cmd," command failed: not enough measurement data received");
			return(201);
		}

		if (plateType == VerDef::_ReaderCheckPlate)
		{ // ------scan data of first row well center
			wellBorder_1 = wellBorder_2 = 0;
			rowDataBlockNumber = datablock_StartPos;// + (rowPositionScanData.GetAt(rowNumber)-2) * 54;
			if("my00"!= StrMid(rsp, rowDataBlockNumber, 4))
			{
				FormatTrace(GetFunctionName(),"()",VerDef::CMD_ERRCOMPL," ",cmd," command failed: wrong data received: '", StrMid(rsp, datablock_StartPos, 4),"' instead 'my00'." );
				return(202);
			}
			wellData_ValueSet.SetSize(0);
			for(ii = 0;ii < 8; ii++) wellData_ValueSet.AddAsLast(0.0);

			wellDataBlockNumber = 0;
			for(rowNumber =0;rowNumber<100;rowNumber++) // maximal 100 rows per block position
			{
				transmission_Data = 0;
				for(columnNumber = 0;columnNumber < 8; columnNumber++) // well positions 
				{
					transmission_Data = transmission_Data + FVal(StrMid(rsp, rowDataBlockNumber +7+6*columnNumber,5))/10000.0;
//Trace("Test: ------------  Data at  >",rowNumber,"> columnNumber =>",columnNumber ,"< transmission_Data  =>",transmission_Data,"<==");
				}
//Trace("Test: -------------------------------- wellBorder_1  =>",wellBorder_1 ,"< wellBorder_2 =>",wellBorder_2 ,"< transmission_Data  ==>",transmission_Data ,"<==");
				if((wellBorder_1 == 0) && ( transmission_Data > (8*0.5))) wellBorder_1 = rowNumber;
				if((wellBorder_1 > 0) && ( transmission_Data < (8*0.5)))
				{	
					wellBorder_2 = rowNumber - 1;
					break;	
				}			
				wellDataBlockNumber = wellDataBlockNumber + 8;
				rowDataBlockNumber = rowDataBlockNumber + 54;
			}
			rowNumber = 0.5*(wellBorder_1 + wellBorder_2); // well center
//Trace("Test: ------------------------------------------------------ wellBorder_1  =>",wellBorder_1 ,"< wellBorder_2 =>",wellBorder_2 ,"< rowNumber  ==>",rowNumber ,"<==");
			plate_OD_ValueSet.SetAt(0, rowNumber); // assign row number as first (and only) measured value
			return(0);
		}

		// ------ extract well center specific data out of return string	----------------
		datablock_StartPos = StrFind(rsp,rsp1);
		for(rowNumber = 0; rowNumber < amountOfRows; rowNumber++)
		{
			rowDataBlockNumber = datablock_StartPos + (rowPositionScanData.GetAt(rowNumber)-2) * 54;
			if("my00"!= StrMid(rsp, rowDataBlockNumber, 4))
			{
				FormatTrace(GetFunctionName(),"()",VerDef::CMD_ERRCOMPL," ",cmd," command failed: wrong data received: '", StrMid(rsp, datablock_StartPos, 4),"' instead 'my00'." );
				return(202);
			}

//Trace("Test: ------------  Data at  >",rowNumber,"> at data block =>",rowPositionScanData.GetAt(rowNumber),">-------");
			for(ii = 0;ii < 24; ii++) wellData_ValueSet.SetAt(ii, 0.0);

			wellDataBlockNumber = 0;
			for(ii=0;ii<5;ii++) // 5 values per block position
			{
				for(columnNumber = 0;columnNumber < 8; columnNumber++) // well positions 
				{
					transmission_Data = FVal(StrMid(rsp, rowDataBlockNumber +7+6*columnNumber,5))/10000.0;
//					transmission_Data = transmission_Data + row_wellData_ValueSet.GetAt(wellDataBlockNumber + columnNumber);
					wellData_ValueSet.SetAt(wellDataBlockNumber + columnNumber,transmission_Data);
				}
				wellDataBlockNumber = wellDataBlockNumber + 8;
				rowDataBlockNumber = rowDataBlockNumber + 54;
			}

			// ------ calculate OD values for wells of one row
			for(columnNumber = 0; columnNumber < 8; columnNumber++) 
			{
				// get values per well
				wellDataBlockNumber 	= 0;
				minTransData			= 1.1;
				maxTransData			= 0.0;
				meanTransData			= 0.0;
				loop(5) // 5 values per block position
				{
					transmission_Data = wellData_ValueSet.GetAt(wellDataBlockNumber + columnNumber);
					if(transmission_Data < minTransData) minTransData = transmission_Data;
					if(transmission_Data > maxTransData) maxTransData = transmission_Data;
					meanTransData			= meanTransData + transmission_Data;
					wellDataBlockNumber	= wellDataBlockNumber + 8;
//Trace("Test: ------------  Data at  >",rowNumber,"> columnNumber =>",columnNumber,"<  transmission data =>",transmission_Data,"<-------");
				}
				// calculate mean transmission value, extreme values excluded
				transmission_Data = (meanTransData - minTransData - maxTransData)/3.0;
				if (transmission_Data > 0 )	OD_Data = -1.0 * Log10(transmission_Data);
				else									OD_Data = maxODValue;
				if (OD_Data < minODValue) OD_Data = 0;
				OD_Data= MthRound(OD_Data,5);
				OD_Data = MthMin(OD_Data,maxODValue);
				wellData_ValueSet.SetAt(columnNumber, OD_Data);	
//Trace ( "Data at well block >",rowNumber,".",ii,"> well pos >",columnNumber,"> = data =>", transmission_Data , ">==>", OD_Data ,">--" );
				// ------ assign OD values to well corresponding array index: A1 -> index 0, P1 -> index 15 , P24 -> index 383
//Trace ( "Data at  wellIndex >",wellIndex,"<  OD data ==>", OD_Data ,"<--" );
				if	(rowNumber < amountOfRows) plate_OD_ValueSet.SetAt(wellIndex, OD_Data);
				
				wellIndex = wellIndex + dataIncrement;
			}							
		}

		FormatTrace(GetFunctionName(),"()",VerDef::CMD_COMPLET);
		return(0);
	} // --------  end of function "Reader_Measure_Plate" -------------------------

	//--------------------------------------------------------------------------------------------------
	function Trace_96erPlate_OD_Values(variable& plate_OD_ValueSet[], variable& del, variable& dataFileName) 
	{
		variable rowNumber, columnNumber, wellIndex;
		variable temp(""), valuesOfRow(""), valuesOfColumn("");
		variable traceContent("");
		variable generateFileData(hslFalse);
		variable ColumnIdentifyer[];

		file dataFile;
		
		ColumnIdentifyer.SetSize(16);
		ColumnIdentifyer.SetAt(0,  "A" );
		ColumnIdentifyer.SetAt(1,  "B" );
		ColumnIdentifyer.SetAt(2,  "C" );
		ColumnIdentifyer.SetAt(3,  "D" );
		ColumnIdentifyer.SetAt(4,  "E" );
		ColumnIdentifyer.SetAt(5,  "F" );
		ColumnIdentifyer.SetAt(6,  "G" );
		ColumnIdentifyer.SetAt(7,  "H" );

		if (plate_OD_ValueSet.GetSize() < 96) return(1);
		valuesOfColumn = del + "Row:" + del + "Column:"; 
		for(rowNumber=0; rowNumber< 12; rowNumber++)
		{
			valuesOfColumn = StrConcat4(valuesOfColumn, del , "Col. " , rowNumber + 1);
		}
		Trace (valuesOfColumn );

		if (dataFileName != "")
		{
			generateFileData = hslTrue;
			dataFile.AddField( 1, traceContent, hslString);
			dataFile.Open( dataFileName, hslWrite );
//			valuesOfRow = " - " + valuesOfRow;
			traceContent =" - " + valuesOfColumn;
			dataFile.WriteRecord( );
		}		
		
		wellIndex = 0;
		for(columnNumber = 0; columnNumber < 8; columnNumber++) 
		{
			traceContent = del + ColumnIdentifyer.GetAt(columnNumber) + del ;
			wellIndex 	 = columnNumber;
			for(rowNumber=0; rowNumber <12; rowNumber++)
			{
//				temp = FStr(plate_OD_ValueSet.GetAt(wellIndex),hslFalse,4);
				temp = FormatNumber_PointAsDecimal(plate_OD_ValueSet.GetAt(wellIndex),4);
				traceContent = traceContent + del + temp;
				wellIndex = wellIndex + 8;
//				valuesOfColumn = StrConcat4(del, rowNumber+1, del, traceContent);
			}
			Trace ( traceContent );
//			Trace ( del, rowNumber+1, del, traceContent);
			if (generateFileData) dataFile.WriteRecord( );
		}

		if (generateFileData) dataFile.Close( );

		return(0);
	}// --------  end of function "Trace_96erPlate_OD_Values" -------------------------

   //--------------------------------------------------------------------------------------------------
	function Trace_384erPlate_OD_Values(variable& plate_OD_ValueSet[], variable& del, variable& dataFileName) 
	{
		variable rowNumber, columnNumber, wellIndex;
		variable temp(""), valuesOfRow(""), valuesOfColumn("");
		variable traceContent("");
		variable generateFileData(hslFalse);
		variable ColumnIdentifyer[];

		file dataFile;
		
		ColumnIdentifyer.SetSize(16);
		ColumnIdentifyer.SetAt(0,  "A" );
		ColumnIdentifyer.SetAt(1,  "B" );
		ColumnIdentifyer.SetAt(2,  "C" );
		ColumnIdentifyer.SetAt(3,  "D" );
		ColumnIdentifyer.SetAt(4,  "E" );
		ColumnIdentifyer.SetAt(5,  "F" );
		ColumnIdentifyer.SetAt(6,  "G" );
		ColumnIdentifyer.SetAt(7,  "H" );
		ColumnIdentifyer.SetAt(8,  "I" );
		ColumnIdentifyer.SetAt(9,  "J" );
		ColumnIdentifyer.SetAt(10, "K" );
		ColumnIdentifyer.SetAt(11, "L" );
		ColumnIdentifyer.SetAt(12, "M" );
		ColumnIdentifyer.SetAt(13, "N" );
		ColumnIdentifyer.SetAt(14, "O" );
		ColumnIdentifyer.SetAt(15, "P" );

		if (plate_OD_ValueSet.GetSize() < 384) return(1);
		valuesOfColumn = del + "Row:" + del + "Column:"; 
		for(rowNumber=0; rowNumber<24; rowNumber++)
		{
			valuesOfColumn = StrConcat4(valuesOfColumn, del , "Col. " , rowNumber + 1);
		}
		Trace (valuesOfColumn );

		if (dataFileName != "")
		{
			generateFileData = hslTrue;
			dataFile.AddField( 1, traceContent, hslString);
			dataFile.Open( dataFileName, hslWrite );
			traceContent =" - " + valuesOfColumn;
			dataFile.WriteRecord( );
		}		
		
		wellIndex = 0;
		for(columnNumber = 0; columnNumber < 16; columnNumber++) 
		{
			traceContent = del + ColumnIdentifyer.GetAt(columnNumber) + del ;
			wellIndex 	 = columnNumber;
			for(rowNumber=0; rowNumber<24; rowNumber++)
			{
				temp = FormatNumber_PointAsDecimal(plate_OD_ValueSet.GetAt(wellIndex),4);
				traceContent = traceContent + del + temp;
				wellIndex = wellIndex + 16;
			}
			Trace ( traceContent );
//			Trace ( del, rowNumber+1, del, traceContent);
			if (generateFileData) dataFile.WriteRecord( );
		}

		if (generateFileData) dataFile.Close( );

		return(0);
	}// --------  end of function "Trace_384erPlate_OD_Values" -------------------------


	//------------------------------------------------------------------------------
	function GetPhotoCheckPlateData(variable& io_serialNo, 
												variable& io_pathName, 			// path of reference data file " FOT.TEX"
												variable& o_partNo , 			// part no of plate
												variable& o_expiryDate,			// expiry date stored in file
												variable& nominalValues[],	// o: nominal values of wavelength for accuracy calculation
												variable& acceptanceCriteria[]// o: acceptanceCriteria of well and wavelength for accuracy calculation
																					) variable
	//------------------------------------------------------------------------------
	{
		file 	 checkPlateFile;
		variable refFileName, pathName, referenceData; 
		variable expiryDate,serialNumber,partNo, pos, year;
		variable tempOD_Data(0.0), positionToRead;
		variable dataFound;

		object fso;  				// file system object

		if (fso.IsNull()) fso.CreateObject("Scripting.FileSystemObject");

		//----- change photometer check plate definitions
		o_expiryDate = "x";
		pathName = GetMethodsPath() + VerDef::photoCheckPlateSubDirName;
		StrReplace(pathName,"XXXX", io_serialNo);

		if (io_pathName == "") io_pathName = pathName;
		if (StrRight(io_pathName,1) != "\\") io_pathName = StrConcat2(io_pathName,"\\");

		refFileName = io_pathName + Reader::ReferenceFileName;

		if (!fso.FileExists(refFileName)) return(hslFalse); // no reference data found

//Trace(" ChangeVerificationToolData: 'refFileName' ==>", refFileName, "<==");	
		// find and check new photometer data
		dataFound = 0;
	  
		checkPlateFile.AddField(1, referenceData, hslString);
		checkPlateFile.SetDelimiter(hslAsciiText);
		checkPlateFile.Open(refFileName, hslRead);			
		expiryDate = "";
		while (!checkPlateFile.Eof( ))
		{
			checkPlateFile.ReadRecord( );
			if (StrFind(referenceData," PPR") >=0)
			{
//	Trace("'Part Number' found    Data  ==>", referenceData, "<==");	
				pos = StrFind(referenceData," PPR");
				partNo =StrMid(referenceData,pos + 4,10);
				dataFound++;
			}	
			
			if (StrFind(referenceData,"S/N : ") >=0)
			{
//	Trace("'Serial Number' found    Data  ==>", referenceData, "<==");	
				serialNumber =StrRight(referenceData,4);
				dataFound++;
//	Trace("'Serial Number'  ==>", serialNumber, "<==");	
			}	
			if (StrFind(referenceData,"Datum") >=0)
			{
//	Trace("'Datum' found    Data  ==>", referenceData, "<==");	
				pos = StrFind(referenceData,"/");
				year = StrIVal( StrMid(referenceData,pos + 4,2));
				year = year + 2001;
				expiryDate = StrConcat4(year, "-",StrMid(referenceData,pos - 2,2),"-");
				expiryDate = expiryDate + StrMid(referenceData,pos + 1,2);
				if (CheckISODate(expiryDate)) dataFound++;
							//Trace("Test: 'checkPlateExpiryDate'  ==>", expiryDate, "<==");	
			}	

			// get tolerance criteria value
			if (StrFind(referenceData,"TOL405") >=0)
			{
				checkPlateFile.Seek( 4, hslCurrent);
				loop(6)
				{
					checkPlateFile.ReadRecord();
					tempOD_Data = StrIVal(StrRight(referenceData,4))/ 1000.0;
					acceptanceCriteria.AddAsLast(tempOD_Data );
// Trace("Tolerance criteria for 405nm is string ==>",referenceData, "<  as float =>",tempOD_Data,"<==");
				}
			}	

			// get accuracy nominal values
// Trace(" GetPhotmeterCritera for ",waveLenth,"nm <== nominal values at line =>",lineNo,"< searchArgument =>",searchArgument,"<==");
			if (StrFind(referenceData,"RIC405") >=0)
			{
				checkPlateFile.Seek( 4, hslCurrent);
				loop(5)
				{
					checkPlateFile.ReadRecord();
					positionToRead = 13;
					loop(8)
					{
						tempOD_Data = StrIVal(StrMid(referenceData,positionToRead,4))/ 1000.0;
						nominalValues.AddAsLast( tempOD_Data );
						positionToRead = positionToRead + 5;

// Trace("Nominal value for 405nm is string ==>",referenceData, "<  at position =>",positionToRead,"<  as float =>",tempOD_Data,"<==");
					}
				}
			}
		}
		checkPlateFile.Close( );
		checkPlateFile.RemoveFields( );

		if (dataFound != 3) return(hslFalse);  // not enough relevant data found

		io_serialNo 	= serialNumber;
		o_expiryDate 	= expiryDate;
		o_partNo			= partNo;

		pathName = GetMethodsPath() + VerDef::photoCheckPlateSubDirName;
		StrReplace(pathName,"XXXX", io_serialNo);

		if (io_pathName != pathName)
		{	//copy valid file to tool data folder	
			CopyFile(refFileName, pathName + Reader::ReferenceFileName, 0, 1);
		}

		return(hslTrue);

	} //---  end of function "GetPhotoCheckPlateData"

	//------------------------------------------------------------------------------
	function SelectFileNameDialog(variable i_titelText,
											variable& io_fileName, 
											variable& io_pathName, 
											variable i_fileFilter) 
	//------------------------------------------------------------------------------
	{
		const variable cdlOFNExplorer(0x00080000);  // FileOpenConstants

		object commonDialog;
		variable fullPath("");
		variable directory("");
		variable fileName("");
		variable pathName("");
		variable fileFilter("");	
		variable fileAndPathName;				//  Full path file name (string), e.g. "C:\\Temp\\Test.txt"
		object fso;
		object drv;
		object dir;
		object fil;

		if (fso.IsNull()) fso.CreateObject("Scripting.FileSystemObject");
		
		fileName = io_fileName;
		pathName = io_pathName;
		if (StrReverseFind(io_fileName,"\\") >=0) 
		{
			fileName = StrRight(io_fileName,StrGetLength(io_fileName) - StrReverseFind(io_fileName,"\\") -1);
			pathName = StrLeft(io_fileName,StrReverseFind(io_fileName,"\\"));
		} 

		if (i_fileFilter == "") fileFilter = "All Files|*.*";
		else							fileFilter = i_fileFilter;   // e.g. "Checkplate Files (*.tex)|*.tex|All Files|*.*"

		// Create File-Open dialog 
		commonDialog.CreateObject("HxStarVer2Dlg.VerCommonDlg");

		// Set titel of File-Open dialog 
		commonDialog.SetDialogTitle(i_titelText);

		//  Set init folder of File-Open dialog  
		commonDialog.SetInitDir(pathName);

		// Set filename of File-Open dialog 
		commonDialog.SetFileName(fileName);

		// Set filter  of File-Open dialog
		commonDialog.SetFilter(fileFilter); // eg "Checkplate Files (*.tex)|*.tex|All Files|*.*")

		// Set type of dialog
		commonDialog.SetFlags(cdlOFNExplorer);

		// Show  File-Open dialog
		commonDialog.ShowOpen();

		// Get path and file name  of selected file 
		fileAndPathName = commonDialog.GetFileName();

		// Extract path and file name
		if (fso.FileExists(fileAndPathName))
		{
			//Trace("Test: fullPath = ", fileAndPathName);

			fil = fso.GetFile(fileAndPathName);
			drv = fil.Drive;
			dir = fil.ParentFolder;
			io_fileName = fil.Name;
			io_pathName	= dir.Path;

			//Trace("Test: io_fileName = ", io_fileName);
			//Trace("Test: io_pathName = ", io_pathName);

		}

		return(fso.FileExists(fileAndPathName));
	}// -- end of function "SelectFileNameDialog"

	//------------------------------------------------------------------------------
	function DialogEnvironmentData(
						variable i_DialogTitle		//	dialog titel information of environment
														) variable  // hslOkay, hslCanel, hslAbort
	//------------------------------------------------------------------------------
	{
		variable index;
		variable titelBarText,description, remarks, warning;
		variable lowerTempLimit(15.0), upperTempLimit(35.0);
		variable valueOkay(0), allValuesOkay(0);
		variable temperature(""),humidity(""), extendedReportOption(0);
		variable returnValue;
		variable prop1(""),prop2(""),prop3(""),sn(""),date(""),lcd(""),lcb(""); // dummy place holder ;
		string 	DialogObjectName("HxStarVer2Dlg.VerEnviromentDlg"); //	function of HxStarVer2Dlg.dll
		string 	message("Create Object Failed -->");
		object 	mainDlg;

		if ( 0 == mainDlg.CreateObject(DialogObjectName) )
		{		
			//Trace("Test: Error Message => ", message, DialogObjectName, "<---");
			return( hslAbort );
		}
		// get last data out of stored information 
		//	GetVerificationInformation(Key,prop1,prop2,prop3,sn,date,lcd,lcb);

		GetVerificationInformation(KeyOperator,RPD::operatorName,prop2,prop3,sn,date,lcd,lcb);
		GetVerificationInformation(KeyLaboratory,RPD::laboratoryName, extendedReportOption ,prop3,sn,date,lcd,lcb);
		RPD::extendedReportMode = extendedReportOption= IVal(extendedReportOption);
		if(StrFind(RPD::ExtendedReportingKey,"f72e5216b4e4ea772188b40baf") < 0) extendedReportOption = -1;
		GetVerificationInformation(KeyReason,RPD::verifcationReason,prop2,prop3,sn,date,lcd,lcb);
		GetVerificationInformation(KeyTemperature,temperature,prop2,prop3,sn,date,lcd,lcb);
		RPD::temperature        = VerTool::convertToFloat(temperature);
		GetVerificationInformation(KeyHumidity,humidity,prop2,prop3,sn,date,lcd,lcb);
		RPD::humidity           = VerTool::convertToFloat(humidity);


		// display dialog until all input criteria are okay or dialog is canceled
		index = 0;
		titelBarText = "Verification Environment Conditions:";
		while ( allValuesOkay == 0 )
		{	
			index++;
			allValuesOkay = 1;
			description = LdT("Operator Name :");
			mainDlg.SetOperatorName(RPD::operatorName,description);
			description = LdT("Location Name :");
			mainDlg.SetLaboratoryName(RPD::laboratoryName,description);
			description = LdT("Verification Reason :");
			mainDlg.SetVerificationReason(RPD::verifcationReason, description);
			// check and display ambient temperature value
			description = LdT("Ambient Temperature :");
			lowerTempLimit = 15.0;
			upperTempLimit = 35.0;
			remarks 		= "15°C ... 35°C";
			valueOkay	= 1;
				 
			if(!checkInputValue(RPD::temperature, upperTempLimit, lowerTempLimit, temperature) ) valueOkay = allValuesOkay = 0;
//Trace("Test: RPD::temperature =>",RPD::temperature, "<  description =>", description, "<  remarks =>",remarks, "< valueOkay =>",valueOkay);
			temperature = VerTool::FormatNumber_PointAsDecimal(RPD::temperature,1);
			mainDlg.SetTemperature(temperature, description, remarks, valueOkay);
			// call function again to uptdate remarks and background color (a work-around)
			mainDlg.SetTemperature(temperature, description, remarks, valueOkay); 

			// check and display humidity value
			description = LdT("Ambient Humidity :");
			remarks 		= "15% ... 85%";
			valueOkay	= 1;
			if(!checkInputValue(RPD::humidity , 85.0, 15.0, humidity ) ) valueOkay = allValuesOkay = 0;
//Trace("Test: RPD::humidity =>",RPD::humidity, "<  description =>", description, "<  remarks =>",remarks, "< valueOkay =>",valueOkay);
			humidity = VerTool::FormatNumber_PointAsDecimal(RPD::humidity,1);
			mainDlg.SetHumidity(humidity, description, remarks, valueOkay);
			// call function again to uptdate remarks and background color (a work-around)
			mainDlg.SetHumidity(humidity, description, remarks, valueOkay);
			// Display extended reporting option
Trace("Test: VerDef::isRoche =>",VerDef::isRoche, "<  extendedReportOption =>", extendedReportOption, "<==");
			if((!VerDef::isRoche) && (extendedReportOption >=0))
			{
				if((PID::doVolume_1000ul_Channel_Verification	> 0) || 
					(PID::doVolume_5ml_Channel_Verification 		> 0) ||
					(PID::doTemperature_Verification 				> 0) ||
					((PID::doVolume_96mpH_Verification > 0) && (VerDef::multi96PipHead == 4)) )
					{
						description = LdT("Extented reporting option (with prelonged execution)");
						mainDlg.SetExtendedReportingOption(description, RPD::extendedReportMode);
					}
			}
			else 
			{	
				RPD::extendedReportMode = 0;
				extendedReportOption		= -1;
			}

			if ((allValuesOkay > 0) && (index > 1)) break;

			if (allValuesOkay > 0) 	warning = "";
			else					 		warning = LdT("WARNING:") + " " + LdT("Invalid values are yellow marked!");

			mainDlg.SetDialogInfo(titelBarText,i_DialogTitle, warning);

			// --- Display dialog
			returnValue = mainDlg.Show();
//Trace("Test: returnValue = mainDlg.Show();=>",returnValue);
			if ( returnValue == 0)
			{
				VerTool::TraceDlgCancel( titelBarText);
				return( hslCancel );
			}

			// Get the input values
			mainDlg.GetLabInformation(RPD::operatorName, RPD::laboratoryName, RPD::verifcationReason);
			temperature			= mainDlg.GetTemperature();
			StrReplace(temperature, "," , ".");			
			RPD::temperature	= VerTool::convertToFloat(temperature);
			humidity = mainDlg.GetHumidity();
			StrReplace(humidity , "," , ".");			
			RPD::humidity     = VerTool::convertToFloat(humidity);
			if(extendedReportOption>= 0) RPD::extendedReportMode = mainDlg.GetExtendedReportingOption();
			allValuesOkay = 0;
		}

		VerTool::TraceDlgOK( titelBarText);

		//Trace("Test: RPD::operatorName  		= ", RPD::operatorName);
		//Trace("Test: RPD::laboratoryName    = ", RPD::laboratoryName);
		//Trace("Test: RPD::verfifcationReason= ", RPD::verifcationReason);
		//Trace("Test: RPD::temperature  		= ", RPD::temperature);
		//Trace("Test:  RPD::humidity      		= ", RPD::humidity);

		// update  data into stored information 
		//	UpdateVerificationInformation(store,Key,prop1,prop2,prop3,sn,date);
		prop1 = prop2 = prop3 =sn = date = "";

		UpdateVerificationInformation(0,KeyOperator,RPD::operatorName,prop2,prop3,sn,date);
		UpdateVerificationInformation(0,KeyLaboratory,RPD::laboratoryName, RPD::extendedReportMode,prop3,sn,date);
		UpdateVerificationInformation(0,KeyReason,RPD::verifcationReason, prop2,prop3,sn,date);
		UpdateVerificationInformation(0,KeyTemperature,mainDlg.GetTemperature(), prop2,prop3,sn,date);
		UpdateVerificationInformation(1,KeyHumidity,mainDlg.GetHumidity(), prop2,prop3,sn,date);

		return( hslOK);
	} // -- end of function "DialogMainProcessData"

	//------------------------------------------------------------------------------
	function DialogVerifcationToolData(
						variable i_DialogTitle					//	dialog titel information of environment
														) variable  // hslOkay, hslCanel, hslAbort
	//------------------------------------------------------------------------------
	{
		variable index;
		variable titelBarText("");
		variable description(""), remarks(""), warning(""), commandButton(""),guidance(""), checkplateInfo("");
		variable calibrationDateText(""), expiryDateText, serialNoText(""),partAndSerialNoText(""), dateFormatText("");
		variable dateOkay(0),portOkay(0),valueOkay(0), allValuesOkay(0);
		variable comPort(""),comPortDescription(""), ethernetOptionTxt(""),ethernetOption(0);                               
		variable prop1(""),prop2(""),prop3(""), balanceSNx(""),expiryDate,sn,date(""),lcd(""),lcb(""); // dummy place holder ;
		variable nominalValues[],acceptanceCriteria[]; // // dummy place holder ;

		variable returnValue(0);
		variable fileName, pathName;
		string DialogObjectName("HxStarVer2Dlg.VerToolsDlg"); //	function of HxStarVer2Dlg.dll
		string message("Create Object Failed -->");
		object mainDlg;

		if ( 0 == mainDlg.CreateObject(DialogObjectName) )
		{		
			//Trace("Test: Error Message => ", message, DialogObjectName, "<---");
			return( hslAbort );
		}
		
//		if ((	 PS::showBalanceData + PS::showTempDeviceData + PS::showTempHumDeviceData + PS::showPhotoCheckPlateData + PS::showBC_CarrierData + PS::showBC_TwisterData) == 0)
		if ((	 PS::showBalanceData + PS::showTempHumDeviceData + PS::showPhotoCheckPlateData + PS::showBC_CarrierData + PS::showBC_TwisterData) == 0)
		{	// no verification tool data to show
			return( hslOK );
		}

		// get last data out of stored information 
		//	GetVerificationInformation(Key,prop1,prop2,prop3,sn,date,lcd,lcb);
		GetVerificationInformation(KeyBalance,Balance::Type ,comPort, Balance::CheckedStatus, Balance::SerialNumber, Balance::CalibrationDate,lcd,lcb);
		Balance::ComPort = VerTool::convertToInteger(comPort);
		if((Balance::Type == Balance::Type_WMC) && (Balance::ComPort < 0)) {ethernetOption = 1;}

		GetVerificationInformation(KeyCalWeight,Balance::CalibrationWeight,Balance::CalibrWeightExpiryDate,prop3,Balance::CalibrationWeightID,Balance::CalibrationWeightDate,lcd,lcb);

//		GetVerificationInformation(KeyTempDevice,IR_Temp::Sensor_ExpiryDate,IR_Temp::Sensor_ComPort,prop3,IR_Temp::Sensor_SerialNo,IR_Temp::Sensor_CalDate,lcd,lcb);

		GetVerificationInformation(KeyHumidityDevice,RPD::humidityDeviceExpiryDate,prop2,prop3,RPD::humidityDeviceSerial,RPD::humidityDeviceCalDate,lcd,lcb);

//		GetVerificationInformation(KeyTwisterTool,RPD::twisterToolExpiryDate,prop2,prop3,RPD::twisterToolSerial,RPD::twisterToolCalDate,lcd,lcb);
		GetVerificationInformation(KeyTwisterTool,RPD::twisterToolExpiryDate,prop2,prop3,RPD::twisterToolSerial,date,lcd,lcb);

		GetVerificationInformation(KeyBC_Carrier,RPBARC::BC_CarrierExpiryDate,prop2,prop3,RPBARC::BC_CarrierSerial,RPBARC::BC_CarrierCalDate,lcd,lcb);

		GetVerificationInformation(KeyPhotoCheckPlate,Reader::photoCheckPlatePartNo,prop2,prop3,Reader::photoCheckPlateSerial,Reader::photoCheckPlateExpiryDate,lcd,lcb);
		pathName = "";
		GetPhotoCheckPlateData(Reader::photoCheckPlateSerial, pathName ,Reader::photoCheckPlatePartNo, 
													Reader::photoCheckPlateExpiryDate,nominalValues,acceptanceCriteria);

//Trace("------------------ GetVerificationInformation -------------------");
//Trace("Balance::Type  		= ", Balance::Type);
//Trace("Balance::CalibrationDate= ", Balance::CalibrationDate);
//Trace("Balance::ComPort   		= ", Balance::ComPort);
//Trace("Balance::CalibrationWeightDate   = ", Balance::CalibrationWeightDate);
//Trace("IR_Temp::Sensor_SerialNo      =>", IR_Temp::Sensor_SerialNo,"< IR_Temp::Sensor_CalDate   = ", IR_Temp::Sensor_CalDate, "<==");
//Trace("RPD::humidityDeviceSerial  =>", RPD::humidityDeviceSerial,"< RPD::humidityDeviceCalDate   = ", RPD::humidityDeviceCalDate, "<==");
//Trace("Reader::photoCheckPlateSerial   = ", Reader::photoCheckPlateSerial,"< Reader::photoCheckPlateExpiryDate   = ", Reader::photoCheckPlateExpiryDate);
//Trace("RPBARC::BC_CarrierSerial  = ", RPBARC::BC_CarrierSerial,"< RPD::tempHumCalDate   = ", RPBARC::BC_CarrierCalDate);
//Trace("------------------------------------------------------------------");

		titelBarText 			= LdT("Verification Tool Definitions:");
		calibrationDateText	= LdT("Calibration Date:");
		expiryDateText			= LdT("Expiry Date:");
		serialNoText			= LdT("Serial No.");
		partAndSerialNoText	= LdT("Part and Serial No.");
		dateFormatText			= LdT("(YYYY-MM-DD)");
		comPortDescription	= LdT("Com-Port:");
		fileName					= Reader::ReferenceFileName;
		pathName 				= GetMethodsPath() + VerDef::toolsSubDirName;

		// display dialog until all input criteria are okay or dialog is canceled
		index = 0;
		while ( allValuesOkay == 0 )
		{	
			index++;
			allValuesOkay  = 1;
			dateOkay			= 1;
			portOkay			= 1;
			// --- define balance information
			if (PS::showBalanceData >0)
			{
				description = LdT("Balance") + " :";
				if (VerTool::ValidateDate(Balance::CalibrationDate, VerDef::oneYear, Balance::ExpiryDate, dateOkay, remarks) < 0) allValuesOkay = 0;
				if ((ethernetOption == 0)&& ((Balance::ComPort < 1) || (Balance::ComPort > 20))) portOkay	= allValuesOkay = 0;
				comPort= VerTool::FormatNumber_PointAsDecimal(Balance::ComPort,0);
				mainDlg.AddBalanceType(Balance::Type_WXS);
				mainDlg.AddBalanceType(Balance::Type_SAG);
				if(VerDef::isRoche) 
				{
					mainDlg.AddBalanceType(Balance::Type_WMC);
					ethernetOptionTxt = LdT("via Ethernet Interface");
					mainDlg.ShowEthernetOption(ethernetOptionTxt, ethernetOption);
					if(ethernetOption == 1) comPort = "1";
				}
			}
			else description = ""; // no data displayed
			mainDlg.SetBalanceInfo(description, Balance::Type, Balance::CalibrationDate, dateOkay, remarks,
																		comPortDescription, comPort, portOkay);
          // call function again to uptdate remarks and background color (a work-around)
			mainDlg.SetBalanceInfo(description, Balance::Type, Balance::CalibrationDate, dateOkay, remarks,
																		comPortDescription, comPort, portOkay);

        // ---- define calibration weight information  
			dateOkay			= 1; 
			if (PS::showBalanceData > 0)
			{          
				description = LdT("Calibration Weight No.:");
				if (VerTool::ValidateDate(Balance::CalibrationWeightDate, VerDef::twoYears, Balance::CalibrWeightExpiryDate, dateOkay, remarks) < 0) allValuesOkay = 0;
			}
			else description = ""; // no data displayed
			mainDlg.SetCalWeightInfo(description, Balance::CalibrationWeightID, Balance::CalibrationWeightDate, dateOkay, remarks);

         // ---- define temperature device information  
//			dateOkay			= 1;           
//			if (PS::showTempDeviceData > 0)
//			{          
//				description = LdT("Temperature Measurement Device :");
//				if (VerTool::ValidateDate(IR_Temp::Sensor_CalDate, VerDef::oneYear, IR_Temp::Sensor_ExpiryDate,  dateOkay, remarks) < 0) allValuesOkay = 0;
//
//			}
//			else description = ""; // no data displayed
//			mainDlg.SetTempDeviceData(description, IR_Temp::Sensor_ComPort, IR_Temp::Sensor_CalDate, dateOkay, remarks);

         // ---- define humidity device information  
			dateOkay			= 1;           
			if (PS::showTempHumDeviceData > 0)
			{          
				description = LdT("Ambient Temperature and Humidity Measurement Device :");
				if (VerTool::ValidateDate(RPD::humidityDeviceCalDate, VerDef::oneYear, RPD::humidityDeviceExpiryDate,  dateOkay, remarks) < 0) allValuesOkay = 0;
			}
			else description = ""; // no data displayed
			mainDlg.SetHumidityDeviceData(description, RPD::humidityDeviceSerial, RPD::humidityDeviceCalDate, dateOkay, remarks);
			
         // ---- define photo checkplate information  
			dateOkay			= 1;           
			if (PS::showPhotoCheckPlateData > 0)
			{          
				if (StrFind(Reader::photoCheckPlatePartNo, "148395")>= 0) description = "Photo Check Plate =>";
				else description = LdT("Reader Check Plate :");
				if (VerTool::ValidateDate(Reader::photoCheckPlateExpiryDate, 0,expiryDate, dateOkay, remarks) < 0) allValuesOkay = 0;
			}
			else description  = ""; // no data displayed
			commandButton		= LdT("Get New Reference Data");
			guidance				= LdT("For new check plate reference data, insert the mini CD with the file 'FOT_REF.TEX'.  ") + VerDef::CRLF 
										 + LdT("Please leave the CD in the CD-ROM Drive until the end of the Verification.");

			checkplateInfo		= StrConcat4(Reader::photoCheckPlatePartNo," ; ",Reader::photoCheckPlateSerial,"");
			mainDlg.SetPhotoCheckPlateData(description, checkplateInfo, Reader::photoCheckPlateExpiryDate,  
														remarks, guidance,  commandButton, dateOkay);
         // ---- define barcode carrier information  
			dateOkay			= 1;           
			if (PS::showBC_CarrierData > 0)
			{          
				description = LdT("Barcode Verification Carrier :");
				if (VerTool::ValidateDate(RPBARC::BC_CarrierCalDate, VerDef::twoYears, RPBARC::BC_CarrierExpiryDate, dateOkay,remarks) < 0) allValuesOkay = 0;
			}
			else description = ""; // no data displayed
			mainDlg.SetBC_CarrierData(description, RPBARC::BC_CarrierSerial, RPBARC::BC_CarrierCalDate, dateOkay, remarks);

         // ---- define twister verification tool information  
			dateOkay			= 1;           
			if (PS::showBC_TwisterData > 0)
			{          
				description = LdT("Twister Verification Tool:");
            RPD::twisterToolCalDate = ""; // no check of twister tool expiry date (2013-07-10 / ec)
            // if (VerTool::ValidateDate(RPD::twisterToolCalDate, VerDef::twoYears, RPD::twisterToolExpiryDate, dateOkay,remarks) < 0) allValuesOkay = 0;
			}
			else description = ""; // no data displayed
			mainDlg.SetTwisterToolData(description, RPD::twisterToolSerial, RPD::twisterToolCalDate, dateOkay, remarks);

			// check status	
			if ((allValuesOkay > 0) && (index > 1)) break;

			if (allValuesOkay > 0) 	warning = "";
			else					 		warning = LdT("WARNING:") + " " +LdT("Invalid values are yellow marked!");

			mainDlg.SetDialogInfo(titelBarText, i_DialogTitle, warning, calibrationDateText,expiryDateText, 
											dateFormatText, serialNoText, partAndSerialNoText	);

			// -------   Display dialog   -----------------------------------------------------------------------------------
			returnValue = mainDlg.Show();
			// --------------------------------------------------------------------------------------------------------------

			//Trace("Test: returnValue = mainDlg.Show();=>",returnValue);
			if ( returnValue == 0)
			{
				VerTool::TraceDlgCancel( titelBarText);
				return( hslCancel );
			}

			// Get the input values
			if (PS::showBalanceData > 0)
			{
				mainDlg.GetBalanceData(Balance::Type , Balance::CalibrationDate, comPort, ethernetOption);
				if((ethernetOption > 0) && (Balance::Type != Balance::Type_WMC)) 
				{// Ethernet option only with WMC balance	
					comPort = "0"; 
					ethernetOption = 0;
				}
				Balance::ComPort = VerTool::convertToInteger(comPort);
				Balance::CalibrationWeightDate = mainDlg.GetCalWeightDate(Balance::CalibrationWeightID);
				//Trace("Test: Balance::Type =>",Balance::Type,"<    CalibrationWeightID ==>",Balance::CalibrationWeightID,"<=="); 
			}
//			if (PS::showTempDeviceData > 0)		mainDlg.GetTempDeviceData(IR_Temp::Sensor_ComPort, IR_Temp::Sensor_CalDate );
			if (PS::showTempHumDeviceData > 0) 	mainDlg.GetHumidityDeviceData(RPD::humidityDeviceSerial, RPD::humidityDeviceCalDate );

			if (PS::showPhotoCheckPlateData > 0)	
			{  // get photometer data
				if (returnValue == 2) 
				{
					VerTool::TraceDlgCancel( titelBarText);
					Reader::photoCheckPlateSerial = "";
					SelectFileNameDialog("Select Photometer Check Plate Reference Data File:",
													fileName, pathName,"Checkplate Files (*.tex)|*.tex|All Files|*.*");
					GetPhotoCheckPlateData(Reader::photoCheckPlateSerial, pathName,Reader::photoCheckPlatePartNo, 
													Reader::photoCheckPlateExpiryDate,nominalValues,acceptanceCriteria);
					Reader::newReferenceData = hslTrue;
					index = 0; // to display tool dialog again
				}
//				else	mainDlg.GetPhotoCheckPlate(Reader::photoCheckPlateSerial,Reader::photoCheckPlateExpiryDate);

			}
			if (PS::showBC_CarrierData > 0) mainDlg.GetBC_CarrierData(RPBARC::BC_CarrierSerial, RPBARC::BC_CarrierCalDate);
			if (PS::showBC_TwisterData > 0) mainDlg.GetTwisterToolData(RPD::twisterToolSerial, RPD::twisterToolCalDate);		

			allValuesOkay = 0;
		}// --- end of loop


		VerTool::TraceDlgOK( titelBarText );

//		Trace("------------------ Update following verification data -------------------");
//		Trace("Balance::Type  		= ", Balance::Type);
//		Trace("Balance::CalibrationDate= ", Balance::CalibrationDate);
//		Trace("Balance::ComPort   		= ", Balance::ComPort);
//		Trace("Balance::CalibrationWeightDate   = ", Balance::CalibrationWeightDate);
//		Trace("IR_Temp::Sensor_ComPort     =>", IR_Temp::Sensor_ComPort,"< IR_Temp::Sensor_CalDate   = ", IR_Temp::Sensor_CalDate, "<==");
//		Trace("RPD::humidityDeviceSerial =>", RPD::humidityDeviceSerial,"< RPD::humidityDeviceCalDate   = ", RPD::humidityDeviceCalDate, "<==");
//		Trace("Reader::photoCheckPlateSerial   = ", Reader::photoCheckPlateSerial,"< Reader::photoCheckPlateExpiryDate   = ", Reader::photoCheckPlateExpiryDate);
//		Trace("RPBARC::BC_CarrierSerial  = ", RPBARC::BC_CarrierSerial,"< RPD::tempHumCalDate   = ", RPBARC::BC_CarrierCalDate);
//		Trace("------------------------------------------------------------------");

		// update  data into stored information 
		//	UpdateVerificationInformation(store,Key,prop1,prop2,prop3,sn,date);
		prop1 = prop2 = prop3 =sn = date = "";
		if(ethernetOption == 1) comPort = "-1";
		UpdateVerificationInformation(0, KeyBalance,Balance::Type ,comPort, Balance::CheckedStatus, Balance::SerialNumber, Balance::CalibrationDate);
		UpdateVerificationInformation(0, KeyCalWeight,Balance::CalibrationWeight,Balance::CalibrWeightExpiryDate,prop3,Balance::CalibrationWeightID,Balance::CalibrationWeightDate);
//		UpdateVerificationInformation(0, KeyTempDevice,IR_Temp::Sensor_ExpiryDate,IR_Temp::Sensor_ComPort,prop3,IR_Temp::Sensor_SerialNo,IR_Temp::Sensor_CalDate);
		UpdateVerificationInformation(0, KeyHumidityDevice,RPD::humidityDeviceExpiryDate,prop2,prop3,RPD::humidityDeviceSerial,RPD::humidityDeviceCalDate);
		UpdateVerificationInformation(0, KeyPhotoCheckPlate,Reader::photoCheckPlatePartNo,prop2,prop3,Reader::photoCheckPlateSerial,Reader::photoCheckPlateExpiryDate);
		UpdateVerificationInformation(0, KeyTwisterTool,RPD::twisterToolExpiryDate,prop2,prop3,RPD::twisterToolSerial,RPD::twisterToolCalDate);
		UpdateVerificationInformation(1, KeyBC_Carrier,RPBARC::BC_CarrierExpiryDate,prop2,prop3,RPBARC::BC_CarrierSerial,RPBARC::BC_CarrierCalDate);

		return( hslOK);
	} // -- end of function "DialogVerifcationToolData"

	//------------------------------------------------------------------------------
	function DialogVerifcationConsumableData(
						variable i_DialogTitle,					//	dialog titel information of environment
						variable i_solutionPartNo,				// solution part number
						variable i_showSolution_1				// to show verification solution 1 data
																) variable  // hslOkay, hslCanel
	//------------------------------------------------------------------------------
	{
		variable index;
		variable titelBarText("");
		variable description(""), remarks(""), warning("");
		variable sn,lcd,lcb;
		variable expiryDateText(""),serialNoText(""),dateFormatText(""),expiryDate("");
		variable solution_1_Description(""),solution_2_Description("") ,solution_3_Description("");
		variable date1Okay(0),date2Okay(0),date3Okay(0), valueOkay(0), allValuesOkay(0);

		string DialogObjectName("HxStarVer2Dlg.VerConsumableDlg"); //	function of HxStarVer2Dlg.dll
		string message("Create Object Failed -->");
		object mainDlg;

		if ( 0 == mainDlg.CreateObject(DialogObjectName) )
		{		
			//Trace("Test: Error Message => ", message, DialogObjectName, "<---");
			return( hslAbort );
		}

		titelBarText 			= LdT("Consumables Definitions:");
		expiryDateText			= LdT("Expiry Date:");
		dateFormatText			= LdT("(YYYY-MM-DD)");

 		GetVerificationInformation(KeyReagent,RPD::solutionLotNumber,RPD::solution1_ExpiryDate,RPD::solution2_ExpiryDate
												,sn,RPD::solution3_ExpiryDate,lcd,lcb);
                            
		// display dialog until all input criteria are okay or dialog is canceled
		index = 0;
		while ( allValuesOkay == 0 )
		{	
			index++;
			allValuesOkay  = 1;
			date1Okay = date2Okay = date3Okay = 1;
			if (VerTool::ValidateDate(RPD::solution1_ExpiryDate, 0, RPD::solution1_ExpiryDate, date1Okay, remarks) < 0) allValuesOkay = 0;

			// --- define verification solution information
			if (i_showSolution_1 > 0)
			{
				description 				= LdT("Verification Solution Kit Lot No. :");
				solution_1_Description 	= "---->";
			}

			mainDlg.SetReagentInfo(description, RPD::solutionLotNumber, i_solutionPartNo,
											solution_1_Description, RPD::solution1_ExpiryDate, date1Okay,
											solution_2_Description, RPD::solution2_ExpiryDate, date2Okay,
											solution_3_Description, RPD::solution3_ExpiryDate, date3Okay);

         // ---- define tip rack information weight information  
			if ((allValuesOkay > 0) && (index > 1)) break;

			if (allValuesOkay > 0) 	warning = "";
			else					 		warning = LdT("WARNING:") + " " + LdT("Invalid values are yellow marked!");

			mainDlg.SetDialogInfo(titelBarText, i_DialogTitle, warning, expiryDateText, dateFormatText);

			// --- Display dialog
			if ( mainDlg.Show() == hslFalse )
			{
				VerTool::TraceDlgCancel( titelBarText);
				return( hslCancel );
			}

			// Get the input values
			mainDlg.GetReagentInfos(RPD::solutionLotNumber, RPD::solution1_ExpiryDate, RPD::solution2_ExpiryDate, RPD::solution3_ExpiryDate);

			allValuesOkay = 0;

			//Trace("RPD::solutionLotNumber 	  = ", RPD::solutionLotNumber);
			//Trace("RPD::solution1_ExpiryDate   = ", RPD::solution1_ExpiryDate);
		}

		UpdateVerificationInformation(1, KeyReagent,RPD::solutionLotNumber,RPD::solution1_ExpiryDate,RPD::solution1_ExpiryDate
												,sn,RPD::solution1_ExpiryDate);

		VerTool::TraceDlgOK( titelBarText);

		return( hslOK);
	} // -- end of function "DialogVerifcationConsumableData"


	//-----------------------------------------------------------------------------------------------------
	function SetDialogTimer(variable i_indicatedTime, variable i_dialogTimeOut)
	//	add time out information used in function "DialogInfoData"
	//-----------------------------------------------------------------------------------------------------
	{
		VerDef::indicatedTime = i_indicatedTime;			// dialog (count down) timer  indicating time
		// dialog (count down) timer  time out
		if(i_dialogTimeOut > i_indicatedTime) 	VerDef::dialogTimeOut = i_indicatedTime;
		else												VerDef::dialogTimeOut = i_dialogTimeOut;
	} // -- end of function "DialogVerifcationToolData"

	//------------------------------------------------------------------------------
	function DialogInfoData(
						variable i_dialogTitle,			//	dialog titel information
						variable i_pictureFile,			// picture file name (in subdirectory "..\\Methods\Verification\Pictures\""
						variable i_dialogInfoText,		// dialog information text
						variable i_warningText,			// Warning text
						variable i_buttonsTypes,		// indicate the buttons: hslOKOnly (0), hslOKCancel (1), hslYesNo(4) 
						variable i_defaultButton,		// define number ofdefault button: (else first button is default)
						variable i_inputDescription,	// input value description (if "" no value will be displayed
						variable i_inputRemarks,		// remarks for input value: units, range, meanng
						variable& io_variableValue			// input value to be changed (string)
																) variable
	//------------------------------------------------------------------------------
	{
		object infoDlg;
		variable titelBarText(""),warningText;
		variable picFileName(""), picFolderName("");
		variable cmdButton1(""), cmdButton2(""), cmdButton3(""), defaultButton;
		variable userResponse, returnValue;

		string DialogObjectName("HxStarVer2Dlg.VerInfoDlg"); //	function of HxStarVer2Dlg.dll
		string message("Create Object Failed -->");

		object fso;  // file system object
		if (fso.IsNull()) fso.CreateObject("Scripting.FileSystemObject");

		if ( 0 == infoDlg.CreateObject(DialogObjectName) )
		{		
			//			Trace("Test Error Message => ", message, DialogObjectName, "<---");
			return( hslFalse );
		}
		// define command buttons
		cmdButton1 = LdT("OK");
		if (i_buttonsTypes == hslOKCancel) cmdButton2 = LdT("Cancel");
		if (i_buttonsTypes == hslYesNoCancel) 
		{	
			cmdButton1 = LdT("Yes");
			cmdButton2 = LdT("No");
			cmdButton3 = LdT("Cancel");
			if ((i_defaultButton > 3) || (i_defaultButton < 2)) i_defaultButton = 1;
		}	

		if (i_buttonsTypes == hslYesNo) 
		{	
			cmdButton1 = LdT("Yes");
			cmdButton2 = LdT("No");
			if (i_defaultButton != 2) i_defaultButton = 1;
		}

		titelBarText = LdT("User information:");
		picFolderName = GetMethodsPath() + "\\Verification\\Pictures\\";
		picFileName = picFolderName + i_pictureFile;
		//Trace( "Test: Debug information:  Dialog '", i_dialogTitle, "' ->  picture file'", i_pictureFile,"' ");
		if (!fso.FileExists(picFileName)) 
		{
			picFileName = picFolderName +  "WaitForPicture.jpg";
			//Trace( "Test: Debug information:  Dialog '", i_dialogTitle, "' has no picture file'", i_pictureFile,"' ");
		}

		warningText	= i_warningText;
		infoDlg.SetPicture(picFileName);

		// -- Trace dialog information
		FormatTrace("Dialog information:","()", VerDef::CMD_COMPLET ,"----------------------------------");
		FormatTrace("Dialog information:","()", VerDef::CMD_COMPLET ,"--",titelBarText);
		FormatTrace("Dialog information:","()", VerDef::CMD_COMPLET ,"--",i_dialogTitle);
		FormatTrace("Dialog information:","()", VerDef::CMD_COMPLET ,"----------------------------------");
		FormatTrace("Dialog information:","()", VerDef::CMD_COMPLET ,"--",i_dialogInfoText);
		FormatTrace("Dialog information:","()", VerDef::CMD_COMPLET ,"--",warningText);
		FormatTrace("Dialog information:","()", VerDef::CMD_COMPLET ,"----------------------------------");


		infoDlg.SetInfoText(i_dialogInfoText, warningText); 
//Trace("--- Test: cmdButton1 ==>", cmdButton1,"< cmdButton2==>", cmdButton2,"< cmdButton3 ==>", cmdButton3,"< default =>",i_defaultButton,"<==");
		infoDlg.SetDialogInfo(titelBarText, i_dialogTitle, cmdButton1, cmdButton2, cmdButton3, i_defaultButton);

		infoDlg.SetInputField(io_variableValue,i_inputDescription, i_inputRemarks);

		// show timer info
		if (VerDef::indicatedTime > 0) 
		{
			if (VerDef::dialogTimeOut > VerDef::indicatedTime  ) VerDef::dialogTimeOut = VerDef::indicatedTime ;
			infoDlg.SetTimer(VerDef::indicatedTime , VerDef::dialogTimeOut);
			// reset timer variable
			VerDef::indicatedTime = 0;
			VerDef::dialogTimeOut = 0;
		}

		userResponse = infoDlg.Show();
//Trace("Information Dialog: button ",returnValue, " was pressed.");
		// assign return value to correspondig hsl status
		if (i_buttonsTypes == hslOKOnly) returnValue = hslOK;
		if (i_buttonsTypes == hslOKCancel) 
		{
			if (userResponse < 2 )	returnValue = hslOK;
			else							returnValue = hslCancel;
		}
		if (i_buttonsTypes == hslYesNoCancel) 
		{	
			if (userResponse < 2 ) 			returnValue = hslYes;
			else	if (userResponse == 2 ) 	returnValue = hslNo;
					else							returnValue = hslCancel;					
		}	
		if (i_buttonsTypes == hslYesNo) 
		{
			if (userResponse < 2 ) 	returnValue = hslYes;
			else							returnValue = hslNo;
		}
      //Trace("Test: Information Dialog: button =>",userResponse, " was pressed => returnValue =>",returnValue,"<==");
		if (userResponse == 0 ) return( returnValue ); // time out

		if (i_inputDescription != "") 
		{
			io_variableValue = infoDlg.GetInputField();
			FormatTrace("Dialog information:","()", VerDef::CMD_COMPLET ,"--",i_inputDescription);
			FormatTrace("Dialog information:","()", VerDef::CMD_COMPLET ,"--",i_inputRemarks);
			FormatTrace("Dialog information:","()", VerDef::CMD_COMPLET ,"==>",io_variableValue);
			FormatTrace("Dialog information:","()", VerDef::CMD_COMPLET ,"----------------------------------");
		}

		FormatTrace("Dialog information:","()", VerDef::CMD_COMPLET ," User Response ==>", returnValue ,"<==");
		FormatTrace("Dialog information:","()", VerDef::CMD_COMPLET ,"----------------------------------");


//Trace("--- Test: ",i_inputDescription, " ==>", io_variableValue,"<==", i_inputRemarks,"< is type ", GetType(io_variableValue));

		return( returnValue );
	}  // -- end of function "DialogInfoData"

	//------------------------------------------------------------------------------
	function VerificationNotImplementedDialog(variable dialogTitle, variable warning) //variable
	//------------------------------------------------------------------------------
	{
		variable pictureFile("");			// picture file name (in subdirectory "..\\Methods\Verification\Pictures\""

		pictureFile 		= "Not_Implemented.jpg";
		VerTool::NewTextLine(1,"===  " + LdT("VERIFICATION NOT IMPLEMENTED!") +  "====");
		VerTool::NewTextLine(0," ");
		VerTool::NewTextLine(0," ");
		VerTool::NewTextLine(0,LdT("Installed Software Version:") + "  " + VerDef::SWReleaseVersion);

		if (warning	== "x") warning = LdT("Note:") + " " +LdT("The Verification step will be skipped.");	

		VerTool::DialogInfoData(dialogTitle, pictureFile, VerDef::dialogText,warning, hslOKOnly, 1,"","","");

	}  // -- end of function "VerificationNotImplementedDialog"
		
	//------------------------------------------------------------------------------
	function Check_PreConditions(device ML_STAR, variable processIDs[], variable dialogTitle) //variable
	//------------------------------------------------------------------------------
	{
		variable pictureFile("");			// picture file name (in subdirectory "..\\Methods\Verification\Pictures\""
		variable warning(""), remarks;
		variable sizeOfSteps(0), index;
		variable checkStatus(hslTrue), dateOkay;
		variable processID, processedState, processedDate, expiryDate, processedTime, verInterval;
		sizeOfSteps = processIDs.GetSize();
			
		pictureFile 		= "Steps_missing.jpg";

		warning = LdT("Note:") + " " + LdT("Verification status will not be changed.");	
		VerTool::NewTextLine(1,"===  " +  LdT("VERIFICATION SKIPPED") +  "====");
		VerTool::NewTextLine(0," ");
		VerTool::NewTextLine(0," ");
		VerTool::NewTextLine(0, LdT("Following steps should be properly performed in advanced:"));
		VerTool::NewTextLine(0," ");
		for ( index = 0; index < sizeOfSteps ; index++)
		{
			processID =  processIDs.GetAt(index);
			VerTool::GetProcessDataFromInstrument( ML_STAR, processID, processedState, processedDate, processedTime, verInterval);
			
			if ((VerTool::ValidateDate(processedDate, verInterval, expiryDate, dateOkay, remarks) < 0) || (processedState == 0) )
			{
				checkStatus = hslFalse;
				VerTool::NewTextLine(0," ");

				if(processID == PID::DailyMaintenance) {VerTool::NewTextLine(0,"- " + LdT("Daily Maintenance"));}
				else if(processID == PID::XYZ_1000ulChannel)
				{
					VerTool::NewTextLine(0,"- " + LdT("1000µl Pipetting Channels Position Verification"));				
				}
				else if(processID == PID::XYZ_5mlChannel)
				{
					VerTool::NewTextLine(0,"- " + LdT("5ml Pipetting Channels Position Verification"));				
				}
				else if(processID == PID::XYZ_multi96PipHead)
				{
					VerTool::NewTextLine(0,"- " + LdT("96 Multi-Probe Head Position Verification"));				
				}
				else if(processID == PID::XYZ_multi384PipHead)
				{
					VerTool::NewTextLine(0,"- " + LdT("384 Multi-Probe Head Position Verification"));				
				}
				else
				{
					VerTool::NewTextLine(0," Unknown process ID => " + IStr( processID));				
				}
			}
		}

		if (checkStatus) return (hslTrue); // all checks okay

		VerTool::DialogInfoData(dialogTitle, pictureFile, VerDef::dialogText, warning, hslOKOnly, 1, "","","");
		if(VerDef::SimulationMode) return (hslTrue);
		return(hslFalse);

	}  // -- end of function "Check_Predecessor"

	//------------------------------------------------------------------------------
	function VerificationFailedDialog(variable dialogTitle, variable warning) //variable
	//------------------------------------------------------------------------------
	{
		variable pictureFile("");			// picture file name (in subdirectory "..\\Methods\Verification\Pictures\""

		if (warning	== "s") 
		{ 
			pictureFile 		= "Verification_stopped.jpg";

			warning = LdT("Note:") + " " + LdT("Verification status will not be changed.");	
			VerTool::NewTextLine(1,"===  " +  LdT("VERIFICATION STOPPED") +  "====");
			VerTool::NewTextLine(0," ");
			VerTool::NewTextLine(0, LdT("Reason: Processing error"));
			VerTool::NewTextLine(0," ");
			VerTool::NewTextLine(0," ");
			VerTool::NewTextLine(0,LdT("Check trace file for detailed information."));
		}
		else if (warning	== "m") 
		{ 
			pictureFile 		= "OutOfRange.jpg";

			warning = LdT("Note:") + " " + LdT("Verification status will not be changed.");	
			VerTool::NewTextLine(1,"===  " +  LdT("NOT A REACHABLE POSITION") +  "====");
			VerTool::NewTextLine(0," ");
			VerTool::NewTextLine(0, LdT("Reason: No access to defined labware position possible."));
			VerTool::NewTextLine(0," ");
			VerTool::NewTextLine(0," ");
			VerTool::NewTextLine(0,LdT("Define position correctly before starting verification run again."));
		}
		else
		{
			pictureFile 		= "Verification_failed.jpg";

			VerTool::NewTextLine(1,"===  " +  LdT("VERIFICATION FAILED!") +  "====");
			VerTool::NewTextLine(0," ");
			VerTool::NewTextLine(0," ");
			VerTool::NewTextLine(0,LdT("Check the report and manual for detailed information."));
		}
		if (warning	== "x") warning = LdT("ATTENTION:") + " " + LdT("Verification status is set to 'Failed'.");	


		VerTool::DialogInfoData(dialogTitle, pictureFile, VerDef::dialogText,warning, hslOKOnly, 1, "","","");

	}  // -- end of function "VerificationFailedDialog"
		
	//------------------------------------------------------------------------------
	static function searchReportFile(variable fileNameBase) variable
	//------------------------------------------------------------------------------
	{
		variable i;
		variable date, lastDate;
		variable strDate;
		variable fileName;
		variable reportFileName("");

		object sourceFolder; 
		object enumerator;
		object files;
		object fileItem;
		object fso;  // file system object

		if (fso.IsNull()) fso.CreateObject("Scripting.FileSystemObject");

		onerror resume next;

		// search for file in folder
		if(VerDef::isRoche)
		{ 	//		SN0000_Cover-Safety-Verification_201307291703.pdf 
			fileNameBase 	= StrConcat8("SN",VerDef::InstrumentSerialNo,"_",fileNameBase, "_","","","" );
		}
		else
		{
			fileNameBase 	= StrConcat4(fileNameBase ,"_", VerDef::InstrumentSerialNo,"_");
		}
		fileNameBase 	= StrMakeLower(fileNameBase );
//Trace("Test: searchReportFile  =>  with fileNameBase  ==>",fileNameBase,"<==");
		lastDate			= 0;
		sourceFolder 	= fso.GetFolder(GetSystemPath());
		files = sourceFolder.Files();
		// get enumerator from files collection
		enumerator = files._NewEnum;

		// iterate through files collection
		i = 0;
		while (enumerator.EnumNext(fileItem))
		{
			i++;
			fileName = fileItem.Name();
			fileName = StrMakeLower(fileName);
//Trace("At loop =>",i,"<  Name ==>", fileName,"<   File path & name ==>",fileItem.Path(),"< StrFind(fileName, fileNameBase) ==>",StrFind(fileName, fileNameBase));
			if(StrFind(fileName, fileNameBase) == 0) 
			{// corresponding report file found
//Trace("Test: File =>",fileName,"<  ground with fileNameBase  ==>",fileNameBase,"<==");
				if((StrFind(fileName, ".pdf") > 0) || (StrFind(fileName, ".xls") > 0))
				{ // get last report file
					strDate = StrMid(fileName,StrGetLength(fileNameBase),12);
					date = FVal(strDate);
//Trace("Test: File =>",fileName,"<  strDate ==>",strDate,"<  date ==>",date,"< lastDate ==>",lastDate,"<==");
					if( lastDate < date)
					{
						reportFileName = fileItem.Path();
						lastDate 		= date;
					}
				}
			}
		}
		enumerator.ReleaseObject();
		files.ReleaseObject();
		sourceFolder.ReleaseObject();
//	Trace("Test: searchReportFile: reportFileName =>",reportFileName,"<==");

		return(reportFileName);
	}  // -- end of function "searchReportFile"

	//-----------------------------------------------------------------------------------------------------
	function setArrayInfo(variable& array[], variable index, variable content)
	//-----------------------------------------------------------------------------------------------------
	{
		if((index < 1) || (index > array.GetSize())) return;
		array.SetAt( index - 1, content);

	} // end of function "setArrayInfo"

	//------------------------------------------------------------------------------
	function ShowReports( variable i_Action[])
	// show reposrt of selected verification features
	//------------------------------------------------------------------------------
	{
		variable i;
		variable reportFile;
		variable arrReportFiles[];
		variable userMessages[];

		arrReportFiles.SetSize(0);
		for( i = 0; i < i_Action.GetSize();i++) arrReportFiles.AddAsLast("x");

		// Assign report file names
		//  --- Get selcted verification report files
		if(VerDef::isRoche)
		{ 	//		fileName = StrConcat8("SN", VerDef::InstrumentSerialNo,"_",templateFile ,"_", GetDate("%Y%m%d"), GetTime("%H%M"),"");

			setArrayInfo( arrReportFiles, PID::doCoverSafety_Verification,					"Cover-Safety-Verification");  				// SN0000_Cover-Safety-Verification_201307291703.pdf
			setArrayInfo( arrReportFiles, PID::doBarcode_Verification,						"Barcode-Verification");						// SN0000_Barcode-Verification_201307291704.pdf
			setArrayInfo( arrReportFiles, PID::doXYZ_Pos_1000ul_Channel_Verification,	"Channel-Position-Verification");			// SN0000_Channel-Position-Verification_201307291704.pdf
			setArrayInfo( arrReportFiles, PID::doVolume_1000ul_Channel_Verification ,	"Volume-Verification");							// SN0000_Volume-Verification_201307291706.pdf
			setArrayInfo( arrReportFiles, PID::doTemperature_Verification ,				"Temperature-Verification");					// SN0000_Temperature-Verification_201307291720.pdf
			setArrayInfo( arrReportFiles, PID::doShaker_Verification ,						"Shaker-Verification");							// SN0000_Shaker-Verification_201307291735.pdf
			setArrayInfo( arrReportFiles, PID::doTwister_Verification ,						"Twister-Verification");						// SN0000_Twister-Verification_201307300808.pdf
		}
		else if(VerDef::isIVD)
		{
			setArrayInfo( arrReportFiles, PID::doCoverSafety_Verification,					"Report_CoverSafety_IVD_Ver");  				// Report_CoverSafety_IVD_VerEnu.xls
			setArrayInfo( arrReportFiles, PID::doBarcode_Verification,						"Report_Barcode_IVD_Ver");						// Report_Barcode_IVD_Ver.xls
			setArrayInfo( arrReportFiles, PID::doXYZ_Pos_1000ul_Channel_Verification,	"Report_XYZ_IVD_Ver_1000ulSingleChannels");// Report_XYZ_IVD_Ver_1000ulSingleChannelsEnu.xls
			setArrayInfo( arrReportFiles, PID::doXYZ_Pos_5ml_Channel_Verification ,		"Report_XYZ_IVD_Ver_5mlSingleChannels");	// Report_XYZ_IVD_Ver_5mlSingleChannelsEnu.xls
			setArrayInfo( arrReportFiles, PID::doVolume_1000ul_Channel_Verification ,	"Report_Vol_IVD_Ver_1000ulSingleChannels");// Report_Vol_IVD_Ver_1000ulSingleChannelsEnu.xls
			setArrayInfo( arrReportFiles, PID::doVolume_5ml_Channel_Verification ,		"Report_Vol_IVD_Ver_5mlSingleChannels");	// Report_Vol_IVD_Ver_5mlSingleChannelsEnu.xls
			setArrayInfo( arrReportFiles, PID::doTemperature_Verification ,				"Report_Temperature_IVD_Ver");				// Report_Temperature_IVD_VerEnu.xls
			setArrayInfo( arrReportFiles, PID::doShaker_Verification ,						"Report_Shaker_IVD_Ver");						// Report_Shaker_IVD_VerEnu.xls
			setArrayInfo( arrReportFiles, PID::doEasyPunch_Verification ,					"Report_easyPunch_IVD_Ver");					// Report_easyPunch_IVD_VerEnu.xls
			setArrayInfo( arrReportFiles, PID::doTwister_Verification ,						"Report_Twister_IVD_Ver");						// Report_Twister_IVD_VerEnu.xls
		}
		else
		{
			setArrayInfo( arrReportFiles, PID::doCoverSafety_Verification ,				"Report_CoverSafety_Ver");						// Report_CoverSafety_VerEnu.xls
			setArrayInfo( arrReportFiles, PID::doBarcode_Verification ,						"Report_Barcode_Ver");							// Report_Barcode_VerEnu.xls
			setArrayInfo( arrReportFiles, PID::doXYZ_Pos_96mpH_Verification ,				"Report_XYZ_Ver_96erPipHead");				// Report_XYZ_Ver_96erPipHeadEnu.xls
			setArrayInfo( arrReportFiles, PID::doXYZ_Pos_384mPh_Verification ,			"Report_XYZ_Ver_384erPipHead");				// Report_XYZ_Ver_384erPipHeadEnu.xls
			setArrayInfo( arrReportFiles, PID::doXYZ_Pos_1000ul_Channel_Verification ,	"Report_XYZ_Ver_1000ulSingleChannels");	// Report_XYZ_Ver_1000ulSingleChannelsEnu.xls
			setArrayInfo( arrReportFiles, PID::doXYZ_Pos_5ml_Channel_Verification ,		"Report_XYZ_Ver_5mlSingleChannels");		// Report_XYZ_Ver_5mlSingleChannelsEnu.xls
			setArrayInfo( arrReportFiles, PID::doXYZ_Pos_NanoPip_Verification ,			"Report_XYZ_Ver_NanoPipetter");	
			if(VerDef::multi96PipHead == 1)	setArrayInfo( arrReportFiles, PID::doVolume_96mpH_Verification ,"Report_Vol_Ver_300ul96erPipHead");	// Report_Vol_Ver_300ulSingleChannelsEnu.xls
			else 									 	setArrayInfo( arrReportFiles, PID::doVolume_96mpH_Verification ,"Report_Vol_Ver_1000ul96erPipHead");	// Report_Vol_Ver_1000ul96erPipHeadEnu.xls
			setArrayInfo( arrReportFiles, PID::doVolume_384mpH_Verification ,				"Report_Vol_Ver_384erPipHead");				// Report_Vol_Ver_384erPipHeadEnu.xls
			setArrayInfo( arrReportFiles, PID::doVolume_1000ul_Channel_Verification ,	"Report_Vol_Ver_1000ulSingleChannels");	// Report_Vol_Ver_1000ulSingleChannelsEnu.xls
			setArrayInfo( arrReportFiles, PID::doVolume_5ml_Channel_Verification ,		"Report_Vol_Ver_5mlSingleChannels");		// Report_Vol_Ver_5mlSingleChannelsEnu.xls
			setArrayInfo( arrReportFiles, PID::doVolume_NanoPip_Verification ,			"Report_Vol_Ver_NanoPipetter");	
			setArrayInfo( arrReportFiles, PID::doTemperature_Verification ,				"Report_Temperature_Ver");						// Report_Temperature_VerEnu.xls
			setArrayInfo( arrReportFiles, PID::doShaker_Verification ,						"Report_Shaker_Ver");							// Report_Shaker_VerEnu.xls
			setArrayInfo( arrReportFiles, PID::doEasyPunch_Verification ,					"Report_easyPunch_Ver");						// Report_easyPunch_VerEnu.xls
			setArrayInfo( arrReportFiles, PID::doTwister_Verification ,						"Report_Twister_Ver");							// Report_Twister_VerEnu.xls
		}

		// trace user selection
//		VerTool::TraceArray("Test: ShowReports: --- i_Action ----", i_Action);
//		VerTool::TraceArray("Test: ShowReports: --- G_VAR::arrDescription ----", G_VAR::arrDescription);
//		VerTool::TraceArray("Test: ShowReports: --- arrReportFiles ----", arrReportFiles);

		// Display "available" last report or warning
		userMessages.SetSize( 0 );
		for( i = 0; i < i_Action.GetSize();i++) 
		{
			if(i_Action.GetAt(i) > 0)
			{
				reportFile = searchReportFile(arrReportFiles.GetAt(i) );
//Trace("Test: ShowReports => last report file of =>",arrReportFiles.GetAt(i),"<  ==>",reportFile ,"<==");
				if(reportFile == "") userMessages.AddAsLast( " - " + G_VAR::arrDescription.GetAt(i));
				else 						ShowReportFile(reportFile);
			}
		}
		VerificationUserMessagesDialog(LdT("No reports found for"), userMessages, "");
	} // -- end of function "ShowReports"

	//------------------------------------------------------------------------------
	function DlgVerificationData(
						variable i_DialogTitle,		//	dialog titel information of environment
						variable i_Description[],	// array of verification descriptions
						variable i_Status[],			// array of verification status
						variable i_DeckPosition[],	// array of verification sites deck position
						variable i_ExpiryDate[],	// array of verification expiry date
						variable i_inputRemarks[],	// array of verification remarks
						variable i_amountOfButtons,// amount of buttons: > 2 reports & help buttons
						variable& io_Action[]		// input/output array of verification action selection
																) variable
	//------------------------------------------------------------------------------
	{
		object infoDlg;
		variable index, sizeOfInputLines(0);
		variable titelBarText(""),warningText, statusTitelText, dateFormat, expiryDateText,remarksTitel;
		variable deckPosition, deckPosition_1;
		variable statusBackGround, dateBackGround, deckInfoPresent(0);
		variable returnValue, returnValue_1;
		variable actionState, actionNeeded(0);
		variable expiryDate, dateOkay, remarks;
		variable OKButton, CancelButton, ReportButton, HelpButton;
		variable manualFileName;
		string 	DialogObjectName("HxStarVer2Dlg.VerOverViewDlg"); //	function of HxStarVer2Dlg.dll
		string 	message("Create Object Failed -->");
		object 	fso;  // file system object

		if (fso.IsNull()) fso.CreateObject("Scripting.FileSystemObject");

		if ( 0 == infoDlg.CreateObject(DialogObjectName) )
		{		
			//Trace("Test: Error Message => ", message, DialogObjectName, "<---");
			return( hslFalse );
		}
		
		titelBarText 		= VerDef::FVK2_ReleaseVersion;
		StrReplace(titelBarText, "/%s1", "");

		titelBarText 		= LdT("Start Dialog for the ML_STAR Verification:") + "             (" + 
																							LdT("Version:") + "  " + titelBarText + ")";
		statusTitelText 	= LdT("Status:");
		warningText 		= "";
		
		deckPosition_1		= LdT("Track / Site- Position:");
		expiryDateText 	= LdT("Expiry Date:");
		dateFormat 			= LdT("(YYYY-MM-DD)");
		remarksTitel		= LdT("Remark:");
		OKButton				= LdT("OK");
		CancelButton		= LdT("Cancel");
		ReportButton		= "";
		HelpButton			= "";
		if (i_amountOfButtons > 2)
		{
			ReportButton	= LdT("Reports");
			HelpButton		= LdT("Help");
		}
		for(index = 0; index < i_Description.GetSize(); index++)
		{
			if ((i_Status.GetAt(index) == VerDef::failed) || (i_Status.GetAt(index) == VerDef::excluded) || (i_Status.GetAt(index) == VerDef::invalid))
			{
				statusBackGround 	= 0;
				actionNeeded 		= 1;
			}
			else statusBackGround = 1;

			if (VerTool::ValidateDate(i_ExpiryDate.GetAt(index), 0, expiryDate, dateOkay, remarks) < 0) 
			{
				dateBackGround = 0;
				actionNeeded 	= 1;
			}
			else dateBackGround = 1;
			deckPosition		= "";
			if ((index < i_DeckPosition.GetSize()) && (i_DeckPosition.GetAt(index) != ""))
			{
				deckPosition	= 	i_DeckPosition.GetAt(index);
				deckInfoPresent = 1;
			}
			infoDlg.SetVerificationInfo(index, i_Description.GetAt(index), io_Action.GetAt(index), i_Status.GetAt(index), statusBackGround, 
								deckPosition, i_ExpiryDate.GetAt(index), dateBackGround, i_inputRemarks.GetAt(index));
		}
		warningText = LdT("ATTENTION:") + " " + LdT("Deck and labware must be decontaminated prior verification execution!") + VerDef::CRLF;
		if (actionNeeded > 0) 
		{
			warningText = warningText + LdT("WARNING:") + " " + LdT("Verification for at least one process is required!");
		}
		if (deckInfoPresent == 0) deckPosition_1 = "";
		infoDlg.SetDialogInfo(titelBarText, i_DialogTitle, warningText, statusTitelText, deckPosition_1, 
										expiryDateText, dateFormat, remarksTitel,OKButton, CancelButton, ReportButton, HelpButton);
		while(hslTrue)
		{
			returnValue = infoDlg.Show();
			for(index = 0; index < i_Description.GetSize(); index++)
			{
				returnValue_1 = infoDlg.GetVerificationSelection(index , actionState);
//Trace("Test: DlgVerificationData ====> actionState at index =>",index,"<  is ==>",actionState, "<  returnValue_1 ==>",returnValue_1,"<==");
//				io_Action.SetAt(index, actionState);
				io_Action.SetAt(index, returnValue_1);
			}

//VerTool::TraceArray(" -X -- io_Action ----", io_Action);

			if ( returnValue == 0)
			{
				VerTool::TraceDlgCancel( titelBarText);
				return( hslCancel );
			}
			
			if ( returnValue == 1)
			{
				VerTool::TraceDlgOK( titelBarText);
				break;
			}

			// 
			if ( returnValue == 2)
			{ // show verification manual
				manualFileName = GetMethodsPath() + "\\Verification\\Manual\\ML_STARline_Verification_2_Manual_";
		 		if (fso.FileExists(manualFileName  + GetLanguage() + ".pdf")) 
						manualFileName = manualFileName + GetLanguage() + ".pdf";
				else	manualFileName = manualFileName +  "Enu.pdf"; // english file as default manual
				ShowReportFile(manualFileName);
			}
			if ( returnValue > 2)
			{ // show reports of selected devices
				ShowReports(io_Action);
			}

		}

		return( hslOK);
	} // -- end of function "DlgVerificationData"


	//------------------------------------------------------------------------------
	function ShowVerificationData(
						variable i_DialogTitle,		//	dialog titel information of environment
						variable i_DialogInfoType	// dialog information type : G = general, T = temperature, S = Shake;
																) variable
	//------------------------------------------------------------------------------
	{
		variable returnValue;
		variable i;
		variable arrDeckPosition[];

		// Display "available" and requested general verification steps
		if(i_DialogInfoType == PID::General)
		{
			returnValue = VerTool::DlgVerificationData(i_DialogTitle, G_VAR::arrDescription, G_VAR::arrStatus, G_VAR::arrDeckPosition, 
																					G_VAR::arrExpiryDate, G_VAR::arrInputRemarks,4, G_VAR::arrAction);

//			VerTool::TraceArray(" --- G_VAR::arrDescription ----", G_VAR::arrDescription);
//			VerTool::TraceArray(" --- G_VAR::arrAction ----", G_VAR::arrAction);

			//  --- Get selcted verification processes
			if(PID::doCoverSafety_Verification > 0) 				PID::doCoverSafety_Verification = G_VAR::arrAction.GetAt( PID::doCoverSafety_Verification -1);

			if(PID::doBarcode_Verification > 0)						PID::doBarcode_Verification = G_VAR::arrAction.GetAt( PID::doBarcode_Verification -1);
			if(PID::doBarcode_Verification > 0)						PS::showBC_CarrierData = 1;

			if(PID::doTwister_Verification > 0)						PID::doTwister_Verification = G_VAR::arrAction.GetAt( PID::doTwister_Verification -1);
			if(PID::doTwister_Verification > 0)						PS::showBC_TwisterData = 1;

			if(PID::doXYZ_Pos_96mpH_Verification > 0) 			PID::doXYZ_Pos_96mpH_Verification = G_VAR::arrAction.GetAt( PID::doXYZ_Pos_96mpH_Verification -1);

			if(PID::doXYZ_Pos_384mPh_Verification > 0) 			PID::doXYZ_Pos_384mPh_Verification = G_VAR::arrAction.GetAt( PID::doXYZ_Pos_384mPh_Verification -1);
		
			if(PID::doXYZ_Pos_1000ul_Channel_Verification > 0) PID::doXYZ_Pos_1000ul_Channel_Verification = G_VAR::arrAction.GetAt( PID::doXYZ_Pos_1000ul_Channel_Verification -1);
		
			if(PID::doXYZ_Pos_5ml_Channel_Verification > 0)		PID::doXYZ_Pos_5ml_Channel_Verification = G_VAR::arrAction.GetAt( PID::doXYZ_Pos_5ml_Channel_Verification -1);
		
			if(PID::doXYZ_Pos_NanoPip_Verification > 0) 			PID::doXYZ_Pos_NanoPip_Verification = G_VAR::arrAction.GetAt( PID::doXYZ_Pos_NanoPip_Verification -1);
		
			if(PID::doVolume_96mpH_Verification > 0) 				PID::doVolume_96mpH_Verification = G_VAR::arrAction.GetAt( PID::doVolume_96mpH_Verification -1);
			if(PID::doVolume_96mpH_Verification > 0)				PS::showTempHumDeviceData = PS::showPhotoCheckPlateData = PS::showBalanceData = 1; 

			if(PID::doVolume_384mpH_Verification > 0) 			PID::doVolume_384mpH_Verification = G_VAR::arrAction.GetAt( PID::doVolume_384mpH_Verification -1);
			if(PID::doVolume_384mpH_Verification > 0) 		 	PS::showTempHumDeviceData  = PS::showPhotoCheckPlateData = PS::showBalanceData = 1;

			if(PID::doVolume_1000ul_Channel_Verification > 0) 	PID::doVolume_1000ul_Channel_Verification = G_VAR::arrAction.GetAt( PID::doVolume_1000ul_Channel_Verification -1);
			if(PID::doVolume_1000ul_Channel_Verification > 0)	PS::showTempHumDeviceData = PS::showBalanceData = 1;
			if((PID::doVolume_1000ul_Channel_Verification > 0) && !VerDef::isIVD)	PS::showPhotoCheckPlateData = 1;

			if(PID::doVolume_5ml_Channel_Verification > 0) 		PID::doVolume_5ml_Channel_Verification = G_VAR::arrAction.GetAt( PID::doVolume_5ml_Channel_Verification -1);
			if(PID::doVolume_5ml_Channel_Verification > 0) 	 	PS::showTempHumDeviceData =  PS::showBalanceData = 1;

			if(PID::doVolume_NanoPip_Verification > 0) 			PID::doVolume_NanoPip_Verification = G_VAR::arrAction.GetAt( PID::doVolume_NanoPip_Verification -1);
			if(PID::doVolume_NanoPip_Verification > 0) 		 	PS::showTempHumDeviceData  = PS::showPhotoCheckPlateData = PS::showBalanceData = 1;

			if(PID::doEasyPunch_Verification > 0)	 				PID::doEasyPunch_Verification = G_VAR::arrAction.GetAt( PID::doEasyPunch_Verification -1);

			if(PID::doTemperature_Verification > 0) 				PID::doTemperature_Verification = G_VAR::arrAction.GetAt( PID::doTemperature_Verification -1);
			if(PID::doTemperature_Verification == 0) 	// reset all temperature verification sites action
																	for(i = 0;i < T_VAR::arrAction.GetSize();i++) T_VAR::arrAction.SetAt(i, 0);

			if(PID::doShaker_Verification > 0) 						PID::doShaker_Verification = G_VAR::arrAction.GetAt( PID::doShaker_Verification -1);
			if(PID::doShaker_Verification == 0) 		// reset all shaker verification sites action
																	for(i = 0;i < S_VAR::arrAction.GetSize();i++) S_VAR::arrAction.SetAt(i, 0);
			// trace user selection
			for( i = 0; i < G_VAR::arrAction.GetSize();i++) 
			{
				if(G_VAR::arrAction.GetAt(i) > 0)
				{
					FormatTrace( LdT("User Selection:"), " ", 2, LdT("Selected Verification of")," --->  ", G_VAR::arrDescription.GetAt(i));
				}
			}
		}

		// ------ Display "available" and requested temperature verification sites 
		if((i_DialogInfoType == PID::Temperature) && (PID::doTemperature_Verification > 0))
		{
			arrDeckPosition.SetSize(0);
			for( i = 0; i < T_VAR::arrDeckPosition.GetSize();i++) 
											arrDeckPosition.AddAsLast(VerTool::convertXYcoordToTrackSite(T_VAR::arrDeckPosition.GetAt(i)));
			returnValue = VerTool::DlgVerificationData(i_DialogTitle, T_VAR::arrDescription, 
								T_VAR::arrStatus, arrDeckPosition, T_VAR::arrExpiryDate, T_VAR::arrInputRemarks, 2, T_VAR::arrAction);

//			VerTool::TraceArray("Test: ShowVerificationData: --- T_VAR::arrAction ----", T_VAR::arrAction);
//			VerTool::TraceArray("Test: ShowVerificationData: --- T_VAR::arrDescription ----", T_VAR::arrDescription);
//			VerTool::TraceArray("Test: ShowVerificationData: --- T_VAR::arrProcessID ----", T_VAR::arrProcessID);

//			VerTool::TraceArray("Test: ShowVerificationData: --- T_VAR::arrStatus ----", T_VAR::arrStatus);
//			VerTool::TraceArray("Test: ShowVerificationData: --- T_VAR::arrDeckPosition ----", T_VAR::arrDeckPosition);
//			VerTool::TraceArray("Test: ShowVerificationData: --- T_VAR::arrExpiryDate ----", T_VAR::arrExpiryDate);
//			VerTool::TraceArray("Test: ShowVerificationData: --- T_VAR::arrInputRemarks ----", T_VAR::arrInputRemarks);

			// get selected number of sites
			VerDef::numberOfTemperatureSites = 0;
			for(i = 0; i < T_VAR::arrAction.GetSize();i++)
			{
				if (T_VAR::arrAction.GetAt(i) > 0)
				{
					VerDef::numberOfTemperatureSites++;
					FormatTrace( LdT("User Selection:"), " ", 2, LdT("Selected Temperature Verification of")," --->  ", T_VAR::arrDescription.GetAt(i)," / ", arrDeckPosition.GetAt(i) );
				}
			}

			PID::doTemperature_Verification 	= VerDef::numberOfTemperatureSites;
			//Trace("Test: Number of selected temperature verification sites ==>", VerDef::numberOfTemperatureSites ,"<==");
		}

		// ------  Display "available" and requested shaker verification sites 
		if((i_DialogInfoType == PID::Shaker) && (PID::doShaker_Verification > 0))
		{
			arrDeckPosition.SetSize(0);
			for( i = 0; i < S_VAR::arrDeckPosition.GetSize();i++) 
											arrDeckPosition.AddAsLast(VerTool::convertXYcoordToTrackSite(S_VAR::arrDeckPosition.GetAt(i)));

			returnValue = VerTool::DlgVerificationData(i_DialogTitle, S_VAR::arrDescription, 
								S_VAR::arrStatus, arrDeckPosition, S_VAR::arrExpiryDate, S_VAR::arrInputRemarks, 2, S_VAR::arrAction);

			// get selected number of sites
			VerDef::numberOfShakerSites = 0;
			for(i = 0; i < S_VAR::arrAction.GetSize(); i++)
			{
				if (S_VAR::arrAction.GetAt(i) > 0) 
				{
					VerDef::numberOfShakerSites++;
					FormatTrace( LdT("User Selection:"), " ", 2, LdT("Selected Shaker Verification of")," --->  ", S_VAR::arrDescription.GetAt(i)," / ", arrDeckPosition.GetAt(i) );
				}	
			}

			//Trace("Test: Number of selected shaker verification sites ==>", VerDef::numberOfShakerSites ,"<==");

//			VerTool::TraceArray("Test: ShowVerificationData: --- S_VAR::arrAction ----", S_VAR::arrStatus);
//			VerTool::TraceArray("Test: ShowVerificationData: --- S_VAR::arrDescription ----", S_VAR::arrDescription);
//			VerTool::TraceArray(" --- S_VAR::arrProcessID ----", S_VAR::arrProcessID);

//			VerTool::TraceArray("Test: ShowVerificationData: --- S_VAR::arrStatus ----", S_VAR::arrStatus);
//			VerTool::TraceArray("Test: ShowVerificationData: --- S_VAR::arrDeckPosition ----", S_VAR::arrDeckPosition);

			PID::doShaker_Verification 	= VerDef::numberOfShakerSites;
			//Trace("Test: Number of selected shaking verification sites ==>", VerDef::numberOfShakerSites ,"<==");
		}

		return( returnValue);
	} // -- end of function "ShowVerificationData"

	//------------------------------------------------------------------------------
	// Get configuration data as  
	// - corresponding deck file
	function GetConfigurationData( variable& layoutFileName, variable& instrumentNo )
	//------------------------------------------------------------------------------
	{
		device ML_STAR;
		object fso;  // file system object	
			
		if (fso.IsNull()) fso.CreateObject("Scripting.FileSystemObject");

		InitVerToolsLibrary();
		
		// get instrument type
		instrumentNo = HSLML_STAR::GetInstrumentType();

		if (instrumentNo == 0) // ML STAR
		{
			layoutFileName 		= VerDef::layoutFileName_Star;
			VerDef::numbOfAutoLoadTracks = 54;	// Autoload: 54 Tracks
//			VerDef::lastDeckTrack 			= 54;	
		}	
		else if (instrumentNo == 1) // ML STARlet
		{
			layoutFileName = VerDef::layoutFileName_Starlet;
			VerDef::numbOfAutoLoadTracks = 30;	// Autoload: 30 Tracks
//			VerDef::lastDeckTrack 			= 30;	
		}
		else if (instrumentNo == 2) // ML STARplus
		{
			layoutFileName = VerDef::layoutFileName_StarPlus;
			VerDef::numbOfAutoLoadTracks = 30;// Autoload: 30 Tracks
//			VerDef::lastDeckTrack 			= 82;	
		}
		else
		{
			MessageBox( StrConcat2("Unknown Instrument No =>",instrumentNo) , "ErrorInstrumentText", hslOKOnly | hslInformation, hslInfinite );
			VerTool::TraceDlgOK( "ErrorInstrumentText");
			return;
		}

		if (ML_STAR.GetCfgValueWithKey( 3 )== 0) 
		{ // no autoload installed
			VerDef::numbOfAutoLoadTracks = 0;
		}

		// check for customer defined verification layout
		if (fso.FileExists(GetMethodsPath() +  "\\" + layoutFileName + "_mod.lay"))
		{
			layoutFileName = layoutFileName + "_mod.lay";
			VerDef::predefinedLayout = hslTrue;
		}
		else
		{ 
			layoutFileName = layoutFileName + ".lay";
			VerDef::predefinedLayout = hslFalse;
		}
		fso.ReleaseObject();


//Trace("Test: layoutFileName =>",layoutFileName,"<  numbOfAutoLoadTracks =>",VerDef::numbOfAutoLoadTracks,"< lastDeckTrack=>",VerDef::lastDeckTrack,"<==");


		VerDef::SimulationMode 			= HSLML_STAR::IsSimulatorMode(ML_STAR);
		VerDef::SimulationModeBalance = VerDef::SimulationMode ;
		VerDef::SimulationModeReader	= VerDef::SimulationMode ;

		// for testing only
//		VerDef::SimulationModeBalance = hslFalse; // for testing only
		// for testing only
//		VerDef::SimulationModeReader = hslFalse; // for testing only
      
//Trace("Test: VerDef::SimulationMode =>",VerDef::SimulationMode,"<  VerDef::SimulationModeBalance =>",VerDef::SimulationModeBalance,
//				"<  VerDef::SimulationModeReader =>",VerDef::SimulationModeReader,"<==");

		// operating system information
		VerDef::is64BitArchitecture = GetProcessorArchitecture();
		Trace(" ------ ", " 64 Bit Operating Architecture is =>", VerDef::is64BitArchitecture,"<==");
		VerDef::operatingSystem 	= GetOSVersion();
		Trace(" ------ ", " Operating System is =>", VerDef::operatingSystem,"<==");

		// instrument name	
		VerDef::InstrumentName = ML_STAR.GetInstrumentName();
		Trace( LdT("Instrument Name:"), "  ",  VerDef::InstrumentName);

		// sw release
		VerDef::SWReleaseVersion = ML_STAR.GetReleaseVersion();
		Trace( LdT("User Software Version:"),"  ", VerDef::SWReleaseVersion);
		VerDef::SWVersionNumber = FVal(StrLeft(VerDef::SWReleaseVersion,3));

		// operator
		RPD::operatorName = GetUserName();
		Trace( LdT("Operator:"), "  ", RPD::operatorName);	
		
		// IVD configuration
		VerDef::isIVD = GetIVDSystem();
//Trace(" ------ ", " IVD application ==>",VerDef::isIVD, "<--------");

		// get block and field delimiter out of config file
		StepReturn::SetBlockDelimiterEx(ML_STAR);
		StepReturn::SetFieldDelimiterEx(ML_STAR);

//Trace("Test: StepReturn::SetBlockDelimiterEx =>",StepReturn::StringConstants::blockDelimiter,"<  StepReturn::SetFieldDelimiterEx =>",StepReturn::StringConstants::fieldDelimiter,"<==");

	} // --- end of function "GetConfigurationData" ----

	//------------------------------------------------------------------------------
	// Get corresponding deck layout file to ML-STAR type
	function GetStarConfiguration( device ML_STAR)
	//------------------------------------------------------------------------------
	{
		variable i;
		variable arrayOfPositions[];
		variable array_of_templateNames[], array_of_labwareNames[],arrLabPosition[];
		variable installationData;
		variable machineConfig;
		variable bitFilterValue(0); // bit n = = 2^n 
		variable tempBitValue;
		variable configKeyNo, leftArmConfig, rightArmConfig;
		variable prop2, prop3, sn, date(""),lcd(""),lcb(""); // dummy place holder ;
		variable trackNo("");
		variable extraConfguration("");

		// instrument serial number  (from response of command "C0RI", parameter "sn")
			installationData = VerTool::FwCommand( "C0RI", "", hslTrue, ML_STAR );
			VerDef::InstrumentSerialNo = StrMid(installationData, StrReverseFind(installationData,"sn")+2, 4);
			//Trace( "Test: ML-STAR Instrument Serial Number =>", VerDef::InstrumentSerialNo);

		// get FW version of master module
			installationData	= VerTool::FwCommand("C0RF" , "", hslTrue,  ML_STAR);  // ==> RFid0001rf1.0F 1998-01-05c
			VerDef::fwVersionC0 = IVal(StrMid(installationData, StrReverseFind(installationData,"rf")+2, 3));
			// check if configuration is STAR ELISA 
			GetVerificationInformation(KeyExtraConfiguration, extraConfguration, prop2, prop3 ,sn, date, lcd, lcb);
			if(StrFind(extraConfguration,"ELISA") >= 0)
			{ // master firmaware of STAR ELISA is at least standrad firmaware version 7.0)
				if(VerDef::fwVersionC0 < 7.0) VerDef::fwVersionC0 = 7.0; 
			}

		// --- machine configuration, from response of command "C0RM" 
			machineConfig = FwCommand( "C0RM", "", hslTrue, ML_STAR );
			//Trace("Test: Response machineConfig C0RM=>",machineConfig,"<==");

		// check if iSWAP is available: Bit 1 of hex value of parameter "kb"
			bitFilterValue = 2; // bit 1 ==> 2^1 = 2
			tempBitValue = StrMid(machineConfig, StrReverseFind(machineConfig,"kb")+2, 2);
			tempBitValue = StrIVal("0x" + tempBitValue);
			VerDef::iSWAP= MthBitwiseAND(bitFilterValue, tempBitValue) / bitFilterValue;
		
			// check if cover locking available: Bit 2 of hex value of parameter "kb"
			bitFilterValue = 4; // bit 2 ==> 2^2 = 4
			tempBitValue = StrMid(machineConfig, StrReverseFind(machineConfig,"kb")+2, 2);
			tempBitValue = StrIVal("0x" + tempBitValue);
			VerDef::CoverLocking = MthBitwiseAND(bitFilterValue, tempBitValue) / bitFilterValue;

		// check if auto load available: Bit 3 of hex value of parameter "kb" 
			bitFilterValue = 8; // bit 3 ==> 2^3 = 8
			tempBitValue = StrMid(machineConfig, StrReverseFind(machineConfig,"kb")+2, 2);
			tempBitValue = StrIVal("0x" + tempBitValue);
			VerDef::AutoLoad  = MthBitwiseAND(bitFilterValue, tempBitValue) / bitFilterValue;
			VerDef::tipPlateCarrierLoadable = VerDef::AutoLoad;

		// number of 1000ul single pipetting channels (from response of command "C0RM", parameter "kp")
//Trace("Test: machineConfig=>", machineConfig,"<==");
			// VerDef::InstrumentNumberOfChannels = StrMid(machineConfig, StrReverseFind(machineConfig,"kp")+2, 2);
			//	VerDef::InstrumentNumberOfChannels = StrIVal(StrTrimLeft(VerDef::InstrumentNumberOfChannels, "0"));
			VerDef::InstrumentNumberOfChannels = ML_STAR.GetCfgValueWithKey(1);
			//Trace( "Test: Instrument Number of Channels:   =>" , VerDef::InstrumentNumberOfChannels);

		// --- machine configuration, from response of command "C0QM" 
			machineConfig = FwCommand( "C0QM", "", hslTrue, ML_STAR );
			//Trace("Test: Response machineConfig C0QM=>",machineConfig,"<==");
			
			// Get maximal number of autoload tracks
			VerDef::numbOfAutoLoadTracks = StrIVal(StrMid(machineConfig, StrReverseFind(machineConfig,"xa") + 2, 2) );
			if(VerDef::AutoLoad == 0) VerDef::numbOfAutoLoadTracks = 0; // no autoload installed
			//Trace("Test: Autoload is installed =>",VerDef::AutoLoad ,"< with Autoload Tracks ==>", VerDef::numbOfAutoLoadTracks,"<==");

		// check if 96er multiPipHead is installed: Bit 1 of hex value of parameter "ka"
			bitFilterValue = 2; // bit 1 ==> 2^1 = 2
			VerDef::multi96PipHead = StrMid(machineConfig, StrReverseFind(machineConfig,"ka")+2, 6);
			VerDef::multi96PipHead = StrIVal("0x" + VerDef::multi96PipHead);
			VerDef::multi96PipHead = MthBitwiseAND(bitFilterValue, VerDef::multi96PipHead) / bitFilterValue;

		// check if 384er multiPipHead is installed: Bit 12 of hex value of parameter "ka"
			bitFilterValue = 4096; // bit 12 ==> 2^12 = 4096
			VerDef::multi384PipHead = StrMid(machineConfig, StrReverseFind(machineConfig,"ka")+2, 6);
			VerDef::multi384PipHead = StrIVal("0x" + VerDef::multi384PipHead);
			VerDef::multi384PipHead = MthBitwiseAND(bitFilterValue, VerDef::multi384PipHead) / bitFilterValue;			

		// check if left (or main) front cover is installed: Bit 7 of hex value of parameter "ka"
			bitFilterValue = 128; // bit 7 ==> 2^7 = 128
			VerDef::leftCover = StrMid(machineConfig, StrReverseFind(machineConfig,"ka")+2, 6);
			VerDef::leftCover = StrIVal("0x" + VerDef::leftCover);
			VerDef::leftCover = MthBitwiseAND(bitFilterValue, VerDef::leftCover) / bitFilterValue;			

		// check if right front cover is installed: Bit 8 of hex value of parameter "ka"
			bitFilterValue = 256; // bit 8 ==> 2^8 = 256
			VerDef::rightCover = StrMid(machineConfig, StrReverseFind(machineConfig,"ka")+2, 6);
			VerDef::rightCover = StrIVal("0x" + VerDef::rightCover);
			VerDef::rightCover = MthBitwiseAND(bitFilterValue, VerDef::rightCover) / bitFilterValue;			

		// check if additional cover locking available: Bit 9 of hex value of parameter "ka"
			bitFilterValue = 512; // bit 9 ==> 2^9 = 512
			tempBitValue = StrMid(machineConfig, StrReverseFind(machineConfig,"ka")+2, 6);
			tempBitValue = StrIVal("0x" + tempBitValue);
			tempBitValue = MthBitwiseAND(bitFilterValue, tempBitValue) / bitFilterValue;
			if (tempBitValue> 0) VerDef::AddtionalCoverLocking = tempBitValue;

		// check if vertical cover is installed: Bit 10 of hex value of parameter "ke"
			bitFilterValue = 1024; // bit 10 ==> 2^10 = 1024
			VerDef::verticalCover = StrMid(machineConfig, StrReverseFind(machineConfig,"ke")+2, 8);
			VerDef::verticalCover = StrIVal("0x" + VerDef::verticalCover);
			VerDef::verticalCover = MthBitwiseAND(bitFilterValue, VerDef::verticalCover) / bitFilterValue;			

		// number of 5ml-channels (accepted values: <= 8 ) for sw-version >= 4.2 : value of parameter "kc"
			if (StrReverseFind(machineConfig,"kc") < 0) VerDef::InstrumentNumberOf_5mlChannels = 0;
			else 	VerDef::InstrumentNumberOf_5mlChannels = IVal(StrMid(machineConfig, StrReverseFind(machineConfig,"kc")+2, 1));
			// VerDef::InstrumentNumberOf_5mlChannels = ML_STAR.GetCfgValueWithKey( 43 );
			if (VerDef::InstrumentNumberOf_5mlChannels > 0)
			{
				//Trace("Test: Number of 5ml pipettting channels =>",VerDef::InstrumentNumberOf_5mlChannels,"<==");
			}
		// check if 5ml-channels are on right arm installed: : Bit 5 of hex value of parameter "xr"  
			VerDef::_5mlChannelOnRightArm = hslFalse;
			bitFilterValue = 32; // bit 5 ==> 2^5 = 32
			tempBitValue = StrMid(machineConfig, StrReverseFind(machineConfig,"xr")+2, 6);
			tempBitValue = StrIVal("0x" + tempBitValue);
			tempBitValue = MthBitwiseAND(bitFilterValue, tempBitValue) / bitFilterValue;			
			if (tempBitValue > 0) VerDef::_5mlChannelOnRightArm = hslTrue;
			//Trace("Test: 5ml pipettting is installed on right arm =>",VerDef::_5mlChannelOnRightArm,"<==");

		// check if nano pipetter is installed: : Bit 3 of hex value of parameter "xl"  (left arm) or "xr"  (right arm)
			bitFilterValue = 8; // bit 3 ==> 2^3 = 8
			tempBitValue = StrMid(machineConfig, StrReverseFind(machineConfig,"xl")+2, 6);
			tempBitValue = StrIVal("0x" + tempBitValue);
			VerDef::NanoPipetter = MthBitwiseAND(bitFilterValue, tempBitValue) / bitFilterValue;			
			tempBitValue = StrMid(machineConfig, StrReverseFind(machineConfig,"xr")+2, 6);
			tempBitValue = StrIVal("0x" + tempBitValue);
			tempBitValue = MthBitwiseAND(bitFilterValue, tempBitValue) / bitFilterValue;			
			if (tempBitValue > 0) VerDef::NanoPipetter = tempBitValue;
			//Trace("Test: Nano pipetter is installed =>",VerDef::NanoPipetter,"<==");

		// check if dual arm is installed
		// left arm configuration: value of parameter "xl" and "xn"
			VerDef::hasLeftArm = hslFalse;
			leftArmConfig = StrMid(machineConfig, StrReverseFind(machineConfig,"xl")+2, 2); 
			leftArmConfig = StrIVal("0x" + leftArmConfig);
			if(leftArmConfig > 0) 	VerDef::hasLeftArm = hslTrue;
			else
			{
				leftArmConfig = StrMid(machineConfig, StrReverseFind(machineConfig,"xn")+2, 2); 
				leftArmConfig = StrIVal("0x" + leftArmConfig);
				if(leftArmConfig > 0) 	VerDef::hasLeftArm = hslTrue;
			}
			//Trace("Test: VerDef::hasLeftArm =>",VerDef::hasLeftArm,"<==");
			
		// right arm configuration: value of parameter "xr" and "xo"
			VerDef::hasRightArm = hslFalse;
			rightArmConfig = StrMid(machineConfig, StrReverseFind(machineConfig,"xr")+2, 2);
			rightArmConfig = StrIVal("0x" + rightArmConfig);	
			if(rightArmConfig > 0) 	VerDef::hasRightArm = hslTrue;
			else							
			{
				rightArmConfig = StrMid(machineConfig, StrReverseFind(machineConfig,"xo")+2, 2);
				rightArmConfig = StrIVal("0x" + rightArmConfig);	
				if(rightArmConfig > 0) 	VerDef::hasRightArm = hslTrue;
			}
			//Trace("Test: VerDef::hasRightArm =>",VerDef::hasRightArm,"<==");

		// get channel raster for 1000ul pipetting channels: value of parameter ys###
			VerDef::RasterOf_1000ulChannels = IVal(StrMid(machineConfig, StrReverseFind(machineConfig,"ys")+2, 3)) / 10; 
			if(VerDef::RasterOf_1000ulChannels < 9) 	VerDef::RasterOf_1000ulChannels = 9;
			if(VerDef::RasterOf_1000ulChannels > 9) 	VerDef::RasterOf_1000ulChannels = 18;
			if(VerDef::RasterOf_1000ulChannels > 18) 	VerDef::RasterOf_1000ulChannels = 36;
			//Trace("Test: VerDef::RasterOf_1000ulChannels =>",VerDef::RasterOf_1000ulChannels,"<==");

		// get channel raster for 5ml pipetting channels: value of parameter kl###
			VerDef::RasterOf_5mlChannels = IVal(StrMid(machineConfig, StrReverseFind(machineConfig,"kl")+2, 3)) / 10; 
			if(VerDef::RasterOf_5mlChannels < 18) 	VerDef::RasterOf_5mlChannels = 18;
			if(VerDef::RasterOf_5mlChannels > 18) 	VerDef::RasterOf_5mlChannels = 36;
			if(VerDef::RasterOf_5mlChannels > 36) 	VerDef::RasterOf_5mlChannels = 72;
			//Trace("Test: VerDef::RasterOf_5mlChannels =>",VerDef::RasterOf_5mlChannels,"<==");

		// get easyPunch devices:	Punch card handler	Bit 0 of hex value of parameter "ke"
		//									Puncher 					Bit 1 of hex value of parameter "ke"
			VerDef::easyPunch = 0;	
			if (StrReverseFind(machineConfig,"ke") >= 0) 
			{
				bitFilterValue = 1; // bit 1 ==> 2^0 = 1
				tempBitValue = StrMid(machineConfig, StrReverseFind(machineConfig,"ke")+2, 8);
				tempBitValue = StrIVal("0x" + tempBitValue);
				tempBitValue = MthBitwiseAND(bitFilterValue, tempBitValue) / bitFilterValue;
				VerDef::easyPunch = VerDef::easyPunch + tempBitValue;			
				bitFilterValue = 2; // bit 1 ==> 2^1 = 2
				tempBitValue = StrMid(machineConfig, StrReverseFind(machineConfig,"ke")+2, 8);
				tempBitValue = StrIVal("0x" + tempBitValue);
				tempBitValue = MthBitwiseAND(bitFilterValue, tempBitValue) / bitFilterValue;
				VerDef::easyPunch = VerDef::easyPunch + tempBitValue;			
				if(VerDef::easyPunch > 1) 	VerDef::easyPunch = 1; // both devices must be installed for verification
				else								VerDef::easyPunch = 0;	
			}

		// get number of Twister devices:	Number of robotic channels => value of parameter "kr#"
			if (StrReverseFind(machineConfig,"kr") < 0) VerDef::Twisters = 0;
			else 	VerDef::Twisters = IVal(StrMid(machineConfig, StrReverseFind(machineConfig,"kr")+2, 1));
			if (VerDef::Twisters > 0)
			{ // check type of robotics channels with command "C0OU" => C0OUid1234ou04
				machineConfig = FwCommand("C0OU", "", hslFalse, ML_STAR );  // ou04 = Twister + barcode 
				if(StrIVal(StrMid(machineConfig, StrReverseFind(machineConfig,"ou") + 2, 2) ) != 4) VerDef::Twisters = 0;		
				Trace("Test: Number of Twister channels =>",VerDef::Twisters,"<==");
			}

		// --- machine configuration, from response of command "H0QG"  // 96er multi Pipetting Head
		// check if low volume or high volume 96er multiPipHead is installed: parameter "qg" (0 = low, 1 = high volume, 2 = WA)
			if ((VerDef::multi96PipHead > 0) && (VerDef::SWVersionNumber >= 4.1))// && !VerDef::SimulationMode) 
			{
				machineConfig = FwCommand( "H0QG", "", hslFalse, ML_STAR ); 
				tempBitValue = StrIVal(StrMid(machineConfig, StrReverseFind(machineConfig,"qg") + 2, 1) );
				VerDef::multi96PipHead = tempBitValue + 1; 		// 1 = 300ul, 2 = 1000ul, 3 = WA (Head Type II), 4 = WA (Head Type II with TADM)
				//Trace("Test: Response machineConfig H0QG =>",machineConfig,"< VerDef::multi96PipHead ==>",VerDef::multi96PipHead ,"<==");
			}

		// --- machine configuration, from response of command "D0QG"  // 384er multi Pipetting Head
		// check if low volume or high volume 384er multiPipHead is installed: parameter "qg" (0 = low, 1 = high volume, 2 = STP)
			if ((VerDef::multi384PipHead > 0) && (VerDef::SWVersionNumber >= 4.1))// && !VerDef::SimulationMode) 
			{
				machineConfig = FwCommand( "D0QG", "", hslFalse, ML_STAR );
				tempBitValue = StrIVal(StrMid(machineConfig, StrReverseFind(machineConfig,"qg") + 2, 1) );
				VerDef::multi384PipHead = tempBitValue + 1; 			// 1 = 30ul, 2 = 50ul, 3 = STP
				//Trace("Test: Response machineConfig D0QG =>",machineConfig,"< VerDef::multi384PipHead ==>",VerDef::multi384PipHead ,"<==");			
			}

		// ----- layout information of instrument  -----------------
		// get track number for reagent carrier (balance)
			GetVerificationInformation(VerDef::KeyBalanceCarTrack, trackNo, prop2, prop3 ,sn, date, lcd, lcb);
			VerDef::balanceTrackPos	= IVal(trackNo);

		// get track number for tip plate carrier
			GetVerificationInformation(VerDef::KeyTipPlateCarTrack, trackNo, prop2, prop3 ,sn, date, lcd, lcb);
			VerDef::tipPlateCarrierTrackPos	= IVal(trackNo);

	} // --- end of function "GetStarConfiguration" ----

	//------------------------------------------------------------------------------
	function MWP_ExternalCalibration() variable
	//------------------------------------------------------------------------------
	{
		variable dialogTitle(""), pictureFile("");			// picture file name (in subdirectory "..\\Methods\Verification\Pictures\""
		variable warning(""), userResponse("");
		variable command(""), response("");
		variable doCalibration(hslTrue), executionStatus(hslFalse);
		variable trialCounter(-1), loopCounter(-1), timeOut(30);
		variable initCommand(hslTrue);
		variable cmdButtons(hslOKCancel);

		executionStatus 	= hslFalse;
		timeOut 				= 30;
		dialogTitle 		= LdT("External Calibration of Balance:");

		while(doCalibration)
		{
			trialCounter++;
			VerTool::MWPUserComand("@", timeOut) ; // stop command execution  , time out
			VerTool::MWPUserComand("@", timeOut) ; // stop command execution  , time out
			VerTool::MWPUserComand("M67 40", timeOut) ; // set balance timeout back to 40s
			VerTool::MWPUserComand("M02 4", timeOut) ; // set enviroment filter to enstable condition

			warning = LdT("ATTENTION:") + " " + LdT("Weighing Bowl must be very clean for external calibration!");
			VerTool::NewTextLine(1, LdT("External calibration of OWS balance will be executed."));
			VerTool::NewTextLine(0, "===================================================");
			VerTool::NewTextLine(0, "");
			VerTool::NewTextLine(0, "");
			VerTool::NewTextLine(0, LdT("Unload calibration weight, if it is still on balance."));
			VerTool::NewTextLine(0, "");
			VerTool::NewTextLine(0, "");
			VerTool::NewTextLine(0, LdT("ATTENTION:"));
			VerTool::NewTextLine(0, LdT("Execute user instructions immediately,"));
			VerTool::NewTextLine(0, LdT("otherwise external execution of balance can fail."));
			VerTool::NewTextLine(0, "");
			VerTool::NewTextLine(0, LdT("Prepare following items for manipulation:"));
			VerTool::NewTextLine(0, " -   "+ LdT("Calibration Weight"));
			VerTool::NewTextLine(0, " -   "+ LdT("Forceps"));
			cmdButtons = hslOKCancel;
			VerTool::NewTextLine(0, "");
			VerTool::NewTextLine(0, "");
			VerTool::NewTextLine(0, LdT("Press OK to calibrate the Balance."));
			VerTool::NewTextLine(0, LdT("Press Cancel to stop the Verification."));
			pictureFile  = "Balance_WMC_Check.jpg";
			userResponse = VerTool::DialogInfoData(dialogTitle, pictureFile, VerDef::dialogText,warning, cmdButtons, 1, "","","");
			if(userResponse == hslCancel) 
			{	
				doCalibration = hslFalse; // no more external calibration needed
				break;
			}

			loopCounter = -1;
			command = "C2";
			initCommand = hslTrue;
			while(hslTrue)
			{
				loopCounter++;
				pictureFile = "";
				Trace("Test: MWP_ExternalCalibration => loop number =>",loopCounter,"<==");
				response = VerTool::MWPUserComand_2(command, timeOut) ; // command, time out
				//Trace("Test a: -----------  Response during externe Calibration =>",	command,"<  is ==>",response,"<==");
				if(VerDef::SimulationModeBalance)
				{
					Trace("Test: Simulated date in loop ==>", loopCounter);
					if(trialCounter == 0) response = "C2 I";
					if(loopCounter == 1) response = "C2 B";
					if(loopCounter == 2) response = "C2 '   0.00000 g'";
					if(loopCounter == 3) response = "C2 '   0.00000 g'";
					if(loopCounter == 4) response = "C2 A";
				}
				Trace("Test b: === loop number =>",loopCounter,"<======  Response during External Calibration =>",	command,"<  is ==>",response,"<==");
				if(StrFind(response,"C2 A")>= 0) 
				{
					executionStatus = hslTrue; // successful external calibration
					doCalibration	 = hslFalse; // no more external calibrration needed
					break;
				}
				if((response == VerDef::notDefined) || (StrFind(response,"C2 I")>= 0) || (StrFind(response,"C2 L")>= 0))
				{
					VerTool::NewTextLine(1, LdT("External calibration failed!"));
					VerTool::NewTextLine(0, "=================================");
					VerTool::NewTextLine(0, "");
					VerTool::NewTextLine(0, "");
					VerTool::NewTextLine(0, LdT("Unload calibration weight, if it is still on balance."));
					cmdButtons = hslOKCancel;
					VerTool::NewTextLine(0, "");
					VerTool::NewTextLine(0, "");
					VerTool::NewTextLine(0, LdT("Press OK to calibrate the Balance again."));
					VerTool::NewTextLine(0, LdT("Press Cancel to stop the Verification."));

					pictureFile = "Unload_CalWeightFromWMCBalance.jpg";
					warning = LdT("ATTENTION:") + " " + LdT("External calibration failed!");
					userResponse =VerTool::DialogInfoData(dialogTitle, pictureFile, VerDef::dialogText,warning, cmdButtons, 1, "","","");
					if(userResponse == hslCancel) 
					{
						doCalibration = hslFalse; // no more external calibration needed
					}
					break;
				}

				command = "";	
				if(StrFind(response,"C2 B")< 0)
				{
					VerTool::NewTextLine(1, LdT("Load calibration weight."));

					warning = LdT("ATTENTION:") + " " + LdT("Execute user instruction immediately!");

					if(StrFind(response," 10.0")>= 0) pictureFile = "Load_CalWeightOntoWMCBalance.jpg";
					if(StrFind(response," 0.0")>= 0 ) 
					{
						if(initCommand) response = VerTool::MWPUserComand_2(command, 1) ; // command, short time out
						initCommand = hslFalse;
						if((VerDef::SimulationModeBalance) &&(loopCounter == 2)) response = "C2 '   10.00000 g'";
						Trace("Test c: =========  Response during External Calibration =>",	command,"<  is ==>",response,"<==");
						if(StrFind(response," 10.0") >= 0) pictureFile = "Load_CalWeightOntoWMCBalance.jpg";
						else
						{
							warning = "";
							pictureFile = "Unload_CalWeightFromWMCBalance.jpg";
							VerTool::NewTextLine(1, LdT("Unload calibration weight."));
						}	
					}
					if(pictureFile != "")
					{ 
						cmdButtons = hslOKOnly;
						VerTool::NewTextLine(0, " ");
						VerTool::NewTextLine(0, " ");
						VerTool::NewTextLine(0, LdT("Press 'OK' to continue."));
//							VerTool::NewTextLine(0, LdT("Press 'Cancel' to stop the Verification."));
						userResponse = VerTool::DialogInfoData(dialogTitle, pictureFile, VerDef::dialogText,warning, cmdButtons, 1, "","","");
						if(userResponse == hslCancel) 
						{
							doCalibration = hslFalse; // no more external calibration needed
							break;
						}
					}
				}		
			}	
		} 

		// end of calibration processing
		VerTool::MWPUserComand("@", timeOut) ; 		// stop command execution  , time out
		VerTool::MWPUserComand("@", timeOut) ; 		// stop command execution  , time out
		VerTool::MWPUserComand("M67 40", timeOut) ;  // set balance timeout back to 40s
		
		return(executionStatus);
	}  // -- end of function "MWP_ExternalCalibration"

	// --------------------------------------------------------------------------------------
	// Check loading of balance: Glas or 96er plate or 384er plate
	function CheckLoadingOnBalance(device ML_STAR, variable labwareOnBalance) variable  // true or false
	// --------------------------------------------------------------------------------------
	{
		const variable measureMode_8(8);	// measure weight at 8 seconds +/- 6s
		variable userMessageText(""), dialogTitle(""), warning(""), pictureFile(""), pictureFile_0(""), pictureFile_1("");
		variable nominalValue(0.0), lowerLimit(0.0), upperLimit(0.0), emptyLimit(0.0);
		variable deviation, deviationLimit;
		variable weight(1.0), simulatedWeight(0.0), trailNo(0);
		variable useWindShield(hslFalse);
		variable buttonSelection, returnValue;
		variable tempText("");
		// define acceptance criteria
		deviationLimit = 25300; // 25.3mg
		emptyLimit = 5.0; // ==> empty detection < 5g
		if (labwareOnBalance == VerDef::_8ml_Tube)
		{	// 	_8ml_Tube: 	13g 	==> Acceptance range:  5 ... 30g
			nominalValue	= 13.0;
			lowerLimit 		= 5.0;
			upperLimit 		= 30.0; 	
			pictureFile_0 	= "Balance_TubeWindshield.jpg";
			pictureFile_1 	= "Balance_Tube.jpg";
		}
		if (labwareOnBalance == VerDef::_96erPlate)
		{		// 	_96erPlate:	44g 	==> Acceptance range: 30 ... 53g
			nominalValue	= 44.0;
			lowerLimit 		= 30.0;
			upperLimit 		= 53.0; 			
			pictureFile_0	= "Balance_PlatePlatform.jpg";
			pictureFile_1 	= "Balance_96erPlate.jpg";
		}
		if (labwareOnBalance == VerDef::_384erPlate)
		{		// 	_384erPlate:47g 	==> Acceptance range: 30 ... 80g
			nominalValue	= 47.0;
			lowerLimit 		= 30.0;
			upperLimit 		= 80.0; 	
			pictureFile_0	= "Balance_PlatePlatform.jpg";
			pictureFile_1 	= "Balance_384erPlate.jpg";
		}

		while(hslTrue)
		{	
			trailNo++;
			simulatedWeight = nominalValue;

//			weight = MWPMeasure(Balance::MeasureMode_0, simulatedWeight * 1000.0)/1000000.0; 

			if(VerDef::SimulationModeBalance)
			{// for testing only
				deviation = deviationLimit + 1;
				if (trailNo > 2) deviation = deviationLimit;			
				if (trailNo > 3) weight = 3.0;
				if (trailNo > 4) weight = 83.0;			
				if (trailNo > 5) weight = nominalValue;			
			}
			else
			{
				weight = measureMultipleWeight(measureMode_8, deviation)/1000000.0; // weight in g
            tempText = StrConcat2(weight*1000.0," mg");
            VerTool::UpdateStatusDialog("",tempText,Dlg::Green);

				weight = weight - Balance::emptyWeight; 
			}

			//Trace("Test: CheckLoadingOnBalance ",userMessageText, "  weight is ", weight," g");

			if((deviation <= deviationLimit) && (weight >= lowerLimit) && (weight <= upperLimit)) break; 

			// --------------------------------------------------------------------------
			// Unlock front cover		
			CoverLock(ML_STAR , VerDef::coverUnlock);
			// --------------------------------------------------------------------------

			if(deviation > deviationLimit)	// weight measurement is instable
			{ 
				dialogTitle 	= LdT("Balance Function Check:");
				pictureFile		= "Balance_Unstable.jpg";
				NewTextLine(1, LdT("Unstable Weight Measurement:"));
				NewTextLine(0, " -------------------------------------");
				NewTextLine(0, " ");
				NewTextLine(0, LdT("The following reasons may cause weight measurement problems:"));
				NewTextLine(0, " ");
				NewTextLine(0, "- " + LdT("Wind: Prevent drafts inside the Instrument"));
				NewTextLine(0, "- " + LdT("Vibrations on the Deck"));
				NewTextLine(0, "- " + LdT("The Balance is still in the Warm-up period"));
				NewTextLine(0, " ");
				NewTextLine(0, " ");
				if (trailNo > 1)
				{		
					buttonSelection 	= hslYesNoCancel;
					NewTextLine(0, LdT("Press Yes to check the Balance again."));
					NewTextLine(0, LdT("Press No to continue with the Verification."));
					warning = LdT("WARNING:") + " " + LdT("Unstable weight measurement can cause a failed Volume Verification!");
				}
				else
				{
					buttonSelection 	= hslOKCancel;
					NewTextLine(0, LdT("Press OK to check the Balance again."));
					warning = LdT("WARNING:") + " " + LdT("Unstable weight measurement on the Balance!");
				}
				NewTextLine(0, LdT("Press Cancel to end the Verification."));

			
				returnValue = VerTool::DialogInfoData(dialogTitle, pictureFile, VerDef::dialogText,warning, buttonSelection, 1,"","","");
				if (returnValue == hslCancel) {VerTool::HideStatusDialog(); abort;}
				if (returnValue == hslNo) 		deviation = 0;

			}
			if(deviation <= deviationLimit) // Wrong Labware loaded on the Balance
			{	
				dialogTitle 	= LdT("Balance Loading Check:");

				// remove labware form balance to measure empty weight again
				NewTextLine(1, LdT("Wrong Labware loaded on the Balance:"));
				NewTextLine(0, " -------------------------------------");
				NewTextLine(0, " ");
				NewTextLine(0, " ");
				NewTextLine(0, LdT("Press 'Yes' to check the Labware loading again."));

				if ( weight < emptyLimit)
				{
				 	warning = LdT("WARNING:") + " " + LdT("No labware loaded on the Balance!");
					pictureFile = pictureFile_0;
				}
				else
				{
					NewTextLine(0, "   " + LdT("Hint:") + " " + LdT("Remove the present Labware from the Balance."));
					warning = LdT("WARNING:") + " " + LdT("Wrong labware loaded on the Balance !");
					pictureFile = pictureFile_1;
				}
				NewTextLine(0, " ");
				NewTextLine(0, LdT("Press 'No' to end the labware loading check."));
			
				returnValue = VerTool::DialogInfoData(dialogTitle, pictureFile, VerDef::dialogText,warning, hslYesNo, 1,"","","");
				if (returnValue == hslNo) return(hslFalse);

				// set balance to zero (fast mode)
				VerTool::MWPSetZero(1); 
				Balance::emptyWeight = MWPMeasure(Balance::MeasureMode_0, 0.0)/1000000.0; 		// [g]

				// measure loading again
				useWindShield = hslFalse;
				if (labwareOnBalance == VerDef::_8ml_Tube)
				{	// 	_8ml_Tube: 	
					userMessageText= "     - " + LdT("the Measurement Vial");
					useWindShield = hslTrue;
				}
				if (labwareOnBalance == VerDef::_96erPlate)
				{		// 	_96erPlate:
					userMessageText	= "     - " + LdT("96 Well MTP (Well 'A1' at the left, rear position)");
				}
				if (labwareOnBalance == VerDef::_384erPlate)
				{		// 	_384erPlate:
					userMessageText	= "     - " + LdT("384 Well MTP (Well 'A1' at the left, rear position)");
				}

				NewTextLine(1, LdT("Reload proper Labware onto the Balance:"));
				NewTextLine(0, " ----------------------------------");
				NewTextLine(0, " ");
				NewTextLine(0, LdT("Following Labware must be loaded:"));
				NewTextLine(0, " ");
				NewTextLine(0, userMessageText);
				if(useWindShield)
				{
					NewTextLine(0, " ");
					NewTextLine(0, LdT("Place the Windshield back onto the Balance."));
				}
				returnValue = VerTool::DialogInfoData(dialogTitle, pictureFile_1, VerDef::dialogText,warning, hslOKOnly, 1,"","","");
			}
		}

		// --------------------------------------------------------------------------
		// Lock front cover, if requested (VerDef::CoverLocking > 0)
		CoverLock(ML_STAR , VerDef::coverLock);
		// --------------------------------------------------------------------------

		return(hslTrue);
	} // -- end of function "CheckLoadingOnBalance"

	// --------------------------------------------------------------------------------------
	// Check Balance 
	function Check_Balance(device ML_STAR) variable    		// true or false
	// --------------------------------------------------------------------------------------
	{
		variable comPort(""),validStatus(""),trackNo(""),actualSN(""), translatedText(""), starSN;
		variable prop2, prop3, sn, lastCheck(""),lcd(""),lcb(""); // dummy place holder ;
		variable userMessageText(""), dialogTitle(""), warning(""), pictureFile(""), remarks(""),expiryDate;
		variable dateOkay, checkStatus(hslTrue);
		variable returnValue, buttonSelection, defaultButton(1);//, minTrackNo(7);
		variable simulatedWeight(0.0), weight(1.0), nominalWeight(20.0), deviation(0.0);
		variable balanceResponse;

		if (Balance::Type != Balance::Type_SAG )
		{
		  if (Balance::balanceTerminal)	Balance::WeightInstrNr = "I14 4"; // different command for balance with terminal
		}
		actualSN = MWPUserComand(Balance::WeightInstrNr, 10);	// command for the serial number
		
		translatedText = LdT("Balance firmware version") + StrConcat2(" : ",MWPUserComand("I3", 10));
		FormatTrace(GetFunctionName(),"()", VerDef::CMD_COMPLET ," ", translatedText);

		if(VerDef::SimulationModeBalance) 
		{
			if (Balance::balanceTerminal)	actualSN = "I14 B 4 1 \"1123361924\"I14 A 4 2 \"\"";
			else									actualSN = "I4 A \"1123361924\"";
		}
		if(StrFind(actualSN,"\"")>= 0)
		{
			actualSN = StrMid(actualSN, StrFind(actualSN,"\"")+1, StrGetLength(actualSN));
			if(StrFind(actualSN,"\"")>= 0) actualSN = StrLeft(actualSN, StrFind(actualSN,"\""));
		}
		else	actualSN = StrRight(actualSN, StrGetLength(actualSN)-4);

		GetVerificationInformation(KeyCalWeight,Balance::CalibrationWeight,Balance::CalibrWeightExpiryDate,prop3,Balance::CalibrationWeightID,Balance::CalibrationWeightDate,lcd,lcb);
		GetVerificationInformation(KeyBalance,Balance::Type ,comPort, Balance::CheckedStatus, Balance::SerialNumber, Balance::CalibrationDate,lcd,lcb);
		GetVerificationInformation(VerDef::KeyBalanceCarTrack, trackNo, starSN, validStatus ,sn, lastCheck,lcd,lcb);
		VerDef::balanceTrackPos	= IVal(trackNo);

		VerTool::ValidateDate(lastCheck, 0, expiryDate, checkStatus, remarks); 	// last check was not today
		// additional criteria for not valid status 
		VerTool::ValidateDate(Balance::CalibrationDate, VerDef::oneYear, Balance::ExpiryDate, dateOkay, remarks);
		if (dateOkay == 0)								 checkStatus = 0; // calibration date of balance expired 
		if (validStatus == VerDef::invalid) 		 checkStatus = 0;	// check not valid last time
		if (actualSN != Balance::SerialNumber) 	 checkStatus = 0;	// different balance serial number
		if (starSN != VerDef::InstrumentSerialNo ) checkStatus = 0;	// different star instrumentserial number

		// --------------------------------------------------------------------------
		// Unlock front cover		
		CoverLock(ML_STAR , VerDef::coverUnlock);
		// --------------------------------------------------------------------------

		// show load dialog	
		dialogTitle 		= LdT("Balance Function Check:");
		pictureFile 		= "Balance_TubeWindshield.jpg";
		if(VerDef::isRoche)
		{
			pictureFile 		= "Balance_WXS_Check.jpg";
			if (Balance::Type == Balance::Type_SAG ) pictureFile = "Balance_SAG_Check.jpg";
			if (Balance::Type == Balance::Type_WMC ) pictureFile = "Balance_WMC_Check.jpg";
		}

		translatedText = LdT("Check the '%s1' Balance:");
		StrReplace(translatedText ,"%s1", Balance::Type);
		NewTextLine(1, translatedText);
		NewTextLine(0, " -----------------------------------------------");
		NewTextLine(0, StrConcat4(LdT("Balance Serial Number:")," ", " ", actualSN));
		NewTextLine(0, " -----------------------------------------------");
		NewTextLine(0, " ");
		NewTextLine(0, LdT("Prior to the Balance check:"));
		if (Balance::Type == Balance::Type_WMC ) 
		{
			NewTextLine(0, "- " + LdT("empty and dry the Weighing Bowl onto the Balance."));
			NewTextLine(0, "- " + LdT("mount the WMC Windshield onto the Balance."));
			NewTextLine(0, " ");
			NewTextLine(0, LdT("ATTENTION:") + " " + LdT("Weighing Bowl must be very clean for external calibration!"));
			warning 		= LdT("ATTENTION:") + " " + LdT("Warm-up time of the Balance is at least 3 hours!");
		}
		else
		{
			NewTextLine(0, "- " + LdT("Remove all items from the Balance."));
			NewTextLine(0, "- " + LdT("Mount the Vial Platform and the Centering Ring"));
			NewTextLine(0, LdT("Hint:") + " " + LdT("Vial Windshield should be onto the Balance."));
			warning 		= LdT("ATTENTION:") + " " + LdT("Warm-up time of the Balance is at least 30 minutes!");
		}
		NewTextLine(0, " ");
		if (checkStatus > 0)
		{
			Balance::CheckedStatus = VerDef::valid;
			NewTextLine(0,  LdT("Note:") + " " + LdT("The Balance was checked today."));
			NewTextLine(0, " ");
			NewTextLine(0, LdT("Press 'Yes' to check the Balance again."));
			NewTextLine(0, LdT("Press 'No' to skip the Balance check."));
			buttonSelection 	= hslYesNoCancel;
			defaultButton		= 2; // no as default button
		}
		else
		{
			Balance::CheckedStatus = VerDef::invalid;
			NewTextLine(0,  LdT("ATTENTION:") + " " + LdT("The Balance needs to be checked."));
			NewTextLine(0, " ");
			NewTextLine(0, LdT("Press 'OK' to check the Balance."));
			buttonSelection 	= hslOKCancel;
			defaultButton		= 1;
		}
		NewTextLine(0, LdT("Press 'Cancel' to stop the Verification."));


		// show load dialog	
		returnValue = VerTool::DialogInfoData(dialogTitle, pictureFile, VerDef::dialogText,warning, buttonSelection, defaultButton,"","","");
		if (returnValue == hslCancel) return(hslFalse);
		if (returnValue == hslNo) 		return(hslTrue);
		
		if (Balance::Type == Balance::Type_WMC ) 	nominalWeight = 10.0;  
		else													nominalWeight = 20.0;
		simulatedWeight = (nominalWeight + 0.002123)* 1000.0;  

		if (Balance::Type == Balance::Type_WMC ) 
		{
			MWPBalanceDisplay(Balance::DisplayMode2);		// Set balance display to #.##mg
		}
		
		while(hslTrue)
		{ // perform balance check
         VerTool::ShowStatusDialog(LdT("Balance Information:"));
         VerTool::UpdateStatusDialog("",LdT("Balance checking ..."),Dlg::Yellow);						
			simulatedWeight = simulatedWeight - 1.0; 
			// Set weighting parameters
			MWPSettingOfTheWeighingParameters();
			if (Balance::Type == Balance::Type_WMC ) 
			{  // external calibration of WMC balance
				if(!MWP_ExternalCalibration()){VerTool::HideStatusDialog(); return(hslFalse);}
			}
			else
			{ // internal calibration of SAG or WXS balance
				MWPBalanceDisplay(Balance::DisplayMode1);		// Set balance display to #.#mg
				MWPInternalCalibration();
				MWPBalanceDisplay(Balance::DisplayMode2);		// Set balance display to #.##mg
			}

			MWPSetZero(0);											// And to zero.
			// Put calibration weight on balance
			dialogTitle 		= LdT("Balance Function Check:");
			
			if(VerDef::isRoche)
			{
				pictureFile 		= "Balance_WXS_PutCalWeight.jpg";
				if (Balance::Type == Balance::Type_SAG ) pictureFile = "Balance_SAG_PutCalWeight.jpg";
				if (Balance::Type == Balance::Type_WMC ) pictureFile = "Load_CalWeightOntoWMCBalance.jpg";
			}
			else pictureFile 		= "Load_CalWeight.jpg";

			NewTextLine(1, LdT("Place the Calibration Weight onto the Balance:"));
			NewTextLine(0, " -----------------------------------------------");
			NewTextLine(0, " ");
			NewTextLine(0, " ");
			NewTextLine(0, LdT("Handle the Calibration Weight with the forceps"));
			if (Balance::Type == Balance::Type_WMC ) 
			{
				NewTextLine(0, LdT("and place it into the Weighing Bowl."));
			}
			else
			{
				NewTextLine(0, LdT("and place it onto the Vial platform."));
				NewTextLine(0, " ");
				NewTextLine(0, LdT("Place the Vial Windshield onto the Balance."));
			}
			NewTextLine(0, " ");
			NewTextLine(0, " ");
			NewTextLine(0, LdT("Press 'OK' to continue."));

			VerTool::DialogInfoData(dialogTitle, pictureFile, VerDef::dialogText,"", hslOKOnly, 1, "","","");

			// --------------------------------------------------------------------------
			// Weighting calibration weight 
			//
			weight = MWPMeasure(Balance::MeasureMode1, simulatedWeight)/1000000.0; 
			RPD::calibWeightMeasured = weight;
			deviation = (weight - nominalWeight) * 1000000;

			if(VerDef::isRoche)
			{
				pictureFile 		= "Balance_WXS_RemoveCalWeight.jpg";
				if (Balance::Type == Balance::Type_SAG ) pictureFile = "Balance_SAG_RemoveCalWeight.jpg";
				if (Balance::Type == Balance::Type_WMC ) pictureFile = "Unload_CalWeightFromWMCBalance.jpg";
			}		
			else	pictureFile 		= "Remove_CalWeight.jpg";
			
			NewTextLine(1, LdT("Balance Check Results:"));
			NewTextLine(0, " -----------------------------------------------");
			NewTextLine(0, " ");
			NewTextLine(0, LdT("Measured Weight:") + "  " + FormatNumber_PointAsDecimal(weight,5) + " g");
			NewTextLine(0, " ");
			if (Balance::Type == Balance::Type_WMC ) 	
			{
				NewTextLine(0, LdT("Acceptance Range : 9.99966 g .. 10.00034 g"));
			}
			else
			{
				NewTextLine(0, LdT("Acceptance Range : 19.99966 g .. 20.00034 g"));
			}
			NewTextLine(0, " ");
			translatedText = "--> " + LdT("Deviation:  %s1 ug (Acceptance range: +/-340 ug)");
			StrReplace(translatedText ,"%s1", FormatNumber_PointAsDecimal(deviation,0));
 			NewTextLine(0, translatedText);
			NewTextLine(0, " ");
			NewTextLine(0, LdT("Remove the Calibration Weight with the forceps"));
			NewTextLine(0, LdT("from the Balance."));
			NewTextLine(0, " ");
			if(weight > (nominalWeight + 0.00034) || weight < (nominalWeight - 0.00034) )
			{ // check range
				validStatus = VerDef::invalid;
				warning		= LdT("WARNING:") + " " + LdT("Balance check failed") + " !";
			}
			else
			{
				validStatus = VerDef::valid;
				NewTextLine(0, " ");
				NewTextLine(0, " ");
				NewTextLine(0, LdT("The Balance Check was successful") + " !");
				warning 				= 	"";
				buttonSelection 	= hslOKOnly;
				defaultButton		= 1;
				NewTextLine(0, " ");
				NewTextLine(0, " ");
				NewTextLine(0, LdT("Press 'OK' to continue."));
			}
			if (validStatus == VerDef::invalid)
			{
				NewTextLine(0, " ");
				NewTextLine(0, LdT("Press 'OK' to check the Balance again."));
				NewTextLine(0, LdT("Press 'Cancel' to stop the Verification."));
				buttonSelection = hslOKCancel;
				defaultButton		= 1;				 
			}		
			returnValue = VerTool::DialogInfoData(dialogTitle, pictureFile, VerDef::dialogText,warning, buttonSelection, defaultButton,"","","");

			if (returnValue == hslCancel) {VerTool::HideStatusDialog(); return(hslFalse);}
			if ((returnValue == hslOK )&& (validStatus == VerDef::valid)) break;

		} // end of balance check

		// Set weighting parameters
		MWPSettingOfTheWeighingParameters();

		Balance::CheckedStatus 	= validStatus;
		Balance::SerialNumber 	= actualSN;
		UpdateVerificationInformation(0,KeyBalance, Balance::Type ,comPort,Balance::CheckedStatus, Balance::SerialNumber, Balance::CalibrationDate);	
		UpdateVerificationInformation(0, VerDef::KeyBalanceCarTrack, trackNo, VerDef::InstrumentSerialNo, validStatus ,
																							sn, GetDate("%Y-%m-%d"));	// date = today);
		Balance::CalibrationWeight = VerTool::FormatNumber_PointAsDecimal(weight,5);
		UpdateVerificationInformation(1, KeyCalWeight,Balance::CalibrationWeight,Balance::CalibrWeightExpiryDate,prop3,Balance::CalibrationWeightID,Balance::CalibrationWeightDate);

		RemovePresentLabware(ML_STAR, VerDef::carrierName_Reagent);	
		// --------------------------------------------------------------------------
		// Lock front cover, if requested (VerDef::CoverLocking > 0)
		CoverLock(ML_STAR , VerDef::coverLock);
		// --------------------------------------------------------------------------
      VerTool::HideStatusDialog();
		return(hslTrue);
	} // -- end of function "Check_Balance"

	//------------------------------------------------------------------------------
	// Check presence of program and ML-STAR Software version
	function CheckPrograms(variable firstSW_Version) variable
	//------------------------------------------------------------------------------
	{
		variable prop1(""),prop2(""),prop3(""),sn(""),date(""),lcd(""),lcb(""); // dummy place holder ;
		
		variable firstVersion;
		variable programFileName,fileNamePDF,fileNameAcro, mainFolderName, pathName;
		variable checkStatus(hslTrue),getPDF_Progr(hslFalse),getAcrobat_Progr(hslFalse);
		variable userMessageText(""), userResponse;
		variable fileSelected;
		dialog userMessage;
		object fso;  // file system object	
			
		if (fso.IsNull()) fso.CreateObject("Scripting.FileSystemObject");
		
		// check software version
		if(GetType(firstSW_Version) == "s") firstVersion = FVal(StrLeft(firstSW_Version,3));
			else 										firstVersion = firstSW_Version;
		//Trace( "Test: Release version=>", VerDef::SWVersionNumber, " >= ",firstVersion,"<==");

		if (VerDef::SWVersionNumber < firstVersion) 
		{
			checkStatus = hslFalse;
			userMessageText = StrConcat8(userMessageText,"\n- ",LdT("Verification not foreseen for this User Software Version")," ",VerDef::SWReleaseVersion,".","","");
		}
		//Trace( "Test: ML-STAR instrument software version=>", VerDef::ReleaseVersion, " >= ",firstSW_Version,"< check status =>", checkStatus);

		// --- check for presence of PDF camp program
		fileNamePDF	= StrRight(PDF_CreatorExecutableProgram, StrGetLength(PDF_CreatorExecutableProgram)- StrReverseFind(PDF_CreatorExecutableProgram,"\\") -1);
		GetVerificationInformation(KeyPDFcampExecFile,programFileName,prop2,prop3, sn, date,lcd,lcb);
		if (programFileName == "") UpdateVerificationInformation(1, KeyPDFcampExecFile, PDF_CreatorExecutableProgram, 
																						prop2,prop3, sn, GetDate("%Y-%m-%d"));	// date = today);
		else PDF_CreatorExecutableProgram = programFileName;
		// PDF Camp programm is not working on 64bit operating system resp. not installed on Windows 7 operating system ansd for Roche Installation
		if((VerDef::is64BitArchitecture) || (VerDef::operatingSystem >= 6) || (VerDef::isRoche)) programFileName = VerDef::notInstalled;

//Trace( "Stored 'PDFcamp Printer Pro v2.3' executable program file =>",programFileName,"< = >", PDF_CreatorExecutableProgram, "<==");
		if(programFileName == VerDef::notInstalled) 
		{
			PDF_CreatorExecutableProgram = programFileName;
//			Trace( "No 'PDFcamp Printer Pro v2.3' used!");
		}
		else if(!fso.FileExists(PDF_CreatorExecutableProgram)) 
		{
			mainFolderName = StrLeft(GetBinPath(), StrReverseFind(GetBinPath(),"HAMILTON\\Bin"));
			pathName = searchFilePathName(fileNamePDF, mainFolderName);
			if(pathName == "")
			{
				mainFolderName = StrLeft(PDF_CreatorExecutableProgram, 3);
//	Trace( "Test: Search for File=>", fileNamePDF, "< form folder ==> ",mainFolderName,"<== on ");
				pathName = searchFilePathName(fileNamePDF, mainFolderName);
			}
			if(pathName == "")
			{
				userMessageText	= userMessageText  + "\n- " + LdT("Program 'PDFcamp Printer Pro v2.3' not installed or found");
				getPDF_Progr 		= hslTrue;
			}
			else 
			{
				PDF_CreatorExecutableProgram = pathName;
	 			UpdateVerificationInformation(1, KeyPDFcampExecFile, PDF_CreatorExecutableProgram, 
																			prop2,prop3, sn, GetDate("%Y-%m-%d"));	// date = today);
			}
		}

		// --- check for presence of Acrobat Reader program
		GetVerificationInformation(KeyAcrobatReader,programFileName,prop2,prop3, sn, date,lcd,lcb);
		if (programFileName == "") UpdateVerificationInformation(1, KeyAcrobatReader, AcrobatExecutableProgram, 
																						prop2,prop3, sn, GetDate("%Y-%m-%d"));	// date = today
		else if(AcrobatExecutableProgram != programFileName) AcrobatExecutableProgram = programFileName;

//Trace( "Stored 'Acrobat Reader' executable program file =>", AcrobatExecutableProgram, "<==");
		if(!fso.FileExists(AcrobatExecutableProgram)) 
		{
			fileNameAcro	= StrRight(AcrobatExecutableProgram, StrGetLength(AcrobatExecutableProgram)- StrReverseFind(AcrobatExecutableProgram,"\\") -1);
			mainFolderName = StrLeft(GetBinPath(), StrReverseFind(GetBinPath(),"HAMILTON\\Bin"));
			pathName 		= searchFilePathName(fileNameAcro, mainFolderName);
			if(pathName == "")
			{
				mainFolderName = StrLeft(AcrobatExecutableProgram, 3);
	//Trace( "Test: Search for File=>", fileNameAcro, "< form folder ==> ",mainFolderName,"<== on ");
				pathName = searchFilePathName(fileNameAcro, mainFolderName);
			}
	//Trace( "Test: Search for File=>", fileNameAcro, "< form folder ==> ",mainFolderName,"<== on ");
			if(pathName == "")
			{
				userMessageText = userMessageText + "\n- " + LdT("Program 'Acrobat Reader' not installed or found");
				getAcrobat_Progr= hslTrue;
			}
			else 
			{ 
				AcrobatExecutableProgram = pathName;
				UpdateVerificationInformation(1, KeyAcrobatReader, AcrobatExecutableProgram, prop2,prop3, sn, GetDate("%Y-%m-%d"));	// date = today);
			}
		}

		// -- in case of missing programs display user message
		if (userMessageText != "")
		{
			userMessageText = LdT("Check for following installation errors:") + userMessageText;
			userMessage.SetOutput( userMessageText );
			userResponse = userMessage.ShowOutput( LdT("Verification Installation Error:"), hslOKCancel | hslQuestion, hslInfinite );
			if (userResponse == hslCancel) return(hslFalse);
		}

		// update PDF camp program
		if (getPDF_Progr)
		{
			pathName = "";
			PDF_CreatorExecutableProgram = fileNamePDF;
			fileSelected = SelectFileNameDialog("Select 'PDFcamp Printer Pro v2.3' executable program file:",
											PDF_CreatorExecutableProgram, pathName,"Program Files (*.exe)|*.exe|All Files|*.*");
//Trace( "Test: 'SelectFileNameDialog executable program file pathName =>", pathName,"<  file =>", PDF_CreatorExecutableProgram, "< fileSelected ==>",fileSelected,"<==");
			if(fileSelected) 
			{
//	Trace( "Test: 'PDFcamp Printer Pro v2.3' executable program file =>", pathName,"\\", PDF_CreatorExecutableProgram, "<==");
				PDF_CreatorExecutableProgram = pathName + "\\" + PDF_CreatorExecutableProgram;
			}
			else	PDF_CreatorExecutableProgram 	= VerDef::notInstalled;

			UpdateVerificationInformation(1, KeyPDFcampExecFile, PDF_CreatorExecutableProgram,prop2,prop3, sn, GetDate("%Y-%m-%d"));	// date = today);
		}

		// update Acrobat Reader program
		if (getAcrobat_Progr)
		{
			pathName = "";
			SelectFileNameDialog("Select 'Acrobat Reader' executable program file:",
											AcrobatExecutableProgram, pathName,"Program Files (*.exe)|*.exe|All Files|*.*");
//Trace( "Test: 'Acrobat Reader' executable program file =>", pathName,"\\", AcrobatExecutableProgram, "<==");
			AcrobatExecutableProgram = pathName + "\\" + AcrobatExecutableProgram;
			UpdateVerificationInformation(1, KeyAcrobatReader, AcrobatExecutableProgram, 
																			prop2,prop3, sn, GetDate("%Y-%m-%d"));	// date = today);
		}

		if(!fso.FileExists(AcrobatExecutableProgram)) 		checkStatus = hslFalse;
		if((PDF_CreatorExecutableProgram != VerDef::notInstalled) &&!fso.FileExists(PDF_CreatorExecutableProgram)) 	checkStatus = hslFalse;

		return(checkStatus);	
	} // --- end of function "CheckProgramms" ----

	// ------------------------------------------------------------------------------------------------------------------
	function Check_Photometer( ) variable    		// hslOK, hslCancel
	// Check Photometer measured and check data of processed check plate in photometer 'Reader384'
	// Measure with FAME checkplate or Biomed Checkplate 5 times at 405nm and evaluate 
	//   Accuracy
	//   Plate positioning:
	//   Short term reproducibility
	//   Stray light
	// ------------------------------------------------------------------------------------------------------------------
	{
		variable prop1(""),prop2(""),prop3(""),sn(""),date(""),lcd(""),lcb(""); // dummy place holder ;
		variable loopNo(0), index, rowNo, columnNo, dataIndex, offset, expiryDate, trcText;
		variable externalFileName("");
		variable generateExternalFile(hslFalse);

		variable userMessageText(""), dialogTitle(""), pictureFile(""), remarks(""), warning(""), tempStrValue("");
		variable dateOkay, returnValue, buttonSelection, defaultButton(1);
		variable arrWavelengthSet[], versionFW, prm(""), response(""),pathName("");
		variable primaryOD_ValueSet[];
		variable calValue(0), calValueNew(0);

		variable arrMeasuredData[], arrMeanMeasuredData[], arrCVmeasuredData[], arrMinMeasuredData[],arrMaxMeasuredData[];
		variable standardDeviation(0.0), brightValue(0.0), darkValue(4.0);
		variable nominalAccuracyValues[], accuracyCriteria[];
		variable accDifference(0.0),accCriteria(0.0);
		variable detailedStatus, overallStatus(hslCancel), executionStatus(hslFalse);
		variable measurements(5);
		variable readerCheckPlate(1);
		variable noOrientationCheck(0);

		variable crlf("\013");  // programmed CR only instead VerDef::CRLF ("\013\010");new line: CR + LF
		const variable limitShortTermReprducibility(0.3);	// <= 0.3 % CV
		const variable limitPlatePositioning(0.010); 		// <= 10mOD
		const variable limitStrayLightDarkValue(3.000);   	// >  3 OD
		const variable limitStrayLightBrightValue(0.010);  // <= 10mOD

		file traceFile;


		object fso;  // file system object	
			
		if (fso.IsNull()) fso.CreateObject("Scripting.FileSystemObject");

		overallStatus 	= hslCancel;

		//----- Get reader384 and check plate data ------------------------------------------------------------
		GetVerificationInformation(KeyPhotoCheckPlate,Reader::photoCheckPlatePartNo,prop2,prop3, Reader::photoCheckPlateSerial,Reader::photoCheckPlateExpiryDate,lcd,lcb);
		pathName = "";
		GetPhotoCheckPlateData(Reader::photoCheckPlateSerial, pathName, Reader::photoCheckPlatePartNo, 
													Reader::photoCheckPlateExpiryDate,nominalAccuracyValues,accuracyCriteria);
		// check ML-FANE Photometer Checkplate (P/N148'395) is used, else Biomed Reader Checkplate (P/N 189'116) is used
		if (StrFind(Reader::photoCheckPlatePartNo, "148395")>= 0) readerCheckPlate = 0; // FAME checkplate (not ReaderCheckplate)
		
		//------ perform reader function check
		returnValue = hslYes;
		while(returnValue != hslNo)  
		{ 	loopNo++;
			// open reader door for loading
			Reader::isInitialized = hslFalse;
			response = "er00";
			Reader_TransmitCommand("YI", "", response, 60); // Init plate transport 
			Reader_OpenDoor();
			// show load dialog	
			dialogTitle 		= LdT("Reader384 Function Check:");
			pictureFile 		= "Reader_Checkplate.jpg";
			
			NewTextLine(1, LdT("Load Reader Checkplate onto the Reader384:"));
			NewTextLine(0, " -----------------------------------------------");
			NewTextLine(0, " ");
			NewTextLine(0, LdT("Reader384 Part Number:") + " "  + Reader::partNo);
			NewTextLine(0, LdT("Reader384 Serial Number:")+ " " + Reader::deviceSerialNo);
			NewTextLine(0, " ");
			NewTextLine(0, " ");
			NewTextLine(0, LdT("Checkplate Part Number:") + " " + Reader::photoCheckPlatePartNo);
			NewTextLine(0, LdT("Checkplate Serial Number:") + " " + Reader::photoCheckPlateSerial);
			NewTextLine(0, " ");
			if (VerTool::ValidateDate(Reader::photoCheckPlateExpiryDate, 0, expiryDate, dateOkay, remarks) < 0) 
			{
				warning = LdT("ATTENTION:") + " " +  remarks;
			}
			NewTextLine(0, " ");
			NewTextLine(0, "- " + LdT("Place the 96 Plate Bar on the right side"));
			NewTextLine(0, "- " + LdT("Place the Checkplate with position 'A1'"));
			NewTextLine(0, "     " + LdT("to the right, rear corner."));
			NewTextLine(0, " ");
			NewTextLine(0, " ");

			NewTextLine(0, LdT("Press 'OK' to continue the Reader384 check."));
			NewTextLine(0, LdT("Press 'Cancel' to stop the Reader384 check."));

			returnValue = VerTool::DialogInfoData(dialogTitle, pictureFile, VerDef::dialogText,"", hslOKCancel,1,"","","");
			if (returnValue == hslCancel) 
			{ // close reader door for idle mode
				response = "er00";
				Reader_TransmitCommand("YI","", response, 20);
				Reader_TransmitCommand("YO","", response, 10);
				return(hslCancel);
			}

			//----- Check and adjust plate transport init position------------------------------------------------------------
			userMessageText = "";
			Reader_Initialize();
			Reader::isInitialized = hslTrue;
	      response = "er00ad0064da09";	
			if(Reader_TransmitCommand("QD","ad0064", response, 10) == 0)
			{ // get first plate transport calibration value (in HEX)
				calValue = IVal("0x" + StrMid(response, StrReverseFind(response,"da")+2, 2));	// => P0QDer00ad0064da09		
				Reader_TransmitCommand("LN","", response, 10);
				Reader_TransmitCommand("YI","", response, 20);
				Reader_Measure_Plate(VerDef::_ReaderCheckPlate, 0, primaryOD_ValueSet);
				calValueNew = primaryOD_ValueSet.GetAt(0) - Reader::firstRow;			
				calValue = Floor(calValue + 2.0 * calValueNew);
			
				if((calValue > 0) && (calValue < 20))
				{ // store new adustment value in reader
					prm = StrRight(StrHexIStr(calValue),2);
					prm = "ad0064da" + prm;
					response = "er00" ;
					if(calValueNew != 0) Reader_TransmitCommand("WD",prm, response, 10); // set first plate transport calibration value (in HEX)
				}
				else 	userMessageText = StrConcat4(userMessageText,VerDef::CRLF,"- ",LdT("Reader384 'Calibration' failed"));
			}
			else 	userMessageText = StrConcat4(userMessageText,VerDef::CRLF,"- ",LdT("No connection to the Reader384 established!"));

			if (userMessageText == "") 
			{ // calibration OK
				//----- Measure plate 5 times at 405nm ------------------------------------------------------------
				arrMeasuredData.SetSize( 0 );
				executionStatus	= 0;
				loop(5)
				{
					executionStatus = hslFalse;
					response = "er00";
					if(Reader_TransmitCommand("LN","", response, 10) > 0) break;
					if(Reader_TransmitCommand("YI","", response, 20) > 0) break;			
				
					if(Reader_Measure_Plate(VerDef::_96erPlate, 0, primaryOD_ValueSet) > 0) break;
					
					Trace_96erPlate_OD_Values(primaryOD_ValueSet, VerDef::SemiColon, "");

					// add data to measured array
					for(dataIndex = 0; dataIndex < 96; dataIndex++) arrMeasuredData.AddAsLast(primaryOD_ValueSet.GetAt( dataIndex ));		
					executionStatus = hslTrue;
				}
				if(executionStatus == hslFalse)  userMessageText = StrConcat4(userMessageText,VerDef::CRLF,"- ",LdT("Reader384 execution error occured."));
			}
			if (userMessageText == "")
			{ // measurements OK
				//----- Get external folder name------------------------------------------------------------
				GetVerificationInformation(KeyExternalDataStorage, externalFileName, prop2, prop3 ,sn, date, lcd, lcb);
				if(StrGetLength(externalFileName) > 4)
				{ // -- Assign external file anme
					generateExternalFile = hslTrue;
					if(!fso.FolderExists(externalFileName)) externalFileName = GetSystemPath();
					if (StrRight(externalFileName, 1) != "\\") externalFileName = externalFileName + "\\";

					RPD::externalStoredFileName  = StrConcat12(externalFileName,"Verification_189116SN", Reader::photoCheckPlateSerial,
																		"_189115SN", Reader::deviceSerialNo,"_",	
 																			GetDate("%Y%m%d"), GetTime("%H%M"),".trc","","","");

					Trace("Test: externalStoredFileName =>",RPD::externalStoredFileName,"<===");
					traceFile.AddField( 1, trcText, hslString);
					traceFile.SetDelimiter(hslAsciiText);
					traceFile.Open( RPD::externalStoredFileName, hslWrite);
					traceFile.WriteString( "--------------------  Reader384 Check ------------------------------------" + crlf);
					traceFile.WriteString( " Date:          " + GetDate("%Y-%m-%d") + "    " + GetTime("%H:%M") + crlf);
					traceFile.WriteString( crlf);
					traceFile.WriteString( "Reader384 Part Number:" + " "  + Reader::partNo + crlf);
					traceFile.WriteString( "Reader384 Serial Number:" + " " + Reader::deviceSerialNo + crlf);
					traceFile.WriteString( crlf);
					traceFile.WriteString( "Checkplate Part Number:" + " " + Reader::photoCheckPlatePartNo + crlf);
					traceFile.WriteString( "Checkplate Serial Number:" + " " + Reader::photoCheckPlateSerial + crlf);
					traceFile.WriteString( crlf);
					traceFile.WriteString( "--------------------------------------------------------" + crlf);

				}					
				//----- Evaluate accuracy  (for 405nm) at column 4 .. 8 ----------------------------------------------------

				for (columnNo = 4; columnNo < 9; columnNo++)
				{
					detailedStatus =1;
					dataIndex = columnNo - 4;
					accCriteria = accuracyCriteria.GetAt(dataIndex);
			//Trace("---------- Evaluate 'Accuracy' data at row =>",columnNo,"<===");
					if (accCriteria > 0)
					{
						statisticCalculation(arrMeasuredData, 8, 12, 1, 8 , columnNo, columnNo, measurements,
													arrMeanMeasuredData, arrMinMeasuredData, arrMaxMeasuredData,arrCVmeasuredData);
						for(rowNo = 1; rowNo <= 8; rowNo++)
						{
							dataIndex = 8*(columnNo-4) + rowNo - 1;
			//Trace("Evaluate accuracy at data = ",dataIndex,"<===");
							accDifference = MthRound(arrMeanMeasuredData.GetAt(rowNo) - nominalAccuracyValues.GetAt(dataIndex),3);

			//Trace("Evaluate accuracy at data = ",dataIndex,"<  	accCriteria =>",accCriteria,
			//			"< = nominal value =>",nominalAccuracyValues.GetAt(dataIndex),
			//			"< measured Value =>",arrMeanMeasuredData.GetAt(columnNo),"<==");
							trcText = LdT("Reader384 Check 'Accuracy' in row no '%s1': channel '%s2': => difference value = %s3' ( criteria <= +/-%s4 OD)");
							StrReplace(trcText, "%s1",IStr(columnNo));
							StrReplace(trcText, "%s2",IStr(rowNo));
							StrReplace(trcText, "%s3",FormatNumber_PointAsDecimal(accDifference, 4));
							StrReplace(trcText, "%s4",FormatNumber_PointAsDecimal(accCriteria, 4));
							FormatTrace(GetFunctionName(),"()", VerDef::CMD_COMPLET ," ", trcText);
							if(generateExternalFile) traceFile.WriteString( trcText + crlf  );//traceFile.WriteRecord( );

							if((accDifference > accCriteria) || (accDifference < -1*accCriteria)) detailedStatus = 0;
						}
					}
					if (detailedStatus == 0)
					{
						trcText = LdT("Reader384 Check 'Accuracy' in row no '%s1' failed");
						StrReplace(trcText, "%s1",IStr(columnNo));
						FormatTrace(GetFunctionName(),"()", VerDef::CMD_ERROR ," ", trcText);
						if(generateExternalFile) traceFile.WriteString( trcText + crlf);//traceFile.WriteRecord( );
						userMessageText = StrConcat4(userMessageText, VerDef::CRLF,"- ", trcText);
					}
				}

				// --- Evaluate short-term reproducibility (for 405nm) at column 6 ---------------------------
				detailedStatus =1;
				columnNo = 6;
			//Trace("---------- Evaluate 'Short-term reproducibility ' data at row =>",columnNo,"<===");
				statisticCalculation(arrMeasuredData, 8, 12, 1, 8 , columnNo, columnNo, measurements,
											arrMeanMeasuredData, arrMinMeasuredData, arrMaxMeasuredData,arrCVmeasuredData);

				for(rowNo = 1; rowNo <= 8; rowNo++)
				{
					// --- Criteria Short-term reproducibility ' reporting
					if(arrCVmeasuredData.GetAt(rowNo) > limitShortTermReprducibility) detailedStatus = 0;
					{
						trcText = LdT("Reader384 Check 'Short-term reproducibility' in row 6: channel '%s1': => CV value = %s2% ( criteria <= %s3%)");
						StrReplace(trcText, "%s1",IStr(rowNo));
						tempStrValue = arrCVmeasuredData.GetAt(rowNo);
						StrReplace(trcText, "%s2",FormatNumber_PointAsDecimal(tempStrValue, 3));
						tempStrValue = limitShortTermReprducibility;
						StrReplace(trcText, "%s3",FormatNumber_PointAsDecimal(tempStrValue, 3));
						FormatTrace(GetFunctionName(),"()", VerDef::CMD_COMPLET ," ",trcText);
						if(generateExternalFile) traceFile.WriteString( trcText + crlf );//traceFile.WriteRecord( );

					}
				}
				if(detailedStatus == 0) 
				{
					userMessageText = StrConcat4(userMessageText,VerDef::CRLF,"- ", LdT("Reader384 Check 'Short-term reproducibility' check failed"));
				}

				//----- Evaluate plate positioning (at 405nm and column 1 & 12 ) ----------------------------
				// for 'Biomed Reader Checkplate' in column 12 only well "A12" and "H12"
				brightValue = 0.0;
				columnNo = 1; // column 1
			//Trace("---------- Evaluate 'plate positioning' data at row =>",columnNo,"<===");
	
				statisticCalculation(arrMeasuredData, 8, 12, 1, 8 , columnNo, columnNo, measurements,
										arrMeanMeasuredData, arrMinMeasuredData, arrMaxMeasuredData,arrCVmeasuredData);
				if (brightValue < arrMaxMeasuredData.GetAt(0) ) brightValue = arrMaxMeasuredData.GetAt(0);
				columnNo = 12; // column 12
			//Trace("---------- Evaluate 'plate positioning' data at row =>",columnNo,"<===");
				statisticCalculation(arrMeasuredData, 8, 12, 1, 8 , columnNo, columnNo, measurements,
										arrMeanMeasuredData, arrMinMeasuredData, arrMaxMeasuredData,arrCVmeasuredData);
				if (readerCheckPlate == 0)
				{  
					if (brightValue < arrMaxMeasuredData.GetAt(0) ) brightValue = arrMaxMeasuredData.GetAt(0);
				}
				else
				{	// well "A12"
					if (brightValue < arrMaxMeasuredData.GetAt(1) ) brightValue = arrMaxMeasuredData.GetAt(1);
					// well "H12"
					if (brightValue < arrMaxMeasuredData.GetAt(8) ) brightValue = arrMaxMeasuredData.GetAt(8);
				}
				trcText = LdT("Reader384 Check 'Plate positioning' in row no 1 & 12 : => highest OD value = %s1 ( criteria <= %s2 OD)");
				StrReplace(trcText, "%s1",FormatNumber_PointAsDecimal(brightValue, 4));
				StrReplace(trcText, "%s2",FormatNumber_PointAsDecimal(limitPlatePositioning, 4));

				FormatTrace(GetFunctionName(),"()", VerDef::CMD_COMPLET ," ",trcText);	
				if(generateExternalFile) traceFile.WriteString( trcText + crlf);//traceFile.WriteRecord( );
				if(brightValue > limitPlatePositioning) 
				{
					trcText = LdT("Reader384 Check 'Plate positioning' failed");
					FormatTrace(GetFunctionName(),"()", VerDef::CMD_ERROR ," ",trcText);
					if(generateExternalFile) traceFile.WriteString( trcText + crlf);//traceFile.WriteRecord( );
					userMessageText = StrConcat4(userMessageText,VerDef::CRLF,"- ",trcText);
				}

				//----- Evaluate stray light (at 405nm ) ---------------------------------
				// 	for 'Biomed Reader Checkplate' in column 2 & 11
				// 	for 'FAME Photometer Checkplate' in column 2 & 3

				brightValue = 0.0;
				darkValue	= 4.0;

				columnNo = 2;
				statisticCalculation(arrMeasuredData, 8, 12, 1, 8 , columnNo, columnNo, measurements,
											arrMeanMeasuredData, arrMinMeasuredData, arrMaxMeasuredData,arrCVmeasuredData);
			//Trace("---------- Evaluate 'stray light ' data at row =>",columnNo,"<===");
				for(rowNo = 1; rowNo < 8; rowNo = rowNo + 2)
				{
						if (brightValue < arrMaxMeasuredData.GetAt(rowNo) ) brightValue = arrMaxMeasuredData.GetAt(rowNo);
			//Trace("Test stray light: brightValue =>",brightValue, "< ==> ", extremeMeasuredData.GetAt(columnNo),"<==");			
						if (darkValue > arrMinMeasuredData.GetAt(rowNo + 1) ) darkValue = arrMinMeasuredData.GetAt(rowNo + 1);
			//Trace("Test stray light: darkValue =>",darkValue, "< ==> ", extremeMeasuredData.GetAt(columnNo +8),"<==");			
				}
				if (readerCheckPlate == 0) columnNo = 3;
				else 								columnNo = 11;
				statisticCalculation(arrMeasuredData, 8, 12, 1, 8 , columnNo, columnNo, measurements,
											arrMeanMeasuredData, arrMinMeasuredData, arrMaxMeasuredData,arrCVmeasuredData);
			//Trace("---------- Evaluate 'stray light ' data at row =>",columnNo,"<===");
				for(rowNo = 1; rowNo < 8; rowNo = rowNo + 2)
				{
						if (brightValue < arrMaxMeasuredData.GetAt(rowNo + 1) ) brightValue = arrMaxMeasuredData.GetAt(rowNo + 1);
			//Trace("Test stray light: brightValue =>",brightValue, "< ==> ", extremeMeasuredData.GetAt(columnNo),"<==");			
						if (darkValue > arrMinMeasuredData.GetAt(rowNo) ) darkValue = arrMinMeasuredData.GetAt(rowNo);
			//Trace("Test stray light: darkValue =>",darkValue, "< ==> ", extremeMeasuredData.GetAt(columnNo +8),"<==");			
				}
				trcText = LdT("Reader384 Check 'Stray light' in row no 2 & %s0:=> light OD value = %s1 ( criteria <= %s2 OD) => dark OD value = %s3 ( criteria >= %s4 OD)");
				if (readerCheckPlate == 0) StrReplace(trcText, "%s0","3");
				else 								StrReplace(trcText, "%s0","11");
				StrReplace(trcText, "%s1",FormatNumber_PointAsDecimal(brightValue, 4));
				StrReplace(trcText, "%s2",FormatNumber_PointAsDecimal(limitStrayLightBrightValue, 4));
				StrReplace(trcText, "%s3",FormatNumber_PointAsDecimal(darkValue, 4));
				StrReplace(trcText, "%s4",FormatNumber_PointAsDecimal(limitStrayLightDarkValue, 4));

				FormatTrace(GetFunctionName(),"()", VerDef::CMD_COMPLET ," ",trcText);
				if(generateExternalFile) traceFile.WriteString( trcText + crlf);//traceFile.WriteRecord( );
				if((brightValue > limitStrayLightBrightValue) || ( darkValue < limitStrayLightDarkValue)) 
				{
					trcText = LdT("Reader384 Check 'Stray light' check failed");
					FormatTrace(GetFunctionName(),"()", VerDef::CMD_ERROR ," ",trcText);
					if(generateExternalFile) traceFile.WriteString( trcText + crlf);//traceFile.WriteRecord( );
					userMessageText = StrConcat4(userMessageText,VerDef::CRLF,"- ",trcText);
				}
			}	
			if(generateExternalFile) traceFile.WriteString( trcText + crlf);//traceFile.WriteRecord( );
			// open reader door for unloading
			Reader_OpenDoor();

			// show unload dialog	
			dialogTitle 		= LdT("Reader384 Function Check:");
			pictureFile 		= "Reader_Checkplate.jpg";

			NewTextLine(1, LdT("Unload the Reader Checkplate from the Reader384:"));
			NewTextLine(0, " ----------------------------------------------------");
			NewTextLine(0, " ");
			NewTextLine(0, LdT("Remove first the Check Plate") + " " + Reader::photoCheckPlateSerial);
			NewTextLine(0, LdT("and then 96 Plate Bar from the Reader384."));
			NewTextLine(0, " ");

			if((VerDef::SimulationModeReader) &&(loopNo > 1)) userMessageText = ""; 

			if (userMessageText == "") 
			{ 
				NewTextLine(0, " ");
				NewTextLine(0, " ");
				NewTextLine(0, LdT("The Reader384 Check was successful") + " !");
				NewTextLine(0, " ");
				warning 						= "";
				overallStatus 				= hslOK;
				Reader::CheckedStatus 	= VerDef::valid;
				buttonSelection 			= hslOKOnly;
			}
			else
			{	// error: not all check criteria fulfilled
				warning		= LdT("WARNING:") + " " + LdT("The Reader384 function check failed" + " !");
		 		NewTextLine(0, LdT("ATTENTION:") + " " + LdT("The Reader384 set to INVALID due to:"));
		 		NewTextLine(0, userMessageText);
				NewTextLine(0, " ");
				NewTextLine(0, LdT("Press 'OK' to execute the Reader384 check again."));
				NewTextLine(0, LdT("Press 'Cancel' to stop the Verification."));
				overallStatus 	= hslCancel;
				Reader::CheckedStatus 	= VerDef::invalid;
				buttonSelection = hslOKCancel;
				
			}

			returnValue = VerTool::DialogInfoData(dialogTitle, pictureFile, VerDef::dialogText,warning, buttonSelection, 1,"","","");
			if(generateExternalFile)
			{
				traceFile.WriteString( "--------------------------------------------------------" + crlf);
				if(Reader::CheckedStatus == VerDef::valid) 	traceFile.WriteString("   Reader Check SUCCESSFUL" + crlf);
				else														traceFile.WriteString("   WARNING: Reader Check FAILED" + crlf);
				traceFile.WriteString( "--------------------------------------------------------" + crlf);
				traceFile.Close();			
			}
			if (returnValue == hslCancel)	break;		
			if ((returnValue == hslOK ) && (Reader::CheckedStatus == VerDef::valid))		break;		
		} // end of reader check
		
		// close reader door for idle mode
		response = "er00";
		Reader_TransmitCommand("YI","", response, 20);
		Reader_TransmitCommand("YO","", response, 10);
		UpdateVerificationInformation(1, KeyReader384, Reader::partNo, versionFW, Reader::CheckedStatus,
																		Reader::deviceSerialNo, GetDate("%Y-%m-%d"));	// date = today);


		return(overallStatus); 	

	} // -- end of function "Check_Photometer"

	//------------------------------------------------------------------------------
	function Load_Carrier(device ML_STAR, 
											variable carrierName, 
											variable trackPosition,
											variable checkRackBarcode)  
	//------------------------------------------------------------------------------
	{
		variable sizeOfRackDef, index, i, maxAutoload;
		variable carrierType, rackID, siteID, posWithBC("");
		variable arrRetValues[];
		variable labwareArr[];
		variable labwareAction[];
		variable labwareDescription[];

      variable loadableCarrier(hslFalse);

      if (carrierName == VerDef::carrierName_Magazine_1)
      {  
         loadableCarrier  = hslTrue;
         carrierType      = VerDef::punchCardMagazine_1;
		}
      if (carrierName == VerDef::carrierName_Magazine_2)
      {
         loadableCarrier  = hslTrue;
         carrierType = VerDef::punchCardMagazine_2;
		}
		if (carrierName == VerDef::carrierName_TipPlate)
		{ 
         loadableCarrier  = hslTrue;
			carrierType = VerDef::TipPlate_Carrier;
      }

		labwareArr.AddAsLast(carrierName);
		labwareAction.AddAsLast(1);
Trace("Test: 			AddTemplateOnDeck,  carrierName =>",carrierName,"<  carrierType =>",carrierType,"< trackPosition =>",trackPosition,"<=");

		if (loadableCarrier)
		{ 
			// add labware
			RemovePresentLabware(ML_STAR, carrierName);			
			AddTemplateOnDeck(ML_STAR,  carrierName, carrierType, trackPosition);
		}

		// add rack to carrier sites
		for (index = 0; index < arrayRackID.GetSize(); index++ )
		{
			if ( arrayRackID.GetAt( index ) != "") 
			{ 
				rackID = arrayRackID.GetAt( index );
				if (index  == 0) 	siteID = VerDef::site_Balance;
					else 				siteID = IStr(index);

				if (index  == 1) 	posWithBC = "1";
				if (index  == 2) 
				{	
					if (posWithBC == "1") posWithBC = "1,2";
					else						 posWithBC = "2";
				}
				RemovePresentLabware(ML_STAR, rackID);			
//Trace("Test: Deck: New rack added ->",rackID,"< at site =>",siteID,"<  of template =>",carrierName, "<=");
				ML_STAR.AddLabwareToTemplate( rackID, arrayRackConfigFile.GetAt(index), carrierName, siteID );
				// definitions for visualitation
				labwareArr.AddAsLast(rackID);
				labwareAction.AddAsLast(1);
			}
		}
 		// show deck loading
		DeckVisualize::UpdateLoadedLabware(ML_STAR, labwareArr, labwareAction, "");

 		// lock front cover 
		CoverLock(ML_STAR , VerDef::coverLock);

		if (!loadableCarrier) return;

		// if autoload is not installed: assuming user did load the carrier manually
		VerDef::tipPlateCarrierLoadable = 0;
		if(trackPosition > VerDef::numbOfAutoLoadTracks-5) return;

		// load carrier
		if(checkRackBarcode != hslTrue) posWithBC = ""; // no barcode reading of tip racks requested
		arrRetValues = ML_STAR.LoadCarrier( "3ebb8dd4_8494_4eb1_a71b4c31cdb7dc81" );
		VerDef::tipPlateCarrierLoadable = 1; 
		
		maxAutoload = VerDef::numbOfAutoLoadTracks;
		ML_STAR.MoveAutoLoad( "db051e2a_a7f0_4c0f_b5f93ab4fc94fc04" );
				
		// get tip rack ID at position 1 and position 2 on carrier
		RPD::tipRackID_1 = "";
		RPD::tipRackID_2 = "";	
		if ( arrayRackID.GetAt(1) != "")
      {
         index = StepReturn::GetPositionFromNum(1, arrRetValues[3]);
         RPD::tipRackID_1 = StepReturn::GetBarcode(index, arrRetValues[3]);		
      }   
		if ( arrayRackID.GetAt(2) != "")
      {
        index = StepReturn::GetPositionFromNum(2, arrRetValues[3]);
        RPD::tipRackID_2 = StepReturn::GetBarcode(index, arrRetValues[3]);		
      }
	}  // -- end of function "Load_Carrier"

	//------------------------------------------------------------------------------
	function Unload_TipCarrier(device& ML_STAR) 
	//------------------------------------------------------------------------------
	{
		variable response, maxAutoload ;
//Trace("Test:  Unload_TipCarrier: Unload tip/plate-carrier out of deck automatically is =>",VerDef::tipPlateCarrierLoadable,"<==");

		if (VerDef::tipPlateCarrierLoadable > 0) 
		{
			ML_STAR.UnloadCarrier( "7b999cb9_2c2b_45f0_88985c90b3458a9e" );
			// if installed move autoload to right position
			maxAutoload = VerDef::numbOfAutoLoadTracks;
			ML_STAR.MoveAutoLoad( "47478309_339e_483f_885962822d8c394c" );
			CoverLock(ML_STAR , VerDef::coverUnlock);
		}
		
	}  // -- end of function "Unload_TipCarrier"

	//------------------------------------------------------------------------------
	function Unload_Consumables(device& ML_STAR, variable unloadReader) //variable
	//------------------------------------------------------------------------------
	{
		variable dialogTitle(""), pictureFile("");			// picture file name (in subdirectory "..\\Methods\Verification\Pictures\""
		variable warning(""), response("");
		variable maxAutoload;
//Trace(" Unload_Consumables: Unload tip/plate-carrier out of deck automatically is =>",VerDef::tipPlateCarrierLoadable,"<==");
		if (VerDef::tipPlateCarrierLoadable > 0) 
		{
			ML_STAR.UnloadCarrier( "7b999cb9_2c2b_45f0_88985c90b3458a9e" );
		}
		
		MoveToEndPositions(ML_STAR);
		CoverLock(ML_STAR , VerDef::coverUnlock);

		dialogTitle 		= LdT("Consumables Unload Information:");
		pictureFile 		= "Unload_Consumable.jpg";

		NewTextLine(1, LdT("Remove all Consumables from the Deck"));
		NewTextLine(0," ---------------------------------------");
		NewTextLine(0," ");
		NewTextLine(0, "- " + LdT("Remove Tip/Plate Carrier"));
		NewTextLine(0," ");
		if (unloadReader > 0)
		{	//------------------------------------------------------------------------------
			response = "er00";	
			NewTextLine(0," ");
			NewTextLine(0,"- " + LdT("If present, remove the Plate"));
			NewTextLine(0, "  " + LdT("and then 96 Plate Bar from the Reader384."));
			warning = LdT("Note:") + " " + LdT("Do not disconnect the Reader384.");
			VerTool::Reader_OpenDoor();		
		}
		NewTextLine(0," ");
		NewTextLine(0, LdT("Hint:"));
		NewTextLine(0, LdT("If the Balance is on the Deck"));
		NewTextLine(0, "    " + LdT("and will be used for further verification steps,"));
		NewTextLine(0, "    " + LdT("do not remove the Balance from the Deck!"));
		
		VerTool::DialogInfoData(dialogTitle, pictureFile, VerDef::dialogText,warning, hslOKOnly, 1, "","","");

		if (unloadReader > 0)
		{	// close reader door and switch to idel mode
			response = "er00";	
			Reader_TransmitCommand("YI","", response, 20);
			Reader_TransmitCommand("YO","", response, 10);
		}

	}  // -- end of function "Unload_Consumables"

	//------------------------------------------------------------------------------
	private function CheckBalancePosition(device ML_STAR )
	//------------------------------------------------------------------------------
	{
		variable pictureFile("");			// picture file name (in subdirectory "..\\Methods\Verification\Pictures\""
		variable returnValue;
		variable dialogTitle("");			//	dialog titel information

		variable cmd;
		variable prm;
		string status;
		variable channelPattern;
		variable retCode(hslTrue);
		variable position[];
		variable x_labPos, y_labPos;

		variable windShieldSurface(239.0); 	// [mm]; on top of windshield on balance/reagent carrier; 234.5mm on top of WXS balance 
		variable stepsPerMiliMeter(93.217); // Z-movement step motor resolution 93217 steps/m
		variable needleOffset(51.9); 			// = 51.9mm
		variable startOffset(2.0);				// about 2 mm
		variable maxImmersion(9.0); 			// about 9 mm
		variable zLabwareSteps;
		variable zcSteps1;
		variable zhSteps1;
		variable zcSteps2;
		variable zhSteps2;

		static string balancePosX; // X position in 0.1mm
		static string balancePosY; // Y position in 0.1mm

		// parameter zc and zh for cLLD check firmware command ZL
		static string zhParam1; // draft shield
		static string zcParam1; // draft shield
		static string zhParam2; // balance
		static string zcParam2; // balance

		// original parameter values to restore after temporary changes
		static string zhOriginal;
		static string zcOriginal;
		static string ziOriginal;
		static string zjOriginal;
		static string zvOriginal;
		static string zlOriginal;

		// --------------------------------------------------------------------------
		// Evaluate balance position
		//
		ML_STAR.GetLabwarePosition(PS::seq_Tube.GetLabwareId(), position, PS::seq_Tube.GetPositionId());
		x_labPos = IVal(FStr(10 * position.GetAt(0)));
		y_labPos = IVal(FStr(10 * position.GetAt(1)));

		balancePosX = 	StrFillLeft(IStr(x_labPos), "0", 5);
		balancePosY = 	StrFillLeft(IStr(y_labPos), "0", 4);

		// --------------------------------------------------------------------------
		// Calculate parameter zc and zh for cLLD check firmware command ZL
		//
		// calculate steps of labware z position
		zLabwareSteps = (windShieldSurface + needleOffset) * stepsPerMiliMeter;
		// paramter zc on draft shield
		zcSteps1 = zLabwareSteps + (startOffset * stepsPerMiliMeter);
		zcParam1 = FStr(zcSteps1);
		zcParam1 = zcParam1.Left(5);
		// paramter zh on draft shield
		zhSteps1 = zLabwareSteps - (maxImmersion* stepsPerMiliMeter);
		zhParam1 = FStr(zhSteps1);
		zhParam1 = zhParam1.Left(5);
		// paramter zc on balance
		zcSteps2 = zLabwareSteps + (startOffset* stepsPerMiliMeter);
		zcParam2 = FStr(zcSteps2);
		zcParam2 = zcParam2.Left(5);
		// paramter zh on balance
		zhSteps2 = zLabwareSteps - (maxImmersion* stepsPerMiliMeter);
		zhParam2 = FStr(zhSteps2);
		zhParam2 = zhParam2.Left(5);

		// --------------------------------------------------------------------------
		// Save parameter values to restore after temporary changes
		//
		zhOriginal = VerTool::FwCommand( "P1RA", "razh", hslFalse, ML_STAR );
		zcOriginal = VerTool::FwCommand( "P1RA", "razc", hslFalse, ML_STAR );
		ziOriginal = VerTool::FwCommand( "P1RA", "razi", hslFalse, ML_STAR );
		zjOriginal = VerTool::FwCommand( "P1RA", "razj", hslFalse, ML_STAR );
		zvOriginal = VerTool::FwCommand( "P1RA", "razv", hslFalse, ML_STAR );
		zlOriginal = VerTool::FwCommand( "P1RA", "razl", hslFalse, ML_STAR );

		onerror goto UnhandledError;
		
		// pick up teaching needle from waste block with channel 1
		// 'next'  / 'exclude' must be disabled
		channelPattern = 	VerTool::ChannelPattern(1, 1, VerDef::InstrumentNumberOfChannels);
		ML_STAR.TipPickUp( "d1b275ab_4091_4a24_b113055d68192d9e" );

		if(Balance::Type == Balance::Type_WMC)
		{ // move over center of balance
			if(!VerTool::MoveToPosition( ML_STAR, VerDef::singlePipHead_1000ul, channelPattern, PS::seq_Tube, 18))
			{ // not reachable position
				VerTool::VerificationFailedDialog(LdT("Balance Position") , "m");
				retCode = hslFalse;
			}
			else
			{	// unlock front cover
				VerTool::CoverLock(ML_STAR , VerDef::coverUnlock);
						
				dialogTitle 		= LdT("Check the Tip to Balance Position");
				pictureFile 		= "TipCheck_1000ulTip_WMC.jpg";

				VerTool::NewTextLine(1, LdT("Examine the Tip Position over the Balance:"));
				VerTool::NewTextLine(0," ----------------------------------------------");
				VerTool::NewTextLine(0," ");
				VerTool::NewTextLine(0," ");
				VerTool::NewTextLine(0,"- " + LdT("Is the Tip correctly positioned over the Balance ?"));
				VerTool::NewTextLine(0,"  ");
				VerTool::NewTextLine(0,LdT("Press 'Yes' to continue the Verification."));
				VerTool::NewTextLine(0,LdT("Press 'No' to change balance loading!"));
		
				returnValue = VerTool::DialogInfoData(dialogTitle, pictureFile, VerDef::dialogText,"", hslYesNo, 1,"","","");

				// lock front cover
				VerTool::CoverLock(ML_STAR , VerDef::coverLock);
						
				if (returnValue == hslNo)	retCode = hslFalse;
				else								retCode = hslTrue;
			}
		}
		else
		{	// move channel over balance, -15mm in y-direction from center
			// FW positioning command for ML-STAR 1000ul pipetting head:
			// C0JMid3333tm1 0&xp05186&th2450yp2375&zp2450&;
			cmd = "C0JM";
			if(VerDef::InstrumentNumberOfChannels == 2) 	prm = "tm1 0";
			else														prm = "tm1 0&";
			prm = StrConcat4(prm, "xp" ,balancePosX , "&");
			prm = StrConcat2(prm, "th2470");
			prm = StrConcat4(prm, "yp" ,StrFillLeft(IStr(y_labPos - 150), "0", 4) , "&");
			prm = StrConcat2(prm, "zp2450&");
			if(VerDef::InstrumentNumberOfChannels < 2)
			{
				prm = StrConcat2("tm1xp" ,balancePosX );
				prm = StrConcat2(prm, "th2470");
				prm = StrConcat4(prm, "yp" ,StrFillLeft(IStr(y_labPos - 150), "0", 4) , "");
				prm = StrConcat2(prm, "zp2450");
			}
	//Trace("Test:  Move to position FW command =>", cmd,"< prm =>",prm,"<==");
			VerTool::FwCommand( cmd, prm, hslTrue, ML_STAR );

			// switch on cLLD measurement
			VerTool::FwCommand( "P1AL", "al1lc0", hslFalse, ML_STAR );


			// cLLD detection on the draft shield (if present)
			cmd = "P1ZL";
			// parameter string  for cLLD detection (on draft shield)
			prm = StrConcat2("zh", zhParam1);
			prm = StrConcat4(prm, "zc", zcParam1,"zi0020zj1zv04500zl00100");
			VerTool::FwCommand( cmd, prm, hslFalse, ML_STAR );

			// cLLD request
			cmd = "P1RN";
			status = StrMid( VerTool::FwCommand(cmd,"",hslFalse, ML_STAR ), 2, 1);
			if ( 0 == status.Compare("1") )
			{
				// move Z to collision free position
				cmd = "C0KZ";
				prm = "pn01zj2800";
				VerTool::FwCommand( cmd, prm, hslTrue, ML_STAR ); 

				// move channel over balance, +15mm in y-direction from center
				cmd = "C0KY";
				prm = "pn01yj";
				prm = prm + IStr(IVal(balancePosY)+150); // check y 15mm behind labware position
				VerTool::FwCommand( cmd, prm, hslTrue, ML_STAR ); 

				// switch on cLLD measurement
				VerTool::FwCommand( "P1AL", "al1lc0", hslFalse, ML_STAR );

				// cLLD detection on the draft shield (if present)
				cmd = "P1ZL";
				// parameter string  for cLLD detection (on draft shield)
				prm = StrConcat2("zh", zhParam1);
				prm = StrConcat4(prm, "zc", zcParam1,"zi0020zj1zv04500zl00100");
				VerTool::FwCommand( cmd, prm, hslFalse, ML_STAR );
			
				// cLLD request
				cmd = "P1RN";
				status = StrMid( VerTool::FwCommand(cmd,"",hslFalse, ML_STAR ), 2, 1);
				if ( 0 == status.Compare("1") )
				{
					// move Z to collision free position
					cmd = "C0KZ";
					prm = "pn01zj2800";
					VerTool::FwCommand( cmd, prm, hslTrue, ML_STAR ); 
					// move to position Y of channel 1 to balance position
					cmd = "C0KY";
					prm = "pn01yj";
					prm = prm + IStr(IVal(balancePosY)); // check y labware position
					VerTool::FwCommand( cmd, prm, hslTrue, ML_STAR ); 
					// switch on cLLD measurement
					VerTool::FwCommand( "P1AL", "al1lc0", hslFalse, ML_STAR );

					// cLLD detection on the draft shield (if present)
					cmd = "P1ZL";
					// parameter string  for cLLD detection (on draft shield)
					prm = StrConcat2("zh", zhParam1);
					prm = StrConcat4(prm, "zc", zcParam1,"zi0020zj1zv04500zl00100");
					VerTool::FwCommand( cmd, prm, hslFalse, ML_STAR );

					// cLLD request
					cmd = "P1RN";
					status = StrMid( VerTool::FwCommand(cmd,"",hslFalse, ML_STAR ), 2, 1);
					if ( 0 == status.Compare("1") )
					{
						// level detected
						retCode = hslFalse;
					}
				}
				else
				{
						// no level detected
					retCode = hslFalse;
				}
			}
			else
			{
				// no level detected
				retCode = hslFalse;
			}

			// move Z to collision free position
			cmd = "C0KZ";
			prm = "pn01zj2800";
			VerTool::FwCommand( cmd, prm, hslTrue, ML_STAR ); 

			// switch off cLLD measurement
			VerTool::FwCommand( "P1AL", "al0", hslFalse, ML_STAR ); // move dispenser drive relatively

			// set parameters of ZL back to original values
			cmd = "P1AA";
			prm = StrConcat8(zhOriginal, zcOriginal, ziOriginal, zjOriginal, zvOriginal, zlOriginal, "", "");
			VerTool::FwCommand( cmd, prm, hslFalse, ML_STAR );
		}
		// eject teaching needle back to the waste block
		ML_STAR.TipEject( "8d539037_a5e8_45b0_be1bfe8f82276a31" );
		return (retCode);
		// --------------------------------------------------------------------------
		UnhandledError :
		{
			// set parameters of ZL back to original values
			cmd = "P1AA";
			prm = StrConcat8(zhOriginal, zcOriginal, ziOriginal, zjOriginal, zvOriginal, zlOriginal, "", "");
			VerTool::FwCommand( cmd, prm, hslFalse, ML_STAR );

			ML_STAR.TipEject( "29a0e2ac_722d_41fa_be416323a88eb8bd" );
			return (hslFalse);
		}

	} // end of function "CheckBalancePosition"

	// --------------------------------------------------------------------------------------
	// Install Balance and check status
	function Install_Balance(device ML_STAR, variable minTrackNo) variable    		// hslOK , hslCancel
	// --------------------------------------------------------------------------------------
	{
		variable comPort(""),trackNo(""),track(0), starSN, loopNo(0);
		variable prop3, sn, lastCheck(""),lcd(""),lcb(""); // dummy place holder ;
		variable userMessageText(""), dialogTitle(""), warning(""), pictureFile(""), remarks("");
		variable inputDescription(""), inputRemarks(""), versionFW; 
		variable connection(hslTrue);//,dateOkay;
		variable returnValue;
		sequence seq_DummyDef;  // place holder sequence definition
		variable templateID, templateFound;

      VerTool::ShowStatusDialog(LdT("Balance Information:"));
      VerTool::UpdateStatusDialog("",LdT("Balance installing..."),Dlg::Yellow);
		GetVerificationInformation(KeyBalance, Balance::Type ,comPort,Balance::CheckedStatus, Balance::SerialNumber, Balance::CalibrationDate,lcd,lcb);
		GetVerificationInformation(VerDef::KeyBalanceCarTrack, trackNo, starSN, prop3 ,sn, lastCheck,lcd,lcb);
		VerDef::balanceTrackPos	= IVal(trackNo);

		// --------------------------------------------------------------------------
		// Unlock front cover		
		CoverLock(ML_STAR , VerDef::coverUnlock);
		// --------------------------------------------------------------------------

		inputDescription 	= LdT("Place the Balance with Centering Carrier on Track");
		warning 				= LdT("ATTENTION:") + " " + LdT("Only define a reachable position!");

		loopNo = 0;
		while(hslTrue)
		{	
			// show load dialog	
			dialogTitle 		= LdT("Balance Installation:");
			pictureFile 		= "Install_WXS_Balance.jpg"; // Default : WXS balance
			if (Balance::Type == Balance::Type_WMC) 
			{ // install definition for WMC balance
				pictureFile 		= "Install_WMC_Balance.jpg";
			}
			if (Balance::Type == Balance::Type_SAG) 
			{ // install definition for SAG balance
				pictureFile 		= "Install_SAG_Balance.jpg";
			}

			NewTextLine(1, StrConcat4(LdT("Install the Balance '"), Balance::Type,"':",""));
			NewTextLine(0, " -----------------------------------------------");
			NewTextLine(0, LdT("Place"));
			if(VerDef::isRoche)
			{
				NewTextLine(0, "- " + LdT("the Centering Guide on deck."));
//	Trace(" Test: Balance::Type =>",Balance::Type,"< =?= ",   Balance::Type_WMC) ;
				if (Balance::Type == Balance::Type_WMC) 
				{ // mount WMC balance on guide
					NewTextLine(0, "   - " + LdT("mount and fix the Balance with 2 screws on Centering Guide "));
					NewTextLine(0, "   - " + LdT("tune the vertical position with the 3 adjustment screws"));
				}
				else 	
				{
					NewTextLine(0, "   - " + LdT("the Balance (push to the rear, right position)."));
				}
			}
			else
			{
				NewTextLine(0, "- " + LdT("the Centering Carrier on deck."));
				NewTextLine(0, "- " + LdT("the Balance (push to the rear, right position)."));
				NewTextLine(0, "- " + LdT("the Reagent Carrier onto the Balance."));
			}
			if (Balance::Type == Balance::Type_WMC) 
			{ // WMC balance 
				NewTextLine(0, "- " + LdT("the Weighing Bowl the Balance."));
				NewTextLine(0, "- " + LdT("the WMC Windshield onto the Balance."));
			}
			else 
			{	
				NewTextLine(0, "- " + LdT("the Vial Platform and the Centering Ring onto the Balance."));
				NewTextLine(0, "- " + LdT("the Vial Windshield onto the Balance."));
			}
			NewTextLine(0, " ");
			NewTextLine(0, LdT("Connect the Balance Terminal with"));
			NewTextLine(0, "- " + LdT("Balance"));
			if(IVal(comPort) <= 0) 	NewTextLine(0, "- " + LdT("PC on Ethernet Port") );
			else							NewTextLine(0, "- " + LdT("PC on Serial Port") );
			NewTextLine(0, "- " + LdT("Power Supply"));
			NewTextLine(0, " ");
			NewTextLine(0, LdT("Press 'OK' to continue the Installation."));
			NewTextLine(0, LdT("Press 'Cancel' to stop the Installation."));

			// show load dialog	
			loopNo++;
			returnValue = VerTool::DialogInfoData(dialogTitle, pictureFile, VerDef::dialogText,warning, hslOKCancel, 1,
																	inputDescription, remarks, trackNo);
			if (returnValue == hslCancel) 
         {
            VerTool::HideStatusDialog();
            return(hslCancel);
         }
			// initialize communication to balance 
			if(!MWPInitialize( comPort )) 
         {
            VerTool::UpdateStatusDialog("",LdT("No communication established!"),Dlg::Red);
            warning = LdT("ATTENTION:") + " " + LdT("No communication established!");
         }
			else
			{
            VerTool::UpdateStatusDialog("",LdT("Communication established!"),Dlg::Green);
				if(checkInputValue(trackNo, 100,-5, track)) 
				{
					// add labware
					VerTool::AddRackOnCarrier(VerDef::site_ResetAll,"","",seq_DummyDef); // reset labware loading info

					if (Balance::Type == Balance::Type_WMC) 
					{ // add carrier type for WMC balance
						VerDef::balanceCarrierType = VerDef::WMC_Balance; 			// WMC labware missing
						VerTool::AddRackOnCarrier(VerDef::site_Balance, VerDef::_5ml_Bowl,		"Tube",			PS::seq_Tube);
					}
					else 
					{
						VerDef::balanceCarrierType = VerDef::ReagentCarBalance; 
						VerTool::AddRackOnCarrier(VerDef::site_Balance, VerDef::_8ml_Tube,		"Tube",			PS::seq_Tube);
					}
					if(VerDef::isRoche) 	
					{
						AddTemplateOnDeck(ML_STAR,  VerDef::carrierName_Reagent, VerDef::balanceCarrierType, track);
						Load_Carrier(ML_STAR, VerDef::carrierName_Reagent, track, hslFalse);
					}
					else
					{
						AddTemplateOnDeck(ML_STAR,  VerDef::carrierName_Reagent, VerDef::balanceCarrierType, track - 6);
						Load_Carrier(ML_STAR, VerDef::carrierName_Reagent, track - 6, hslFalse);
					}
					if(VerDef::isRoche || VerDef::isIVD )
					{
							if(CheckBalancePosition(ML_STAR) ) break;
							else 	warning = LdT("ATTENTION:") + " " + LdT("Balance or Windshield are not on defined position!");
							if(VerDef::SimulationMode && (loopNo > 1)) break;
					}
					else break;
				}
				else  remarks = LdT("Define correct number!");
			}
		} // end of dummy loop

		if (VerDef::balanceTrackPos != track) 
		{
			VerDef::balanceTrackPos	= track;
			UpdateVerificationInformation(0, VerDef::KeyBalanceCarTrack, trackNo, starSN, prop3,sn, lastCheck);	// date = today);
		}


		// initialize communication to balance 
		UpdateVerificationInformation(1, KeyBalance,Balance::Type ,comPort, Balance::CheckedStatus, Balance::SerialNumber, Balance::CalibrationDate);

		templateID = VerDef::carrierName_Reagent;
//templateFound = ML_STAR.IsValidLabwareForCurrentDeckLayout(templateID);
//Trace("Test Install balance: IsValidLabwareForCurrentDeckLayout =>",templateID, "< found =>",templateFound);

      VerTool::HideStatusDialog();
		return(hslOK);
	} // -- end of function "Install_Balance"

	// --------------------------------------------------------------------------------------
	// Install Photometer and check status
	function Install_Photometer( ) variable    		// hslCancel, hslOK
	// --------------------------------------------------------------------------------------
	{
		variable prop1(""),prop2(""),prop3(""),sn(""),date(""),lcd(""),lcb(""); // dummy place holder ;
		variable buttonSelection(hslOKCancel), defaultButton(1);
		variable userMessageText(""), dialogTitle(""), warning(""), pictureFile(""), remarks(""), expiryDate;
		variable inputDescription(""), inputRemarks(""), inputValue("");
		variable dateOkay, returnValue, connection(hslTrue), response;
		variable arrWavelengthSet[], versionFW;
		variable overallStatus(hslOK);
		timer 	shortDelay;

		GetVerificationInformation(KeyReader384,Reader::partNo,prop2, Reader::CheckedStatus, Reader::deviceSerialNo,Reader::deviceCheckDate,lcd,lcb);
		VerTool::ValidateDate(Reader::deviceCheckDate, 0, expiryDate, dateOkay, remarks);
		if (Reader::CheckedStatus == VerDef::invalid) dateOkay = 0;
		// show load dialog	
		dialogTitle 		= LdT("Reader384 Installation:");
		pictureFile 		= "Install_Reader384.jpg";

		NewTextLine(1, LdT("Install the Reader384:"));
		NewTextLine(0, " -----------------------------------------------");
		NewTextLine(0, " ");
		NewTextLine(0, LdT("Connect the Reader384 with"));
		NewTextLine(0, "- " + LdT("Power Supply"));
		NewTextLine(0, "- " + LdT("USB Cable to PC"));
		NewTextLine(0, " ");
		if (dateOkay > 0)
		{
			 warning 		= LdT("Note:") + " " + LdT("The Reader384 was checked today.");
			 NewTextLine(0, LdT("Press 'Yes' to check the Reader384 again."));
			 NewTextLine(0, LdT("Press 'No' to skip the Reader384 check."));
			 buttonSelection 	= hslYesNoCancel;
			 defaultButton		= 2; // no as default button
		}
		else
		{
			 NewTextLine(0, "");
			 NewTextLine(0, LdT("Press 'OK' to check the Reader384."));
			 warning				= LdT("ATTENTION:") + " " + LdT("Reader384 needs to be checked.");
			 buttonSelection 	= hslOKCancel;
			 defaultButton		= 1;
		}
		NewTextLine(0, " ");
	   NewTextLine(0, LdT("Press 'Cancel' to stop the Verification."));
		while(hslTrue)
		{
			// show load dialog	
			returnValue = VerTool::DialogInfoData(dialogTitle, pictureFile, VerDef::dialogText,
																						warning, buttonSelection, defaultButton, "","","");
//Trace(" Test: Reader384 dialog return value =>",returnValue);
			if (returnValue == hslCancel) return(hslCancel);

			//----- Check communication ------------------------------------------------------------
			shortDelay.SetTimer( 4 );
			shortDelay.WaitTimer( hslFalse, hslFalse );

			// connect reader384
			connection = hslTrue;
			if (!VerDef::SimulationModeReader)
				loop(3)
				{
					Reader_TerminateCommunication();
					Reader_OpenCommunication();
					connection = hslTrue;
					if (Reader::Device.IsConnected(Reader::ID)) 
					{
				      response = "er00rfReader runs in simulation mode!";	
						if(Reader_TransmitCommand("RF","", response, 10) == 0) break; // get FW version as dummy command to check communication
					}
					connection = hslFalse;
					Reader::Device.ReleaseObject();
				}
			if(connection) break;
			else
			{
				warning = LdT("ATTENTION:") + " " + LdT("Reader384 needs to be checked.");
				warning = warning	+ VerDef::CRLF + LdT("No connection to the Reader384 established!");
			}
		}

		Reader::isInitialized = hslFalse; // Reader needs to be initialized with plate on transport

		Reader_GetStatus(arrWavelengthSet, Reader::deviceSerialNo, versionFW);

		if (returnValue != hslNo)  overallStatus = Check_Photometer();
		else	overallStatus = hslOK;

		if(overallStatus == hslOK) Reader::CheckedStatus = VerDef::valid;
	
		return(overallStatus);
	} // -- end of function "Install_Photometer"


	//--------------------------------------------------------------------------------------------------
	function Measure_Plate_OD_Values(device ML_STAR,
												variable i_DialogTitle,		//	dialog titel of plate loading on Reader384
												variable i_plateID,			//	plate ID for input dialog: 0 no specific infomation
												variable plateType, 			// 96er plate or 384er plate
												variable& OD_ValueSet[]) variable
	//--------------------------------------------------------------------------------------------------
	{ 
		variable measurementData[], referenceData[];
		variable pictureFile, warning(""), plateID("");
		variable response, returnValue;
		variable shakingTime(10), intensity(3);
		variable plateOrientation(0);
		variable errorStatus(0);

		if (Reader::isInitialized == hslFalse)
		{
			response = "er00";
			Reader_TransmitCommand("YI","", response, 20);
		}
		// Unlock front cover		
		CoverLock(ML_STAR , VerDef::coverUnlock);
//Trace("Test: Measure_Plate_OD_Values: --- Measure Plate i_plateID =>",i_plateID,"<  Type =>",	plateType,"<==");
		response = "er00";
		plateID = StrConcat2("",i_plateID);

		measurementData.SetSize( 0 );
		if (plateType == VerDef::_ReaderCheckPlate) 
		{
			errorStatus = Reader_Measure_Plate(plateType, plateOrientation, measurementData);
			return(errorStatus);
		}

		// show load dialog			
		while(hslTrue)
		{
			VerTool::Reader_OpenDoor();

			if (plateOrientation == 0)
			{
				NewTextLine(1, LdT("Load the Plate") + " " + plateID + " " + LdT("onto the Reader384") + ":");
				NewTextLine(0, " ---------------------------------------------------");
				NewTextLine(0, " ");
				if (plateType == VerDef::_96erPlate) 
				{
					NewTextLine(0, " - Place the 96 Plate Bar on right side");
				}
				NewTextLine(0, "- " + LdT("Place the Pipetted Plate with position 'A1'"));
				NewTextLine(0, "    " + LdT("to the right, rear corner."));
				if (plateType == VerDef::_96erPlate) 	pictureFile = "Reader_96erMTP.jpg"; // 96er plate with bar
				else 												pictureFile = "Reader_384erMTP_A1.jpg"; // 384er plate without bar, normal orientation
			}
			else
			{
				NewTextLine(1, LdT("Measure same plate again:"));
				NewTextLine(0, " ---------------------------------------------------");
				NewTextLine(0, " ");
				NewTextLine(0, " ");
				NewTextLine(0, "- " + LdT("Turn and place the Pipetted Plate with position 'A1'"));
				NewTextLine(0, "  " + LdT("to the left, front corner."));
				pictureFile = "Reader_384erMTP_P24.jpg"; // 384er plate without bar, inverse orientation
			}
			NewTextLine(0, " ");
			NewTextLine(0, " ");
			NewTextLine(0, LdT("Press 'OK' to continue the Plate OD-Measurement."));
//			NewTextLine(0, LdT("Press 'Cancel' to stop the Plate OD-Measurement."));

			returnValue = VerTool::DialogInfoData(i_DialogTitle, pictureFile, VerDef::dialogText,warning, hslOKOnly , 1,"","","");
			if (returnValue == hslCancel) 
			{ // open reader door for idle mode
				response = "er00";
				VerTool::Reader_OpenDoor();
				Reader_TransmitCommand("YO","", response, 10);
				return(hslFalse);
			}

			if(errorStatus != 0)
			{ // reader was in erroneous state
				if(  errorStatus >= 100) 
				{
					Reader_TerminateCommunication();
					Reader_OpenCommunication();
				}
				errorStatus = Reader_Initialize();
			}

			if (Reader::isInitialized == hslFalse)
			{
				Reader_Initialize();
				Reader::isInitialized = hslTrue;
			}

			response = "er00";
			if(  errorStatus == 0) errorStatus = Reader_TransmitCommand("LN","", response, 10);
			if(  errorStatus == 0) errorStatus = Reader_TransmitCommand("YI","", response, 20);

			if (plateOrientation == 0) Reader_ShakePlate(shakingTime, intensity);

			// plate measurement
			warning 		= "";
			if(  errorStatus == 0) errorStatus = Reader_Measure_Plate(plateType, plateOrientation, measurementData);
			if(  errorStatus == 0)
			{	// successful measurement
				if (plateType == VerDef::_96erPlate)
				{ // plate measurement of 96er plate
						Trace_96erPlate_OD_Values(measurementData, VerDef::SemiColon, "");
						break;
				}
				else if(plateOrientation > 0) 
				{	
					Trace_384erPlate_OD_Values(measurementData, VerDef::SemiColon, "");
					break; 
				}
				plateOrientation = 1;
			}
			else
			{ // measurement with error 
				warning = LdT("ATTENTION: Measurement with error!") + VerDef::CRLF + LdT("Repeat measurement!");
			}
		}

		Reader_OpenDoor();
		addArrayInformation( OD_ValueSet, measurementData);

		// Lock front cover		
		CoverLock(ML_STAR , VerDef::coverLock);

		return( 0 );
	} // --------  end of function "Measure_Plate_OD_Values" -------------------------

} // end namespace VerTool
#endif	// HSL_RUNTIME
#endif	// __VerificationLibrary_hsl__

// $$author=wbarmettler$$valid=1$$time=2013-10-25 07:37$$checksum=64d71ee7$$length=088$$